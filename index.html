<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="Hongery">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hongery">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hongery">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hongery</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hongery</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Hongery" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/03%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/03%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">公开密钥加密</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 19:01:01 / 修改时间：19:01:46" itemprop="dateCreated datePublished" datetime="2020-03-09T19:01:01+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h1><p>当代密码学的核心是“公开密钥加密”（ Public-key cryptography ）。本节的目的是梳理清楚学习密码学的大思路，以便在后续课程中，遇到椭圆曲线，RSA ，加密通信，数字签名这些术语的时候，起码知道它们的大致归属。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>公开密钥加密也称为”<strong>非对称加密</strong>“，加密和解密的时候使用<strong>不同的秘钥（key）</strong>，其中一个是公钥，是可以公开出去的，另外一个是私钥，要严格保密。<strong>公开密钥加密有两个应用，一个是加密通信，另外一个是数字签名。</strong></p>
<h4 id="公开密钥加密要实现的功能有两个："><a href="#公开密钥加密要实现的功能有两个：" class="headerlink" title="公开密钥加密要实现的功能有两个："></a>公开密钥加密要实现的功能有两个：</h4><ol>
<li><strong>保密</strong>，发送者用接收者的公钥去加密信息，接收者就用自己的私钥去解密信息。</li>
<li><strong>认证</strong>，发出信息的人用自己的私钥去进行数字签名来签署信息，这样任何人拿到公钥之后都可以去确认信息是不是由私钥持有人发出的。</li>
</ol>
<p>公钥和私钥首先应该是有数学联系的，不然所谓的解密和签名操作也就不可能实现了，但是同时<strong>不能由公钥去算出私钥</strong>，如果可以算出来，那么安全性就丧失了。所以加密算法都是基于一些目前无解的数学问题，或者叫单向函数，例如整数分解或者离散对数。具体的算法有 RSA 和 ECC 等。什么叫单向函数呢？8616460799 是两个数相乘得到的，给这两个数，可以很容易算出结果，但是如果给出结果，要分解出两个乘数，就是一个数学上还没有解决的问题，叫做”整数分解“问题。换句话说，如果有一天整数分解问题解决了，攻击者就可以把公钥分解，那么私钥就很容易被算出来了，基于整数分解的加密算法也就失效了。</p>
<h2 id="应用（加密通信和数字签名的基本原理）"><a href="#应用（加密通信和数字签名的基本原理）" class="headerlink" title="应用（加密通信和数字签名的基本原理）"></a>应用（加密通信和数字签名的基本原理）</h2><h5 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h5><p>信息发送者A需要发送一个信息给信息接收者B，需要先使用B的公钥对信息加密，B收到后，使用自己（B）的私钥就可以对这一信息进行解密，而其他人没有私钥，是没有办法对这个加密信息进行解密的。</p>
<table>
<thead>
<tr>
<th>发送者A                                                                                           接收者B</th>
</tr>
</thead>
<tbody><tr>
<td>明文———B的公钥加密———-密文———–发送给B———&gt;  密文————–B的私钥解密———-明文</td>
</tr>
<tr>
<td>加密                                                                                                   解密</td>
</tr>
</tbody></table>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>发送者A先用哈希函数对原文生成一个摘要（Digest），然后使用私钥对摘要进行加密，生成数字签名（Signature）之后将数字签名与原文一起发送给接收者B；B收到信息后使用A的公钥对数字签名进行签名得到摘要，由此确保信息是A发出的，然后再对收到的原文使用哈希函数产生摘要，并与解密得到的摘要进行对比，如果相同，则说明收到的信息在传输过程中没有被修改过。</p>
<h2 id="主要算法"><a href="#主要算法" class="headerlink" title="主要算法"></a>主要算法</h2><p>最知名的算法有两个，一个是 RSA 算法，一个是 ECC 算法。</p>
<p>RSA 算法是开山鼻祖。1970 年，一位英国密码学家预见了“无秘密加密”的可能性，公钥加密思想产生了。公钥加密的比对称加密有明显优势，因为通信之前，双方不用传递密码，只需要传递公钥即可，而公钥不是秘密，被截获也不会影响通信安全。之后几年，人们开发了 RSA 算法，第一次真正实现了这个想法。RSA 算法标志着公开密钥加密真正诞生了。RSA 算法的安全性基于整数分解问题，具体来说就是根据大素数相乘的结果，不可能被反向分解的数学原理。</p>
<p>另外一种加密算法叫做 ECC ，也就是椭圆曲线算法。世界上不可解的数学问题并不是只有整数分解一个，ECC 就是基于另外一个问题：离散对数。一个加密算法的安全性取决于，由公钥去运算私钥的难度。毕竟私钥的位数是有限的，所以即使用暴力搜索的方式，也肯定是能够算出来的。而且各种单向函数虽然无解，但是不代表不能缩小求解范围，所以不同的算法其实安全性还是有差别的。而 ECC 用离散对数原理，同样的 Key 长度，<strong>安全性比 RSA 更高。</strong>比特币就是用 ECC 来生成地址和私钥。这里你可能会有疑问，为何不能把私钥位数尽量弄长一些呢？的确，越长就越安全，但是同时执行效率也低，所以实际使用中还是要保证一种平衡的。</p>
<p>这里我们要记住的是，加密算法很多，但是最重要的就是 RSA 和 ECC 两个，同时加密算法跟哈希算法是两个东西，所以 SHA1 ，MD5 这些哈希算法跟 RSA 和 ECC 根本不是一类运算，不要弄混淆。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住的是：首先公开密钥加密是<strong>基于单向函数的数学原理开发出来的</strong>，主要由两个应用，一个是<strong>加密通信</strong>，一个是<strong>数字签名</strong>。最著名的公开密钥加密的算法有两个，一个是 <strong>RSA</strong> 一个是 <strong>ECC</strong> 。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/02%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/02%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">哈希算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 19:01:00 / 修改时间：19:01:24" itemprop="dateCreated datePublished" datetime="2020-03-09T19:01:00+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>哈希是密码学的基础，理解哈希是理解数字签名和加密通信等技术的必要前提。</p>
<h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>哈希，英文是 hash ，本来意思是”切碎并搅拌“，有一种食物就叫 Hash ，就是把食材切碎并搅拌一下做成的。哈希函数的运算结果就是哈希值，通常简称为哈希。<strong>哈希函数有时候也翻译做散列函数</strong>。</p>
<p><img src="https://img.haoqicat.com/2018100101.jpg" alt="img"></p>
<p>哈希函数要做的事情是<strong>给一个任意大小的数据生成出一个固定长度的数据</strong>，作为它的映射。所谓映射就是一一对应。一个可靠的哈希算法要满足三点。</p>
<ol>
<li><p><strong>安全</strong>，给定数据 M 容易算出哈希值 X ，而给定 X 不能算出 M ，或者说哈希算法应该是一个单向算法。</p>
</li>
<li><p><strong>独一无二</strong>，两个不同的数据，要拥有不相同的哈希。</p>
</li>
<li><p><strong>长度固定</strong>，给定一种哈希算法，不管输入是多大的数据，输出长度都是固定的。</p>
<p>但是仔细想一下，如果哈希的长度是固定的，也就是取值范围是有限的，而输入数据的取值范围是无限的，所以总会找到两个不同的输入拥有相同的哈希。所以，哈希函数的安全性肯定是个相对概念。如果出现了两个不同输入有相同输出的情况，就叫<strong>碰撞（collision ）</strong>。不同的哈希算法，<strong>哈希位数越多，</strong>也就基本意味着安全级别越高，或者说它的<strong>”抗碰撞性</strong>“就越好。</p>
</li>
</ol>
<h4 id="哈希函数的主要作用"><a href="#哈希函数的主要作用" class="headerlink" title="哈希函数的主要作用"></a>哈希函数的主要作用</h4><p>哈希的独一无二性，保证了如果数据在存储或者传输过程中有丝毫损坏，那么它的哈希就会变。哈希函数的最常见的一个作用就是<strong>进行完整性校验（ Integrity Check ）</strong>，完整的意思是数据无损坏。哈希有很多不同的称呼，有时候叫 <strong>Digest 摘要</strong>，有时候叫 <strong>Checksum 校验值</strong>，有时候叫 <strong>Fingerprint 指纹</strong>，其实说的意思差不多，也就是说哈希可以用来代表数据本身。例如朋友给我传递一份数据，传完之后，我有一份，他手里也有一份，如果两份数据的哈希值是一样的，那么这两份数据的内容就是一样的，或者说可以认为传递过程中数据没有损坏，我手里拿到的数据是完整的。</p>
<p>所以说<strong>，哈希函数</strong>的<strong>基本作用</strong>就是给大数据算出一个摘要性的长度固定的字符串，也就是所谓的哈希。<strong>哈希的作用主要是进行完整性校验。</strong></p>
<h2 id="哈希算法的分类"><a href="#哈希算法的分类" class="headerlink" title="哈希算法的分类"></a>哈希算法的分类</h2><p>首先说哈希算法有很多种，例如 md5 ，sha256 等等，但是它们总体上可以分为两大类，一类是<strong>普通哈希</strong>，另外一类是<strong>加密哈希</strong>（cryptographic hash function）</p>
<p>哈希算法的安全性不单单是跟哈希长度有关，但是一般哈希值越长也就是越安全。</p>
<table>
<thead>
<tr>
<th>哈希算法</th>
<th>输出二进制位长度</th>
<th>输出十六进制位长度</th>
</tr>
</thead>
<tbody><tr>
<td>CRC-32</td>
<td>32</td>
<td>8</td>
</tr>
<tr>
<td>MD5</td>
<td>128</td>
<td>32</td>
</tr>
<tr>
<td>SHA-256</td>
<td>256</td>
<td>64</td>
</tr>
</tbody></table>
<p>例如本来 <strong>MD5</strong> 就是设计出来做加密哈希的，但是后来由于计算机的发展 MD5 出现<strong>碰撞的可能性就很大</strong>了，所以目前 MD5 只能当<strong>普通哈希</strong>用，用来做数据校验。<strong>加密哈希跟普通哈希的区别就是安全性</strong>，一般原则是只要一种哈希算法出现过碰撞，就会不被推荐成为加密哈希了，只有安全度高的哈希算法才能用作加密哈希。同时加密哈希其实也能当普通哈希来用，Git 版本控制工具就是用 SHA-1 这个加密哈希算法来做完整性校验的。<strong>一般来讲越安全的哈希算法，处理速度也就越慢，所以并不是所有的场合都适合用加密哈希来替代普通哈希。</strong></p>
<img src="https://img.haoqicat.com/2018100102.jpg" alt="img" style="zoom: 80%;" />

<h4 id="哈希函数和加密函数的区别"><a href="#哈希函数和加密函数的区别" class="headerlink" title="哈希函数和加密函数的区别"></a>哈希函数和加密函数的区别</h4><p>在密码学领域，有两个算法都是把数据做输入，而输出是一段谁也看不懂的数据。其中一个就是<strong>哈希算法</strong>，另外一个是<strong>加密算法</strong>。首先哈希算法的输出长度是固定的，而加密算法的输出长度是跟数据本身长度直接相关的，第二，哈希是不可以逆向运算出数据的，而加密算法的输出是要能够逆向运算出数据的。关于加密算法，我们这里就不展开聊了。Peter 这里主要是强调加密哈希算法只是被用在加密过程中，但是它本身不是加密算法。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总之，哈希算法有很多种，长度越长的算法基本认为越安全。<strong>安全度低的哈希算法被认为是普通哈希算法，主要用来做完整性校验。安全度高的被称为加密哈希算法，会被用在加密算法中。</strong>所谓的高低都是相对概念，例如 MD5 曾经属于加密哈希，但是目前只能用来做安全校验了。而从2017年开始，SHA-1 算法生成的加密证书也会被各大浏览器拒绝了。目前最流行的加密算法是 SHA-2 ，但是跟 SHA-1 不同，SHA-2 不是一种算法，而是一系列算法的统称，其中就包括咱们之前提过的 SHA-256 。</p>
<h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><p>首先一个场景是网站注册。当我们提交用户名密码的时候，用户名被会直接保存到网站的数据库中，但是密码却不是直接保存的，而是先把密码转换成哈希，保存到数据库中的其实是哈希。所以，即使是公司后台管理人员，也拿不到用户的密码。这样，如果万一公司数据库泄露了，用户的密码依然是安全的。而当用户自己登录网站的时候，输入密码提交到服务器，服务器上进行相同的哈希运算，因为输入数据没变，所以哈希也不会变，登录也就成功了。</p>
<p>另外一个场景是区块链和加密货币中。比特币地址生成的时候，就用到了 SHA-256 算法，POW 也就是工作量证明，用的也是这个算法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>哈希的基本作用就是提供一个数据的摘要或者指纹，通常的使用场景就是完整性校验。</strong>哈希算法有很多种，一般来讲哈希越长的算法，安全性也就越高，安全度足够高的哈希，或者说没有任何人能够成功实现碰撞的哈希，才有资格被考虑用在加密场合，而这类的哈希算法也被叫做加密哈希算法。实际中常见的哈希算法有 MD5 ，SHA-1 ，和 SHA-256 等等，其中 MD5 通常用来进行数据校验，SHA-1 曾经是加密哈希算法，但是目前已经被除名，也只能做为一种安全度更高的校验算法了。<strong>SHA-256 依然是广泛使用的加密哈希算法，在比特币生成地址以及 POW 工作量证明算法中都会用到。</strong></p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/01%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/01%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%86%E7%A0%81%E5%AD%A6/" class="post-title-link" itemprop="url">什么是密码学</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 19:00:00 / 修改时间：19:00:42" itemprop="dateCreated datePublished" datetime="2020-03-09T19:00:00+08:00">2020-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>密码学是对安全通信技术的研究，要能够有效的防范潜在攻击。</p>
<h4 id="主要应用（两个方面）"><a href="#主要应用（两个方面）" class="headerlink" title="主要应用（两个方面）"></a>主要应用（两个方面）</h4><p>密码学是数学和计算机科学的一个交叉。</p>
<p>一个就是<strong>加密通信</strong>，这个方向的主要任务是保证信息在传送过程中不会被篡改和窃听，这也是咱们比较容易想到的一个方向。但是，另一个方向其实也同样重要，那就是<strong>数字签名</strong>。数字签名跟现实世界中的纸笔签名类似，可以用来认证签署人身份，防止抵赖。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>密码学最基础的几个概念是<strong>加密，解密，密文和密钥</strong>。比如 Alice 有一段数据要传递给 Bob ，就要首先运行<strong>加密</strong>算法把数据转换成密文，密文就是一些看起来不知所云的内容。密文到了 Bob 机器上，Bob 运行对应的<strong>解密</strong>算法，就可以把密文再转换成数据。</p>
<p>那么什么是密钥呢？其实在加密和解密运算过程中有两个要素，一个是<strong>算法</strong>，另外一个是<strong>密钥</strong>（英文叫 <strong>key</strong>） 。key 就是参与加密解密运算过程的一小段数据。其实目前流行的加密解密算法一般都是公开的，因为不公开一般也没人敢用，怕有后门。所以信息的安全完全在于加密人和解密人手里是握有 key 的。如果我们把加密算法封装到一个加密函数中，函数的输入就是两个，一个是信息，一个是 key ，而函数的返回结果就是密文。解密过程也类似，就是把密文和 key 传递给解密函数，返回结果就是信息。我们以凯撒密码为例，凯撒要给他的将军发一封密信，这里凯撒使用的算法是把字母按照字母表顺序往后移动一定的位数，比如信息本来是 A ，现在往后移动3个位数，就变成了 D ，这样生成的密文就谁也看不懂了。那这个过程中算法是“字母偏移”，而 key 就是3。将军收到密文后，根据同样的算法和 key 反推就可以解密。</p>
<h3 id="公钥加密的核心地位"><a href="#公钥加密的核心地位" class="headerlink" title="公钥加密的核心地位"></a>公钥加密的核心地位</h3><p>当代密码学一直以来是分两套系统：<strong>对称加密和非对称加密</strong>。其中非对称加密也被叫做公钥加密，密码学的最核心技术。</p>
<h5 id="对称加密和非对称加密是如何区分"><a href="#对称加密和非对称加密是如何区分" class="headerlink" title="对称加密和非对称加密是如何区分"></a>对称加密和非对称加密是如何区分</h5><p>如果加密和解密使用同一个 key ，这就是对称加密技术，否则则是非对称加密技术。具体做法是首先生成一对 key ，其中一个是<strong>公钥（Public Key）</strong> ，公钥是可以公开给任何人的。另外一个是<strong>私钥（Private Key）</strong> ，要严格保密。发送方首先拿到接收方的公钥，用公钥把信息加密，接收方收到密文后，用私钥解密获得信息。</p>
<h5 id="非对称加密中最著名的算法有两种"><a href="#非对称加密中最著名的算法有两种" class="headerlink" title="非对称加密中最著名的算法有两种"></a>非对称加密中最著名的算法有两种</h5><p>一个是 <strong>RSA</strong> ，这是用三个作者的名字的缩写命名的算法， 另外一个是 <strong>ECC</strong> ，也就是椭圆曲线算法。RSA 是非对称加密技术的开山鼻祖。ECC 是更高效的一种加密算法，比特币就是使用了这种加密算法。</p>
<p>对称加密在发送方和接收方使用相同的 key ，所以建立安全通信的前提是双方先要有共享的 key 。相对比之下，公钥加密技术要分享的是公钥，不用担心泄露问题，相对要安全一些，另外公钥加密技术也衍生出了数字签名技术。</p>
<p>当然，公钥加密技术也需要考虑如何确认公钥所有人等技术问题，所以就有了 CA 也就是发证机构，以及 PKI 公钥基础设施等等这些的概念，这里我们就不展开了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们对密码学做了一个简要的介绍，大体上要点有这么几个：</p>
<ol>
<li>密码学是对安全通信技术的研究，要能抵御各种恶意攻击。</li>
<li>密码学的底层是数学，密码学的安全取决于一个难度足够高的数学问题，保证计算机在可接受的时间跨度内根本不可能运算出密钥。</li>
<li>当代密码学是互联网环境下的密码学，关键性技术是公钥加密技术。</li>
</ol>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/09%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/09%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/" class="post-title-link" itemprop="url">密码学/09椭圆曲线密码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 18:58:37 / 修改时间：15:49:31" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="椭圆曲线密码学简介"><a href="#椭圆曲线密码学简介" class="headerlink" title="椭圆曲线密码学简介"></a>椭圆曲线密码学简介</h1><p>这一节要聊的是 ECC （ Elliptic Curve Cryptography ），也就是椭圆曲线密码学。跟 RSA 一样，ECC 也属于公开密钥加密，<strong>ECC 算法也是用来生成公钥的私钥的</strong>。本节我们不会深入椭圆曲线算法本身，只是对 ECC 做一下简介。</p>
<h2 id="ECC-的作用"><a href="#ECC-的作用" class="headerlink" title="ECC 的作用"></a>ECC 的作用</h2><p>ECC 跟 RSA 算法一样，都可以生成公钥和私钥，然后进行加密通信和数字签名操作。ECC 在区块链领域有着特殊的地位。<strong>因为比特币就是用 ECC 来生成地址和私钥的</strong>。注意，比特币地址不是原封不动的公钥，而是公钥的一种转换形式。著名的以太坊项目，也使用了 ECC 。既然区块链领域的两个老大都会用到 ECC ，其他的公链项目中当然也都非常可能用到。HTTPS 也会用到 ECC 。现代的浏览器也都支持基于椭圆曲线密钥对的认证证书。</p>
<p>总之，ECC 应用范围很广，有人说”ECC是下一代的公开密钥加密算法”，似乎有取代 RSA 的意味。</p>
<h2 id="对比-RSA-的改进"><a href="#对比-RSA-的改进" class="headerlink" title="对比 RSA 的改进"></a>对比 RSA 的改进</h2><p>我们知道 RSA 是公钥密码学的鼻祖，那么后来者 ECC 到底有何改进呢？其实简单来说就是两个字“<strong>性能</strong>”。</p>
<p>我们先说 RSA 的不足。RSA 基于整数分解问题，我们可以相信只要两个大素数的乘积的反向求解问题没有解决，RSA 算法就是安全的，所以 RSA 可以说是非常简单的密码学。但是 RSA 的性能是短板，需要设置很长的秘钥，才能保证算法的安全。而<strong>秘钥越长，运算效率就越低</strong>。一个很尴尬的情况是，我们的超级计算机越来越厉害，所以就要求 RSA 的秘钥要越来越长。但是矛盾的是，移动设备又很流行，这就要求秘钥不能太长，不然在资源有限的移动设备上 RSA 算法就不能用了。这个矛盾越来越尖锐，所以更高效的算法就呼声很高。</p>
<p>ECC 算法从 2004 年开始才被广泛应用，要比 RSA 要晚很多，它的关键改进就是性能。同样的秘钥长度下，ECC 要安全很多。ECC 和 RSA 基于的都是正向运算很容易，反向运算很难的单向函数来设计的。运算越难，也就是意味着破解它运算所耗费的能源越多，或者说对应的碳排放量越多。比如给定一个228字节长度 RSA 秘钥，破解需要花费煮沸一勺水的能量。而同样长度的 ECC 秘钥，需要煮沸整个地球上所有水的能量。</p>
<p>可见，ECC 作为后来出现的算法要比 RSA 高效很多。</p>
<h2 id="ECC-的缺陷"><a href="#ECC-的缺陷" class="headerlink" title="ECC 的缺陷"></a>ECC 的缺陷</h2><p>但是，ECC 虽好也不是没有问题，如果真的是完美的，那么 RSA 应该早就被彻底替代了。</p>
<p>ECC 的数学原理是椭圆曲线和离散对数，椭圆曲线并不是一个很好理解的数学理论。造成了 ECC 其实要比 RSA 复杂很多。复杂带来的好处就是性能的提升，但是也同时潜藏了一些问题。椭圆曲线理论不展开讨论，但是粗略的讲，设计 ECC 的一套运算标准，涉及到的一个问题就是要选择一条合适的椭圆曲线。注意，ECC 使用的所谓的椭圆曲线其实并不是椭圆形，而只是在运算上跟椭圆运算有关联，实际上是一个类似乳头的形状。根据曲线选择的不同，ECC 的运算也会不同，所以就会形成不同的标准。</p>
<p><img src="https://img.haoqicat.com/2018100701.jpg" alt="img"></p>
<p>首先第一个潜藏的问题是，一套标准对应的这条曲线，是不是有可能有人暗藏数学机关呢？造成算法其实是可以通过后门来破解的。目前使用面很广的一套标准是 NSA ，也就是美国国家安全局发布的，这套标准就被怀疑是有后门的。</p>
<p>另外一个问题就是专利。基于 ECC 的各种使用方式，有人申请了很多个专利。而且这些专利很多都被一个公司所持有，这个公司就是黑莓。你永远也不知道自己开发一套新的 ECC 方案，会不会被认为触犯了某个专利，这一点也是很恶心的。</p>
<p>总之，虽然 ECC 目前发展良好，但是也面临着各种挑战。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先比较重要的是大家要理解什么是加密，这样才能理解 ECC 的使用场景。<strong>ECC 被称为新一代公开密钥加密技术，就是因为它比 RSA 算法更高效。但是 ECC 也因为算法复杂，导致了出各种问题的可能，例如被植入后门或者涉及专利之争。</strong></p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/08Merkle%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/08Merkle%E6%A0%91/" class="post-title-link" itemprop="url">密码学/08Merkle树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 18:58:37 / 修改时间：15:35:43" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h1><p>Merkle Tree 是由计算机科学家 Ralph Merkle 在很多年前提出的，并以他本人的名字来命名，中文翻译过来叫默克尔树，也叫哈希树。<strong>Merkle Tree 号称区块链面试必考题</strong>，因为的确太常用了。说到根本上 Merkle Tree 就是<strong>用来做完整性校验</strong>的，所谓的完整性校验，就是检查一下数据有没有损坏或者被恶意篡改。Merkle Tree 的最大的应用场合就是在点对点网络上，Git 版本控制系统，IPFS 协议以及比特币以太坊等等项目，都用到了它。</p>
<h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希 Hash"></a>哈希 Hash</h2><p>Merkle Tree 如果直接去看定义，会看到一张比较复杂的图，可能会把你一下子吓到，然后就不想学了。但是别忘了，Merkle Tree 还有另外一个名字，叫哈希树。这里会先讲哈希，再讲什么是哈希列表，最后在递进到哈希树，这样三步下来，每一步都其实很好理解，保证你能一下子就掌握 Merkle Tree 的概念。</p>
<p>先介绍什么是哈希。其实要实现完整性校验，最简单的方法就是对要校验的整个的数据文件做个哈希运算，把得到的哈希值公布在网上，这样我们把数据下载到手之后，再次运算一下哈希值，如果运算结果相等，就表示我们下载过程中文件没有任何的损坏。因为哈希的最大特点是，如果数据稍微变了一点点，那么经过哈希运算，得到的哈希值将会变得面目全非。没有人可以把数据篡改了，同时还能保证数据的哈希不变。</p>
<p><img src="https://img.haoqicat.com/2018092401.jpg" alt="img"></p>
<p>这种简单的采用哈希的方式做数据运算，比较适合数据本身不做分割，同时是放在一台服务器上的情况。例如，如果去某个公司网站上去下载他们的一个软件，就会看到公司网站上公布了这个下载包的哈希值，这个哈希值非常重要，因为有了这串数，我们就可以放心的去下载这个软件，<strong>下载完做一下完整性校验</strong>，就知道这个软件没有损坏。甚至可以放心从其他的不可信网站上去下载这个软件包，因为有了校验机制，也一样可以保证这个包是跟官方的包丝毫不差的。</p>
<h2 id="哈希列表-Hash-List"><a href="#哈希列表-Hash-List" class="headerlink" title="哈希列表 Hash List"></a>哈希列表 Hash List</h2><p>但是在去中心化网络，或者叫点对点网络上，数据往往都是拆分成很多小碎片去下载的，而且其中很多机器可以认为是不稳定或者是不可信的，这时需要有更加巧妙的做法。最简单的方式就是用 Hash List ，也就是哈希列表。</p>
<p><img src="https://img.haoqicat.com/2018092402.jpg" alt="img"></p>
<p>实际中，点对点网络在传输数据的时候，其实都是把比较大的一个文件，切成小的数据块。这样的好处是，如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，不用重新下载整个文件。当然这就要求对每个数据块计算哈希值，所有这些小数据块的哈希值都是兄弟关系，这样大家就组成了一个哈希列表。BT 下载的时候，在下载真正的数据之前，会先下载一个哈希列表的，这个就是所谓的种子文件。有了各个 hash 之后，数据本身就可以从任意的机器上下载了，不用管那些机器是否是安全可信的。</p>
<p>这时有一个问题就出现了，那么多的哈希，我们怎么保证它们本身都是正确地呢？</p>
<p><img src="https://img.haoqicat.com/2018092403.jpg" alt="img"></p>
<p>答案是我们需要一个根哈希，根就是树根的根。<strong>把每个小块的哈希值拼到一起，然后对整个这个长长的字符串再做一次哈希运算，最终的结果就是哈希列表的根哈希。</strong>于是，如果我们能够保证从一个绝对可信的网站，或者从我们的朋友手里拿到一个正确的根哈希，就可以用它来校验哈希列表中的每一个哈希都是正确的，进而可以保证下载的每一个数据块的正确性了。</p>
<p>Hash List 也就是哈希列表形式，就非常适合在点对点网络上存储的大型数据了。</p>
<h2 id="Merkle-Tree-哈希树"><a href="#Merkle-Tree-哈希树" class="headerlink" title="Merkle Tree 哈希树"></a>Merkle Tree 哈希树</h2><p>其实 Merkle Tree 本身也算是一个哈希列表，只不过是在这个基础上又引入了树形结构，从而获得了更高的灵活性。</p>
<p>我们先说计算机科学中的树的概念，树跟自然界一棵树有着类似的结构，只不过计算机科学中的树通常都是倒着画，根在上面，然后一路往下开枝散叶。举一个最简单的例子，所有的文件都存放在一个文件夹中，这个文件夹就叫根文件夹，根就是树根的意思，这个文件夹又会包含其他文件夹，子文件夹中又会包含孙子辈的文件夹。这样层层的包含或者说从属关系，画成图就是一棵倒挂的树，而这个结构就是计算机科学中随处可见的树的概念，怎么样，简单吧？</p>
<p><img src="https://img.haoqicat.com/2018092404.jpg" alt="img"></p>
<p>然后就说到主角 Merkle Tree 了。在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root 。需要补充一下的是，根哈希有时候也叫主哈希 Master Hash ，也有人叫它顶哈希 Top Hash ，因为画图的时候通常都是倒着画这根树，反正不管叫什么，说的都是一个东西。</p>
<p><img src="https://img.haoqicat.com/2018092405.jpg" alt="img"></p>
<p>于是我们看到 Merkle Tree 比普通的哈希列表稍微复杂了一点点，那么优点是什么呢？相对于 Hash List，Merkle Tree 的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这给很多使用场合就带来了哈希列表所不能比拟的灵活和高性能。</p>
<p><img src="https://img.haoqicat.com/2018092406.jpg" alt="img"></p>
<p>Merkle Tree 是三个概念的叠加，一个是哈希，第二个是哈希列表，第三个是树。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哈希和树都是计算机科学中最基础最重要的两个概念，可以用在很多不同场合。单个哈希不能担当大文件在分布式点对点网络上的校验工作，于是我们有了哈希列表的概念。 Merkle Tree 可以认为是哈希列表的一个变体，让哈希列表变得更加灵活高效，因为每次校验都可以单纯拿出树的一个分支来操作。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/07RSA-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/07RSA-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">密码学/07RSA-基础原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-09 18:58:37 / 修改时间：15:28:25" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RSA-算法–基本原理篇"><a href="#RSA-算法–基本原理篇" class="headerlink" title="RSA 算法–基本原理篇"></a>RSA 算法–基本原理篇</h1><p>RSA 算法是非对称加密算法鼻祖，至今仍然是最为广泛使用的算法之一，所以我们就来拆解一下 RSA 算法本身。</p>
<h2 id="宏观思路"><a href="#宏观思路" class="headerlink" title="宏观思路"></a>宏观思路</h2><p>说到最底层，<strong>RSA 算法的作用非常简单，就是生成公钥和私钥的</strong>。公钥用于加密信息，私钥用来解密，先上锁，后开锁。实现加密和解密的第一步就是找到一个函数，函数的正向运算很容易，但是逆向运算很难。对应 RSA 的情况，也就是把公钥和信息作为参数进行运算，得到密文，这个过程要很容易，而逆向运算，由密文和公钥想要获得信息，是很难做到的。</p>
<p><img src="https://img.haoqicat.com/2018100401.jpg" alt="img"></p>
<p>当然，这个函数还必须有另外一个特点。就是逆向操作虽然默认很难做到的，但是如果拥有了特定的提示信息，操作就变得非常容易了。这里的提示信息，显然就是<strong>私钥</strong>。</p>
<p>总之，找到这样一个正向容易运算，反向默认很难，但是如果有了私钥就很容易运算的函数，就是实现 RSA 算法的核心思路。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面我们就来看看 RSA 算法具体的实现方式。</p>
<p>先来补充一个数学知识：取模运算。取模运算其实就是算余数。例如 3 mod 2 的结果就是1，mod 就是取模的意思。</p>
<p><img src="https://img.haoqicat.com/2018100402.jpg" alt="img"></p>
<p>RSA 使用的单向函数是这样的，拿出要<strong>加密的信息 m</strong> ，我们知道任何的计算机信息都能转换成二进制数，所以当然也能转换成十进制的一个整数。这里 m 是一个整数，接下来<strong>随机选择一个 e</strong> ，来作为 m 的指数。注意，这里的指数 e 的选择范围是有一定限制的，但是在这个范围内是任意选择的。接下来，进行 m 的 e 次方运算，然后对另一个<strong>随机选取整数 N</strong> 进行取模运算，最后得到的结果就是<strong>密文，用 c</strong> 表示 。举个例子，m 等于7 ，e 选择为2 ，N 选择23，这样，最后的密文 c 就等于49对23取模，结果是6。也就是说7经过加密，最后密文是6。这个运算有个特点，给定 m 和 e 以及 N 的值，很容易算出 c ，但是给定 c 和 e 以及 N 很难算出 m 来。这就是我们需要的单向函数。</p>
<p><img src="https://img.haoqicat.com/2018100403.jpg" alt="img"></p>
<p>于是，我们的锁就有了，也就是 ”e 次方然后对 N 取模“。那么，开这把锁的钥匙是什么呢？简单来说，就是让逆向运算过程变得简单的信息。</p>
<p><img src="https://img.haoqicat.com/2018100404.jpg" alt="img"></p>
<p>逆向运算，就是从密文得到信息。经过数学推导，可以得到这样的逆向运算过程，一定存在一个整数 d ，使得 c 的 d 次方对 N 取模，是可以得到 m 的。最终，<strong>e 和 N 按照一定规范组合到一起，就是公钥，（加密），而 d 和 N 组合到一起就是私钥。（解密）</strong></p>
<p>总之，RSA 算法的单向函数找到了，于是加密用的锁也就找到了。但是其实这个函数本身不是 RSA 算法最复杂的地方，最复杂的内容在于如何由 e 算出 d 。<strong>而如何给定 e ，算出合适的 d ，其实是要引入第二个单向运算了，这就是整数分解问题了。</strong></p>
<h2 id="安全性取决与整数分解问题"><a href="#安全性取决与整数分解问题" class="headerlink" title="安全性取决与整数分解问题"></a>安全性取决与整数分解问题</h2><p>如何运算出 d 的过程本节不展开。粗略来讲，从 e 运算出 d 的过程，涉及到 N 的整数分解问题。整个 RSA 算法的安全性就取决于整数分解这个基本数学问题。</p>
<p>来解释一下整数分解问题。<strong>整数分解就是把一个数分解成多个素数的乘积</strong>。<strong>素数就是那些只能被1和自己整除的整数</strong>，这个小时候咱们学过的。例如 45 可以分解成 3x3x5 。而 RSA 算法中的整数分解有一定的特殊性。<strong>被分解的数需要是两个</strong>，而不是多个素数的乘积。虽然由两个素数相乘获得结果非常简单，但是反过来，分解过程是很难的。很难的意思就是如果数足够大，即使用计算机也需要成千上万年才能算出来的问题，或者可以说“很难”就等于”实际中不能实现“。而这一点就是 RSA 算法的安全基石。如果有一天，有数学家找出整数分解的有效运算方法，那么 RSA 算法也就不能用了。</p>
<p>实际生成公钥和私钥的过程是，我们选出 p1 和 p2 两个大素数，让 N = p1 * p2 。随机选择一个指数 e ，这样公钥就有了。而在知道 p1 和 p2 的前提下，从公钥算出私钥，也就是算出 d ，是非常容易的。而外人，因为不知道 p1 和 p2 ，而只知道 N ，所以不可能从 e 算出 d ，<strong>也就是不可能用公钥算出私钥。</strong></p>
<p>总之只要整数分解问题无解，那么 RSA 就是安全的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏观上的思路就是，要找到一个包含取模运算的单向函数，保证信息加密容易，而反向解密很难。另外，还要找到第二个单向函数，也就是整数分解问题的函数，保证在知道分解结果的条件下，从公钥算出私钥是容易的，而如果不知道，就不可能算出私钥。真正的 RSA 算法，是这两个单向函数的综合使用。但是对于如何进行解密，公钥和私钥生成的细节，我们没有展开，因为这涉及到更多的数学推导，下个小节 Peter 再给大家介绍。</p>
<h1 id="RSA-算法–粗略数学推导篇"><a href="#RSA-算法–粗略数学推导篇" class="headerlink" title="RSA 算法–粗略数学推导篇"></a>RSA 算法–粗略数学推导篇</h1><p>上节我们介绍完 RSA 算法的基本原理了，了解了 RSA 算法的加密锁就是先幂后模的运算。这个锁的特点是正向运算很容易，也就是<strong>加密过程很容易，但是解密过程很难</strong>，也就是要直接反向运算是不可能的。而要想让反向运算成为可能，就要在先幂后模运算的各项参数上做文章，让各项参数之间通过整数分解问题建立关系，这样只要我们把握住这种关系，那么反向运算就变得容易了。所以本节就来深入到整数分解问题，看看如何来构建先幂后模中的各项参数之间的关系，进而引申出如何生成公钥和私钥。</p>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>下面我们把要解决的问题进一步明确一下，抽象成具体的数学任务。先幂后模函数的正向运算，从信息 m 获得密文 c 是简单的，而反向运算，从 c 运算获得 m 是很难的。但是如果我们能够合理的构建 e 和 N 之间的关系，同时把握体现 e 和 N 之间关系的关键信息，这个反向运算将不再困难。</p>
<p><img src="https://img.haoqicat.com/2018100402.jpg" alt="img"></p>
<p>实际上，我们总能找到一个合适的 d ，<strong>使得 c 的 d 次方对 N 求模的结果就是 m</strong> 。所以问题进一步的就是要构建 e , d 以及 N 的数学联系。</p>
<p><img src="https://img.haoqicat.com/2018100403.jpg" alt="img"></p>
<p>实际上我们要做到的是，给定两个大素数 p1 和 p2 ，让 p1*p2 = N ，由 e 容易算出 d 的前提是我们知道 p1 和 p2 的值，也就是是知道 N 的整数分解的结果。而如果不知道 ，那么根据 e 和 N 算出 d 的难度就相当于对两个大素数的乘积做反向分解，这个是很难的。“很难”在这里的意思就是没有有效的求解方法，只能靠暴力搜索去解决，于是运算量超大，所以实际中不可能做到。</p>
<h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>问题的关键就是使用<strong>欧拉函数</strong>。</p>
<p>在 RSA 这里，欧拉函数的本来目的不重要，重要的是要使用的是它的一个属性：也就是，只有满足特定条件下才容易计算出它的结果，否则，就很难。推导过程我们就不说了，那这个特定条件是什么呢？<strong>其实就是当 N 是两个素数 p1 和 p2 的乘积的时候</strong>，因为此时可以保证下面的等式成立。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">φ<span class="comment">(N)</span> = <span class="comment">(p1-1)</span><span class="comment">(p2-1)</span></span><br></pre></td></tr></table></figure>

<p>例如 ，77 的欧拉函数其实是很难运算出来了，但是如果我们知道 77 可以分解为 7 和 11，那么就可以很容易得到结果 60 了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">φ(<span class="number">77</span>) = (<span class="number">7</span><span class="number">-1</span>)*(<span class="number">11</span><span class="number">-1</span>) = <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>基于欧拉函数的这个特点，只要我们能推导出 e ，d 跟 φ(n) 的关系，那就能保证在 φ（n) 能够运算出结果的时候，从 e 很容易得到 d ，否则，从 e 就很难算出 d 。推导过程要基于欧拉定理来进行。欧拉定理的具体意义我们不必深究。</p>
<p><img src="https://img.haoqicat.com/2018100601.jpg" alt="img"></p>
<p>其中三个横杠是组成的等式叫做同余式。例如，正整数 a，b 对 p 取模，它们的余数相同，就记做 a ≡ b (mod p)。</p>
<p>推导过程我们也从略了。最终，经过欧拉定义和上面其他结论进行推导，可以得到下面两个等式是同时成立的。</p>
<p><img src="https://img.haoqicat.com/2018100602.jpg" alt="img"></p>
<p>这样，就可以得到 e 和 d 的关系了：也就是 e 和 d 的乘积，等于 k 乘以 φ(N) 加 1 ：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = (<span class="name">k*</span>φ(<span class="name">N</span>) + <span class="number">1</span>)/e</span><br></pre></td></tr></table></figure>

<p>只要知道 φ(N) ，d 就可以算出来了。而如果不知道 φ(N) ，有了 e 也根本算不出 d 来。上面的 k 没有预先的固定值，而是要在运算过程中算出来的。<strong>k 的取值要保证给定一个 e 的数值</strong>， d 最终可以算出整数来。</p>
<p>通过上面的讨论，如何生成公钥和私钥的方法就有了，公钥是 N 和 e ，e 是在一定范围内随机选择的，而且是公开的。私钥是由 N 和 d 组成的，而 d 是在知道 N 的整数分解结果的条件下，通过上面的运算计算出来的。同时，加密函数也有了，就是信息 m 的 e 次方对 N 取模，解密函数就是密文 c 的 d 次方对 N 取模。</p>
<h2 id="运算公钥和私钥"><a href="#运算公钥和私钥" class="headerlink" title="运算公钥和私钥"></a>运算公钥和私钥</h2><p>下面我们就来实际使用一下上面的结论，生成一下公钥和私钥，并且做一遍加密和解密。</p>
<p>首先选择两个比较大的素数，实际中一般是几百位，但是我们这里为了演示方便，选择小的一点的。p1 = 53 , p2 = 59 ，这样 N = 53*59=3127 。</p>
<p>首先来生成公钥和私钥，Alice 选取 e = 3 。于是公钥就是 e 和 N 这两个数的组合。公钥有了。下一步来生成私钥，也就是去运算 d 。 因为知道 p1 和 p2 的值，所以 φ(N) 很容易算出结果，就是 3016 。根据上面运算 d 的公式，当 k 等于 2 的时候，d 可以取得整数值，d 就等于</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = (<span class="number">2</span>*<span class="number">3016</span>+<span class="number">1</span>)/<span class="number">3</span> = <span class="number">2011</span></span><br></pre></td></tr></table></figure>

<p>私钥就是 N 和 d 的组合。</p>
<p>接下来看加密和解密过程。Alice 把 e 和 N ，也就是公钥发送给了 Bob 。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">89</span>^<span class="number">3</span> mod <span class="number">3127</span> = <span class="number">1394</span></span><br></pre></td></tr></table></figure>

<p>Bob 把原文 89 ，e 和 N 带入到加密函数中，最终得到密文 c = 1394 。加密过程完成。</p>
<p>Alice 收到密文之后，可以用私钥进行解密。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1394</span>^<span class="number">2011</span> mod <span class="number">3127</span> = <span class="number">89</span></span><br></pre></td></tr></table></figure>

<p>也就是，把密文，d 和 n 都带入解密函数，这样就得到了信息 m = 89 。</p>
<p>这样我们就完成了整个的过程。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>我们的问题是，如何构建先幂后模运算的各项参数之间的关系，从而保证如果一个人掌握了这种关系，是可以对加密锁进行反向运算的。关系是通过整数分解问题去构建的，推导过程中会用到欧拉函数的一个重要特性，也就是如果参数的整数分解结果是知道的，那么欧拉函数的结果也就很容易算出来，否则欧拉函数很难被求解。于是经过推导，我们可以得出 <code>e*d</code> 跟欧拉函数的值有着固定的联系，于是得到了从公钥（基本就是 e ）运算出私钥（基本就是 d ）的方法。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/06%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/06%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/" class="post-title-link" itemprop="url">密码学/06数字证书</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 18:58:37" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 23:57:46" itemprop="dateModified" datetime="2020-03-08T23:57:46+08:00">2020-03-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>先来个预警，没有婚姻的社会里面，没有人能理解结婚证是干什么的，同理，不理解公开密钥加密技术的加密通信和数字签名这两个概念，也不会理解数字证书什么用。这些话题之前，前面小节中咱们都聊过了，不知道你有没有记住呢？好，那么什么是数字证书，发证机构的作用是什么，加密通信和数字签名过程中证书发挥什么作用呢？下面一一揭晓。</p>
<h2 id="什么是数字证书？证明公钥是你的"><a href="#什么是数字证书？证明公钥是你的" class="headerlink" title="什么是数字证书？证明公钥是你的"></a>什么是数字证书？证明公钥是你的</h2><p>数字证书是一个由可信的第三方发出的，用来证明所有人身份以及所有人拥有这个公钥的电子文件。</p>
<p>拿出一份典型的数字证书，看看里面到底都包含哪几项内容。<strong>首先是发证机构 CA。第二个是所有人姓名，例如 Peter 。第三个是所有人公钥，以及公钥的过期时间。最后一项就是 CA 的数字签名。</strong>好，根据咱们已有的数字签名的知识，可以得出几个结论。首先，数字签名是 CA 发出的，也就是说 CA 用自己的信用为这个证书做背书。第二点，证书上同时带有所有人信息和公钥，数字签名保证了证书是不可篡改的，所以说，只要大家信任 CA ，就可以信任所有人和公钥之间的绑定关系。</p>
<p><img src="https://img.haoqicat.com/2018093001.jpg" alt="img"></p>
<p>所以说，<strong>数字证书就是第三方机构发行的证书，主要作用就是证明你的公钥的确是属于你的</strong>，而公钥其实就是我们在数字世界的身份，所以说数字证书的作用实际上就是证明你是你自己。</p>
<h2 id="数字证书的作用"><a href="#数字证书的作用" class="headerlink" title="数字证书的作用"></a>数字证书的作用</h2><p>常见的两个应用场合，<strong>一个是用在数字签名方面</strong>，<strong>另外一个就是 HTTPS</strong> 。我们首先看一个完整的数字签名的使用过程，分析其中的安全隐患，再看看数字证书是怎么解决这个问题的。</p>
<p>Bob 想要把一个带数字签名的文件传递给 Alice 。于是 Bob 生成了公钥和私钥，用私钥签署了文件。然后把公钥上传到一个公共服务器上。如果一切顺利，那 Alice 去下载这个公钥，然后就可以验证签名，确认文件的确是 Bob 发出的，同时没有被篡改过。但是这里的安全漏洞是明显的，那就是 Alice 无法确认她下载的公钥是不是真的是 Bob 的。这就给所谓的“中间人攻击”提供了可能。假设在 Bob 的文件还没有到达 Alice 之前，黑客发起了中间人攻击，删除 Bob 的文件，然后签署一个假文件发送给 Alice ，Alice 收到后去公共服务上下载的公钥其实也被黑客替换过的，她用这个公钥去验证了签名，自认为文件就是 Bob 发出的，所以被骗了。其实仔细想想，问题就出在公钥本身没有办法证明自己的主人是谁。</p>
<p>所以要避免中间人攻击，就要使用数字证书。<strong>Bob 签名文件之后，给 Alice 发送时附上自己的证书</strong>。Alice 收到证书之后，就可以信任证书中的公钥的确就是 Bob 的了。有了这个公钥，可以验证文件附带的数字签名是 Bob 的。数字签名没问题，就保证了文件是没有被篡改过的。至于 Alice 如何确认证书本身是可信的，稍后我们聊 HTTPS 的过程中再展开聊。</p>
<p>到这里，我们就明白了数字证书在验证数字签名的过程中发挥的作用了。</p>
<h2 id="通过-HTTPS-理解证书"><a href="#通过-HTTPS-理解证书" class="headerlink" title="通过 HTTPS 理解证书"></a>通过 HTTPS 理解证书</h2><p>日常中非常常见的加密通信过程就是 HTTPS ，下面我们就详细聊聊 HTTPS 的原理，来帮大家加深一下对数字证书的理解。</p>
<p>HTTPS 就是安全的 HTTP 的意思，是一套用在浏览器和服务器之间通信的协议。使用了 HTTPS 后，浏览器跟服务器之间所有的通信内容都是加密过的。这个过程中的主角就是 SSL 证书，<strong>SSL 证书就是用在 HTTPS 条件下的数字证书</strong>，也是由可信的第三方 CA 来颁发。只不过验证的不是人的身份，而是用来<strong>验证服务器身份和它的公钥</strong>，目的是建立浏览器和服务器之间的信任。</p>
<p>比如，我现在用浏览器来访问谷歌服务器。要建立加密通道，首先第一步是要传递公钥过来，但是服务器传递过来的公钥如果过程中被篡改过，那么后续的加密通信也就全无安全性可言了。所以谷歌需要先去 CA 机构申请 SSL 证书，放到自己的服务器上。这样，我在浏览器中输入谷歌的网址，谷歌那边会首先给浏览器发送 SSL 证书。注意，各个浏览器中都内置了对全球各大 CA 机构的验证机制，底层的原理就是拥有 CA 们的公钥，可以验证证书上 CA 的签名。如果证书没有问题，浏览器就可以断定证书中携带过来的公钥就是谷歌的。这时候，浏览器会生成一个秘钥，注意这里就是对称加密的思路了，发送给谷歌服务器。这样，谷歌拥有浏览器的加密秘钥，可以用对称加密的思路来跟浏览器通信了，这样一个双向的加密通信通道也就开通了。对称加密的加密效率要比非对称高，所以大量数据的传递首选对称加密。</p>
<p><img src="https://img.haoqicat.com/2018093002.jpg" alt="img"></p>
<p>这个就是 HTTPS 的基本原理了。加密通信过程中，证书的作用是判断公钥所有人。HTTPS 整个过程中，同时涉及到了数字签名和加密通信，还用到了对称加密和公钥加密两种不同的加密方式，算是比较综合的一个知识点了。但是要提醒一下，SSL 证书，尤其是免费的 SSL 证书，一般对于申请人的身份本身没有很严格的审查，CA 只能保障我拥有这个域名和这个服务器，而且这个公钥是跟这个域名和服务器绑定的。但是究竟我是不是好人，网站是不是会干坏事，CA 机构也不知道。所以一个网站拥有了 HTTPS，浏览器地址栏上面出现了绿色的安全小锁，也并不代表你就可以完全信任这个网站。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>证书的作用就是认证所有人和公钥的关系。有了证书就可以避免中间人攻击，可以安全的建立起加密通道。但是我们要知道的是，这里的安全完全基于对一个第三方机构，也就是 CA ，的信任。而 CA 为何值得信任呢？基本上就是因为 CA 一般都是大机构，都是政府认证的，等等这些传统的信任机制。不过当前，已经有区块链公司会通过去中心化的思路来“去信任”，来实现无 CA 机构的数字证书，让我们共同期待。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/05%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/05%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="post-title-link" itemprop="url">密码学/05数字签名</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 18:58:37" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 22:06:48" itemprop="dateModified" datetime="2020-03-08T22:06:48+08:00">2020-03-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>公开密钥加密技术有两大应用，之前已经聊了一个，就是加密通信，本节来聊另外一个：数字签名。数字签名的基本作用跟现实世界的纸笔形式的签名有什么相同点和不同点，数字签名的基本原理和流程又是什么呢？</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>先说数字签名的基本原理。数字签名过程跟加密通信有着一定的对称性，这种对称有着一种逻辑上的美。</p>
<p><strong>加密通信是用公钥进行加密，而用私钥进行解密。而数字签名刚好相反，是采用私钥加密，公钥解密。</strong>对于加密通信，公钥加密过程就是通过加密算法把信息加密成密文，私钥解密过程就是通过解密算法解密密文。<strong>而对于数字签名，私钥加密过程是通过签名算法来生成数字签名的过程，而公钥解密过程是通过验证算法来确定数字签名是不是有私钥持有者签署的。</strong>可以看到，加密算法，解密算法，签名算法，验证算法，对称性是很明显的。</p>
<p><img src="https://img.haoqicat.com/2018092901.jpg" alt="img"></p>
<p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息，输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p>
<p><img src="https://img.haoqicat.com/2018092902.jpg" alt="img"></p>
<p>所以说数字签名的原理是非常清晰的，因为数字签名本身跟加密通信形成一个对称关系，而数字签名自己的签名过程跟验证过程，也是个对称关系。把握这种对称性，就比较容易记住基本原理了。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>静态的基本原理懂了，咱们再来从时间维度看看数字签名动态流程。</p>
<p>Alice 要签署一个文件，于是她就拿出自己的私钥，执行签名算法，得到数字签名。那么其他人如何去验证这个数字签名的确出自 Alice 呢？首先，Alice 要把自己的公钥放到一个大家都可以访问到的服务器上，这样其他人都可以获得 Alice 的公钥，大家把文件，数字签名以及公钥下载到自己的计算机上，调用验证算法，就可以判断这个文件是不是 Alice 签署的了。不管是签名算法还是验证算法都是全球公开的，每个人都可以在自己的计算机上安装软件来执行这两个算法。</p>
<p><img src="https://img.haoqicat.com/2018092903.jpg" alt="img"></p>
<p>这就是一个 Alice 签署文件，其他人验证签名的完整过程了。这个过程中有一点要注意，就是签名本身是不会加密文件本身的。在底层，签名过程其实是加密了文件的哈希值，总之签名的目的不在于加密文件信息，而在于生成数字签名。</p>
<h2 id="实际作用"><a href="#实际作用" class="headerlink" title="实际作用"></a>实际作用</h2><p><strong>数字签名有三大作用</strong></p>
<p><strong>第一个是认证</strong></p>
<p>先看第一个认证，意思就是确认签署人身份，这个跟纸笔签名的作用是一致的。</p>
<p><strong>第二个是防止抵赖</strong></p>
<p>再看第二个防止抵赖，同样是纸笔签名也拥有的特性，一份合同签署了，就要承担责任，白纸黑字，不能耍赖。</p>
<p><strong>第三个是保证文件完整性，也就是没有被篡改过。</strong></p>
<p>第三个作用是保证文件没有被篡改过，这个作用纸笔签名很难保证，比如签名只签署了最后一页，那么如果有人想悄悄换掉了前几页的内容，签名本身是阻止不了的。但是数字签名就可以，因为数字签名是由两个输入运算得出的，一个是私钥，另一个就是文件，所以如果在验证过程中，发现文件有改动，验证会失败。这个很类似于现实世界签合同的时候，有时候需要故意用签名或者图章覆盖有文字的区域，或者在写信的时候，给信封加上蜡封，这些措施也都是为了防篡改。</p>
<p>这就是数字签名的三大作用，主要用在各种防伪造场合，在世界上很多国家，数字签名都是有法律效力的。另外要注意，数字签名属于电子签名的一种，但并不是所有的电子签名都是数字签名，这两个概念要区分一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数字签名是公钥加密技术的两大应用之一。主要采用了私钥加密，公钥解密的方式，文件签署者用私钥签署文件，就表示他认可了这个文件的内容。要验证数字签名，只需要签名人公布自己的公钥即可，其他人通过验证数字签名即可验证文件是私钥签署的。签署人不需要暴露自己的私钥，就可以间接证明自己拥有私钥。除了认证签署人身份，数字签名还有两个作用，分别是防止抵赖和保证文件完整性。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/04%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/04%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">密码学/04加密通信</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-09 18:58:37" itemprop="dateCreated datePublished" datetime="2020-03-09T18:58:37+08:00">2020-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-08 21:37:21" itemprop="dateModified" datetime="2020-03-08T21:37:21+08:00">2020-03-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h1><p>早期人们的解决方案其实跟密室是一个道理，就是通过私有网络，也就是从物理上隔绝其他人。但是私有网络衰落，互联网兴起后，客观条件就不同了，互联网是一个公开场合，数据在通信过程中默认是能够被别人获取到的，那么这个时候保证私密的策略就从“不让你看见”变成“看见你也看不懂”了。具体做法就是：首先把信息加密成密文，到达接收方之后，再把密文解密成信息了，这个过程就是加密通信。</p>
<h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>先说加密通信的一种最简单的方式，就是对称加密。这个是人类用了几千年的方式，凯撒密码就属于这种。所谓对称，意思就是发送方和接收方使用的是同一个钥匙，或者英文叫 key 。但是互联网上的加密通信，也使用了另外一种形式，也就是非对称加密，或者叫公开密钥加密。</p>
<p>说说类似于凯撒密码的对称加密的基本工作原理。发送方会按照一定规则，把信息变成密文，密文说白了就是谁也看不懂的东西。等密文到了接收方手里，接收者需要按照同样的规则，也就是同一个 key ，把密文翻译成信息。加密通信过程就完成了。</p>
<p><img src="https://img.haoqicat.com/2018092601.jpg" alt="img"></p>
<p>但是对称加密的问题就在于如何安全的传递 key 本身。没有 key ，就不能建立安全的通信通道，没有安全的通信通道，就无法安全的把 key 传递给接收方，所以这就是一个鸡生蛋蛋生鸡的问题了。于是，互联网上做加密通信就用到了非对称加密。非对称加密，也叫做公开密钥加密，<strong>特点是发送方和接收方使用的不是同一个 key</strong> 。这种方式略微有点反直觉了吧，具体原理稍候会讲到。</p>
<p><img src="https://img.haoqicat.com/2018092602.jpg" alt="img"></p>
<p>总之，加密通信可以采用的方式有两种，一种是对称加密，一种是非对称或者叫公开密钥加密。对称加密的特点是发送方和接收方采用相同的 key ，非对称加密发送方和接收方采用的是不同的 key 。</p>
<h2 id="公开密钥加密基本原理"><a href="#公开密钥加密基本原理" class="headerlink" title="公开密钥加密基本原理"></a>公开密钥加密基本原理</h2><p>下面来详细说说用公开密钥加密的基本原理。主要是要理解公钥和私钥的关系。</p>
<p>首先，可以在自己的机器上安装类似 ssh-keygen 这样的软件来生成公钥和私钥。公钥和私钥之所以是一对，是因为二者有天然的数学联系，但是同时要保证给定公钥不能够算出私钥，不然就相当于加密方法被破解了。公钥和私钥的联系一般就是通过一些无解的数学问题来确定的，这类问题只能正向运算，不能反向运算。比如 8616460799 这个数是两个数相乘得到的，但是要从结果反推出这两个数，是基本不可能的。实际中 RSA 和 ECC 算法，都是基于这一类的数学问题。</p>
<p><strong>加密通信过程是怎么样的呢？</strong></p>
<p>首先，如果 Alice 想让 Bob 给她发信息，注意这里 Bob 是发送方，而 Alice 是接收方。首先 Alice 要把自己的公钥传递给 Bob ，然后 Bob 用 Alice 的公钥去加密信息，Alice 收到密文之后可以用私钥进行解密。这就是非对称加密的基本逻辑了，<strong>发送者将接收者公钥用于加密，接收者将自己的私钥用于解密</strong>。</p>
<p><img src="https://img.haoqicat.com/2018092603.jpg" alt="img"></p>
<p>当然，上面所说的过程还只是单向通信，要实现双向通信，就需要双方把各自的公钥传递给对方了。</p>
<h2 id="公开密钥加密的更多技术细节"><a href="#公开密钥加密的更多技术细节" class="headerlink" title="公开密钥加密的更多技术细节"></a>公开密钥加密的更多技术细节</h2><p>公开密钥加密的基本思路是比较简单的，就是用公钥去加密，用私钥去解密。</p>
<p>如果公钥就是用来加密信息的，那为啥不叫 lock 也就是锁，而要叫 key ，钥匙呢？所以说既然公钥也是钥匙，那么它就是一定也有解密功能。公钥加密技术其实有两个重大应用，一个就是我们本文所述的加密通信，但是还有第二个，就是数字签名。<strong>加密通信是用来保证机密性的，而数字签名是用来认证的</strong>。<strong>数字签名的基本原理是用私钥去加密，而用公钥去解密。</strong>也就是我用私钥签名一份文件，而全世界的人都可以用我的公钥去解密数字签名，如果解密成功，就可以认定，这个文件的确是我签署的。所以说，加密通信条件下，私钥可以叫做“解密 key”，而在数字签名条件下，公钥可以叫做“验证 key”。这样，我们就理解了为啥公钥也是 key 了。</p>
<p>另外一个问题是，公开密钥加密都有哪些实际应用呢？首先就是加密通信，银行政府传递数据也是用这个思路的，所以加密通信还真是关系重大。如果你是程序员，可能会经常用 ssh 登录服务器，这个背后也是用公开密钥加密技术来实现安全通信的。另外网站现在都流行使用 HTTPS 协议，也就是安全的 HTTP ，来达成浏览器跟服务器之间的加密通信，这个背后也是公开密钥加密技术。另外，比特币等加密货币，背后也都是公开密钥加密技术。</p>
<p>最后一个问题会引发我们进一步的学习，那就是如何解决公钥加密过程中的一些具体问题，例如，如何安全的把公钥发送给对方，保证公钥没有被篡改过。实际上这个问题还真的是非常困难的，所以会涉及到发证机构（ CA ）这样的概念。后面我们专门有一节介绍 CA 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要实现加密通信，有对称加密和非对称加密，也就是公开密钥加密两种方式。所谓非对称，就是加密和解密是采用不同的 key 。<strong>公钥用来加密信息，私钥用来解密信息</strong>。双方通信之前，要先互相交换公钥，这样才能建立起安全的双向通道。公钥加密的应用有两个，一个就是本节聊的加密通信，另一个就是数字签名。】</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">kafka软件配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-03 09:06:59 / 修改时间：19:35:19" itemprop="dateCreated datePublished" datetime="2020-03-03T09:06:59+08:00">2020-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index">
                    <span itemprop="name">软件配置</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hongery"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Hongery</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hongery" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hongery" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_40098405" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40098405" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1281185088@qq.com" title="E-Mail1 → mailto:1281185088@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail1</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hongery@yeah.net" title="E-Mail2 → mailto:hongery@yeah.net" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail2</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hongery</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">NaN:aN字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
