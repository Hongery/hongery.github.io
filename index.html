<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="website">
<meta property="og:title" content="Hongery">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hongery">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hongery">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hongery</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hongery</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Hongery" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">Ripple支付开源协议</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:45:24 / 修改时间：14:46:35" itemprop="dateCreated datePublished" datetime="2020-01-10T14:45:24+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>224</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><p>Ripple（瑞波）是一种基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。在Ripple的网络中，交易由客户端发起，经过追踪节点（tracking node）或验证节点（validating node）把交易广播到整个网络中。追踪节点的主要功能是分发交易信息以及相应客户端的账本请求。验证节点除了包含追踪节点的所有功能外，还能通过共识协议，在账本中增加新的账本实例数据。</p>
<p>下面我用在图形中分析具体的共识过程：</p>
<p><img src="http://image.chaindesk.cn/Ripple1.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple2.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple4.png/mark" alt="img"></p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">EOS共识机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:44:42 / 修改时间：14:44:54" itemprop="dateCreated datePublished" datetime="2020-01-10T14:44:42+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="EOS共识机制"><a href="#EOS共识机制" class="headerlink" title="EOS共识机制"></a>EOS共识机制</h3><p>EOS在第一版白皮书中使用的DPOS共识机制，而在新一版的白书中，对共识机制进行了改进，使用BFT+DPOS混合共识机制。使出块速度从原来的3秒变为0.5秒，tps显著提高，达到测试3590次/秒。</p>
<h2 id="EOS第一版共识机制DPOS"><a href="#EOS第一版共识机制DPOS" class="headerlink" title="EOS第一版共识机制DPOS"></a>EOS第一版共识机制DPOS</h2><p>EOS现在系统运行的链用的共识机制是第一版白皮书的，也就是纯DPOS共识机制。<br>DPOS即授权权益证明共识机制。相比于比特币的POW机制，DPOS不用浪费算力资源去争夺记账权，而是通过赋予EOS通证持有人的投票选举，选出21个超级节点担任记账人的角色，保证整个网络的正常运行。值得一提的是，人们的投票所占的比重取决于他们持有多少token。这意味着拥有更多token的人将比拥有极少token的人更多地影响网络。这其实很好理解，因为持有网络的运行的好坏会对持有更多token的人的利益产生更大的影响，这使得他们的投票更谨慎。<br>21个超级节点轮流负责记账。<strong>每轮都会随机打乱他们的出块顺序，</strong>每个超级节点作为出块节点时，只负责出一个块。每一个区块产生后会按照顺序传递给下一个超级节点中。第二个超级节点要负责打包新的区块，同时还要确认上一个区块的内容。当某一个区块被超过2/3的超级节点确认后，则该区块将成为不可逆转区块，即上链区块。</p>
<p>该算法有些地方明显需要改良。比如容易出现漏块现象。21个超级节点分布世界各地，如果随机打乱顺序，导致总是依次顺序的节点相距地理位置很远，如中国和美国，这两国的网络传输单向时间是300毫秒，一来一回总共600毫秒。那么中国这边出块，然后经过其他20个节点确认后返回，假设时间总共是4秒；而接下来美国出块，反馈回来的时间是3秒，比中国快1秒，肯定是先上链的，结果中国出的块就被丢弃掉了。当前目前设的出块时间是3秒，理论上能够解决这种漏块现象，但想提高eos的性能，这块肯定是要改进的。</p>
<h2 id="EOS最新版共识机制BFT-DPOS"><a href="#EOS最新版共识机制BFT-DPOS" class="headerlink" title="EOS最新版共识机制BFT-DPOS"></a>EOS最新版共识机制BFT-DPOS</h2><p>BFT即拜占庭容错算法。EOS引入这个算法，主要是赋予出块节点更大的权力，加快出块速度，解决节点出的块都被漏掉的问题。</p>
<p>EOS共识算法的升级，势必需要超级节点们更新代码，使用新的程序，然后在当前链上继续运行。但如果超过1/3的节点拒绝更新代码，可能会出现硬分叉问题。所以如何很好地做好过渡是EOS最大难题。</p>
<p>我们一起分析下改进后的共识机制是如何工作的。</p>
<p>EOS使用BFT+DPOS共识机制后，不再按照出块顺序让超级节点一个个验证区块内容，而是让出块节点成为主节点。出块后，同时向其他20个超级节点进行广播该区块，并获得他们的验证。如果超过2/3的节点验证通过后，则该区块将成为不可逆转区块。</p>
<p>BFT可以使EOS出块速度显著增加。目前使用BFT+DPOS共识机制的EOS，可以实现0.5秒的出块速度，1秒实现区块的不可逆转。为避免因出块速度过快而漏块，EOS的超级节点按照其他的地理位置依次轮流成为主节点，尽可能减少超级节点的网络延迟。比如超级节点有中国、美国、加拿大、日本，那么成为主节点的顺序是中国&gt;日本&gt;美国&gt;加拿大或者反过来，总之保证相邻最近的超级节点要依次交接主节点角色。</p>
<p>同时规定每个主节点连续生产6个区块，至少保证6个区块的前几个能确认完成，不存在整个超级节点被跳过的现象。可以看出每轮记账节点的出块总时间还是3秒钟，在这3秒里，因为他对他自己出的块是信任的，所以可以持续出块。一边出块一边广播，3秒之内率先广播的区块肯定能够得到确认，在网络通畅的情况下，6个区块都会可能得到确认。</p>
<p>EOS共识处理分叉问题非常简单，和比特币一样，节点只会认可最长的链作为合法链。假如某个节点开始作恶，自己出块并生成自己的链，也就是每次轮到它就产生6个块。但是超级节点总共21个，每轮产生理论126个块。根据选择最长链作为主链原则，肯定作恶的链得不到认可。所以EOS不会发生分叉问题。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">PBFT实用拜占庭容错系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:44:02 / 修改时间：14:44:14" itemprop="dateCreated datePublished" datetime="2020-01-10T14:44:02+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>PBFT即<strong>实用拜占庭容错系统</strong>，英文全称<strong>Practical Byzantine Fault Tolerance</strong>。它是第一个基于BFT理论并结合实际产生的新的共识算法。但应用场景是私有链和联盟链，如果用于公链，需要和其他共识算法进行灵活的混用。</p>
<h2 id="PBFT算法原理"><a href="#PBFT算法原理" class="headerlink" title="PBFT算法原理"></a>PBFT算法原理</h2><p>PBFT是一类<strong>状态机拜占庭系统</strong>，要求共同维护一个状态，所有节点采用的行动一致。为此，需要运行三类基本协议，包括一致性协议（Agreement）、验证确认协议（Validity）和视图更换协议（Viewchange）。</p>
<h5 id="1-一致性协议："><a href="#1-一致性协议：" class="headerlink" title="1.一致性协议："></a>1.一致性协议：</h5><p>在PBFT系统中，节点分为两类：主节点（Lead）和从节点（Follow）。主节点就一个，其他剩余节点都是从节点。在实现PBFT系统功能之前，所有节点都是从节点，经过选举，产生一个主节点。每个节点都有被选举权和选举权，选举过程每个节点的概率都是平等的。</p>
<p>一致性协议包含若干个阶段：请求（Request）&gt;序列分配（Pre-prepare）&gt;相互交互（Prepare） &gt;确认（Commit） &gt;响应（Reply）。过程如下图：</p>
<p><img src="http://image.chaindesk.cn/pbft.jpg/mark" alt="img"></p>
<p>注：C为客户端或叫请求节点；0为当前视图下的主节点；1，2，3是从节点，其中3为宕机节点。<br>该视图满足拜占庭容错，即系统节点总数4 &gt;故障节点个数1x3             1&lt; 4 * (1/3)</p>
<p>1）Request阶段<br>也就是Lead生成请求阶段。</p>
<p>客户端发送请求到主节点，或者主节点主动从某数据源获取数据作为请求</p>
<p>2）Pre-prepare阶段<br>也就是Lead给其他所有Follow发送请求阶段。</p>
<p>主节点将收到的请求进行处理，给请求赋值一个序列号n，形成一个带序号的副本，然后分发给其从节点。其中序号n必须在水线（watermark）上下限h和H之间。水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间。发送副本的格式是 <code>&lt;,m&gt;</code>，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要，n是序号。</p>
<p>3）Prepare阶段<br>也就是Follow收到请求，但不知道其他节点请求是什么，就给收到的<strong>请求签名</strong>发给其他所有节点，告诉他们我收到了这样一个请求。</p>
<p>从节点接收到副本后，对副本进行校验和确认。检查副本中请求是否签名合法；检查d与m的摘要是否一致；检查当前视图编号是是否与副本v一致。满足这些条件后，从节点将副本存入消息日志中，然后对副本进行签名并转发给其他的所有节点（包括主节点）。如果不满足，则该验证节点就会进入View change阶段。</p>
<p>4）Commit阶段<br>也就是每个节点收到其他所有节点的签名请求，把这个合法请求跟自己之前保存的请求进行比较，如果超过有2f个请求一样，那么这个请求他会认为是大家共识的请求。然后对这个请求进行处理。</p>
<p>当前阶段所有节点，包括主节点，<strong>对接收到的签名副本进行签名验证和确认</strong>。签名验证通过后的副本与自己保存的副本进行比较，设和自己一样的副本个数记为 s，满足(自己+收到的副本) s+1&gt;= 2f，故障节点的个数为f，则该节点将会对这个请求进行响应，给予运算结果，并做签名。 2+1&gt;=2*1</p>
<p>5）Reply阶段<br>也就是将处理结果发送给客户端，客户端收到 f+1(=2)个一样结果，那么客户端会认为该结果正确。</p>
<p>每个收到请求的节点都会对请求进行响应处理，将结果广播给客户端。当客户端接收到 f+1的响应相同时，则会认为该响应就是请求的结果。</p>
<h5 id="2-验证确认协议："><a href="#2-验证确认协议：" class="headerlink" title="2.验证确认协议："></a>2.验证确认协议：</h5><p>在一致性协议使用时都用到了这个协议。在PBFT系统中，时刻保证数据的准确性，要进行数据校验和签名确认。对Lead的任何行为要进行监视，如果Lead有做越权或错误的事件，其他节点可以对其进行举报。</p>
<h5 id="3-视图更换协议：-更换主节点"><a href="#3-视图更换协议：-更换主节点" class="headerlink" title="3.视图更换协议：(更换主节点)"></a>3.视图更换协议：(更换主节点)</h5><p>此阶段主要是用户在设计PBFT系统时，<strong>对Lead节点权限的设定</strong>。</p>
<p>比如定时多长时间，正常更换Lead，其他Follow节点都有机会成为新的Lead。在Lead任期时期，如果超过2/3的节点反映它有问题，那么也会触发view change。还有Lead在运行中突然挂掉，也会触发view change。我们需要确保在新的view中如何来延续上一个view最终的状态，（比如给这时来的新请求的编号，还有如何处理上一个view还没来得及完全处理好的请求。）</p>
<h2 id="PBFT算法在公链中的应用"><a href="#PBFT算法在公链中的应用" class="headerlink" title="PBFT算法在公链中的应用"></a>PBFT算法在公链中的应用</h2><p>PBFT机制不需要挖矿，也不需要权益计算，所以通过它达成共识的时间会很快，为了提高公链的tps(每秒事务处理量(TransactionPerSecond))，将PBFT灵活改进并引入公链，和pow算法或pos相结合形成一套新的混合机制，非常明智。目前这样应用的公链比较多，我下边主要讲解初链（TrueChain）是怎么实现的。</p>
<p><strong>初链</strong>使用双链结构，即快链和慢链。运用PBFT和POW混合共识算法，前者生成快链，后者生成慢链。交易确认和挖矿是分开的。交易被打包后，通过PBFT委员会确认，生成fastBlock，此时交易已经得到确认；慢链将快链里的fastBlock打包成为一个snailBlock，经过矿工挖矿确认，实现上链。通过这种混合共识算法，tps得到很大的提升，达到3000左右，而且使用POW挖矿，实现了去中心化的思想。PBFT委员会每两天换届一次，候选委员都是POW挖矿成功后的矿工，保证了公平公正的原则。</p>
<p>虽然PBFT算法的设计初期是服务于私有链和公有链的，但是随着人们对它的不断改进和灵活使用，未来公链它将在共识机制中处于重要地位。</p>
<h2 id="Go语言实现一个网络交互的PBFT工程"><a href="#Go语言实现一个网络交互的PBFT工程" class="headerlink" title="Go语言实现一个网络交互的PBFT工程"></a>Go语言实现一个网络交互的PBFT工程</h2><p>工程思路：<br>1.开启4个终端，分别代表4个小国，开启http监听，监听路径有4个，分别是”/req”，”/prePrepare”, “/prepare”, “/commit”。<br>2.任意一个节点通过http网页发起请求；<br>3.该被请求节点会将数据写入自己的数组，然后并通过”/prePrepare”路径向其他节点广播该请求数据；<br>4.其他节点通过节点监听接收到请求数据，将请求数据写入自己的数组，并通过”/Prepare”路径向其他节点广播该请求数据；<br>5.所有节点将收到的数据进行校验，如果当前数组的长度大于所有节点个数的2/3，则输出OK，并将OK数据通过路径”/commit”广播给其他所有节点；<br>6.当节点收到OK数量达到所有节点个数的1/3，则就是最后的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明nodeInfo节点，代表各个小国家</span></span><br><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//节点名称</span></span><br><span class="line">    id <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//节点路径</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//http响应</span></span><br><span class="line">    writer http.ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map，存储各个国家的ip地址,也就是url</span></span><br><span class="line"><span class="keyword">var</span> nodeTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当http服务器，接收到网络请求并且/req 则回调request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">request</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">//该命令允许request请求参数</span></span><br><span class="line">    request.ParseForm()<span class="comment">//解析完毕，打包返回。所以该方法不需要返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.writer = writer</span><br><span class="line">        fmt.Println(<span class="string">"主节点接收到的参数信息为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment">//fmt.Println(request.Form["warTime"])打印出来是个数组，如果warTime=1111&amp;2222等等，等号后边的是数组，warTime是map的key</span></span><br><span class="line">        <span class="comment">//激活主节点后，向其他的节点发送广播</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prePrepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点发送广播的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">broadcast</span><span class="params">(msg <span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"广播"</span>, path)</span><br><span class="line">    <span class="comment">//遍历所有的节点</span></span><br><span class="line">    <span class="keyword">for</span> nodeId, url := <span class="keyword">range</span> nodeTable &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeId == node.id &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使当前节点以外的节点做响应</span></span><br><span class="line">        http.Get(<span class="string">"http://"</span> + url + path + <span class="string">"?warTime="</span> + msg + <span class="string">"&amp;nodeId="</span> + node.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理广播后接收到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prePrepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    fmt.Println(<span class="string">"接收到的广播为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收子节点的广播</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//打印消息</span></span><br><span class="line">    fmt.Println(<span class="string">"接收到的子节点的广播"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">2</span>/<span class="number">3</span>*<span class="built_in">len</span>(nodeTable) &#123;</span><br><span class="line">        node.authentication(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authenticationNodeMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> authenticationSuceess = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//校验拜占庭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">authentication</span><span class="params">(request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !authenticationSuceess &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"nodeId"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            authenticationNodeMap[request.Form[<span class="string">"nodeId"</span>][<span class="number">0</span>]] = <span class="string">"OK"</span></span><br><span class="line">            <span class="comment">//如果有两个国家节点正确的返回了结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(authenticationNodeMap) &gt; <span class="built_in">len</span>(nodeTable)/<span class="number">3</span> &#123;</span><br><span class="line">                authenticationSuceess = <span class="literal">true</span></span><br><span class="line">                node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/commit"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回成功响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">commit</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> writer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"拜占庭校验成功"</span>)</span><br><span class="line">        <span class="comment">//在网页上显示ok</span></span><br><span class="line">        io.WriteString(node.writer, <span class="string">"ok"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//接受终端参数</span></span><br><span class="line">    userId := os.Args[<span class="number">1</span>]</span><br><span class="line">    fmt.Println(userId)</span><br><span class="line">    <span class="comment">//存储4个国家的IP地址</span></span><br><span class="line">    nodeTable = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"Apple"</span>:  <span class="string">"localhost:1111"</span>,</span><br><span class="line">        <span class="string">"MS"</span>:     <span class="string">"localhost:1112"</span>,</span><br><span class="line">        <span class="string">"Google"</span>: <span class="string">"localhost:1113"</span>,</span><br><span class="line">        <span class="string">"IBM"</span>:    <span class="string">"localhost:1114"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建国家对象</span></span><br><span class="line">    node := nodeInfo&#123;id: userId, path: nodeTable[userId]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http协议的回调函数</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/req"</span>, node.request)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prePrepare"</span>, node.prePrepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prepare"</span>, node.prepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/commit"</span>, node.commit)</span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(node.path, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">BFT拜占庭容错系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:42:54 / 修改时间：14:43:21" itemprop="dateCreated datePublished" datetime="2020-01-10T14:42:54+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="BFT技术"><a href="#BFT技术" class="headerlink" title="BFT技术"></a>BFT技术</h3><p>BFT技术即拜占庭容错技术，是一类分布式计算领域的容错技术。名称拜占庭是一个泛指，它代表着计算机领域，在这个领域内会有很多问题，如硬件错误、网络拥堵或中断以及遭到恶意攻击等等，造成计算机网络可能出现的混乱。<strong>BFT技术就是为了使混乱状态达到一致性。</strong></p>
<h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h2><p>BFT技术的由来源于一个叫拜占庭将军问题。<br>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都，由于当时拜占庭罗马帝国国土辽阔，每支军队的驻地分隔很远，将军们只能靠信使传递消息。发生战争时，将军们必须制订统一的行动计划。然而，这些将军中有叛徒，叛徒希望通过影响统一行动计划的制定与传播，破坏忠诚的将军们一致的行动计划。因此，将军们必须有一个预定的方法协议，使所有忠诚的将军能够达成一致，而且少数几个叛徒不能使忠诚的将军做出错误的计划。也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们能在一个有叛徒的非信任环境中建立对战斗计划的共识，拜占庭问题就此形成。</p>
<p>拜占庭将军问题（Byzantine Generals Problem），首先由Leslie Lamport与另外两人在1982年提出，很简单的故事模型，却困扰了计算机科学家们数十年。</p>
<p>我们将拜占庭将军问题简化一下，所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动；而形式化的要求就是，“一致性”与“正确性”。</p>
<p>一致性：每个忠诚的将军必须收到相同的命令值 <strong>vi</strong>（vi是第i个将军的命令）</p>
<p>正确性：如果第<strong>i</strong>个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的 <strong>vi</strong> 相同。</p>
<p>Lamport 对拜占庭将军的问题的研究表明，当 <strong>n &gt; 3m</strong> 时，即叛徒的个数 <strong>m</strong> 小于将军总数的 <strong>n</strong> 的 <strong>1/3</strong> 时，通过口头同步通信（假设通信是可靠的），可以构造同时满足“一致性”和“正确性”的解决方法，即将军们可以达成一致的命令。（叛徒个数=m，将军总数=n）m &lt; n * 1/3</p>
<h2 id="BFT理论算法"><a href="#BFT理论算法" class="headerlink" title="BFT理论算法"></a>BFT理论算法</h2><p>BFT即拜占庭容错系统，英文全称是<strong>Byzantine Fault Tolerance</strong>，是一种理论上解决拜占庭问题的方法，并非实用，不过基于BFT理论延伸出了其他共识机制。</p>
<p>区块链网络的记账共识和拜占庭将军的问题是相似的。参与共识记账的每一个节点相当于将军，节点之间的消息传递相当于信使，某些节点可能由于各种原因而产生错误的信息传递给其他节点。<strong>通常这些发生故障的节点被称为拜占庭节点，而正常的节点即为非拜占庭节点。</strong></p>
<p>假设分布式系统拥有n台节点，并假设整个系统拜占庭节点不超过m台（n ≥ 3m + 1），拜占庭容错系统需要满足如下<strong>两个条件</strong>：</p>
<pre><code>1. 所有非拜占庭节点使用相同的输入信息，产生同样的结果。在区块链系统中，可以理解为，随机数相同、区块算法相同、原账本相同的时候，计算结果相同。

2. 如果输入的信息正确，那么所有非拜占庭节点必须接收这个消息，并计算相应的结果。在区块链系统中，可以理解为，非拜占庭节点需要对客户的请求进行计算并生成区块。</code></pre><p>另外，拜占庭容错系统需要达成如下<strong>两个指标</strong>：</p>
<pre><code>1. 安全性：任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。

2. 活性：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。</code></pre><p>在分析拜占庭问题的时候，假设信道是可信的。拓展开来，在拜占庭容错系统，普遍采用的假设条件包括：</p>
<pre><code>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；
节点之间的错误是不相关的；
节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；
节点之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和破坏信息的完整性。</code></pre><h2 id="Go语言简单实现BFT"><a href="#Go语言简单实现BFT" class="headerlink" title="Go语言简单实现BFT"></a>Go语言简单实现BFT</h2><p>模拟4个小国家攻打拜占庭，这4个国家要保证3个及以上同时攻打才能胜利。</p>
<p>思路：<br>1.创建4个节点，每个节点代表一个小国，我们用1代表打，0代表不打；<br>2.每个节点将自己的攻打意愿1或0分发给其他小国；<br>3.收到所有节点发送的消息后，将所有消息放在一个数组中；<br>4.每个节点遍历这个数组，如果数组中的0数量&lt;总数的1/3，那么返回一个true，表示攻打拜占庭可行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拜占庭理论的代码实现部分</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Status <span class="keyword">int</span><span class="comment">//1 代表去，０代表不去</span></span><br><span class="line">    Votes []*Node<span class="comment">//记录账本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存４个node</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">make</span>([]*Node,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNodes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A:=Node&#123;<span class="string">"A"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    B:=Node&#123;<span class="string">"B"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    C:=Node&#123;<span class="string">"C"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    D:=Node&#123;<span class="string">"D"</span>,<span class="number">0</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//不去</span></span><br><span class="line">    <span class="comment">//按照拜占庭的1/3理论，这次打仗是可行的</span></span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;A)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;B)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;C)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互相转达</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">votes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nodes);i++&#123;</span><br><span class="line">        node:=nodes[i]</span><br><span class="line">        <span class="comment">//可以将每个人的进攻状态获取出来</span></span><br><span class="line">        fmt.Println(node.Status)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此人的状态分发给其他人</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nodes);j++&#123;</span><br><span class="line">            inode := nodes[j]</span><br><span class="line">            node.Votes=<span class="built_in">append</span>(node.Votes,inode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次进攻是否可行，判断叛徒是否小于三分之一  cnt叛徒的个数小于总节点数的三分之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">//在数组中取出最后一个对象</span></span><br><span class="line">    node:=nodes[<span class="built_in">len</span>(nodes)<span class="number">-1</span>]</span><br><span class="line">    votes:=node.Votes</span><br><span class="line"></span><br><span class="line">    cnt:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,n :=<span class="keyword">range</span> votes &#123;</span><br><span class="line">        fmt.Println(n.Status)</span><br><span class="line">        <span class="keyword">if</span> n.Status == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cnt只有小于n/3的情况下，才能成功,拜占庭</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">float32</span>(cnt) &lt; <span class="keyword">float32</span>(<span class="built_in">len</span>(nodes))/<span class="keyword">float32</span>(<span class="number">3.0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    createNodes()</span><br><span class="line">    votes()</span><br><span class="line">    fmt.Println(isValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/" class="post-title-link" itemprop="url">DPOS股权授权证明</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:41:56 / 修改时间：14:42:56" itemprop="dateCreated datePublished" datetime="2020-01-10T14:41:56+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h1><h2 id="什么是-DPoS"><a href="#什么是-DPoS" class="headerlink" title="什么是 DPoS"></a>什么是 DPoS</h2><p>DPoS即股份授权证明，英文全称是<code>Delegated Proof of Stake</code>。它是PoS算法的改造版。<br>最早于2013年由比特股Bitshares提出，目的为解决PoW和PoS机制的不足。</p>
<h2 id="DPoS-基本原理"><a href="#DPoS-基本原理" class="headerlink" title="DPoS 基本原理"></a>DPoS 基本原理</h2><p>PoS解决了PoW的算力问题，但是依据权益结余来选择出块者，会导致首富账户的权力更大，有可能支配记账权。为改善这种中心化的负面影响，DPoS引进了代理人机制，类似于人民代表选举，被选举者就是这里的代理人。代理人是由所有持币者根据自己的意愿选出来的，他理论上能够代表大众的权益。以eos为例，它有21个超级节点，每个节点都是持币人选举出来的。</p>
<p>一般选举过程是这样的，首先设立一个评审委员会，全球所有节点都可以报名参加，报名的前提是交纳保证金，通过审核的最为满足条件的前N个节点将作为候选节点，进入下一轮，也就是竞选阶段。这些候选节点会将会各种演说游说其他的持币人，让他们给自己投票，这里可能场外会给投票人某些好处。<strong>最终投票总数前m名的候选节点成为公链的代理人，负责出块。每次出块时，系统会随机顺序挑选指定某个代理人出块。</strong> 每次选举出来的代理人都有任期，任期期间如果被监管发现某些作恶行为将会被追责和卸任。</p>
<p>代理人的职责主要有：</p>
<p><strong>1.提供一台服务器节点，保证节点的正常运行；</strong><br><strong>2.节点服务器收集网络里的交易；</strong><br><strong>3.节点验证交易，把交易打包到区块；</strong><br><strong>4.节点广播区块，其他节点验证后把区块添加到自己的数据库；</strong><br><strong>5.带领并促进区块链项目的发展；</strong></p>
<p>代理人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p>
<p>普通节点不能直接参与出块，利益何在？<br>每个节点都有自己的选举权和监督权，对代理人的行为进行监视，保证链的正常运行。链稳定了，持币人在生态中的操作才能安心。同时，tps的速度快了，在链上的交易秒级可以实现，使持币人感受到了极大的方便。整个链的生态如果因为良好的运行，会吸引更多的人或应用加入，使币的价格升值，持币人当然开心。当然这些都是理想情况下，在实际中很难得以实现。</p>
<h3 id="DPoS的伪代码实现"><a href="#DPoS的伪代码实现" class="headerlink" title="DPoS的伪代码实现"></a>DPoS的伪代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点 授权</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure>

<h3 id="DPoS-运行机制"><a href="#DPoS-运行机制" class="headerlink" title="DPoS 运行机制"></a>DPoS 运行机制</h3><p>DPoS 的运作机制如下：</p>
<ol>
<li><p>所有持币者先选出代理人负责签署区块：选举过程比较类似由股东会选举出董事会（101人代表），代替股东会做出日常营运决策。授权董事会后，决策会更有效率 （相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。）</p>
</li>
<li><p>与PoW相同，DPoS的规则也是最长链胜出。其中每个受托人必须按照生产排程，轮流产生区块，拿一间工厂作为比方，假设排程排定A、Ｂ、Ｃ分别轮早、中、晚班生产，Ａ在晚上是无法刷门禁卡进入厂房生产的，同样地，C在早班时段也是无法进厂房的。</p>
<p><img src="http://image.chaindesk.cn/DPOS01.png/mark" alt="img"></p>
</li>
<li><p>今天有一些恶意的节点生产了分叉区块，假设Ａ、Ｃ都是诚实的节点，只有B节点是恶意的，由于B产生区块的速度（每9秒只能产生1个）慢于A、Ｃ合力产生区块的速度（每9秒产生2个），根据最长链胜出的规则，诚实的节点还是会胜出。</p>
<p><img src="http://image.chaindesk.cn/DPOS2.png/mark" alt="img"></p>
</li>
<li><p>同理，因为一个节点要产生重复两个区块的速度必定慢于诚实区块产生的速度，所以根据最长链胜出的规则，诚实的节点还是会胜出。</p>
<p><img src="http://image.chaindesk.cn/DPOS3.png/mark" alt="img"></p>
</li>
<li><p>如果今天A、Ｂ、Ｃ三个代理人的网络有段时间是碎片化、各自为政的呢？在短期内的确有可能三链并行，但一旦网络连结恢复，短链自然会向最长的链回归。</p>
<p><img src="http://image.chaindesk.cn/DPOS4.png/mark" alt="img"></p>
</li>
</ol>
<p><strong>因为代理可签署人数为奇数，所以两大派系势均力敌僵持不下的情况不会维持太久，最终势必会有其中一方的链更长。</strong></p>
<h2 id="DPoS的优缺点"><a href="#DPoS的优缺点" class="headerlink" title="DPoS的优缺点"></a>DPoS的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li>
<li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li>
<li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li>
<li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li>
</ol>
<h3 id="知名-DPoS-项目"><a href="#知名-DPoS-项目" class="headerlink" title="知名 DPoS 项目"></a><strong>知名 DPoS 项目</strong></h3><p>1.Bitshares</p>
<p>最早应用DPoS机制的项目，其DPoS机制里包含见证人(Witnesses)和代理人(Delegates)， 见证人负责区块的打包，代理人负责系统参数的修改和出块。</p>
<p>2.EOS</p>
<p>共识算法我DPoS + BFT， 有21个代理人。</p>
<p>3.Asch</p>
<p>共识算法为DPoS + PBFT， 有101个代理人。</p>
<h2 id="用Go实现一个简单的DPOS项目"><a href="#用Go实现一个简单的DPOS项目" class="headerlink" title="用Go实现一个简单的DPOS项目"></a>用Go实现一个简单的DPOS项目</h2><p>通过这个简易的项目，让大家对DPOS的工作加深下了解。<br>工程思路：<br>1.手动创建一个数组，将里面的元素作为代理人<br>2.每30秒将代理人的顺序随机打乱1次<br>3.乱序后的委员会将顺序出块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//DPoS原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="keyword">int</span></span><br><span class="line">    PreHash <span class="keyword">string</span></span><br><span class="line">    HashCode <span class="keyword">string</span></span><br><span class="line">    BMP <span class="keyword">int</span></span><br><span class="line">    validator <span class="keyword">string</span></span><br><span class="line">    TimeStamp <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块链</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNextBlock</span><span class="params">(oldBlock Block,BMP <span class="keyword">int</span> ,adds <span class="keyword">string</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.PreHash = oldBlock.HashCode</span><br><span class="line">    newBlock.BMP = BMP</span><br><span class="line">    newBlock.TimeStamp = time.Now().String()</span><br><span class="line">    newBlock.validator = adds</span><br><span class="line">    newBlock.HashCode = GenerateHashValue(newBlock)</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生区块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHashValue</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hashCode = block.PreHash+block.validator+block.TimeStamp+</span><br><span class="line">        strconv.Itoa(block.Index)+strconv.Itoa(block.BMP)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sha = sha256.New()</span><br><span class="line">    sha.Write([]<span class="keyword">byte</span>(hashCode))</span><br><span class="line">    hashed:=sha.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放代理人,存放delegete的地址信息</span></span><br><span class="line"><span class="keyword">var</span> delegate =[]<span class="keyword">string</span>&#123;<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"dddd"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机委托人的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandDelegate</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> r = rand.Intn(<span class="number">3</span>)</span><br><span class="line">    t:=delegate[r]</span><br><span class="line">    delegate[r]=delegate[<span class="number">3</span>]</span><br><span class="line">    delegate[<span class="number">3</span>]=t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(delegate)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创世区块</span></span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,firstBlock)</span><br><span class="line">    <span class="comment">//通过n按顺序让delegate作为矿工</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    ch1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag:&lt;-ch1</span><br><span class="line">        count:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//每间隔3秒产生新的区块，通过count记录睡眠次数</span></span><br><span class="line">            count++</span><br><span class="line">            time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">            <span class="comment">//轮到的节点进行出块</span></span><br><span class="line">            <span class="keyword">var</span> nextBlock = GenerateNextBlock(firstBlock,<span class="number">1</span>,delegate[n])</span><br><span class="line">            n++</span><br><span class="line">            n=n%<span class="built_in">len</span>(delegate)</span><br><span class="line">            firstBlock = nextBlock</span><br><span class="line">            <span class="comment">//上链</span></span><br><span class="line">            Blockchain = <span class="built_in">append</span>(Blockchain,nextBlock)</span><br><span class="line">            fmt.Println(Blockchain)</span><br><span class="line">            fmt.Println(count)</span><br><span class="line">            <span class="comment">//每30秒将代理人顺序打乱一次</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">10</span>&#123;</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">                ch2&lt;-<span class="literal">true</span></span><br><span class="line">                <span class="keyword">goto</span> flag</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; ;  &#123;</span><br><span class="line"></span><br><span class="line">        RandDelegate()</span><br><span class="line">        fmt.Println(<span class="string">"更换顺序后的代理人"</span>,delegate)</span><br><span class="line">        ch1&lt;-<span class="literal">true</span></span><br><span class="line">        &lt;-ch2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">POS代码实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:40:58 / 修改时间：14:41:25" itemprop="dateCreated datePublished" datetime="2020-01-10T14:40:58+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="用go语言实现一个POS共识机制"><a href="#用go语言实现一个POS共识机制" class="headerlink" title="用go语言实现一个POS共识机制"></a>用go语言实现一个POS共识机制</h1><h2 id="POS工程简述"><a href="#POS工程简述" class="headerlink" title="POS工程简述"></a>POS工程简述</h2><p>在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。</p>
<h2 id="实现-POS-主要功能点"><a href="#实现-POS-主要功能点" class="headerlink" title="实现 POS 主要功能点"></a>实现 POS 主要功能点</h2><ul>
<li>我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器</li>
<li>最新的区块链状态将定期广播到每个节点</li>
<li>每个节点都能提议建立新的区块</li>
<li>基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中</li>
</ul>
<h2 id="实现-POS"><a href="#实现-POS" class="headerlink" title="实现 POS"></a>实现 POS</h2><h3 id="设置-TCP-服务器的端口"><a href="#设置-TCP-服务器的端口" class="headerlink" title="设置 TCP 服务器的端口"></a>设置 TCP 服务器的端口</h3><p>新建 <code>.env</code>，添加如下内容 <code>PORT=9000</code></p>
<h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/davecgh/<span class="keyword">go</span>-spew/spew</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> get github.com/joho/godotenv</span><br></pre></td></tr></table></figure>

<ul>
<li><code>spew</code> 在控制台中格式化输出相应的结果。</li>
<li><code>godotenv</code> 可以从我们项目的根目录的 <code>.env</code> 文件中读取数据。</li>
</ul>
<h3 id="引入相应的包"><a href="#引入相应的包" class="headerlink" title="引入相应的包"></a>引入相应的包</h3><p>新建 <code>main.go</code>，引入相应的包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">    <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents each 'item' in the blockchain</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span></span><br><span class="line">    Timestamp <span class="keyword">string</span></span><br><span class="line">    BPM       <span class="keyword">int</span></span><br><span class="line">    Hash      <span class="keyword">string</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span></span><br><span class="line">    Validator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blockchain is a series of validated Blocks</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"><span class="keyword">var</span> tempBlocks []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// candidateBlocks handles incoming blocks for validation</span></span><br><span class="line"><span class="keyword">var</span> candidateBlocks = <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// announcements broadcasts winning validator to all nodes</span></span><br><span class="line"><span class="keyword">var</span> announcements = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validators keeps track of open validators and balances</span></span><br><span class="line"><span class="keyword">var</span> validators = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Block</code> 是每个区块的内容</li>
<li><code>Blockchain</code> 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 <code>PrevHash</code> 与前面块的 <code>Hash</code> 相比较，以确保我们的链是正确的。 <code>tempBlocks</code> 是临时存储单元，在区块被选出来并添加到 <code>BlockChain</code> 之前，临时存储在这里</li>
<li><code>candidateBlocks</code> 是 <code>Block</code> 的通道，任何一个节点在提出一个新块时都将它发送到这个通道</li>
<li><code>announcements</code> 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链</li>
<li><code>mutex</code>是一个标准变量，允许我们控制读/写和防止数据竞争</li>
<li><code>validators</code> 是节点的存储map，同时也会保存每个节点持有的令牌数</li>
</ul>
<h3 id="生成区块"><a href="#生成区块" class="headerlink" title="生成区块"></a>生成区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>generateBlock</code> 是用来创建新块的。<br><code>newBlock.PrevHash</code> 存储的是上一个区块的 <code>Hash</code><br><code>newBlock.Hash</code> 是通过 <code>calculateBlockHash(newBlock)</code> 生成的 Hash 。<br><code>newBlock.Validator</code> 存储的是获取记账权的节点地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SHA256 hasing</span></span><br><span class="line"><span class="comment">// calculateHash is a simple SHA256 hashing function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculateBlockHash returns the hash of all block information</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calculateHash</code> 函数会接受一个 <code>string</code> ，并且返回一个<code>SHA256 hash</code> 。</p>
<p><code>calculateBlockHash</code> 是对一个 <code>block</code> 进行 <code>hash</code>，将一个 <code>block</code> 的所有字段连接到一起后，再调用 <code>calculateHash</code> 将字符串转为 <code>SHA256 hash</code> 。</p>
<h3 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h3><p>我们通过检查 <code>Index</code> 来确保它们按预期递增。我们也检查以确保我们 <code>PrevHash</code> 的确与 <code>Hash</code> 前一个区块相同。最后，我们希望通过在当前块上 <code>calculateBlockHash</code> 再次运行该函数来检查当前块的散列。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isBlockValid makes sure block is valid by checking index</span></span><br><span class="line"><span class="comment">// and comparing the hash of the previous block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculateBlockHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：</p>
<ul>
<li>输入令牌的余额（之前提到过，我们不做钱包等逻辑)</li>
<li>接收区块链的最新广播</li>
<li>接收验证者赢得区块的广播信息</li>
<li>将自身节点添加到全局的验证者列表中（validators)</li>
<li>输入Block的BPM数据- BPM是每个验证者的人体脉搏值</li>
<li>提议创建一个新的区块</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            msg := &lt;-announcements</span><br><span class="line">            io.WriteString(conn, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 验证者地址</span></span><br><span class="line">    <span class="keyword">var</span> address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权</span></span><br><span class="line">    io.WriteString(conn, <span class="string">"Enter token balance:"</span>)</span><br><span class="line">    scanBalance := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> scanBalance.Scan() &#123;</span><br><span class="line">        <span class="comment">// 获取输入的数据，并将输入的值转为 int</span></span><br><span class="line">        balance, err := strconv.Atoi(scanBalance.Text())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"%v not a number: %v"</span>, scanBalance.Text(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        <span class="comment">// 生成验证者的地址</span></span><br><span class="line">        address = calculateHash(t.String())</span><br><span class="line">        <span class="comment">// 将验证者的地址和token 存储到 validators</span></span><br><span class="line">        validators[address] = balance</span><br><span class="line">        fmt.Println(validators)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line"></span><br><span class="line">    scanBPM := bufio.NewScanner(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// take in BPM from stdin and add it to blockchain after conducting necessary validation</span></span><br><span class="line">            <span class="keyword">for</span> scanBPM.Scan() &#123;</span><br><span class="line">                bpm, err := strconv.Atoi(scanBPM.Text())</span><br><span class="line">                <span class="comment">// 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"%v not a number: %v"</span>, scanBPM.Text(), err)</span><br><span class="line">                    <span class="built_in">delete</span>(validators, address)</span><br><span class="line">                    conn.Close()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                oldLastIndex := Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的区块，然后将其发送到 candidateBlocks 通道</span></span><br><span class="line">                newBlock, err := generateBlock(oldLastIndex, bpm, address)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Println(err)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> isBlockValid(newBlock, oldLastIndex) &#123;</span><br><span class="line">                    candidateBlocks &lt;- newBlock</span><br><span class="line">                &#125;</span><br><span class="line">                io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环会周期性的打印出最新的区块链信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Minute)</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        output, err := json.Marshal(Blockchain)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(conn, <span class="keyword">string</span>(output)+<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>io.WriteString(conn, &quot;Enter token balance:&quot;)</code>允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 <code>SHA256</code>地址，随后该验证者地址和验证者的令牌数被添加到验证者列表<code>validators</code> 中。</li>
<li>接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑</li>
<li><code>delete(validators, address)</code> 如果验证者试图提议一个被污染（例如伪造）的 <code>block</code>，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 <code>validators</code> 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</li>
<li>正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。</li>
<li>接着，我们用 <code>generateBlock</code> 函数创建一个新的 <code>block</code>，然后将其发送到 <code>candidateBlocks</code> 通道进行进一步处理。将<code>Block</code> 发送到通道使用的语法: <code>candidateBlocks &lt;- newBlock</code></li>
<li>最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。</li>
</ul>
<h3 id="选择获取记账权的节点"><a href="#选择获取记账权的节点" class="headerlink" title="选择获取记账权的节点"></a>选择获取记账权的节点</h3><p>下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain</span></span><br><span class="line"><span class="comment">// by random selecting from the pool, weighted by amount of tokens staked</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickWinner</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    temp := tempBlocks</span><br><span class="line">    mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    lotteryPool := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slightly modified traditional proof of stake algorithm</span></span><br><span class="line">        <span class="comment">// from all validators who submitted a block, weight them by the number of staked tokens</span></span><br><span class="line">        <span class="comment">// in traditional proof of stake, validators can participate without submitting a block to be forged</span></span><br><span class="line">    OUTER:</span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="comment">// if already in lottery pool, skip</span></span><br><span class="line">            <span class="keyword">for</span> _, node := <span class="keyword">range</span> lotteryPool &#123;</span><br><span class="line">                <span class="keyword">if</span> block.Validator == node &#123;</span><br><span class="line">                    <span class="keyword">continue</span> OUTER</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock list of validators to prevent data race</span></span><br><span class="line">            mutex.Lock()</span><br><span class="line">            setValidators := validators</span><br><span class="line">            mutex.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取验证者的tokens</span></span><br><span class="line">            k, ok := setValidators[block.Validator]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">// 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens</span></span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">                    lotteryPool = <span class="built_in">append</span>(lotteryPool, block.Validator)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过随机获得获胜节点的地址</span></span><br><span class="line">        s := rand.NewSource(time.Now().Unix())</span><br><span class="line">        r := rand.New(s)</span><br><span class="line">        lotteryWinner := lotteryPool[r.Intn(<span class="built_in">len</span>(lotteryPool))]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息</span></span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="keyword">if</span> block.Validator == lotteryWinner &#123;</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, block)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                <span class="keyword">for</span> _ = <span class="keyword">range</span> validators &#123;</span><br><span class="line">                    announcements &lt;- <span class="string">"\nwinning validator: "</span> + lotteryWinner + <span class="string">"\n"</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    tempBlocks = []Block&#123;&#125;</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个<code>lotteryPool</code>，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过<code>if len(temp) &gt; 0</code>来判断是否已经有了被提议的区块。</li>
<li>在<code>OUTER FOR</code>循环中，要检查暂存区域是否和 <code>lotteryPool</code> 中存在同样的验证者，如果存在，则跳过。</li>
<li>在以 <code>k, ok := setValidators[block.Validator]</code>开始的代码块中，我们确保了从<code>temp</code>中取出来的验证者都是合法的，即这些验证者在验证者列表<code>validators</code>已存在。若合法，则把该验证者加入到<code>lotteryPool</code>中。</li>
<li>那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？<ul>
<li>首先，用验证者的令牌填充<code>lotteryPool</code>数组，例如一个验证者有100个令牌，那么在<code>lotteryPool</code>中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。</li>
<li>然后，从<code>lotteryPool</code>中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。</li>
</ul>
</li>
<li>接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：<code>announcements &lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot;</code>。</li>
<li>最后，清空tempBlocks，以便下次提议的进行。</li>
</ul>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := godotenv.Load()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始区块</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    genesisBlock := Block&#123;&#125;</span><br><span class="line">    genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateBlockHash(genesisBlock), <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">    spew.Dump(genesisBlock)</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line"></span><br><span class="line">    httpPort := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务</span></span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+httpPort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"HTTP Server Listening on port :"</span>, httpPort)</span><br><span class="line">    <span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> candidate := <span class="keyword">range</span> candidateBlocks &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            tempBlocks = <span class="built_in">append</span>(tempBlocks, candidate)</span><br><span class="line">            mutex.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 完成 pickWinner 函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            pickWinner()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收验证者节点的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>godotenv.Load()</code> 会解析 <code>.env</code> 文件并将相应的Key/Value对都放到环境变量中，通过 <code>os.Getenv</code> 获取</li>
<li>然后创建一个创世区块genesisBlock，形成了区块链。</li>
<li>接着启动了Tcp服务，等待所有验证者的连接。</li>
<li>启动了一个Go协程从 <code>candidateBlocks</code> 通道中获取提议的区块，然后填充到临时缓冲区 <code>tempBlocks</code> 中，最后启动了另外一个Go协程来完成 <code>pickWinner</code> 函数。</li>
<li>最后的for循环，用来接收验证者节点的连接。</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>go run main.go</code> 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">(main.Block) &#123;</span><br><span class="line"> Index: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Timestamp: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">50</span>) <span class="string">"2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793"</span>,</span><br><span class="line"> BPM: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Hash: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">64</span>) <span class="string">"96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7"</span>,</span><br><span class="line"> PrevHash: (<span class="keyword">string</span>) <span class="string">""</span>,</span><br><span class="line"> Validator: (<span class="keyword">string</span>) <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">27</span> HTTP Server Listening on port : <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>打开新的终端，运行 <code>nc localhost 9000</code>，<br>输入 <code>tokens</code> , 然后输入 <code>BPM</code></p>
<p>可以打开多个终端，输入不同的 <code>tokens</code> ,来检验 PoS 算法</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">POW+POS混合公式算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:40:12 / 修改时间：14:40:32" itemprop="dateCreated datePublished" datetime="2020-01-10T14:40:12+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="POW-POS混合共识算法"><a href="#POW-POS混合共识算法" class="headerlink" title="POW+POS混合共识算法"></a>POW+POS混合共识算法</h3><p>上一章节说过，实际运用pos是需要借助其他算法才能实现的。本章节主要学习点点币的共识算法，该算法是基于POW改进的POS算法。</p>
<h2 id="混合共识算法的定义"><a href="#混合共识算法的定义" class="headerlink" title="混合共识算法的定义"></a>混合共识算法的定义</h2><p>现在很多公链都是在用基于xx和xx算法的混合共识算法实现共识机制的。什么是混合共识算法呢？<br>有两种情况都可以认为是混合机制：<br>1.在某个算法的基础上，运用其他算法的技术进行改进。如点点币，它的共识机制是用pos算法对pow算法进行改进后的机制，不过大家往往认为点点币的共识机制是pos，其实严格来说是pow+pos的。<br>2.两个算法运算相互独立，但共同组成了一个共识机制。如初链，它的共识是pow和pbft两个算法组成的，然后自己给自己起了个新名字叫混合共识机制fpow。这种混合很明显，所以大家都会叫混合机制。</p>
<h2 id="混合共识机制POW-POS"><a href="#混合共识机制POW-POS" class="headerlink" title="混合共识机制POW+POS"></a>混合共识机制POW+POS</h2><p>点点币是第一个基于POS发行的数字货币，所以接下来我将带大家深入学习它的共识算法，加深对POS的理解。</p>
<p>与PoW一样，为了抢到将区块写入区块链的权利，节点同样要进行hash计算，只不过最终的解和币龄有关，计算公式：<br>proofHash &lt; coinAge * target；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coinAge是币龄，target是一个目标值，用于调整难度。coinAge * target的值越大，难度就越小，抢到区块的概率就越高。</span><br></pre></td></tr></table></figure>

<p>假如你的钱包里是0个币，那么你的币龄就是0, 计算一个小于0的hash值根本不可能，因此基本上抢不到区块。<br>点点币的出块时间也是10分钟左右一个。币龄之前讲过，就是持币数*持币时间；proofHash也就是pow的挖矿函数，即两次sha256 hash运算。所以重点我们要学习target的值是怎么实现的，怎么调整使出块时间在10分钟左右呢？</p>
<h2 id="点点币的目标值"><a href="#点点币的目标值" class="headerlink" title="点点币的目标值"></a>点点币的目标值</h2><p>点点币难度值是一个一直动态调整的，每隔2个区块就调整一次难度（目标值），使出块时间维持在10分钟左右。<br>点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。<br>计算公式如下：</p>
<p>　<code>当前区块目标值 = 前一个区块目标值 * (1007 * 10 * 60 + 2 * 前两个区块时间间隔) / (1009 * 10 * 60)</code><br>由公式可见，两个区块目标间隔时间即为10分钟。<br>如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。<br>反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。<br><code>点点币的挖矿难度值=创始区块目标值/当前区块目标值</code>。网页中显示的当前块难度值就是这样算出来的。</p>
<p>挖矿过程和pow一样，需要比较hash值与目标值大小，广播区块，验证区块，上链等等。</p>

      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/" class="post-title-link" itemprop="url">POS权益证明</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:39:11 / 修改时间：14:39:39" itemprop="dateCreated datePublished" datetime="2020-01-10T14:39:11+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>通过本章节，大家一起学习单纯的pos是什么机制，以及如何工作的。它较pow有什么优缺点。</p>
<h2 id="POS概述"><a href="#POS概述" class="headerlink" title="POS概述"></a>POS概述</h2><p>POS即权益证明，英文全称Proof of Stake。它是由匿名极客<code>Sunny King</code>发明的。<code>Sunny King</code>很神秘，类似中本聪，他的具体信息很少有人知道。同时他也是点点币（PPCoin）和质数币（PrimeCoin）的创始人。2012年点点币问世，成为全球首次使用POS共识机制的数字货币。</p>
<p>基于POW的公链挖矿纯靠算力，挖矿难度越高，算力也会越来越中心化。目前比特币挖矿的算力超过70%在中国，据<code>Blockchain.info</code>2018年的统计数据显示，目前世界前十大矿池中，中国独占8家，而中国70%的算力在四川。这样完全背离了去中心化的思想，只有算力高的机构或矿场才能挖到区块，而算力低的个人几乎没有可能挖到区块。算力低的矿工要是参与挖矿，那得赔死，投入电费、场地、矿机等等，结果几乎甚至没有收益。然后他们大部分会放弃挖矿或加入其他大型矿池。而且挖矿代币价格的较大波动也会影响挖矿收益。所以POW类型的挖矿具有很大的投资风险。POW挖矿比拼的就是算力，随着挖矿难度的提高，算力会要求越来越高，导致参与挖矿的矿机数量越来越多，配置也越来越高，如此会造成多大的资源浪费啊。</p>
<p>针对POW的问题，POS指出了一个全新的概念-币龄，币龄 = 持有的币数 * 持有币的天数，例如钱包里有90个点点币，持有了10天，则币龄=900。决定下一个区块是由谁出，是看当前时刻谁的币龄大。出块后币龄归零，重新计时持币时间。币龄是对应账户恒定数量持币数的值，如果账户的持币数量发生变化，那么币龄也会归零，重新计时。通过币龄来决定出块，不再需要比拼算力，多么环保啊，节省了多少资源啊。</p>
<p>而且为了让持币人把币握住，不乱抛售，POS还使用了“利息”机制。用户的持币钱包或客户端24小时处于工作状态或后台运行状态，其实就是pos的挖矿状态，系统会在固定时间参照币龄给予持币人一定量的利息（一定量的币）。如此币的抛售将不会像传统的币那么频繁，币价相应的也会稳定。</p>
<p>POS出块时间可以设为恒定值，如10分钟一个块，那么每10分钟，会触发记账功能。</p>
<p>为了让POS出块人带有随机性，需要借助一些随机函数，币龄只是增加成为出块者可能性的筹码。如，A的币龄100，B的币龄10，那么A能够出块的概率要比B大10倍。</p>
<p>使用POS较POW更不容易遭受51%攻击，相比起掌握系统一半以上的算力，拥有整个系统51%的财力会更加困难。</p>
<p>POS解决或者缓解了POW的一些问题，但是它也有它的很大缺点：</p>
<pre><code>1.更容易被垄断：因为持币越多，持有的越久，币龄就越高，越容易挖到区块并得到激励，持币少的人基本上没有机会，这样整个系统的安全性实际上会被持币数量较大的一部分人（大股东们）掌握；而POW理论上则不存在这个问题，因为理论上任何人都可以购买矿机获得提高自己的算力（甚至可以联合起来），提升自己挖矿成功的概率；

2.很难应对分叉的情况：当出现分叉时，PoS可以在两条链上同时挖矿并获得收益。而PoW则不存在这个问题，因为当出现分叉以后，PoW总是选择工作量大的链做为主链。</code></pre><p>但是在实际应用中，纯POS的共识机制是不可行的，通常会和POW混合一起用或者通过POS升级改进POW。这样会更好的发挥各自的优点，减小双方缺点带来的影响。</p>
<p>根据masternodes.online的数据显示，目前基于POS算法的币种数量已有330，但是市值在2000万美金以上的只有9种，分别是DASH、PIVX、SYS、BLOCK、XZC、SMART、XSN、PAC、DEV。其中，市值最高的为DASH，目前为21.57亿美元，POS年化收益约为7.19%；XZC市值9805万美元，POS年化收益约为27.28%。</p>
<h2 id="Go实现一个纯POS机制的简单挖矿"><a href="#Go实现一个纯POS机制的简单挖矿" class="headerlink" title="Go实现一个纯POS机制的简单挖矿"></a>Go实现一个纯POS机制的简单挖矿</h2><p>设计思路：<br>1.有两个挖矿节点，分别持有的币为10个和5个，持币时间为1 。所以他们的币龄也就是10和5 。<br>2.创建一个长度为15的数组，分别将两个节点的账户地址按照比例布满这个数组。<br>3.选择一个从0到14的随机数，将该随机数作为2步数组的下表，找到该下表下的挖矿地址。<br>4.挖矿地址确认后，通过方法产生区块。<br>5.将区块上链，这里的区块链我们定义了一个切片。上链过程就是append过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个块结构体</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span>  <span class="comment">//区块高度</span></span><br><span class="line">    Timestamp <span class="keyword">string</span> <span class="comment">//时间戳，也就是当前时间转换成字符串</span></span><br><span class="line">    BPM       <span class="keyword">int</span>   <span class="comment">//要保存的上链数据</span></span><br><span class="line">    Hash      <span class="keyword">string</span>  <span class="comment">//当前区块hash值</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span>  <span class="comment">//父区块hash值</span></span><br><span class="line">    Validator <span class="keyword">string</span>  <span class="comment">//当前区块出块人的账户地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个区块链，类型是切片。也就是将区块放在这个切片里面</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出块函数，也就是当随机抽中哪个账户后，该账户就会作为该区块的参数，生成一个最新区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成区块过程就是给区块的字段赋值</span></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最新区块</span></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256算法计算当前区块的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将区块字段拼接，为生成hash函数做准备</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//持币人信息</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在参与挖矿的币总数为15个，我们认为现在是平等机会的15个持币1个的矿工。</span></span><br><span class="line"><span class="comment">//声明一个数组保存15个账户地址</span></span><br><span class="line"><span class="comment">//两个节点参与挖矿</span></span><br><span class="line"><span class="keyword">var</span> N[<span class="number">15</span>] <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> p [<span class="number">2</span>] Node</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给两个挖矿节点赋值</span></span><br><span class="line">    p[<span class="number">0</span>]=Node&#123;<span class="number">10</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">    p[<span class="number">1</span>]=Node&#123;<span class="number">5</span>,<span class="string">"bcd"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下边的for循环，按照两个节点他们的持币数，分别将他们的地址赋值到之前定义好的账户地址数组中。</span></span><br><span class="line">    <span class="comment">//可以看出，前10个账户都是p[0]的；后边5个是p[1]的</span></span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;p[i].tokens;j++&#123;</span><br><span class="line"></span><br><span class="line">            N[cnt] = p[i].address</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据随机数种子产生的随机数，找到矿工的地址，然后出块  （0~14）随机数</span></span><br><span class="line">    <span class="comment">//（拥有10个币上链的概率为10/15，拥有5个币上链概率为5/15，rand.Intn(cnt)找到地址   其中有10个是拥有10个币的地址，5个事拥有5个币的地址）</span></span><br><span class="line">    <span class="keyword">var</span> b,_ = generateBlock(firstBlock,<span class="number">10</span>,N[rand.Intn(cnt)])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的区块放到区块链上。</span></span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(Blockchain)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">POW代码实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:35:51 / 修改时间：14:38:49" itemprop="dateCreated datePublished" datetime="2020-01-10T14:35:51+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="用go语言实现一个pow共识工程"><a href="#用go语言实现一个pow共识工程" class="headerlink" title="用go语言实现一个pow共识工程"></a>用go语言实现一个pow共识工程</h3><h2 id="1-1-项目代码结构"><a href="#1-1-项目代码结构" class="headerlink" title="1.1 项目代码结构"></a>1.1 项目代码结构</h2><p><img src="http://img.kongyixueyuan.com/0301_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png/mark" alt="img"></p>
<h2 id="1-2-项目运行结果"><a href="#1-2-项目运行结果" class="headerlink" title="1.2 项目运行结果"></a>1.2 项目运行结果</h2><p><img src="http://img.kongyixueyuan.com/0302_%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif/mark" alt="img"></p>
<h2 id="1-3-完整代码"><a href="#1-3-完整代码" class="headerlink" title="1.3 完整代码"></a>1.3 完整代码</h2><p>Block.go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//1. 区块高度</span></span><br><span class="line">    Height <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//2. 上一个区块HASH</span></span><br><span class="line">    PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//3. 交易数据</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//4. 时间戳</span></span><br><span class="line">    Timestamp <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//5. Hash</span></span><br><span class="line">    Hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 6. Nonce</span></span><br><span class="line">    Nonce <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建新的区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建区块</span></span><br><span class="line">    block := &amp;Block&#123;height,prevBlockHash,[]<span class="keyword">byte</span>(data),time.Now().Unix(),<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用工作量证明的方法并且返回有效的Hash和Nonce</span></span><br><span class="line">    pow := NewProofOfWork(block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挖矿验证</span></span><br><span class="line">    hash,nonce := pow.Run()</span><br><span class="line"></span><br><span class="line">    block.Hash = hash[:]</span><br><span class="line">    block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 单独写一个方法，生成创世区块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBlock(data,<span class="number">1</span>, []<span class="keyword">byte</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlockChain.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">    Blocks []*Block  <span class="comment">// 存储有序的区块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加区块到区块链里面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blc *Blockchain)</span> <span class="title">AddBlockToBlockchain</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,preHash []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 创建新区块</span></span><br><span class="line">    newBlock := NewBlock(data,height,preHash)</span><br><span class="line">    <span class="comment">// 往链里面添加区块</span></span><br><span class="line">    blc.Blocks = <span class="built_in">append</span>(blc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建带有创世区块的区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockchainWithGenesisBlock</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建创世区块</span></span><br><span class="line">    genesisBlock := CreateGenesisBlock(<span class="string">"Genesis Data......."</span>)</span><br><span class="line">    <span class="comment">// 返回区块链对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProofOfWork.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 1001 0001 0000 .... 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 256位Hash里面前面至少要有16个零</span></span><br><span class="line"><span class="keyword">const</span> targetBit  = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash nil</span></span><br><span class="line"><span class="comment">//256位</span></span><br><span class="line"><span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 二进制表示 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 2 的 32 - 8 次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    Block *Block <span class="comment">// 当前要验证的区块</span></span><br><span class="line">    <span class="comment">// 0000 0001 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">    target *big.Int <span class="comment">// 大数据存储 2^24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面必须有8个零</span></span><br><span class="line"><span class="comment">// 0000 0000 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0001</span></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0000 0000 0000 1111 111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拼接，返回字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            pow.Block.PrevBlockHash,</span><br><span class="line">            pow.Block.Data,</span><br><span class="line">            IntToHex(pow.Block.Timestamp),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(targetBit)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(pow.Block.Height)),</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.proofOfWork.Block.Hash</span></span><br><span class="line">    <span class="comment">//2.proofOfWork.Target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int</span><br><span class="line">    <span class="comment">// []byte 转 Int</span></span><br><span class="line">    hashInt.SetBytes(proofOfWork.Block.Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">    <span class="comment">//    0 if x == y</span></span><br><span class="line">    <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">    <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>,<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 将Block的属性拼接成字节数组</span></span><br><span class="line">    <span class="comment">//2. 生成hash</span></span><br><span class="line">    <span class="comment">//3. 判断hash有效性，如果满足条件，跳出循环</span></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int <span class="comment">// 存储我们新生成的hash</span></span><br><span class="line">    <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        dataBytes := proofOfWork.prepareData(nonce)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hash</span></span><br><span class="line">        hash = sha256.Sum256(dataBytes)</span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>,hash)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将hash存储到hashInt</span></span><br><span class="line">        hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断hashInt是否小于Block里面的target</span></span><br><span class="line">        <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">        <span class="comment">//    0 if x == y</span></span><br><span class="line">        <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">        <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonce = nonce + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[:],<span class="keyword">int64</span>(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的工作量证明对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProofOfWork</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.big.Int对象 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//0000 0001</span></span><br><span class="line">    <span class="comment">// 8 - 2 = 6</span></span><br><span class="line">    <span class="comment">// 0100 0000  64</span></span><br><span class="line">    <span class="comment">// 0010 0000</span></span><br><span class="line">    <span class="comment">// 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 .... 0000</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 创建一个初始值为1的target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int Int</span></span><br><span class="line">    target := big.NewInt(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 左移256 - targetBit</span></span><br><span class="line"></span><br><span class="line">    target = target.Lsh(target,<span class="number">256</span> - targetBit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ProofOfWork&#123;block,target&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>utils.go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64转换为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数main.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"kongyixueyuan.com/blockchain_go_videos-master/part8-proof-of-work/BLC"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创世区块</span></span><br><span class="line">    blockchain := BLC.CreateBlockchainWithGenesisBlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新区块</span></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 100RMB To tom"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 200RMB To lily"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 300RMB To hanmeimei"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 50RMB To lucy"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(blockchain)</span><br><span class="line">    fmt.Println(blockchain.Blocks)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hongery">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hongery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">POW挖矿及共识流程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-10 14:34:08 / 修改时间：14:35:56" itemprop="dateCreated datePublished" datetime="2020-01-10T14:34:08+08:00">2020-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">共识机制</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="PoW-挖矿及共识流程"><a href="#PoW-挖矿及共识流程" class="headerlink" title="PoW-挖矿及共识流程"></a>PoW-挖矿及共识流程</h3><p>本章节主要是熟悉比特币pow挖矿及共识流程，和简单实现一个pow挖矿helloworld的小demo。</p>
<h2 id="比特币pow挖矿及共识流程"><a href="#比特币pow挖矿及共识流程" class="headerlink" title="比特币pow挖矿及共识流程"></a>比特币pow挖矿及共识流程</h2><p>比特币挖矿的过程如下：</p>
<ol>
<li>构建一个空区块，称为候选区块</li>
<li>从内存池中打包交易至候选区块</li>
<li>构造区块头，填写区块头的下述字段<br>　　1）填写版本号version字段<br>   　　2）填写父区块哈希prevhash字段<br>   　　3）用merkle树汇总全部的交易，将merkle root的哈希值填写至merkle root字段<br>   　　4）填写时间戳timestamp字段<br>   　　5）填写目标值Bits字段</li>
<li>开始挖矿。挖矿就是不断重复计算区块头的哈希值，修改nonce参数，直到找到一个满足条件的nonce值，也就是该nonce值下，hash函数运算出来的hash值 &lt; Bits。当挖矿节点成功求出一个解后把解填入区块头的nonce字段。</li>
<li>这时一个新区块就成功挖出了，然后挖矿节点会做下面这些事：<br>　　1) 按照标准清单检验新区块，检验通过后进行下面的 2)和 3)步骤<br>   　　2）立刻将这个新区块发给它的所有相邻节点，相邻节点收到这个新区块后进行验证，验证有效后会继续传播给所有相邻节点。<br>   　　3）将这个新区块连接到现有的区块链中，按照如下规则：<br>   　　　　根据新区块的prevhash字段在现有区块链中寻找这个父区块，<br>   　　　　(Ⅰ) 如果父区块是主区块链的“末梢”，则将新区块添加上去即可；<br>   　　　　(Ⅱ) 如果父区块所在的链是备用链，则节点将新区块添加到备用链，同时比较备用链与主链的工作量。如果备用链比主链积累了更多的工作量，节点将选择备用链作为其新的主链，而之前的主链则成为了备用链；<br>   　　　　(Ⅲ) 如果在现有的区块链中找不到它的父区块，那么这个区块被认为是“孤块”。孤块会被保存在孤块池中，直到它们的父区块被节点接收到。一旦收到了父区块并且将其连接到现有的区块链上，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</li>
</ol>
<p>pow工作量证明共识机制流程图如下：</p>
<p><img src="http://image.chaindesk.cn/pow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png/mark" alt="img"></p>
<p>演示挖坑过程，可链接下面网址：</p>
<p><a href="https://anders.com/blockchain/blockchain.html" target="_blank" rel="noopener">https://anders.com/blockchain/blockchain.html</a></p>
<h2 id="pow简单的例子"><a href="#pow简单的例子" class="headerlink" title="pow简单的例子"></a>pow简单的例子</h2><p>下边这个代码很糙，只是简化版的pow挖矿过程，里面的N就是挖矿Bits，我设置了一个常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//声明了一个挖矿难度Bits</span></span><br><span class="line"><span class="keyword">const</span> N  = <span class="number">0x00FFffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个block结构体</span></span><br><span class="line"><span class="keyword">type</span> block <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//区块数据</span></span><br><span class="line">    Data  []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//随机数</span></span><br><span class="line">    Nonce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//当前块的hash</span></span><br><span class="line">    hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//挖矿目标难度值</span></span><br><span class="line">    Bits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化一个空块</span></span><br><span class="line">    <span class="keyword">var</span> b = block&#123;[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>), <span class="number">0</span>,<span class="literal">nil</span>,N&#125;</span><br><span class="line"></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接block字段内容</span></span><br><span class="line">        dataBytes := b.PreParae(nonce)</span><br><span class="line">        <span class="comment">//矿工计算函数，我只用了一次256hash</span></span><br><span class="line">        hash := sha256.Sum256(dataBytes)</span><br><span class="line">        <span class="comment">//将hash转换成Uint64类型，将与N进行比较大小</span></span><br><span class="line">        hash1 := BytesToUint64(hash[:])</span><br><span class="line">        <span class="comment">//不断显现hash函数后的值</span></span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">        <span class="comment">//hash值与目标值进行大小比较</span></span><br><span class="line">        <span class="keyword">if</span> hash1 &lt; <span class="keyword">uint64</span>(N) &#123;</span><br><span class="line">        <span class="comment">//挖矿成功后，给b重新赋值，并跳出循环</span></span><br><span class="line">            fmt.Println()</span><br><span class="line">            b.Nonce=nonce</span><br><span class="line">            b.hash=hash[:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonce++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//block字段拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b block)</span> <span class="title">PreParae</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            b.Data,</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            b.hash,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节转换成64进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToUint64</span><span class="params">(array []<span class="keyword">byte</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">        data = data + <span class="keyword">uint64</span>(<span class="keyword">uint</span>(array[i])&lt;&lt;<span class="keyword">uint</span>(<span class="number">8</span>*i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将64进制数字转换成字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hongery"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Hongery</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hongery" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hongery" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_40098405" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_40098405" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1281185088@qq.com" title="E-Mail1 → mailto:1281185088@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail1</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hongery@yeah.net" title="E-Mail2 → mailto:hongery@yeah.net" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail2</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hongery</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">NaN:aN字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
