<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>10Go语言基础之结构体</title>
      <link href="/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之结构体"><a href="#Go语言基础之结构体" class="headerlink" title="Go语言基础之结构体"></a>Go语言基础之结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><a id="more"></a><h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过<code>Type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type（<span class="keyword">int</span>，<span class="keyword">string</span>，<span class="keyword">byte</span>。。。）</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="keyword">string</span></span><br><span class="line">age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">"沙河娜扎"</span></span><br><span class="line">p1.city = <span class="string">"北京"</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person&#123;name:"沙河娜扎", city:"北京", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//匿名结构体</span></span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">"小王子"</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">"小王子"</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">"上海"</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"小王子", city:"上海", age:28&#125;</span></span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。（new &amp;make申请内存空间）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person（自定义类型）</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">"七米"</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">"成都"</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"七米", city:"成都", age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p4 person</span><br><span class="line">fmt.Printf(<span class="string">"p4=%#v\n"</span>, p4) <span class="comment">//p4=main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p6=%#v\n"</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:"", city:"北京", age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">"沙河娜扎"</span>,</span><br><span class="line"><span class="string">"北京"</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p8=%#v\n"</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:"沙河娜扎", city:"北京", age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int8</span></span><br><span class="line">c <span class="keyword">int8</span></span><br><span class="line">d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"n.a %p\n"</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">"n.b %p\n"</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">"n.c %p\n"</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">"n.d %p\n"</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com" target="_blank" rel="noopener">在 Go 中恰到好处的内存对齐</a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>请问下面代码的执行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">stus := []student&#123;</span><br><span class="line">&#123;name: <span class="string">"小王子"</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"娜扎"</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"大王八"</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">m[stu.name] = &amp;stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">"=&gt;"</span>, v.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数：约定成俗new开头</span></span><br><span class="line"><span class="comment">//返回的是结构体还是结构体指针</span></span><br><span class="line"><span class="comment">//当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">"张三"</span>, <span class="string">"沙河"</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p9) <span class="comment">//&amp;main.person&#123;name:"张三", city:"沙河", age:90&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法作用于特定类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;<span class="comment">//只用dog才能使用</span></span><br><span class="line">fucn(d *dog)wang()&#123;</span><br><span class="line">    fmt.Println(<span class="string">"汪汪汪"</span>，d.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s的梦想是学好Go语言！\n"</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者：传内存地址进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge(<span class="number">30</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者 ：传拷贝进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, 我是一个int。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v  %T\n"</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">    <span class="comment">//不能再定义string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">"小王子"</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person&#123;string:"北京", int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address Address  <span class="comment">//如果换成Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">"小王子"</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">"山东"</span>,</span><br><span class="line">City:     <span class="string">"威海"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(user1.Address.city)  <span class="comment">//如果上面换成匿名Address ，user1.city 就可以直接访问</span></span><br><span class="line">    fmt.Println(user1.city)<span class="comment">//现在自己的结构体里面找，找不到就去匿名嵌套的结构体里面找</span></span><br><span class="line">    fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)<span class="comment">//user1=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.Name = <span class="string">"小王子"</span></span><br><span class="line">user2.Gender = <span class="string">"男"</span></span><br><span class="line">user2.Address.Province = <span class="string">"山东"</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">user2.City = <span class="string">"威海"</span> <span class="comment">//（user2.Address.city）               //直接访问匿名结构体的字段名</span></span><br><span class="line">fmt.Printf(<span class="string">"user2=%#v\n"</span>, user2) <span class="comment">//user2=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="keyword">string</span></span><br><span class="line">City       <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user3 User</span><br><span class="line">user3.Name = <span class="string">"沙河娜扎"</span></span><br><span class="line">user3.Gender = <span class="string">"男"</span></span><br><span class="line"><span class="comment">// user3.CreateTime = "2019" //ambiguous selector user3.CreateTime</span></span><br><span class="line">user3.Address.CreateTime = <span class="string">"2000"</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">user3.Email.CreateTime = <span class="string">"2000"</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动！\n"</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="keyword">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会汪汪汪~\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">"乐乐"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体字段的可见性（-）"><a href="#结构体字段的可见性（-）" class="headerlink" title="结构体字段的可见性（**）"></a>结构体字段的可见性（**）</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span></span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">"101"</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;"Title":"101","Students":[&#123;"ID":0,"Gender":"男","Name":"stu00"&#125;,&#123;"ID":1,"Gender":"男","Name":"stu01"&#125;,&#123;"ID":2,"Gender":"男","Name":"stu02"&#125;,&#123;"ID":3,"Gender":"男","Name":"stu03"&#125;,&#123;"ID":4,"Gender":"男","Name":"stu04"&#125;,&#123;"ID":5,"Gender":"男","Name":"stu05"&#125;,&#123;"ID":6,"Gender":"男","Name":"stu06"&#125;,&#123;"ID":7,"Gender":"男","Name":"stu07"&#125;,&#123;"ID":8,"Gender":"男","Name":"stu08"&#125;,&#123;"ID":9,"Gender":"男","Name":"stu09"&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">"value1"</span> key2:<span class="string">"value2"</span>`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 <strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key </span></span><br><span class="line">name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">name:   <span class="string">"沙河娜扎"</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json str:%s\n"</span>, data) <span class="comment">//json str:&#123;"id":1,"Gender":"男"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体中遇到的问题"><a href="#结构体中遇到的问题" class="headerlink" title="结构体中遇到的问题"></a>结构体中遇到的问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个int类型的变量，它的值是10//1</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">x =<span class="number">10</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">x :=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="keyword">var</span> myInt <span class="keyword">int</span> <span class="comment">//自定义类型</span></span><br><span class="line">m :=myInt(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>问题2结构体初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pserson <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> </span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法1，声明一个person类型的变量p</span></span><br><span class="line">    <span class="keyword">var</span> p person</span><br><span class="line">    p.name=<span class="string">"hg"</span></span><br><span class="line">    p.age=<span class="number">19</span></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    <span class="comment">//方法2，键值对初始化</span></span><br><span class="line">    <span class="keyword">var</span> p2=person&#123;</span><br><span class="line">        name :<span class="string">"hg"</span>,</span><br><span class="line">        age : <span class="number">19</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p2)</span><br><span class="line">    <span class="comment">//方法3，zhi值列表初始化</span></span><br><span class="line">    <span class="keyword">var</span> p3 = person&#123;</span><br><span class="line">        <span class="string">"理想"</span>，</span><br><span class="line">        <span class="number">12</span>，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题3：为什么要用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(x <span class="keyword">string</span>,y <span class="keyword">int</span>)</span> <span class="title">person</span></span>&#123;      <span class="comment">//返回*person</span></span><br><span class="line">    <span class="comment">//别人调用，我能给他一个person类型的变量 </span></span><br><span class="line">    <span class="keyword">return</span> person&#123;<span class="comment">//return &amp;person</span></span><br><span class="line">        name:x,</span><br><span class="line">        age :y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用“面向对象”的思维方式编写一个学生信息管理系统。<ol><li>学生有id、姓名、年龄、分数等信息</li><li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数版学生管理系统，</span></span><br><span class="line"><span class="comment">写一个系统能够产看，新增学生，删除学生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allStudent <span class="keyword">map</span>[<span class="keyword">int64</span>]*student <span class="comment">//变量声明</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudnet</span><span class="params">(id <span class="keyword">int64</span>,name <span class="keyword">string</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">id : id ,</span><br><span class="line">name : name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示所有学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showallStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k,v :=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line">fmt.Printf(<span class="string">"学号：%d 姓名：%s\n"</span>,k,v.name,)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建一个学生</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">id <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生学号："</span>)</span><br><span class="line">fmt.Scanln(&amp;id)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生姓名："</span>)</span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line">newStu :=newStudnet(id,name)</span><br><span class="line"><span class="comment">//2追加到allstudent这个map中</span></span><br><span class="line">allStudent[id]=newStu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//1.请输入删除学生的学号</span></span><br><span class="line"><span class="keyword">var</span> deleteId  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"请输入你要删除学生的学号:"</span>)</span><br><span class="line">fmt.Scanln(&amp;deleteId)</span><br><span class="line"><span class="comment">//2.去allStudent这个map中根据学号删除对应的键值对</span></span><br><span class="line"><span class="keyword">for</span> k,_:=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line"><span class="keyword">if</span> k==deleteId&#123;</span><br><span class="line"><span class="built_in">delete</span>(allStudent,deleteId)</span><br><span class="line">fmt.Println(<span class="string">"删除成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">allStudent =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*student,<span class="number">48</span>) <span class="comment">//初始化（开辟内存空间）</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//1.打印菜单</span></span><br><span class="line">fmt.Println(<span class="string">"欢迎学生管理系统"</span>)</span><br><span class="line">fmt.Println(<span class="string">`</span></span><br><span class="line"><span class="string">1.查看所用学生</span></span><br><span class="line"><span class="string">2.新增学生</span></span><br><span class="line"><span class="string">3.删除学生</span></span><br><span class="line"><span class="string">4.退出</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">fmt.Println(<span class="string">"请输入你要干啥:"</span>)</span><br><span class="line"><span class="comment">//2.等待用户选择要做什么</span></span><br><span class="line"><span class="keyword">var</span> choice <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;choice)</span><br><span class="line">fmt.Printf(<span class="string">"你选择了%d这个选项\n"</span>, choice)</span><br><span class="line"><span class="comment">//3.执行对应的函数</span></span><br><span class="line"><span class="keyword">switch</span> choice &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">showallStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">addStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">deleteStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"gun~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09Go语言基础之函数</title>
      <link href="/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之函数"><a href="#Go语言基础之函数" class="headerlink" title="Go语言基础之函数"></a>Go语言基础之函数</h1><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello 沙河"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret := intSum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名的函数值就相当于在函数中声明一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x,y <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int</span>)</span></span>&#123;  <span class="comment">//若func f(x,y int) int()&#123; return x+y&#125;</span></span><br><span class="line">res =x+y</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//命名的返回值可以不写res</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可变长参数，必须放在函数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s</span><span class="params">(s <span class="keyword">string</span>,y... <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(y)  <span class="comment">//y的类型是切片slice</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go函数没有默认参数这个概念</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">r :=f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s(<span class="string">"hg"</span>)   <span class="comment">//hg []</span></span><br><span class="line">s(<span class="string">"huang"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)<span class="comment">//huang [1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum2</span><span class="params">(x ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x) <span class="comment">//x是一个切片       </span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 := intSum2()</span><br><span class="line">ret2 := intSum2(<span class="number">10</span>)</span><br><span class="line">ret3 := intSum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret4 := intSum2(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) <span class="comment">//0 10 30 60</span></span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 := intSum3(<span class="number">100</span>)</span><br><span class="line">ret6 := intSum3(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">ret7 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret8 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) <span class="comment">//100 110 130 160</span></span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言中通过<code>return</code>关键字向外输出返回值。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testGlobalVar() <span class="comment">//num=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"x=%d\n"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) <span class="comment">// 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">// 函数中优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testNum() <span class="comment">// num=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar2</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x, y) <span class="comment">//函数的参数也是只在本函数中生效</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">100</span> <span class="comment">//变量z只在if语句块生效</span></span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(z)//此处无法使用变量z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//变量i只在当前for语句块中生效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(i) //此处无法使用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用声明calculation也可以直接函数赋值</span></span><br><span class="line">f := add                        <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line">fmt.Printf(<span class="string">"type of f:%T\n"</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>, op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">"无法识别的操作符"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：  (闭包是一个函数，函数是可以成为返回值，这个函数包含了他外部作用域的一个变量)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = adder()   <span class="comment">//func f(y int) int&#123; x+=y  return x&#125;</span></span><br><span class="line"> fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder2(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//70</span></span><br><span class="line"></span><br><span class="line">f1 := adder2(<span class="number">20</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//60</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">".jpg"</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">".txt"</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">"test"</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">"test"</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：第一步：返回值赋值。第二部：真正的return返回；</p><p>函数中如果存在defer。那么defer执行的时机是在第一步和第二步之间</p><p><img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p><h3 id="defer经典案例-面试题"><a href="#defer经典案例-面试题" class="headerlink" title="defer经典案例(面试题)"></a>defer经典案例(面试题)</h3><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">int</span></span> &#123;   <span class="comment">//f1()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//x=6</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x   <span class="comment">//x =5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f2()=6  定义了返回值</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>   <span class="comment">//返回值=x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(y <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f3()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//修改的是x的值</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x  <span class="comment">//返回值y=x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;   <span class="comment">//f4()=5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x++  <span class="comment">//改变函数中的副本</span></span><br><span class="line">&#125;(x)<span class="comment">//外部穿的参数，属于局部变量，不是返回值x传进去的参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span> <span class="comment">//返回值x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">fmt.Println(f3())</span><br><span class="line">fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"AA"</span>, x, calc(<span class="string">"A"</span>, x, y))</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"BB"</span>, x, calc(<span class="string">"B"</span>, x, y))</span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 1 2 3</span></span><br><span class="line"><span class="comment">B 0 2 2</span></span><br><span class="line"><span class="comment">BB 0 2 2</span></span><br><span class="line"><span class="comment">AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 x=1 y=2     defer 是压栈，先进后出</span></span><br><span class="line"><span class="comment">//2 defer calc("AA",x,calc("A", x, y))  压栈的时候将x存进去</span></span><br><span class="line"><span class="comment">//3 calc("A", x, y) //"A" 1 2 3</span></span><br><span class="line"><span class="comment">//4 defer calc("AA",x,3)  （x =1）</span></span><br><span class="line"><span class="comment">//5 x=0</span></span><br><span class="line"><span class="comment">//6 defer calc("BB",x,calc("B", x, y))</span></span><br><span class="line"><span class="comment">//7 calc("B", x, y) //"B" 0 2 2    </span></span><br><span class="line"><span class="comment">//8 defer calc("BB",x,2)</span></span><br><span class="line"><span class="comment">//9 y=1 （有点混淆，没有被引用过）</span></span><br><span class="line"><span class="comment">//10 calc("BB",x,2) //"BB" 0 2 2  出栈  </span></span><br><span class="line"><span class="comment">//calc("AA",x,3) //"AA" 1 3 4   这里有点特别  （x=1 为原先的）</span></span><br></pre></td></tr></table></figure><p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p><h1 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h1><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic <span class="keyword">in</span> B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        .../code/func/main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        .../code/func/main.go:20 +0x98</span><br></pre></td></tr></table></figure><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recover in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>分金币</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span></span><br><span class="line"><span class="comment">分配规则如下：</span></span><br><span class="line"><span class="comment">a. 名字中每包含1个'e'或'E'分1枚金币</span></span><br><span class="line"><span class="comment">b. 名字中每包含1个'i'或'I'分2枚金币</span></span><br><span class="line"><span class="comment">c. 名字中每包含1个'o'或'O'分3枚金币</span></span><br><span class="line"><span class="comment">d: 名字中每包含1个'u'或'U'分4枚金币</span></span><br><span class="line"><span class="comment">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span></span><br><span class="line"><span class="comment">程序结构如下，请实现 ‘dispatchCoin’ 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">coins = <span class="number">50</span></span><br><span class="line">users = []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Matthew"</span>, <span class="string">"Sarah"</span>, <span class="string">"Augustus"</span>, <span class="string">"Heidi"</span>, <span class="string">"Emilie"</span>, <span class="string">"Peter"</span>, <span class="string">"Giana"</span>, <span class="string">"Adriano"</span>, <span class="string">"Aaron"</span>, <span class="string">"Elizabeth"</span>,</span><br><span class="line">&#125;</span><br><span class="line">distribution = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">left := dispatchCoin()</span><br><span class="line">fmt.Println(<span class="string">"剩下："</span>, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08Go语言基础之Map</title>
      <link href="/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/"/>
      <url>/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之map"><a href="#Go语言基础之map" class="headerlink" title="Go语言基础之map"></a>Go语言基础之map</h1><p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p><a id="more"></a><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>Go语言中 <code>map</code>的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">"小明"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line"><span class="built_in">type</span> of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"username"</span>: <span class="string">"沙河小王子"</span>,</span><br><span class="line"><span class="string">"password"</span>: <span class="string">"123456"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//开辟内存空间，要估值好map容量，避免在程序运行期间再动态扩容</span></span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">"张三"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"查无此人"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;  <span class="comment">//默认获得key值</span></span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> _,value:=<span class="keyword">range</span> scoreMap&#123; <span class="comment">//获取value值</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">"小明"</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按照指定顺序遍历map（map本身是无序的）"><a href="#按照指定顺序遍历map（map本身是无序的）" class="headerlink" title="按照指定顺序遍历map（map本身是无序的）"></a>按照指定顺序遍历map（map本身是无序的）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"stu%02d"</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//元素类型为map的切片</span></span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"小王子"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"password"</span>] = <span class="string">"123456"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"address"</span>] = <span class="string">"沙河"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line">key := <span class="string">"中国"</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">"北京"</span>, <span class="string">"上海"</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li></ol><h4 id="看文档"><a href="#看文档" class="headerlink" title="看文档"></a>看文档</h4><p> go doc builtin.delete(delete代表方法)</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07Go语言基础之指针</title>
      <link href="/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/"/>
      <url>/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之指针"><a href="#Go语言基础之指针" class="headerlink" title="Go语言基础之指针"></a>Go语言基础之指针</h1><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><a id="more"></a><h1 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h1><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h2 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h2><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为<code>T</code></li><li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a:%d ptr:%p\n"</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">fmt.Printf(<span class="string">"b:%p type:%T\n"</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">    </span><br><span class="line">    n :=<span class="number">18</span></span><br><span class="line">p :=&amp;n</span><br><span class="line">fmt.Println(&amp;n)<span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,p) <span class="comment">//*int</span></span><br><span class="line">fmt.Println(p) <span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Println(*p)<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">m :=*p</span><br><span class="line">fmt.Println(m) <span class="comment">//18</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,m)<span class="comment">//int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：<img src="https://www.liwenzhou.com/images/Go/pointer/ptr.png" alt="取变量地址图示"></p><h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//指针取值</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b)</span><br><span class="line">c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">"value of c:%v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of b:*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="keyword">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p><strong>指针传值示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var a *int //nil pointer</span></span><br><span class="line"><span class="comment">// *a =100</span></span><br><span class="line"><span class="comment">// fmt.Println(*a)//报错无效内存地址和空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 *<span class="keyword">int</span>  </span><br><span class="line">fmt.Println(a1)  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">var</span> a2=<span class="built_in">new</span>(<span class="keyword">int</span>)  <span class="comment">//new函数申请一个内存地址</span></span><br><span class="line">fmt.Println(a2) <span class="comment">//0xc04204a0e0</span></span><br><span class="line">*a2 =<span class="number">100</span></span><br><span class="line">fmt.Println(*a2) <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>我们先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">100</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><h5 id="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："><a href="#make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：" class="headerlink" title="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："></a>make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与make的区别（面试题）"><a href="#new与make的区别（面试题）" class="headerlink" title="new与make的区别（面试题）"></a>new与make的区别（面试题）</h3><ol><li>二者都是用来做（申请）内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型（int string …）的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06Go语言基础之切片</title>
      <link href="/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/"/>
      <url>/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之切片"><a href="#Go语言基础之切片" class="headerlink" title="Go语言基础之切片"></a>Go语言基础之切片</h1><p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [3]<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="keyword">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。</p><h3 id="基于数组定义切片"><a href="#基于数组定义切片" class="headerlink" title="基于数组定义切片"></a>基于数组定义切片</h3><p>由于切片的底层就是一个数组，所以我们可以基于数组定义切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于数组定义切片</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">4</span>]                     <span class="comment">//基于数组a创建切片，前包后不包，包括元素a[1],a[2],a[3]</span></span><br><span class="line">fmt.Println(b)                  <span class="comment">//[56 57 58]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:[]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := a[<span class="number">1</span>:] <span class="comment">//[56 57 58 59]</span></span><br><span class="line">d := a[:<span class="number">4</span>] <span class="comment">//[55 56 57 58]</span></span><br><span class="line">e := a[:]  <span class="comment">//[55 56 57 58 59]</span></span><br></pre></td></tr></table></figure><h3 id="切片再切片"><a href="#切片再切片" class="headerlink" title="切片再切片"></a>切片再切片</h3><p>除了基于数组得到切片，我们还可以通过切片来得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//切片再切片</span></span><br><span class="line">a := [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"a:%v type:%T len:%d  cap:%d\n"</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))<span class="comment">//6 6</span></span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"b:%v type:%T len:%d  cap:%d\n"</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))<span class="comment">//2 5</span></span><br><span class="line">c := b[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"c:%v type:%T len:%d  cap:%d\n"</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c)) <span class="comment">//4  4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:[北京 上海 广州 深圳 成都 重庆] <span class="built_in">type</span>:[6]string len:6  <span class="built_in">cap</span>:6</span><br><span class="line">b:[上海 广州] <span class="built_in">type</span>:[]string len:2  <span class="built_in">cap</span>:5</span><br><span class="line">c:[广州 深圳 成都 重庆] <span class="built_in">type</span>:[]string len:4  <span class="built_in">cap</span>:4</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</p><p>​            切片指向一个底层数组</p><p>​            切片的长度就是它元素的个数</p><p>​            切片的容量，是最底层数组从切片的第一个元素到最后一个元素的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s6 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s7 :=s6[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//len (2 3 4)   cap(2 3 4 5 6 7)   </span></span><br><span class="line">fmt.Printf(<span class="string">"len(s7)%d   cap(s7)%d"</span>,<span class="built_in">len</span>(s7),<span class="built_in">cap</span>(s7)) <span class="comment">//3 ,6</span></span><br></pre></td></tr></table></figure><p>1.切片不保存具体的值</p><p>2.切片对应一个底层数组</p><p>3.底层数组都是占用一块连续的内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a1 :=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">a2 := a1  <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">// var a3 []int //这样定义a3为nil  没办法进行copy</span></span><br><span class="line"><span class="keyword">var</span> a3 =<span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(a3,a1)  <span class="comment">//a1复制到a3</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[1 3 5] [1 3 5] [1 3 5]</span></span><br><span class="line">a1[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[100 3 5] [100 3 5] [1 3 5]  由于切片是引用类型a1给a2赋值，都指向同一块内存地址</span></span><br><span class="line"></span><br><span class="line">x1 :=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//数组</span></span><br><span class="line">s1 :=x1[:]<span class="comment">//切片</span></span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 2 3] 3 3 </span></span><br><span class="line">s1=<span class="built_in">append</span>(s1[:<span class="number">1</span>],s1[<span class="number">2</span>:]...)</span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 3] 2 3 删除一个元素</span></span><br><span class="line">fmt.Println(x1) <span class="comment">//[1 3 3]  //修改了底层数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0]</span></span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">a =<span class="built_in">append</span>(a,i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//20扩容 面试题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 =[...]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>&#125;</span><br><span class="line">sort.Ints(b1[:]) <span class="comment">//对切片进行排序</span></span><br><span class="line">fmt.Println(b1)<span class="comment">//1，2，4，9</span></span><br></pre></td></tr></table></figure><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  <span class="comment">//创建切片</span></span><br><span class="line">fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质（引用类型）"><a href="#切片的本质（引用类型）" class="headerlink" title="切片的本质（引用类型）"></a>切片的本质（引用类型）</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。（切片就是一个框，框住了一块连续的内存，切片属于引用类型，真正的数据都保存在底层数组里的）</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><h5 id="切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："><a href="#切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：" class="headerlink" title="切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："></a>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]   切片是引用类型</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">"%v  len:%d  cap:%d  ptr:%p\n"</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"北京"</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"><a href="#由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。" class="headerlink" title="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"></a>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</h5><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1.请写出下面代码的输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a = <span class="built_in">append</span>(a, fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int{3, 7, 8, 9, 1}</code>进行排序。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05Go语言基础之数组</title>
      <link href="/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
      <url>/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之数组"><a href="#Go语言基础之数组" class="headerlink" title="Go语言基础之数组"></a>Go语言基础之数组</h1><p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><a id="more"></a><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of numArray:%T\n"</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of cityArray:%T\n"</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t"</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li><li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04Go语言基础之流程控制</title>
      <link href="/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之流程控制"><a href="#Go语言基础之流程控制" class="headerlink" title="Go语言基础之流程控制"></a>Go语言基础之流程控制</h1><p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><a id="more"></a><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域  全局变量</span></span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域    局部变量</span></span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p><p>score 的作用域不一样</p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"大拇指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"食指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"中指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"无名指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">"小拇指"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"无效的输入！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">"奇数"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"偶数"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好学习吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好工作吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好享受吧"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"活着真好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"a"</span>:</span><br><span class="line">fmt.Println(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"b"</span>:</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"c"</span>:</span><br><span class="line">fmt.Println(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;                             <span class="comment">//跳出多层循环，经常使用</span></span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">"结束for循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码打印9*9乘法表。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Go语言基础之运算符</title>
      <link href="/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之运算符"><a href="#Go语言基础之运算符" class="headerlink" title="Go语言基础之运算符"></a>Go语言基础之运算符</h1><p>运算符用于在程序运行时执行数学或逻辑运算。</p><a id="more"></a><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">//单独的语句，不能放在=号的右边赋值</span></span><br><span class="line">a-- <span class="comment">//单独语句，不能放在=的右边赋值</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!=</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">||</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+=</td><td align="center">相加后再赋值</td></tr><tr><td align="center">-=</td><td align="center">相减后再赋值</td></tr><tr><td align="center">*=</td><td align="center">相乘后再赋值</td></tr><tr><td align="center">/=</td><td align="center">相除后再赋值</td></tr><tr><td align="center">%=</td><td align="center">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;=</td><td align="center">左移后赋值</td></tr><tr><td align="center">&gt;&gt;=</td><td align="center">右移后赋值</td></tr><tr><td align="center">&amp;=</td><td align="center">按位与后赋值</td></tr><tr><td align="center">|=</td><td align="center">按位或后赋值</td></tr><tr><td align="center">^=</td><td align="center">按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基本数据类型</title>
      <link href="/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之基本数据类型"><a href="#Go语言基础之基本数据类型" class="headerlink" title="Go语言基础之基本数据类型"></a>Go语言基础之基本数据类型</h1><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><a id="more"></a><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint</td><td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td align="center">int</td><td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td align="center">uintptr</td><td align="center">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说：</p><p>v := 123_456 等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"你好"</span></span><br><span class="line">s3 :=<span class="string">'2'</span> <span class="comment">//单独字母，汉字，符号，表示一个字符，</span></span><br><span class="line"><span class="comment">//字节：1个字节=8bit（8个二进制位2^8=156）</span></span><br><span class="line"><span class="comment">//一个字符'A'=1个字节</span></span><br><span class="line"><span class="comment">//1个utf8编码汉子‘啥’=一般占3个字节</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th align="center">转义符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\r</code></td><td align="center">回车符（返回行首）</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\&#39;</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr></tbody></table><p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Code\\lesson1\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"hello沙河"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">"big"</span>    <span class="comment">//字符串不能直接修改，，不能修改的变量</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">"白萝卜"</span></span><br><span class="line">runeS2 := []<span class="keyword">rune</span>(s2)<span class="comment">//吧字符强制转换成rune一个切片</span></span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">    </span><br><span class="line">    c1 :=<span class="string">"红"</span></span><br><span class="line">    c2 :=<span class="string">'红'</span></span><br><span class="line">    fmt.Printf(<span class="string">"c1:%T  c2%T"</span>,c1 ,c2)<span class="comment">//c1:string  c2:int32  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li><li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ripple支付开源协议</title>
      <link href="/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><p>Ripple（瑞波）是一种基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。在Ripple的网络中，交易由客户端发起，经过追踪节点（tracking node）或验证节点（validating node）把交易广播到整个网络中。追踪节点的主要功能是分发交易信息以及相应客户端的账本请求。验证节点除了包含追踪节点的所有功能外，还能通过共识协议，在账本中增加新的账本实例数据。</p><a id="more"></a><p>下面我用在图形中分析具体的共识过程：</p><p><img src="http://image.chaindesk.cn/Ripple1.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple2.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple4.png/mark" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOS共识机制</title>
      <link href="/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="EOS共识机制"><a href="#EOS共识机制" class="headerlink" title="EOS共识机制"></a>EOS共识机制</h3><p>EOS在第一版白皮书中使用的DPOS共识机制，而在新一版的白书中，对共识机制进行了改进，使用BFT+DPOS混合共识机制。使出块速度从原来的3秒变为0.5秒，tps显著提高，达到测试3590次/秒。</p><a id="more"></a><h2 id="EOS第一版共识机制DPOS"><a href="#EOS第一版共识机制DPOS" class="headerlink" title="EOS第一版共识机制DPOS"></a>EOS第一版共识机制DPOS</h2><p>EOS现在系统运行的链用的共识机制是第一版白皮书的，也就是纯DPOS共识机制。<br>DPOS即授权权益证明共识机制。相比于比特币的POW机制，DPOS不用浪费算力资源去争夺记账权，而是通过赋予EOS通证持有人的投票选举，选出21个超级节点担任记账人的角色，保证整个网络的正常运行。值得一提的是，人们的投票所占的比重取决于他们持有多少token。这意味着拥有更多token的人将比拥有极少token的人更多地影响网络。这其实很好理解，因为持有网络的运行的好坏会对持有更多token的人的利益产生更大的影响，这使得他们的投票更谨慎。<br>21个超级节点轮流负责记账。<strong>每轮都会随机打乱他们的出块顺序，</strong>每个超级节点作为出块节点时，只负责出一个块。每一个区块产生后会按照顺序传递给下一个超级节点中。第二个超级节点要负责打包新的区块，同时还要确认上一个区块的内容。当某一个区块被超过2/3的超级节点确认后，则该区块将成为不可逆转区块，即上链区块。</p><p>该算法有些地方明显需要改良。比如容易出现漏块现象。21个超级节点分布世界各地，如果随机打乱顺序，导致总是依次顺序的节点相距地理位置很远，如中国和美国，这两国的网络传输单向时间是300毫秒，一来一回总共600毫秒。那么中国这边出块，然后经过其他20个节点确认后返回，假设时间总共是4秒；而接下来美国出块，反馈回来的时间是3秒，比中国快1秒，肯定是先上链的，结果中国出的块就被丢弃掉了。当前目前设的出块时间是3秒，理论上能够解决这种漏块现象，但想提高eos的性能，这块肯定是要改进的。</p><h2 id="EOS最新版共识机制BFT-DPOS"><a href="#EOS最新版共识机制BFT-DPOS" class="headerlink" title="EOS最新版共识机制BFT-DPOS"></a>EOS最新版共识机制BFT-DPOS</h2><p>BFT即拜占庭容错算法。EOS引入这个算法，主要是赋予出块节点更大的权力，加快出块速度，解决节点出的块都被漏掉的问题。</p><p>EOS共识算法的升级，势必需要超级节点们更新代码，使用新的程序，然后在当前链上继续运行。但如果超过1/3的节点拒绝更新代码，可能会出现硬分叉问题。所以如何很好地做好过渡是EOS最大难题。</p><p>我们一起分析下改进后的共识机制是如何工作的。</p><p>EOS使用BFT+DPOS共识机制后，不再按照出块顺序让超级节点一个个验证区块内容，而是让出块节点成为主节点。出块后，同时向其他20个超级节点进行广播该区块，并获得他们的验证。如果超过2/3的节点验证通过后，则该区块将成为不可逆转区块。</p><p>BFT可以使EOS出块速度显著增加。目前使用BFT+DPOS共识机制的EOS，可以实现0.5秒的出块速度，1秒实现区块的不可逆转。为避免因出块速度过快而漏块，EOS的超级节点按照其他的地理位置依次轮流成为主节点，尽可能减少超级节点的网络延迟。比如超级节点有中国、美国、加拿大、日本，那么成为主节点的顺序是中国&gt;日本&gt;美国&gt;加拿大或者反过来，总之保证相邻最近的超级节点要依次交接主节点角色。</p><p>同时规定每个主节点连续生产6个区块，至少保证6个区块的前几个能确认完成，不存在整个超级节点被跳过的现象。可以看出每轮记账节点的出块总时间还是3秒钟，在这3秒里，因为他对他自己出的块是信任的，所以可以持续出块。一边出块一边广播，3秒之内率先广播的区块肯定能够得到确认，在网络通畅的情况下，6个区块都会可能得到确认。</p><p>EOS共识处理分叉问题非常简单，和比特币一样，节点只会认可最长的链作为合法链。假如某个节点开始作恶，自己出块并生成自己的链，也就是每次轮到它就产生6个块。但是超级节点总共21个，每轮产生理论126个块。根据选择最长链作为主链原则，肯定作恶的链得不到认可。所以EOS不会发生分叉问题。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT实用拜占庭容错系统</title>
      <link href="/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>PBFT即<strong>实用拜占庭容错系统</strong>，英文全称<strong>Practical Byzantine Fault Tolerance</strong>。它是第一个基于BFT理论并结合实际产生的新的共识算法。但应用场景是私有链和联盟链，如果用于公链，需要和其他共识算法进行灵活的混用。</p><a id="more"></a><h2 id="PBFT算法原理"><a href="#PBFT算法原理" class="headerlink" title="PBFT算法原理"></a>PBFT算法原理</h2><p>PBFT是一类<strong>状态机拜占庭系统</strong>，要求共同维护一个状态，所有节点采用的行动一致。为此，需要运行三类基本协议，包括一致性协议（Agreement）、验证确认协议（Validity）和视图更换协议（Viewchange）。</p><h5 id="1-一致性协议："><a href="#1-一致性协议：" class="headerlink" title="1.一致性协议："></a>1.一致性协议：</h5><p>在PBFT系统中，节点分为两类：主节点（Lead）和从节点（Follow）。主节点就一个，其他剩余节点都是从节点。在实现PBFT系统功能之前，所有节点都是从节点，经过选举，产生一个主节点。每个节点都有被选举权和选举权，选举过程每个节点的概率都是平等的。</p><p>一致性协议包含若干个阶段：请求（Request）&gt;序列分配（Pre-prepare）&gt;相互交互（Prepare） &gt;确认（Commit） &gt;响应（Reply）。过程如下图：</p><p><img src="http://image.chaindesk.cn/pbft.jpg/mark" alt="img"></p><p>注：C为客户端或叫请求节点；0为当前视图下的主节点；1，2，3是从节点，其中3为宕机节点。<br>该视图满足拜占庭容错，即系统节点总数4 &gt;故障节点个数1x3             1&lt; 4 * (1/3)</p><p>1）Request阶段<br>也就是Lead生成请求阶段。</p><p>客户端发送请求到主节点，或者主节点主动从某数据源获取数据作为请求</p><p>2）Pre-prepare阶段<br>也就是Lead给其他所有Follow发送请求阶段。</p><p>主节点将收到的请求进行处理，给请求赋值一个序列号n，形成一个带序号的副本，然后分发给其从节点。其中序号n必须在水线（watermark）上下限h和H之间。水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间。发送副本的格式是 <code>&lt;,m&gt;</code>，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要，n是序号。</p><p>3）Prepare阶段<br>也就是Follow收到请求，但不知道其他节点请求是什么，就给收到的<strong>请求签名</strong>发给其他所有节点，告诉他们我收到了这样一个请求。</p><p>从节点接收到副本后，对副本进行校验和确认。检查副本中请求是否签名合法；检查d与m的摘要是否一致；检查当前视图编号是是否与副本v一致。满足这些条件后，从节点将副本存入消息日志中，然后对副本进行签名并转发给其他的所有节点（包括主节点）。如果不满足，则该验证节点就会进入View change阶段。</p><p>4）Commit阶段<br>也就是每个节点收到其他所有节点的签名请求，把这个合法请求跟自己之前保存的请求进行比较，如果超过有2f个请求一样，那么这个请求他会认为是大家共识的请求。然后对这个请求进行处理。</p><p>当前阶段所有节点，包括主节点，<strong>对接收到的签名副本进行签名验证和确认</strong>。签名验证通过后的副本与自己保存的副本进行比较，设和自己一样的副本个数记为 s，满足(自己+收到的副本) s+1&gt;= 2f，故障节点的个数为f，则该节点将会对这个请求进行响应，给予运算结果，并做签名。 2+1&gt;=2*1</p><p>5）Reply阶段<br>也就是将处理结果发送给客户端，客户端收到 f+1(=2)个一样结果，那么客户端会认为该结果正确。</p><p>每个收到请求的节点都会对请求进行响应处理，将结果广播给客户端。当客户端接收到 f+1的响应相同时，则会认为该响应就是请求的结果。</p><h5 id="2-验证确认协议："><a href="#2-验证确认协议：" class="headerlink" title="2.验证确认协议："></a>2.验证确认协议：</h5><p>在一致性协议使用时都用到了这个协议。在PBFT系统中，时刻保证数据的准确性，要进行数据校验和签名确认。对Lead的任何行为要进行监视，如果Lead有做越权或错误的事件，其他节点可以对其进行举报。</p><h5 id="3-视图更换协议：-更换主节点"><a href="#3-视图更换协议：-更换主节点" class="headerlink" title="3.视图更换协议：(更换主节点)"></a>3.视图更换协议：(更换主节点)</h5><p>此阶段主要是用户在设计PBFT系统时，<strong>对Lead节点权限的设定</strong>。</p><p>比如定时多长时间，正常更换Lead，其他Follow节点都有机会成为新的Lead。在Lead任期时期，如果超过2/3的节点反映它有问题，那么也会触发view change。还有Lead在运行中突然挂掉，也会触发view change。我们需要确保在新的view中如何来延续上一个view最终的状态，（比如给这时来的新请求的编号，还有如何处理上一个view还没来得及完全处理好的请求。）</p><h2 id="PBFT算法在公链中的应用"><a href="#PBFT算法在公链中的应用" class="headerlink" title="PBFT算法在公链中的应用"></a>PBFT算法在公链中的应用</h2><p>PBFT机制不需要挖矿，也不需要权益计算，所以通过它达成共识的时间会很快，为了提高公链的tps(每秒事务处理量(TransactionPerSecond))，将PBFT灵活改进并引入公链，和pow算法或pos相结合形成一套新的混合机制，非常明智。目前这样应用的公链比较多，我下边主要讲解初链（TrueChain）是怎么实现的。</p><p><strong>初链</strong>使用双链结构，即快链和慢链。运用PBFT和POW混合共识算法，前者生成快链，后者生成慢链。交易确认和挖矿是分开的。交易被打包后，通过PBFT委员会确认，生成fastBlock，此时交易已经得到确认；慢链将快链里的fastBlock打包成为一个snailBlock，经过矿工挖矿确认，实现上链。通过这种混合共识算法，tps得到很大的提升，达到3000左右，而且使用POW挖矿，实现了去中心化的思想。PBFT委员会每两天换届一次，候选委员都是POW挖矿成功后的矿工，保证了公平公正的原则。</p><p>虽然PBFT算法的设计初期是服务于私有链和公有链的，但是随着人们对它的不断改进和灵活使用，未来公链它将在共识机制中处于重要地位。</p><h2 id="Go语言实现一个网络交互的PBFT工程"><a href="#Go语言实现一个网络交互的PBFT工程" class="headerlink" title="Go语言实现一个网络交互的PBFT工程"></a>Go语言实现一个网络交互的PBFT工程</h2><p>工程思路：<br>1.开启4个终端，分别代表4个小国，开启http监听，监听路径有4个，分别是”/req”，”/prePrepare”, “/prepare”, “/commit”。<br>2.任意一个节点通过http网页发起请求；<br>3.该被请求节点会将数据写入自己的数组，然后并通过”/prePrepare”路径向其他节点广播该请求数据；<br>4.其他节点通过节点监听接收到请求数据，将请求数据写入自己的数组，并通过”/Prepare”路径向其他节点广播该请求数据；<br>5.所有节点将收到的数据进行校验，如果当前数组的长度大于所有节点个数的2/3，则输出OK，并将OK数据通过路径”/commit”广播给其他所有节点；<br>6.当节点收到OK数量达到所有节点个数的1/3，则就是最后的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明nodeInfo节点，代表各个小国家</span></span><br><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//节点名称</span></span><br><span class="line">    id <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//节点路径</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//http响应</span></span><br><span class="line">    writer http.ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map，存储各个国家的ip地址,也就是url</span></span><br><span class="line"><span class="keyword">var</span> nodeTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当http服务器，接收到网络请求并且/req 则回调request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">request</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">//该命令允许request请求参数</span></span><br><span class="line">    request.ParseForm()<span class="comment">//解析完毕，打包返回。所以该方法不需要返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.writer = writer</span><br><span class="line">        fmt.Println(<span class="string">"主节点接收到的参数信息为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment">//fmt.Println(request.Form["warTime"])打印出来是个数组，如果warTime=1111&amp;2222等等，等号后边的是数组，warTime是map的key</span></span><br><span class="line">        <span class="comment">//激活主节点后，向其他的节点发送广播</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prePrepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点发送广播的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">broadcast</span><span class="params">(msg <span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"广播"</span>, path)</span><br><span class="line">    <span class="comment">//遍历所有的节点</span></span><br><span class="line">    <span class="keyword">for</span> nodeId, url := <span class="keyword">range</span> nodeTable &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeId == node.id &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使当前节点以外的节点做响应</span></span><br><span class="line">        http.Get(<span class="string">"http://"</span> + url + path + <span class="string">"?warTime="</span> + msg + <span class="string">"&amp;nodeId="</span> + node.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理广播后接收到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prePrepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    fmt.Println(<span class="string">"接收到的广播为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收子节点的广播</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//打印消息</span></span><br><span class="line">    fmt.Println(<span class="string">"接收到的子节点的广播"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">2</span>/<span class="number">3</span>*<span class="built_in">len</span>(nodeTable) &#123;</span><br><span class="line">        node.authentication(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authenticationNodeMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> authenticationSuceess = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//校验拜占庭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">authentication</span><span class="params">(request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !authenticationSuceess &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"nodeId"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            authenticationNodeMap[request.Form[<span class="string">"nodeId"</span>][<span class="number">0</span>]] = <span class="string">"OK"</span></span><br><span class="line">            <span class="comment">//如果有两个国家节点正确的返回了结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(authenticationNodeMap) &gt; <span class="built_in">len</span>(nodeTable)/<span class="number">3</span> &#123;</span><br><span class="line">                authenticationSuceess = <span class="literal">true</span></span><br><span class="line">                node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/commit"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回成功响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">commit</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> writer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"拜占庭校验成功"</span>)</span><br><span class="line">        <span class="comment">//在网页上显示ok</span></span><br><span class="line">        io.WriteString(node.writer, <span class="string">"ok"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//接受终端参数</span></span><br><span class="line">    userId := os.Args[<span class="number">1</span>]</span><br><span class="line">    fmt.Println(userId)</span><br><span class="line">    <span class="comment">//存储4个国家的IP地址</span></span><br><span class="line">    nodeTable = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"Apple"</span>:  <span class="string">"localhost:1111"</span>,</span><br><span class="line">        <span class="string">"MS"</span>:     <span class="string">"localhost:1112"</span>,</span><br><span class="line">        <span class="string">"Google"</span>: <span class="string">"localhost:1113"</span>,</span><br><span class="line">        <span class="string">"IBM"</span>:    <span class="string">"localhost:1114"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建国家对象</span></span><br><span class="line">    node := nodeInfo&#123;id: userId, path: nodeTable[userId]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http协议的回调函数</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/req"</span>, node.request)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prePrepare"</span>, node.prePrepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prepare"</span>, node.prepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/commit"</span>, node.commit)</span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(node.path, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFT拜占庭容错系统</title>
      <link href="/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="BFT技术"><a href="#BFT技术" class="headerlink" title="BFT技术"></a>BFT技术</h3><p>BFT技术即拜占庭容错技术，是一类分布式计算领域的容错技术。名称拜占庭是一个泛指，它代表着计算机领域，在这个领域内会有很多问题，如硬件错误、网络拥堵或中断以及遭到恶意攻击等等，造成计算机网络可能出现的混乱。<strong>BFT技术就是为了使混乱状态达到一致性。</strong></p><a id="more"></a><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h2><p>BFT技术的由来源于一个叫拜占庭将军问题。<br>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都，由于当时拜占庭罗马帝国国土辽阔，每支军队的驻地分隔很远，将军们只能靠信使传递消息。发生战争时，将军们必须制订统一的行动计划。然而，这些将军中有叛徒，叛徒希望通过影响统一行动计划的制定与传播，破坏忠诚的将军们一致的行动计划。因此，将军们必须有一个预定的方法协议，使所有忠诚的将军能够达成一致，而且少数几个叛徒不能使忠诚的将军做出错误的计划。也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们能在一个有叛徒的非信任环境中建立对战斗计划的共识，拜占庭问题就此形成。</p><p>拜占庭将军问题（Byzantine Generals Problem），首先由Leslie Lamport与另外两人在1982年提出，很简单的故事模型，却困扰了计算机科学家们数十年。</p><p>我们将拜占庭将军问题简化一下，所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动；而形式化的要求就是，“一致性”与“正确性”。</p><p>一致性：每个忠诚的将军必须收到相同的命令值 <strong>vi</strong>（vi是第i个将军的命令）</p><p>正确性：如果第<strong>i</strong>个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的 <strong>vi</strong> 相同。</p><p>Lamport 对拜占庭将军的问题的研究表明，当 <strong>n &gt; 3m</strong> 时，即叛徒的个数 <strong>m</strong> 小于将军总数的 <strong>n</strong> 的 <strong>1/3</strong> 时，通过口头同步通信（假设通信是可靠的），可以构造同时满足“一致性”和“正确性”的解决方法，即将军们可以达成一致的命令。（叛徒个数=m，将军总数=n）m &lt; n * 1/3</p><h2 id="BFT理论算法"><a href="#BFT理论算法" class="headerlink" title="BFT理论算法"></a>BFT理论算法</h2><p>BFT即拜占庭容错系统，英文全称是<strong>Byzantine Fault Tolerance</strong>，是一种理论上解决拜占庭问题的方法，并非实用，不过基于BFT理论延伸出了其他共识机制。</p><p>区块链网络的记账共识和拜占庭将军的问题是相似的。参与共识记账的每一个节点相当于将军，节点之间的消息传递相当于信使，某些节点可能由于各种原因而产生错误的信息传递给其他节点。<strong>通常这些发生故障的节点被称为拜占庭节点，而正常的节点即为非拜占庭节点。</strong></p><p>假设分布式系统拥有n台节点，并假设整个系统拜占庭节点不超过m台（n ≥ 3m + 1），拜占庭容错系统需要满足如下<strong>两个条件</strong>：</p><pre><code>1. 所有非拜占庭节点使用相同的输入信息，产生同样的结果。在区块链系统中，可以理解为，随机数相同、区块算法相同、原账本相同的时候，计算结果相同。2. 如果输入的信息正确，那么所有非拜占庭节点必须接收这个消息，并计算相应的结果。在区块链系统中，可以理解为，非拜占庭节点需要对客户的请求进行计算并生成区块。</code></pre><p>另外，拜占庭容错系统需要达成如下<strong>两个指标</strong>：</p><pre><code>1. 安全性：任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。2. 活性：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。</code></pre><p>在分析拜占庭问题的时候，假设信道是可信的。拓展开来，在拜占庭容错系统，普遍采用的假设条件包括：</p><pre><code>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；节点之间的错误是不相关的；节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；节点之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和破坏信息的完整性。</code></pre><h2 id="Go语言简单实现BFT"><a href="#Go语言简单实现BFT" class="headerlink" title="Go语言简单实现BFT"></a>Go语言简单实现BFT</h2><p>模拟4个小国家攻打拜占庭，这4个国家要保证3个及以上同时攻打才能胜利。</p><p>思路：<br>1.创建4个节点，每个节点代表一个小国，我们用1代表打，0代表不打；<br>2.每个节点将自己的攻打意愿1或0分发给其他小国；<br>3.收到所有节点发送的消息后，将所有消息放在一个数组中；<br>4.每个节点遍历这个数组，如果数组中的0数量&lt;总数的1/3，那么返回一个true，表示攻打拜占庭可行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拜占庭理论的代码实现部分</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Status <span class="keyword">int</span><span class="comment">//1 代表去，０代表不去</span></span><br><span class="line">    Votes []*Node<span class="comment">//记录账本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存４个node</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">make</span>([]*Node,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNodes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A:=Node&#123;<span class="string">"A"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    B:=Node&#123;<span class="string">"B"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    C:=Node&#123;<span class="string">"C"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    D:=Node&#123;<span class="string">"D"</span>,<span class="number">0</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//不去</span></span><br><span class="line">    <span class="comment">//按照拜占庭的1/3理论，这次打仗是可行的</span></span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;A)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;B)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;C)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互相转达</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">votes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nodes);i++&#123;</span><br><span class="line">        node:=nodes[i]</span><br><span class="line">        <span class="comment">//可以将每个人的进攻状态获取出来</span></span><br><span class="line">        fmt.Println(node.Status)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此人的状态分发给其他人</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nodes);j++&#123;</span><br><span class="line">            inode := nodes[j]</span><br><span class="line">            node.Votes=<span class="built_in">append</span>(node.Votes,inode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次进攻是否可行，判断叛徒是否小于三分之一  cnt叛徒的个数小于总节点数的三分之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">//在数组中取出最后一个对象</span></span><br><span class="line">    node:=nodes[<span class="built_in">len</span>(nodes)<span class="number">-1</span>]</span><br><span class="line">    votes:=node.Votes</span><br><span class="line"></span><br><span class="line">    cnt:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,n :=<span class="keyword">range</span> votes &#123;</span><br><span class="line">        fmt.Println(n.Status)</span><br><span class="line">        <span class="keyword">if</span> n.Status == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cnt只有小于n/3的情况下，才能成功,拜占庭</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">float32</span>(cnt) &lt; <span class="keyword">float32</span>(<span class="built_in">len</span>(nodes))/<span class="keyword">float32</span>(<span class="number">3.0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    createNodes()</span><br><span class="line">    votes()</span><br><span class="line">    fmt.Println(isValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPOS股权授权证明</title>
      <link href="/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h1><h2 id="什么是-DPoS"><a href="#什么是-DPoS" class="headerlink" title="什么是 DPoS"></a>什么是 DPoS</h2><p>DPoS即股份授权证明，英文全称是<code>Delegated Proof of Stake</code>。它是PoS算法的改造版。<br>最早于2013年由比特股Bitshares提出，目的为解决PoW和PoS机制的不足。</p><a id="more"></a><h2 id="DPoS-基本原理"><a href="#DPoS-基本原理" class="headerlink" title="DPoS 基本原理"></a>DPoS 基本原理</h2><p>PoS解决了PoW的算力问题，但是依据权益结余来选择出块者，会导致首富账户的权力更大，有可能支配记账权。为改善这种中心化的负面影响，DPoS引进了代理人机制，类似于人民代表选举，被选举者就是这里的代理人。代理人是由所有持币者根据自己的意愿选出来的，他理论上能够代表大众的权益。以eos为例，它有21个超级节点，每个节点都是持币人选举出来的。</p><p>一般选举过程是这样的，首先设立一个评审委员会，全球所有节点都可以报名参加，报名的前提是交纳保证金，通过审核的最为满足条件的前N个节点将作为候选节点，进入下一轮，也就是竞选阶段。这些候选节点会将会各种演说游说其他的持币人，让他们给自己投票，这里可能场外会给投票人某些好处。<strong>最终投票总数前m名的候选节点成为公链的代理人，负责出块。每次出块时，系统会随机顺序挑选指定某个代理人出块。</strong> 每次选举出来的代理人都有任期，任期期间如果被监管发现某些作恶行为将会被追责和卸任。</p><p>代理人的职责主要有：</p><p><strong>1.提供一台服务器节点，保证节点的正常运行；</strong><br><strong>2.节点服务器收集网络里的交易；</strong><br><strong>3.节点验证交易，把交易打包到区块；</strong><br><strong>4.节点广播区块，其他节点验证后把区块添加到自己的数据库；</strong><br><strong>5.带领并促进区块链项目的发展；</strong></p><p>代理人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>普通节点不能直接参与出块，利益何在？<br>每个节点都有自己的选举权和监督权，对代理人的行为进行监视，保证链的正常运行。链稳定了，持币人在生态中的操作才能安心。同时，tps的速度快了，在链上的交易秒级可以实现，使持币人感受到了极大的方便。整个链的生态如果因为良好的运行，会吸引更多的人或应用加入，使币的价格升值，持币人当然开心。当然这些都是理想情况下，在实际中很难得以实现。</p><h3 id="DPoS的伪代码实现"><a href="#DPoS的伪代码实现" class="headerlink" title="DPoS的伪代码实现"></a>DPoS的伪代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点 授权</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure><h3 id="DPoS-运行机制"><a href="#DPoS-运行机制" class="headerlink" title="DPoS 运行机制"></a>DPoS 运行机制</h3><p>DPoS 的运作机制如下：</p><ol><li><p>所有持币者先选出代理人负责签署区块：选举过程比较类似由股东会选举出董事会（101人代表），代替股东会做出日常营运决策。授权董事会后，决策会更有效率 （相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。）</p></li><li><p>与PoW相同，DPoS的规则也是最长链胜出。其中每个受托人必须按照生产排程，轮流产生区块，拿一间工厂作为比方，假设排程排定A、Ｂ、Ｃ分别轮早、中、晚班生产，Ａ在晚上是无法刷门禁卡进入厂房生产的，同样地，C在早班时段也是无法进厂房的。</p><p><img src="http://image.chaindesk.cn/DPOS01.png/mark" alt="img"></p></li><li><p>今天有一些恶意的节点生产了分叉区块，假设Ａ、Ｃ都是诚实的节点，只有B节点是恶意的，由于B产生区块的速度（每9秒只能产生1个）慢于A、Ｃ合力产生区块的速度（每9秒产生2个），根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS2.png/mark" alt="img"></p></li><li><p>同理，因为一个节点要产生重复两个区块的速度必定慢于诚实区块产生的速度，所以根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS3.png/mark" alt="img"></p></li><li><p>如果今天A、Ｂ、Ｃ三个代理人的网络有段时间是碎片化、各自为政的呢？在短期内的确有可能三链并行，但一旦网络连结恢复，短链自然会向最长的链回归。</p><p><img src="http://image.chaindesk.cn/DPOS4.png/mark" alt="img"></p></li></ol><p><strong>因为代理可签署人数为奇数，所以两大派系势均力敌僵持不下的情况不会维持太久，最终势必会有其中一方的链更长。</strong></p><h2 id="DPoS的优缺点"><a href="#DPoS的优缺点" class="headerlink" title="DPoS的优缺点"></a>DPoS的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li><li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li><li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li><li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li></ol><h3 id="知名-DPoS-项目"><a href="#知名-DPoS-项目" class="headerlink" title="知名 DPoS 项目"></a><strong>知名 DPoS 项目</strong></h3><p>1.Bitshares</p><p>最早应用DPoS机制的项目，其DPoS机制里包含见证人(Witnesses)和代理人(Delegates)， 见证人负责区块的打包，代理人负责系统参数的修改和出块。</p><p>2.EOS</p><p>共识算法我DPoS + BFT， 有21个代理人。</p><p>3.Asch</p><p>共识算法为DPoS + PBFT， 有101个代理人。</p><h2 id="用Go实现一个简单的DPOS项目"><a href="#用Go实现一个简单的DPOS项目" class="headerlink" title="用Go实现一个简单的DPOS项目"></a>用Go实现一个简单的DPOS项目</h2><p>通过这个简易的项目，让大家对DPOS的工作加深下了解。<br>工程思路：<br>1.手动创建一个数组，将里面的元素作为代理人<br>2.每30秒将代理人的顺序随机打乱1次<br>3.乱序后的委员会将顺序出块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//DPoS原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="keyword">int</span></span><br><span class="line">    PreHash <span class="keyword">string</span></span><br><span class="line">    HashCode <span class="keyword">string</span></span><br><span class="line">    BMP <span class="keyword">int</span></span><br><span class="line">    validator <span class="keyword">string</span></span><br><span class="line">    TimeStamp <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块链</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNextBlock</span><span class="params">(oldBlock Block,BMP <span class="keyword">int</span> ,adds <span class="keyword">string</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.PreHash = oldBlock.HashCode</span><br><span class="line">    newBlock.BMP = BMP</span><br><span class="line">    newBlock.TimeStamp = time.Now().String()</span><br><span class="line">    newBlock.validator = adds</span><br><span class="line">    newBlock.HashCode = GenerateHashValue(newBlock)</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生区块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHashValue</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hashCode = block.PreHash+block.validator+block.TimeStamp+</span><br><span class="line">        strconv.Itoa(block.Index)+strconv.Itoa(block.BMP)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sha = sha256.New()</span><br><span class="line">    sha.Write([]<span class="keyword">byte</span>(hashCode))</span><br><span class="line">    hashed:=sha.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放代理人,存放delegete的地址信息</span></span><br><span class="line"><span class="keyword">var</span> delegate =[]<span class="keyword">string</span>&#123;<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"dddd"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机委托人的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandDelegate</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> r = rand.Intn(<span class="number">3</span>)</span><br><span class="line">    t:=delegate[r]</span><br><span class="line">    delegate[r]=delegate[<span class="number">3</span>]</span><br><span class="line">    delegate[<span class="number">3</span>]=t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(delegate)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创世区块</span></span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,firstBlock)</span><br><span class="line">    <span class="comment">//通过n按顺序让delegate作为矿工</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    ch1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag:&lt;-ch1</span><br><span class="line">        count:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//每间隔3秒产生新的区块，通过count记录睡眠次数</span></span><br><span class="line">            count++</span><br><span class="line">            time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">            <span class="comment">//轮到的节点进行出块</span></span><br><span class="line">            <span class="keyword">var</span> nextBlock = GenerateNextBlock(firstBlock,<span class="number">1</span>,delegate[n])</span><br><span class="line">            n++</span><br><span class="line">            n=n%<span class="built_in">len</span>(delegate)</span><br><span class="line">            firstBlock = nextBlock</span><br><span class="line">            <span class="comment">//上链</span></span><br><span class="line">            Blockchain = <span class="built_in">append</span>(Blockchain,nextBlock)</span><br><span class="line">            fmt.Println(Blockchain)</span><br><span class="line">            fmt.Println(count)</span><br><span class="line">            <span class="comment">//每30秒将代理人顺序打乱一次</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">10</span>&#123;</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">                ch2&lt;-<span class="literal">true</span></span><br><span class="line">                <span class="keyword">goto</span> flag</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; ;  &#123;</span><br><span class="line"></span><br><span class="line">        RandDelegate()</span><br><span class="line">        fmt.Println(<span class="string">"更换顺序后的代理人"</span>,delegate)</span><br><span class="line">        ch1&lt;-<span class="literal">true</span></span><br><span class="line">        &lt;-ch2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS代码实现</title>
      <link href="/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="用go语言实现一个POS共识机制"><a href="#用go语言实现一个POS共识机制" class="headerlink" title="用go语言实现一个POS共识机制"></a>用go语言实现一个POS共识机制</h1><h2 id="POS工程简述"><a href="#POS工程简述" class="headerlink" title="POS工程简述"></a>POS工程简述</h2><p>在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。</p><a id="more"></a><h2 id="实现-POS-主要功能点"><a href="#实现-POS-主要功能点" class="headerlink" title="实现 POS 主要功能点"></a>实现 POS 主要功能点</h2><ul><li>我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器</li><li>最新的区块链状态将定期广播到每个节点</li><li>每个节点都能提议建立新的区块</li><li>基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中</li></ul><h2 id="实现-POS"><a href="#实现-POS" class="headerlink" title="实现 POS"></a>实现 POS</h2><h3 id="设置-TCP-服务器的端口"><a href="#设置-TCP-服务器的端口" class="headerlink" title="设置 TCP 服务器的端口"></a>设置 TCP 服务器的端口</h3><p>新建 <code>.env</code>，添加如下内容 <code>PORT=9000</code></p><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/davecgh/<span class="keyword">go</span>-spew/spew</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> get github.com/joho/godotenv</span><br></pre></td></tr></table></figure><ul><li><code>spew</code> 在控制台中格式化输出相应的结果。</li><li><code>godotenv</code> 可以从我们项目的根目录的 <code>.env</code> 文件中读取数据。</li></ul><h3 id="引入相应的包"><a href="#引入相应的包" class="headerlink" title="引入相应的包"></a>引入相应的包</h3><p>新建 <code>main.go</code>，引入相应的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">    <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents each 'item' in the blockchain</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span></span><br><span class="line">    Timestamp <span class="keyword">string</span></span><br><span class="line">    BPM       <span class="keyword">int</span></span><br><span class="line">    Hash      <span class="keyword">string</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span></span><br><span class="line">    Validator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blockchain is a series of validated Blocks</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"><span class="keyword">var</span> tempBlocks []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// candidateBlocks handles incoming blocks for validation</span></span><br><span class="line"><span class="keyword">var</span> candidateBlocks = <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// announcements broadcasts winning validator to all nodes</span></span><br><span class="line"><span class="keyword">var</span> announcements = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validators keeps track of open validators and balances</span></span><br><span class="line"><span class="keyword">var</span> validators = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ul><li><code>Block</code> 是每个区块的内容</li><li><code>Blockchain</code> 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 <code>PrevHash</code> 与前面块的 <code>Hash</code> 相比较，以确保我们的链是正确的。 <code>tempBlocks</code> 是临时存储单元，在区块被选出来并添加到 <code>BlockChain</code> 之前，临时存储在这里</li><li><code>candidateBlocks</code> 是 <code>Block</code> 的通道，任何一个节点在提出一个新块时都将它发送到这个通道</li><li><code>announcements</code> 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链</li><li><code>mutex</code>是一个标准变量，允许我们控制读/写和防止数据竞争</li><li><code>validators</code> 是节点的存储map，同时也会保存每个节点持有的令牌数</li></ul><h3 id="生成区块"><a href="#生成区块" class="headerlink" title="生成区块"></a>生成区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateBlock</code> 是用来创建新块的。<br><code>newBlock.PrevHash</code> 存储的是上一个区块的 <code>Hash</code><br><code>newBlock.Hash</code> 是通过 <code>calculateBlockHash(newBlock)</code> 生成的 Hash 。<br><code>newBlock.Validator</code> 存储的是获取记账权的节点地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SHA256 hasing</span></span><br><span class="line"><span class="comment">// calculateHash is a simple SHA256 hashing function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculateBlockHash returns the hash of all block information</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateHash</code> 函数会接受一个 <code>string</code> ，并且返回一个<code>SHA256 hash</code> 。</p><p><code>calculateBlockHash</code> 是对一个 <code>block</code> 进行 <code>hash</code>，将一个 <code>block</code> 的所有字段连接到一起后，再调用 <code>calculateHash</code> 将字符串转为 <code>SHA256 hash</code> 。</p><h3 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h3><p>我们通过检查 <code>Index</code> 来确保它们按预期递增。我们也检查以确保我们 <code>PrevHash</code> 的确与 <code>Hash</code> 前一个区块相同。最后，我们希望通过在当前块上 <code>calculateBlockHash</code> 再次运行该函数来检查当前块的散列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isBlockValid makes sure block is valid by checking index</span></span><br><span class="line"><span class="comment">// and comparing the hash of the previous block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculateBlockHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：</p><ul><li>输入令牌的余额（之前提到过，我们不做钱包等逻辑)</li><li>接收区块链的最新广播</li><li>接收验证者赢得区块的广播信息</li><li>将自身节点添加到全局的验证者列表中（validators)</li><li>输入Block的BPM数据- BPM是每个验证者的人体脉搏值</li><li>提议创建一个新的区块</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            msg := &lt;-announcements</span><br><span class="line">            io.WriteString(conn, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 验证者地址</span></span><br><span class="line">    <span class="keyword">var</span> address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权</span></span><br><span class="line">    io.WriteString(conn, <span class="string">"Enter token balance:"</span>)</span><br><span class="line">    scanBalance := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> scanBalance.Scan() &#123;</span><br><span class="line">        <span class="comment">// 获取输入的数据，并将输入的值转为 int</span></span><br><span class="line">        balance, err := strconv.Atoi(scanBalance.Text())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"%v not a number: %v"</span>, scanBalance.Text(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        <span class="comment">// 生成验证者的地址</span></span><br><span class="line">        address = calculateHash(t.String())</span><br><span class="line">        <span class="comment">// 将验证者的地址和token 存储到 validators</span></span><br><span class="line">        validators[address] = balance</span><br><span class="line">        fmt.Println(validators)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line"></span><br><span class="line">    scanBPM := bufio.NewScanner(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// take in BPM from stdin and add it to blockchain after conducting necessary validation</span></span><br><span class="line">            <span class="keyword">for</span> scanBPM.Scan() &#123;</span><br><span class="line">                bpm, err := strconv.Atoi(scanBPM.Text())</span><br><span class="line">                <span class="comment">// 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"%v not a number: %v"</span>, scanBPM.Text(), err)</span><br><span class="line">                    <span class="built_in">delete</span>(validators, address)</span><br><span class="line">                    conn.Close()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                oldLastIndex := Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的区块，然后将其发送到 candidateBlocks 通道</span></span><br><span class="line">                newBlock, err := generateBlock(oldLastIndex, bpm, address)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Println(err)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> isBlockValid(newBlock, oldLastIndex) &#123;</span><br><span class="line">                    candidateBlocks &lt;- newBlock</span><br><span class="line">                &#125;</span><br><span class="line">                io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环会周期性的打印出最新的区块链信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Minute)</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        output, err := json.Marshal(Blockchain)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(conn, <span class="keyword">string</span>(output)+<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>io.WriteString(conn, &quot;Enter token balance:&quot;)</code>允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 <code>SHA256</code>地址，随后该验证者地址和验证者的令牌数被添加到验证者列表<code>validators</code> 中。</li><li>接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑</li><li><code>delete(validators, address)</code> 如果验证者试图提议一个被污染（例如伪造）的 <code>block</code>，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 <code>validators</code> 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</li><li>正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。</li><li>接着，我们用 <code>generateBlock</code> 函数创建一个新的 <code>block</code>，然后将其发送到 <code>candidateBlocks</code> 通道进行进一步处理。将<code>Block</code> 发送到通道使用的语法: <code>candidateBlocks &lt;- newBlock</code></li><li>最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。</li></ul><h3 id="选择获取记账权的节点"><a href="#选择获取记账权的节点" class="headerlink" title="选择获取记账权的节点"></a>选择获取记账权的节点</h3><p>下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain</span></span><br><span class="line"><span class="comment">// by random selecting from the pool, weighted by amount of tokens staked</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickWinner</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    temp := tempBlocks</span><br><span class="line">    mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    lotteryPool := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slightly modified traditional proof of stake algorithm</span></span><br><span class="line">        <span class="comment">// from all validators who submitted a block, weight them by the number of staked tokens</span></span><br><span class="line">        <span class="comment">// in traditional proof of stake, validators can participate without submitting a block to be forged</span></span><br><span class="line">    OUTER:</span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="comment">// if already in lottery pool, skip</span></span><br><span class="line">            <span class="keyword">for</span> _, node := <span class="keyword">range</span> lotteryPool &#123;</span><br><span class="line">                <span class="keyword">if</span> block.Validator == node &#123;</span><br><span class="line">                    <span class="keyword">continue</span> OUTER</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock list of validators to prevent data race</span></span><br><span class="line">            mutex.Lock()</span><br><span class="line">            setValidators := validators</span><br><span class="line">            mutex.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取验证者的tokens</span></span><br><span class="line">            k, ok := setValidators[block.Validator]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">// 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens</span></span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">                    lotteryPool = <span class="built_in">append</span>(lotteryPool, block.Validator)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过随机获得获胜节点的地址</span></span><br><span class="line">        s := rand.NewSource(time.Now().Unix())</span><br><span class="line">        r := rand.New(s)</span><br><span class="line">        lotteryWinner := lotteryPool[r.Intn(<span class="built_in">len</span>(lotteryPool))]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息</span></span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="keyword">if</span> block.Validator == lotteryWinner &#123;</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, block)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                <span class="keyword">for</span> _ = <span class="keyword">range</span> validators &#123;</span><br><span class="line">                    announcements &lt;- <span class="string">"\nwinning validator: "</span> + lotteryWinner + <span class="string">"\n"</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    tempBlocks = []Block&#123;&#125;</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个<code>lotteryPool</code>，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过<code>if len(temp) &gt; 0</code>来判断是否已经有了被提议的区块。</li><li>在<code>OUTER FOR</code>循环中，要检查暂存区域是否和 <code>lotteryPool</code> 中存在同样的验证者，如果存在，则跳过。</li><li>在以 <code>k, ok := setValidators[block.Validator]</code>开始的代码块中，我们确保了从<code>temp</code>中取出来的验证者都是合法的，即这些验证者在验证者列表<code>validators</code>已存在。若合法，则把该验证者加入到<code>lotteryPool</code>中。</li><li>那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？<ul><li>首先，用验证者的令牌填充<code>lotteryPool</code>数组，例如一个验证者有100个令牌，那么在<code>lotteryPool</code>中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。</li><li>然后，从<code>lotteryPool</code>中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。</li></ul></li><li>接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：<code>announcements &lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot;</code>。</li><li>最后，清空tempBlocks，以便下次提议的进行。</li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := godotenv.Load()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始区块</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    genesisBlock := Block&#123;&#125;</span><br><span class="line">    genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateBlockHash(genesisBlock), <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">    spew.Dump(genesisBlock)</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line"></span><br><span class="line">    httpPort := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务</span></span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+httpPort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"HTTP Server Listening on port :"</span>, httpPort)</span><br><span class="line">    <span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> candidate := <span class="keyword">range</span> candidateBlocks &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            tempBlocks = <span class="built_in">append</span>(tempBlocks, candidate)</span><br><span class="line">            mutex.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 完成 pickWinner 函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            pickWinner()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收验证者节点的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>godotenv.Load()</code> 会解析 <code>.env</code> 文件并将相应的Key/Value对都放到环境变量中，通过 <code>os.Getenv</code> 获取</li><li>然后创建一个创世区块genesisBlock，形成了区块链。</li><li>接着启动了Tcp服务，等待所有验证者的连接。</li><li>启动了一个Go协程从 <code>candidateBlocks</code> 通道中获取提议的区块，然后填充到临时缓冲区 <code>tempBlocks</code> 中，最后启动了另外一个Go协程来完成 <code>pickWinner</code> 函数。</li><li>最后的for循环，用来接收验证者节点的连接。</li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>go run main.go</code> 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">(main.Block) &#123;</span><br><span class="line"> Index: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Timestamp: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">50</span>) <span class="string">"2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793"</span>,</span><br><span class="line"> BPM: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Hash: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">64</span>) <span class="string">"96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7"</span>,</span><br><span class="line"> PrevHash: (<span class="keyword">string</span>) <span class="string">""</span>,</span><br><span class="line"> Validator: (<span class="keyword">string</span>) <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">27</span> HTTP Server Listening on port : <span class="number">9000</span></span><br></pre></td></tr></table></figure><p>打开新的终端，运行 <code>nc localhost 9000</code>，<br>输入 <code>tokens</code> , 然后输入 <code>BPM</code></p><p>可以打开多个终端，输入不同的 <code>tokens</code> ,来检验 PoS 算法</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW+POS混合公式算法</title>
      <link href="/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-POS混合共识算法"><a href="#POW-POS混合共识算法" class="headerlink" title="POW+POS混合共识算法"></a>POW+POS混合共识算法</h3><p>上一章节说过，实际运用pos是需要借助其他算法才能实现的。本章节主要学习点点币的共识算法，该算法是基于POW改进的POS算法。</p><a id="more"></a><h2 id="混合共识算法的定义"><a href="#混合共识算法的定义" class="headerlink" title="混合共识算法的定义"></a>混合共识算法的定义</h2><p>现在很多公链都是在用基于xx和xx算法的混合共识算法实现共识机制的。什么是混合共识算法呢？<br>有两种情况都可以认为是混合机制：<br>1.在某个算法的基础上，运用其他算法的技术进行改进。如点点币，它的共识机制是用pos算法对pow算法进行改进后的机制，不过大家往往认为点点币的共识机制是pos，其实严格来说是pow+pos的。<br>2.两个算法运算相互独立，但共同组成了一个共识机制。如初链，它的共识是pow和pbft两个算法组成的，然后自己给自己起了个新名字叫混合共识机制fpow。这种混合很明显，所以大家都会叫混合机制。</p><h2 id="混合共识机制POW-POS"><a href="#混合共识机制POW-POS" class="headerlink" title="混合共识机制POW+POS"></a>混合共识机制POW+POS</h2><p>点点币是第一个基于POS发行的数字货币，所以接下来我将带大家深入学习它的共识算法，加深对POS的理解。</p><p>与PoW一样，为了抢到将区块写入区块链的权利，节点同样要进行hash计算，只不过最终的解和币龄有关，计算公式：<br>proofHash &lt; coinAge * target；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coinAge是币龄，target是一个目标值，用于调整难度。coinAge * target的值越大，难度就越小，抢到区块的概率就越高。</span><br></pre></td></tr></table></figure><p>假如你的钱包里是0个币，那么你的币龄就是0, 计算一个小于0的hash值根本不可能，因此基本上抢不到区块。<br>点点币的出块时间也是10分钟左右一个。币龄之前讲过，就是持币数*持币时间；proofHash也就是pow的挖矿函数，即两次sha256 hash运算。所以重点我们要学习target的值是怎么实现的，怎么调整使出块时间在10分钟左右呢？</p><h2 id="点点币的目标值"><a href="#点点币的目标值" class="headerlink" title="点点币的目标值"></a>点点币的目标值</h2><p>点点币难度值是一个一直动态调整的，每隔2个区块就调整一次难度（目标值），使出块时间维持在10分钟左右。<br>点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。<br>计算公式如下：</p><p>　<code>当前区块目标值 = 前一个区块目标值 * (1007 * 10 * 60 + 2 * 前两个区块时间间隔) / (1009 * 10 * 60)</code><br>由公式可见，两个区块目标间隔时间即为10分钟。<br>如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。<br>反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。<br><code>点点币的挖矿难度值=创始区块目标值/当前区块目标值</code>。网页中显示的当前块难度值就是这样算出来的。</p><p>挖矿过程和pow一样，需要比较hash值与目标值大小，广播区块，验证区块，上链等等。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS权益证明</title>
      <link href="/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>通过本章节，大家一起学习单纯的pos是什么机制，以及如何工作的。它较pow有什么优缺点。</p><h2 id="POS概述"><a href="#POS概述" class="headerlink" title="POS概述"></a>POS概述</h2><p>POS即权益证明，英文全称Proof of Stake。它是由匿名极客<code>Sunny King</code>发明的。<code>Sunny King</code>很神秘，类似中本聪，他的具体信息很少有人知道。同时他也是点点币（PPCoin）和质数币（PrimeCoin）的创始人。2012年点点币问世，成为全球首次使用POS共识机制的数字货币。</p><a id="more"></a><p>基于POW的公链挖矿纯靠算力，挖矿难度越高，算力也会越来越中心化。目前比特币挖矿的算力超过70%在中国，据<code>Blockchain.info</code>2018年的统计数据显示，目前世界前十大矿池中，中国独占8家，而中国70%的算力在四川。这样完全背离了去中心化的思想，只有算力高的机构或矿场才能挖到区块，而算力低的个人几乎没有可能挖到区块。算力低的矿工要是参与挖矿，那得赔死，投入电费、场地、矿机等等，结果几乎甚至没有收益。然后他们大部分会放弃挖矿或加入其他大型矿池。而且挖矿代币价格的较大波动也会影响挖矿收益。所以POW类型的挖矿具有很大的投资风险。POW挖矿比拼的就是算力，随着挖矿难度的提高，算力会要求越来越高，导致参与挖矿的矿机数量越来越多，配置也越来越高，如此会造成多大的资源浪费啊。</p><p>针对POW的问题，POS指出了一个全新的概念-币龄，币龄 = 持有的币数 * 持有币的天数，例如钱包里有90个点点币，持有了10天，则币龄=900。决定下一个区块是由谁出，是看当前时刻谁的币龄大。出块后币龄归零，重新计时持币时间。币龄是对应账户恒定数量持币数的值，如果账户的持币数量发生变化，那么币龄也会归零，重新计时。通过币龄来决定出块，不再需要比拼算力，多么环保啊，节省了多少资源啊。</p><p>而且为了让持币人把币握住，不乱抛售，POS还使用了“利息”机制。用户的持币钱包或客户端24小时处于工作状态或后台运行状态，其实就是pos的挖矿状态，系统会在固定时间参照币龄给予持币人一定量的利息（一定量的币）。如此币的抛售将不会像传统的币那么频繁，币价相应的也会稳定。</p><p>POS出块时间可以设为恒定值，如10分钟一个块，那么每10分钟，会触发记账功能。</p><p>为了让POS出块人带有随机性，需要借助一些随机函数，币龄只是增加成为出块者可能性的筹码。如，A的币龄100，B的币龄10，那么A能够出块的概率要比B大10倍。</p><p>使用POS较POW更不容易遭受51%攻击，相比起掌握系统一半以上的算力，拥有整个系统51%的财力会更加困难。</p><p>POS解决或者缓解了POW的一些问题，但是它也有它的很大缺点：</p><pre><code>1.更容易被垄断：因为持币越多，持有的越久，币龄就越高，越容易挖到区块并得到激励，持币少的人基本上没有机会，这样整个系统的安全性实际上会被持币数量较大的一部分人（大股东们）掌握；而POW理论上则不存在这个问题，因为理论上任何人都可以购买矿机获得提高自己的算力（甚至可以联合起来），提升自己挖矿成功的概率；2.很难应对分叉的情况：当出现分叉时，PoS可以在两条链上同时挖矿并获得收益。而PoW则不存在这个问题，因为当出现分叉以后，PoW总是选择工作量大的链做为主链。</code></pre><p>但是在实际应用中，纯POS的共识机制是不可行的，通常会和POW混合一起用或者通过POS升级改进POW。这样会更好的发挥各自的优点，减小双方缺点带来的影响。</p><p>根据masternodes.online的数据显示，目前基于POS算法的币种数量已有330，但是市值在2000万美金以上的只有9种，分别是DASH、PIVX、SYS、BLOCK、XZC、SMART、XSN、PAC、DEV。其中，市值最高的为DASH，目前为21.57亿美元，POS年化收益约为7.19%；XZC市值9805万美元，POS年化收益约为27.28%。</p><h2 id="Go实现一个纯POS机制的简单挖矿"><a href="#Go实现一个纯POS机制的简单挖矿" class="headerlink" title="Go实现一个纯POS机制的简单挖矿"></a>Go实现一个纯POS机制的简单挖矿</h2><p>设计思路：<br>1.有两个挖矿节点，分别持有的币为10个和5个，持币时间为1 。所以他们的币龄也就是10和5 。<br>2.创建一个长度为15的数组，分别将两个节点的账户地址按照比例布满这个数组。<br>3.选择一个从0到14的随机数，将该随机数作为2步数组的下表，找到该下表下的挖矿地址。<br>4.挖矿地址确认后，通过方法产生区块。<br>5.将区块上链，这里的区块链我们定义了一个切片。上链过程就是append过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个块结构体</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span>  <span class="comment">//区块高度</span></span><br><span class="line">    Timestamp <span class="keyword">string</span> <span class="comment">//时间戳，也就是当前时间转换成字符串</span></span><br><span class="line">    BPM       <span class="keyword">int</span>   <span class="comment">//要保存的上链数据</span></span><br><span class="line">    Hash      <span class="keyword">string</span>  <span class="comment">//当前区块hash值</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span>  <span class="comment">//父区块hash值</span></span><br><span class="line">    Validator <span class="keyword">string</span>  <span class="comment">//当前区块出块人的账户地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个区块链，类型是切片。也就是将区块放在这个切片里面</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出块函数，也就是当随机抽中哪个账户后，该账户就会作为该区块的参数，生成一个最新区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成区块过程就是给区块的字段赋值</span></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最新区块</span></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256算法计算当前区块的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将区块字段拼接，为生成hash函数做准备</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//持币人信息</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在参与挖矿的币总数为15个，我们认为现在是平等机会的15个持币1个的矿工。</span></span><br><span class="line"><span class="comment">//声明一个数组保存15个账户地址</span></span><br><span class="line"><span class="comment">//两个节点参与挖矿</span></span><br><span class="line"><span class="keyword">var</span> N[<span class="number">15</span>] <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> p [<span class="number">2</span>] Node</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给两个挖矿节点赋值</span></span><br><span class="line">    p[<span class="number">0</span>]=Node&#123;<span class="number">10</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">    p[<span class="number">1</span>]=Node&#123;<span class="number">5</span>,<span class="string">"bcd"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下边的for循环，按照两个节点他们的持币数，分别将他们的地址赋值到之前定义好的账户地址数组中。</span></span><br><span class="line">    <span class="comment">//可以看出，前10个账户都是p[0]的；后边5个是p[1]的</span></span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;p[i].tokens;j++&#123;</span><br><span class="line"></span><br><span class="line">            N[cnt] = p[i].address</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据随机数种子产生的随机数，找到矿工的地址，然后出块  （0~14）随机数</span></span><br><span class="line">    <span class="comment">//（拥有10个币上链的概率为10/15，拥有5个币上链概率为5/15，rand.Intn(cnt)找到地址   其中有10个是拥有10个币的地址，5个事拥有5个币的地址）</span></span><br><span class="line">    <span class="keyword">var</span> b,_ = generateBlock(firstBlock,<span class="number">10</span>,N[rand.Intn(cnt)])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的区块放到区块链上。</span></span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(Blockchain)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW代码实现</title>
      <link href="/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="用go语言实现一个pow共识工程"><a href="#用go语言实现一个pow共识工程" class="headerlink" title="用go语言实现一个pow共识工程"></a>用go语言实现一个pow共识工程</h3><a id="more"></a><h2 id="1-1-项目代码结构"><a href="#1-1-项目代码结构" class="headerlink" title="1.1 项目代码结构"></a>1.1 项目代码结构</h2><p><img src="http://img.kongyixueyuan.com/0301_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png/mark" alt="img"></p><h2 id="1-2-项目运行结果"><a href="#1-2-项目运行结果" class="headerlink" title="1.2 项目运行结果"></a>1.2 项目运行结果</h2><p><img src="http://img.kongyixueyuan.com/0302_%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif/mark" alt="img"></p><h2 id="1-3-完整代码"><a href="#1-3-完整代码" class="headerlink" title="1.3 完整代码"></a>1.3 完整代码</h2><p>Block.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//1. 区块高度</span></span><br><span class="line">    Height <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//2. 上一个区块HASH</span></span><br><span class="line">    PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//3. 交易数据</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//4. 时间戳</span></span><br><span class="line">    Timestamp <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//5. Hash</span></span><br><span class="line">    Hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 6. Nonce</span></span><br><span class="line">    Nonce <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建新的区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建区块</span></span><br><span class="line">    block := &amp;Block&#123;height,prevBlockHash,[]<span class="keyword">byte</span>(data),time.Now().Unix(),<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用工作量证明的方法并且返回有效的Hash和Nonce</span></span><br><span class="line">    pow := NewProofOfWork(block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挖矿验证</span></span><br><span class="line">    hash,nonce := pow.Run()</span><br><span class="line"></span><br><span class="line">    block.Hash = hash[:]</span><br><span class="line">    block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 单独写一个方法，生成创世区块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBlock(data,<span class="number">1</span>, []<span class="keyword">byte</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlockChain.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">    Blocks []*Block  <span class="comment">// 存储有序的区块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加区块到区块链里面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blc *Blockchain)</span> <span class="title">AddBlockToBlockchain</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,preHash []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 创建新区块</span></span><br><span class="line">    newBlock := NewBlock(data,height,preHash)</span><br><span class="line">    <span class="comment">// 往链里面添加区块</span></span><br><span class="line">    blc.Blocks = <span class="built_in">append</span>(blc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建带有创世区块的区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockchainWithGenesisBlock</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建创世区块</span></span><br><span class="line">    genesisBlock := CreateGenesisBlock(<span class="string">"Genesis Data......."</span>)</span><br><span class="line">    <span class="comment">// 返回区块链对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProofOfWork.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 1001 0001 0000 .... 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 256位Hash里面前面至少要有16个零</span></span><br><span class="line"><span class="keyword">const</span> targetBit  = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash nil</span></span><br><span class="line"><span class="comment">//256位</span></span><br><span class="line"><span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 二进制表示 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 2 的 32 - 8 次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    Block *Block <span class="comment">// 当前要验证的区块</span></span><br><span class="line">    <span class="comment">// 0000 0001 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">    target *big.Int <span class="comment">// 大数据存储 2^24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面必须有8个零</span></span><br><span class="line"><span class="comment">// 0000 0000 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0001</span></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0000 0000 0000 1111 111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拼接，返回字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            pow.Block.PrevBlockHash,</span><br><span class="line">            pow.Block.Data,</span><br><span class="line">            IntToHex(pow.Block.Timestamp),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(targetBit)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(pow.Block.Height)),</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.proofOfWork.Block.Hash</span></span><br><span class="line">    <span class="comment">//2.proofOfWork.Target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int</span><br><span class="line">    <span class="comment">// []byte 转 Int</span></span><br><span class="line">    hashInt.SetBytes(proofOfWork.Block.Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">    <span class="comment">//    0 if x == y</span></span><br><span class="line">    <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">    <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>,<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 将Block的属性拼接成字节数组</span></span><br><span class="line">    <span class="comment">//2. 生成hash</span></span><br><span class="line">    <span class="comment">//3. 判断hash有效性，如果满足条件，跳出循环</span></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int <span class="comment">// 存储我们新生成的hash</span></span><br><span class="line">    <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        dataBytes := proofOfWork.prepareData(nonce)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hash</span></span><br><span class="line">        hash = sha256.Sum256(dataBytes)</span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>,hash)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将hash存储到hashInt</span></span><br><span class="line">        hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断hashInt是否小于Block里面的target</span></span><br><span class="line">        <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">        <span class="comment">//    0 if x == y</span></span><br><span class="line">        <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">        <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonce = nonce + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[:],<span class="keyword">int64</span>(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的工作量证明对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProofOfWork</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.big.Int对象 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//0000 0001</span></span><br><span class="line">    <span class="comment">// 8 - 2 = 6</span></span><br><span class="line">    <span class="comment">// 0100 0000  64</span></span><br><span class="line">    <span class="comment">// 0010 0000</span></span><br><span class="line">    <span class="comment">// 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 .... 0000</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 创建一个初始值为1的target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int Int</span></span><br><span class="line">    target := big.NewInt(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 左移256 - targetBit</span></span><br><span class="line"></span><br><span class="line">    target = target.Lsh(target,<span class="number">256</span> - targetBit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ProofOfWork&#123;block,target&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64转换为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"kongyixueyuan.com/blockchain_go_videos-master/part8-proof-of-work/BLC"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创世区块</span></span><br><span class="line">    blockchain := BLC.CreateBlockchainWithGenesisBlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新区块</span></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 100RMB To tom"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 200RMB To lily"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 300RMB To hanmeimei"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 50RMB To lucy"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(blockchain)</span><br><span class="line">    fmt.Println(blockchain.Blocks)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW挖矿及共识流程</title>
      <link href="/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="PoW-挖矿及共识流程"><a href="#PoW-挖矿及共识流程" class="headerlink" title="PoW-挖矿及共识流程"></a>PoW-挖矿及共识流程</h3><p>本章节主要是熟悉比特币pow挖矿及共识流程，和简单实现一个pow挖矿helloworld的小demo。</p><a id="more"></a><h2 id="比特币pow挖矿及共识流程"><a href="#比特币pow挖矿及共识流程" class="headerlink" title="比特币pow挖矿及共识流程"></a>比特币pow挖矿及共识流程</h2><p>比特币挖矿的过程如下：</p><ol><li>构建一个空区块，称为候选区块</li><li>从内存池中打包交易至候选区块</li><li>构造区块头，填写区块头的下述字段<br>　　1）填写版本号version字段<br>   　　2）填写父区块哈希prevhash字段<br>   　　3）用merkle树汇总全部的交易，将merkle root的哈希值填写至merkle root字段<br>   　　4）填写时间戳timestamp字段<br>   　　5）填写目标值Bits字段</li><li>开始挖矿。挖矿就是不断重复计算区块头的哈希值，修改nonce参数，直到找到一个满足条件的nonce值，也就是该nonce值下，hash函数运算出来的hash值 &lt; Bits。当挖矿节点成功求出一个解后把解填入区块头的nonce字段。</li><li>这时一个新区块就成功挖出了，然后挖矿节点会做下面这些事：<br>　　1) 按照标准清单检验新区块，检验通过后进行下面的 2)和 3)步骤<br>   　　2）立刻将这个新区块发给它的所有相邻节点，相邻节点收到这个新区块后进行验证，验证有效后会继续传播给所有相邻节点。<br>   　　3）将这个新区块连接到现有的区块链中，按照如下规则：<br>   　　　　根据新区块的prevhash字段在现有区块链中寻找这个父区块，<br>   　　　　(Ⅰ) 如果父区块是主区块链的“末梢”，则将新区块添加上去即可；<br>   　　　　(Ⅱ) 如果父区块所在的链是备用链，则节点将新区块添加到备用链，同时比较备用链与主链的工作量。如果备用链比主链积累了更多的工作量，节点将选择备用链作为其新的主链，而之前的主链则成为了备用链；<br>   　　　　(Ⅲ) 如果在现有的区块链中找不到它的父区块，那么这个区块被认为是“孤块”。孤块会被保存在孤块池中，直到它们的父区块被节点接收到。一旦收到了父区块并且将其连接到现有的区块链上，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</li></ol><p>pow工作量证明共识机制流程图如下：</p><p><img src="http://image.chaindesk.cn/pow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png/mark" alt="img"></p><p>演示挖坑过程，可链接下面网址：</p><p><a href="https://anders.com/blockchain/blockchain.html" target="_blank" rel="noopener">https://anders.com/blockchain/blockchain.html</a></p><h2 id="pow简单的例子"><a href="#pow简单的例子" class="headerlink" title="pow简单的例子"></a>pow简单的例子</h2><p>下边这个代码很糙，只是简化版的pow挖矿过程，里面的N就是挖矿Bits，我设置了一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//声明了一个挖矿难度Bits</span></span><br><span class="line"><span class="keyword">const</span> N  = <span class="number">0x00FFffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个block结构体</span></span><br><span class="line"><span class="keyword">type</span> block <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//区块数据</span></span><br><span class="line">    Data  []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//随机数</span></span><br><span class="line">    Nonce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//当前块的hash</span></span><br><span class="line">    hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//挖矿目标难度值</span></span><br><span class="line">    Bits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化一个空块</span></span><br><span class="line">    <span class="keyword">var</span> b = block&#123;[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>), <span class="number">0</span>,<span class="literal">nil</span>,N&#125;</span><br><span class="line"></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接block字段内容</span></span><br><span class="line">        dataBytes := b.PreParae(nonce)</span><br><span class="line">        <span class="comment">//矿工计算函数，我只用了一次256hash</span></span><br><span class="line">        hash := sha256.Sum256(dataBytes)</span><br><span class="line">        <span class="comment">//将hash转换成Uint64类型，将与N进行比较大小</span></span><br><span class="line">        hash1 := BytesToUint64(hash[:])</span><br><span class="line">        <span class="comment">//不断显现hash函数后的值</span></span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">        <span class="comment">//hash值与目标值进行大小比较</span></span><br><span class="line">        <span class="keyword">if</span> hash1 &lt; <span class="keyword">uint64</span>(N) &#123;</span><br><span class="line">        <span class="comment">//挖矿成功后，给b重新赋值，并跳出循环</span></span><br><span class="line">            fmt.Println()</span><br><span class="line">            b.Nonce=nonce</span><br><span class="line">            b.hash=hash[:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonce++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//block字段拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b block)</span> <span class="title">PreParae</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            b.Data,</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            b.hash,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节转换成64进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToUint64</span><span class="params">(array []<span class="keyword">byte</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">        data = data + <span class="keyword">uint64</span>(<span class="keyword">uint</span>(array[i])&lt;&lt;<span class="keyword">uint</span>(<span class="number">8</span>*i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将64进制数字转换成字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW目标值</title>
      <link href="/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
      <url>/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-目标值"><a href="#POW-目标值" class="headerlink" title="POW-目标值"></a>POW-目标值</h3><p>很多文章或解析将区块里的Bits字段解读成难度值，其实是错误的。Bits的作用是直接和区块头2次sha256（）的结果进行比较大小的。比较之前，需要先将两者的类型转换成big.Int型。起初Bits类型是Uint32；hash类型是字节数组。</p><a id="more"></a><h2 id="目标值的产生"><a href="#目标值的产生" class="headerlink" title="目标值的产生"></a>目标值的产生</h2><p>目标值是怎么产生的呢？<br>目标值是一个变量，中本聪设的初始值是0x1d00ffff。这个目标值以后会每隔2016个区块，根据过去2016个区块花费时长算出的难度值进行调整，保证正常出块的时间在10分钟左右。所有节点都会按统一公式自动调整Bits，调整公式：</p><p>新难度值=旧难度值*（过去2016个区块花费时长（分）/20160分钟）</p><p>目标值=最大目标值/难度值。</p><p>最大目标值是恒定的，即为创始区块的Bits值<code>0x1d00FFFF</code>。这个数的由来是<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>这个64位16进制数通过小端法存储得来。这个64位数字存储需要占32个字节，而Bits在区块头占大小是4个字节，所以通过小端法存储可以把后边的0都抹去，最后得到的数占4个字节。小端法英文表示little-endian，一种是将低序字节存储在起始地址的存储方法。我们经常用到的存储都是大端法，按数据字节顺序从高到低存储。</p><p><code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>来自中本聪定义的数字<code>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>使用浮点编码类型得来的。方法是为满足实现小端法存储，中本聪处理后面F的方法，具体不作分析。真正在代码中出现的最大目标值只是<code>0x1d00FFFF</code>，也就是创始区块的Bits。</p><p>每2016个区块完成后，会自动调整新的目标值Bits。从上边公式可以看出新Bits与难度值成反比。因为Bits是小端法存储，所以存储的数据越大说明实际的数字越小，那么挖矿越难；反之越简单。难度值也是个变量，最开始前2016个块数值是1，之后每隔2016个块后都会改变。在矿工挖矿过程中，都会有一个计时器，记录每个区块挖矿的时间，当累加2016次后，将会通过新难度值公式，计算出下一次挖矿的难度值，然后再通过目标值公式得到以后挖矿的目标值。</p><h2 id="还原真实目标值"><a href="#还原真实目标值" class="headerlink" title="还原真实目标值"></a>还原真实目标值</h2><p>在矿工挖矿过程中，产生的hash值与目标值进行比较大小，需要将目标值还原成真实值。目标值由指数（exponent）和系数（coefficient）两部分组成。高位一个字节为指数，低位三个字节为系数。真实目标值用target表示。</p><p>真实的目标值的大小计算方式是：target = coefficient <em>2^(8</em> (exponent – 3))</p><p>比如：<br>在区块277,316中，nBits字段的值为0x1903a30c，则0x19为指数，而 0x03a30c为系数。<br>计算难度目标的公式为：<br>target = coefficient <em>2^(8</em> (exponent – 3))</p><p>由此公式，以及难度位nBits的值 0x1903a30c，可得：</p><p>target = 0x03a30c <em>2^(0x08</em> (0x19 - 0x03))^</p><p>=&gt; <code>target = 0x03a30c * 2^(0x08 * 0x16)^</code><br>=&gt;<code>target = 0x03a30c * 2^0xB0^</code></p><p>按十进制计算为：</p><p>=&gt;<code>target = 238,348 * 2^176^</code><br>=&gt; <code>target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</code></p><p>转化回十六进制后为：</p><p>=&gt; <code>target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</code></p><p>也就是说高度为277,316的有效区块的区块头哈希值是小于这个真实目标值的。这个数字的二进制表示中必须超过60位的前导位都是0。在这个级别的难度，一个每秒可以处理1万亿次（1 tera-hash per second 或 1 TH/sec）哈希计算的矿工平均每8,496个区块，或者平均每59天，才能找到一个正确结果。</p><p>再看下比特币中创世区块(GenesisBlock)的难度值：<br>nBits字段值为：0x1d00ffff(十进制即为：486604799)，表示为十六进制的Target值为：<code>00000000ffff0000000000000000000000000000000000000000000000000000</code></p><p>综上，这个高度为277,316的有效区块的区块头的部分信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A：Bits = <span class="string">"0x1903a30c"</span></span><br><span class="line"></span><br><span class="line">B：exponent指数，exponent = <span class="number">0x19</span></span><br><span class="line"></span><br><span class="line">C：coefficient系数，coefficient = <span class="number">0x03a30c</span></span><br><span class="line"></span><br><span class="line">D：target = coefficient * Math.Pow(<span class="number">2</span>, <span class="number">8</span> * (exponent - <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">E：Bits真实值（target）：<span class="number">0x0000000000000003A30C00000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">F：本区块hash：<span class="number">00000000000000000041</span>ff1cfc5f15f929c1a45d262f88e4db83680d90658c0c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW工作量证明</title>
      <link href="/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h3><p>PoW，全称Proof of Work，即工作量证明，又称挖矿。大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。根据挖矿贡献的有效工作，来决定货币的分配。</p><p>接下来主要以pow在比特币公链上的应用展开讲解。</p><a id="more"></a><h2 id="比特币Pow"><a href="#比特币Pow" class="headerlink" title="比特币Pow"></a>比特币Pow</h2><p>比特币的出块时间是10分钟左右。每个区块内包含最多8笔交易，这些交易需要被验证和确认，才能实现账户代币的转移。每个挖矿节点做的工作就是去验证和确认这个区块，使区块内的交易得以实现。而他们用的算法就是pow。pow计算的是一个数学运算难题，矿工们首先验证要挖坑区块的合法性，如果合法，他们就开始计算本次挖矿的数学难题，谁第一个做出来并且广播出去，告诉其他矿工我做出来了，你们不用做了。其他矿工们验证你的计算结果和对应的区块，如果大部分的矿工认同你的结果，那么他们将停止挖坑并同步你的数据。区块内的所有交易也就得到认可，实现转账。你的成功挖矿会被比特币激励模块记录，并会给你发送比特币奖励金。</p><p>pow算法主要寻找一个随机数（Block里的Nonce值）作为输入，通过改变这个输入，使Block数据不重复变化，Hash函数（一般是sha256）不断计算这个改变后Block的hash值，找出一个特定格式哈希值的过程（即要求有一定数量的前导0），这里找到的值就是当前hash值 &lt; 目标值（Bits），只不过这个比较是在2进制的格式下比较运算的，也就是比较2进制后数字前面0的个数。这个过程就是pow运算过程。而要求的前导0的个数越多，代表难度越大。在将pow算法之前，先学习下区块信息。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如下图所示<br><img src="http://image.chaindesk.cn/po%20w%E5%8C%BA%E5%9D%97%E4%BF%A1%E6%81%AF.png/mark" alt="img"></p><p>从图上可知，比特币区块结构分为区块头和区块体，区块体保存交易的具体信息，由它生成的hash保存在区块头里。其中区块头细分为：<br>父区块头哈希值：前一区块的哈希值，使用SHA256(SHA256(父区块头))计算。</p><p>版本(Version)：区块版本号，表示本区块遵守的验证规则 。</p><p>时间戳(Timestamp)：该区块产生的近似时间，精确到秒的UNIX时间戳，必须严格大于前11个区块时间的中值，同时全节点也会拒绝那些超出自己2个小时时间戳的区块。</p><p>目标值(Bits)：该区块工作量证明算法的难度目标，已经使用特定算法编码。</p><p>随机数（Nonce）：为了找到满足难度目标所设定的随机数，为了解决32位随机数在算力飞升的情况下不够用的问题，规定时间戳和coinbase交易信息均可更改，以此扩展nonce的位数。</p><p>Merkle根(MerkleRoot)：该区块中交易的Merkle树根的哈希值。矿工收到计算过的区块，会跟自己的区块进行比较，其中Merkle root就是比较它们包含的交易是否一样。</p><p>区块头里的所有信息拼接成一个新的字节数组，pow函数运算的参数就是这个字节数组。函数运算是采用SHA256(SHA256())计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">var</span> genesisBlock = wire.MsgBlock&#123;</span><br><span class="line">    Header: wire.BlockHeader&#123;</span><br><span class="line">        Version:    <span class="number">1</span>,</span><br><span class="line">        PrevBlock:  chainhash.Hash&#123;&#125;,         <span class="comment">// 0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">        MerkleRoot: genesisMerkleRoot,        <span class="comment">// 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</span></span><br><span class="line">        Timestamp:  time.Unix(<span class="number">0x495fab29</span>, <span class="number">0</span>), <span class="comment">// 2009-01-03 18:15:05 +0000 UTC</span></span><br><span class="line">        Bits:       <span class="number">0x1d00ffff</span>,               <span class="comment">// 486604799 </span></span><br><span class="line">        Nonce:      <span class="number">0x7c2bac1d</span>,               <span class="comment">// 2083236893</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Transactions: []*wire.MsgTx&#123;&amp;genesisCoinbaseTx&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pow三要素"><a href="#Pow三要素" class="headerlink" title="Pow三要素"></a>Pow三要素</h2><p>1.Hash函数：在比特币中使用的是SHA256算法函数，是密码哈希函数家族中输出值为256位的哈希算法。</p><p>2.区块头 Hash函数运算需要的参数，也就是区块头的所有信息字节拼接后的字节数组。</p><p>3.目标值（Bits） 每一个区块会用一种压缩的格式（被称为“Bits”）来表示实际的16进制的目标值。通过这个值和系统中其他常量可计算出该难度值下的难度目标值。Hash函数运算出来的结果与目标值进行比较大小，如果小，则表示挖坑成功，否则继续运算。比较大小时为使运算速度快速，目标值和hash值都会转换成2进制，所以比较大小就是比较前导0的个数。比特币是每隔2016个区块后调整难度值。<br>pow挖矿的难度与目标值成反比，如果Bits的实际值增大，那么挖矿容易点；反之，挖矿难度加大。</p><p>比特币整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力，使整个网络的计算力大致每10分钟产生一个区块。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识机制</title>
      <link href="/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="共识机制概述"><a href="#共识机制概述" class="headerlink" title="共识机制概述"></a>共识机制概述</h3><p>所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。</p><a id="more"></a><p>实现共识机制的算法就是共识算法。接下来的章节我会对Pow，Pos，Pbft，Raft等共识算法进行讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go变量和常量</title>
      <link href="/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之变量和常量"><a href="#Go语言基础之变量和常量" class="headerlink" title="Go语言基础之变量和常量"></a>Go语言基础之变量和常量</h1><p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p><a id="more"></a><h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Q1mi"</span>  <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">"Q1mi"</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span> <span class="comment">//声明并初始化变量,只能在函数内使用，不可使用在函数外</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>执行<code>go fmt main.go</code>使得程序代码格式化</p><h4 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">n <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">isOk <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">name =<span class="string">"lixiang"</span></span><br><span class="line">age =<span class="number">16</span></span><br><span class="line">n=<span class="string">"a"</span></span><br><span class="line">isOk=<span class="literal">true</span></span><br><span class="line"><span class="comment">//GO语言声明变量必须使用，不使用编译不过去</span></span><br><span class="line">fmt.Print(isOk)<span class="comment">//在终端中输出</span></span><br><span class="line">fmt.Printf(<span class="string">"name:%s"</span>,name)<span class="comment">//%s:占位符 使用name这个变量去替换占位符</span></span><br><span class="line">fmt.Println(age)<span class="comment">//打印完后会在后面加上一个换行符，同时类型推导</span></span><br><span class="line">    <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> = <span class="string">"hg"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">//类型推导</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"20"</span></span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">//简短变量声明，声明并初始化，只能在函数内部使用</span></span><br><span class="line">s3 := <span class="string">"hahah"</span></span><br><span class="line">fmt.Println(s3)</span><br><span class="line"><span class="comment">//s1 :=10 同一个作用域&#123;&#125; 中不能重复生命同样的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">"Q1mi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, _ := foo()</span><br><span class="line">_, y := foo()</span><br><span class="line">fmt.Println(<span class="string">"x="</span>, x)</span><br><span class="line">fmt.Println(<span class="string">"y="</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li><strong>函数外的每个语句都必须以关键字开始（var、const、func等）</strong></li><li><strong><code>:=</code>不能使用在函数外。</strong></li><li><strong><code>_</code>多用于占位，表示忽略值。</strong></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>同一个作用域（{}）不允许重复声明变量</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota+1)(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1 n2=iota   //iota=iota+1=1</span></span><br><span class="line">n3        <span class="comment">//2 n3=iota</span></span><br><span class="line">n4        <span class="comment">//3 n4=iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例-笔试题"><a href="#几个常见的iota示例-笔试题" class="headerlink" title="几个常见的iota示例: 笔试题"></a>几个常见的<code>iota</code>示例: 笔试题</h3><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">_</span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100    const中每新增一行常量声明将使iota计数一次(iota+1)</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//（二进制）10000000000=1024kb</span></span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//1024MB</span></span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//1024GB</span></span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2  新增一行才+1</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
