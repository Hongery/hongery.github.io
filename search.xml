<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区块链面试/Untitled</title>
      <link href="/2020/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9D%A2%E8%AF%95/Untitled/"/>
      <url>/2020/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9D%A2%E8%AF%95/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gRPC</title>
      <link href="/2020/04/09/RPC%E5%92%8CGRPC/gRPC/"/>
      <url>/2020/04/09/RPC%E5%92%8CGRPC/gRPC/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC快速入门"><a href="#gRPC快速入门" class="headerlink" title="gRPC快速入门"></a>gRPC快速入门</h1><p>RPC算是近些年比较火热的概念了，随着微服务架构的兴起，RPC的应用越来越广泛。本文介绍了RPC和gRPC的相关概念，并且通过详细的代码示例介绍了gRPC的基本使用。</p><a id="more"></a><h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><h2 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h2><p>在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过<code>发送请求-接受回应</code>进行信息交互的系统。</p><h2 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h2><p><code>gRPC</code>是一种现代化开源的高性能RPC框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用HTTP/2作为传输协议。</p><p>在gRPC里，客户端可以像调用本地方法一样直接调用其他机器上的服务端应用程序的方法，是你更容易创建分布式应用程序和服务。与许多RPC系统一样，gRPC是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法。在服务端程序中实现这个接口并且运行gRPC服务处理客户端调用。在客户端，有一个stub提供和服务端相同的方法。<img src="https://www.liwenzhou.com/images/Go/grpc/grpc.svg" alt="grpc"></p><h2 id="为什么要用gRPC"><a href="#为什么要用gRPC" class="headerlink" title="为什么要用gRPC"></a>为什么要用gRPC</h2><p>使用gRPC， 我们可以一次性的在一个<code>.proto</code>文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑—— gRPC帮你解决了不同语言及环境间通信的复杂性。使用<code>protocol buffers</code>还能获得其他好处，包括高效的序列号，简单的IDL以及容易进行接口更新。总之一句话，使用gRPC能让我们更容易编写跨语言的分布式代码。</p><h2 id="安装gRPC"><a href="#安装gRPC" class="headerlink" title="安装gRPC"></a>安装gRPC</h2><h3 id="安装gRPC-1"><a href="#安装gRPC-1" class="headerlink" title="安装gRPC"></a>安装gRPC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h3 id="安装Protocol-Buffers-v3"><a href="#安装Protocol-Buffers-v3" class="headerlink" title="安装Protocol Buffers v3"></a>安装Protocol Buffers v3</h3><p>安装用于生成gRPC服务代码的协议编译器，最简单的方法是从下面的链接：<a href="https://github.com/google/protobuf/releases下载适合你平台的预编译好的二进制文件（`protoc--.zip`）。" target="_blank" rel="noopener">https://github.com/google/protobuf/releases下载适合你平台的预编译好的二进制文件（`protoc--.zip`）。</a></p><p>下载完之后，执行下面的步骤：</p><ol><li>解压下载好的文件</li><li>把<code>protoc</code>二进制文件的路径加到环境变量中</li></ol><p>接下来执行下面的命令安装protoc的Go插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>编译插件<code>protoc-gen-go</code>将会安装到<code>$GOBIN</code>，默认是<code>$GOPATH/bin</code>，它必须在你的<code>$PATH</code>中以便协议编译器<code>protoc</code>能够找到它。</p><h3 id="安装指定"><a href="#安装指定" class="headerlink" title="安装指定"></a>安装指定</h3><h2 id="gRPC开发分三步"><a href="#gRPC开发分三步" class="headerlink" title="gRPC开发分三步"></a>gRPC开发分三步</h2><p>把大象放进冰箱分几步？</p><ol><li>把冰箱门打开。</li><li>把大象放进去。</li><li>把冰箱门带上。</li></ol><p>gRPC开发同样分三步：</p><ol><li>编写<code>.proto</code>文件，生成指定语言源代码。</li><li>编写服务端代码</li><li>编写客户端代码</li></ol><h2 id="gRPC入门示例"><a href="#gRPC入门示例" class="headerlink" title="gRPC入门示例"></a>gRPC入门示例</h2><h3 id="编写proto代码"><a href="#编写proto代码" class="headerlink" title="编写proto代码"></a>编写proto代码</h3><p>gRPC是基于Protocol Buffers。</p><p><code>Protocol Buffers</code>是一种与语言无关，平台无关的可扩展机制，用于序列化结构化数据。使用<code>Protocol Buffers</code>可以一次定义结构化的数据，然后可以使用特殊生成的源代码轻松地在各种数据流中使用各种语言编写和读取结构化数据。</p><p>关于<code>Protocol Buffers</code>的教程可以自行在网上搜索，本文默认读者熟悉<code>Protocol Buffers</code>。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">// 版本声明，使用Protocol Buffers v3版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pb; <span class="comment">// 包名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个打招呼服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SayHello 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 包含人名的一个请求消息</span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">    string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含问候语的响应消息</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>执行下面的命令，生成go语言源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I helloworld/ helloworld/pb/helloworld.proto --go_out=plugins=grpc:helloworld</span><br></pre></td></tr></table></figure><p>在<code>gRPC_demo/helloworld/pb</code>目录下会生成<code>helloworld.pb.go</code>文件。</p><h3 id="编写Server端Go代码"><a href="#编写Server端Go代码" class="headerlink" title="编写Server端Go代码"></a>编写Server端Go代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">pb <span class="string">"gRPC_demo/helloworld/pb"</span></span><br><span class="line"><span class="string">"golang.org/x/net/context"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监听本地的8972端口</span></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8972"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s := grpc.NewServer() <span class="comment">// 创建gRPC服务器</span></span><br><span class="line">pb.RegisterGreeterServer(s, &amp;server&#123;&#125;) <span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line"></span><br><span class="line">reflection.Register(s) <span class="comment">//在给定的gRPC服务器上注册服务器反射服务</span></span><br><span class="line"><span class="comment">// Serve方法在lis上接受传入连接，为每个连接创建一个ServerTransport和server的goroutine。</span></span><br><span class="line"><span class="comment">// 该goroutine读取gRPC请求，然后调用已注册的处理程序来响应它们。</span></span><br><span class="line">err = s.Serve(lis)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存到<code>gRPC_demo/helloworld/server/server.go</code>文件中，编译并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> helloworld/server</span><br><span class="line">go build</span><br><span class="line">./server</span><br></pre></td></tr></table></figure><h3 id="编写Client端Go代码"><a href="#编写Client端Go代码" class="headerlink" title="编写Client端Go代码"></a>编写Client端Go代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">pb <span class="string">"gRPC_demo/helloworld/pb"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">":8972"</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"faild to connect: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">c := pb.NewGreeterClient(conn)</span><br><span class="line"><span class="comment">// 调用服务端的SayHello</span></span><br><span class="line">r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: <span class="string">"q1mi"</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Greeting: %s !\n"</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存到<code>gRPC_demo/helloworld/client/client.go</code>文件中，编译并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> helloworld/client/</span><br><span class="line">go build</span><br><span class="line">./client</span><br></pre></td></tr></table></figure><p>得到输出如下（注意要先启动server端再启动client端）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./client </span><br><span class="line">Greeting: Hello q1mi!</span><br></pre></td></tr></table></figure><p>此时我们的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./gRPC_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── helloworld</span><br><span class="line">    ├── client</span><br><span class="line">    │   ├── client</span><br><span class="line">    │   └── client.go</span><br><span class="line">    │   ├── client.py</span><br><span class="line">    ├── pb</span><br><span class="line">    │   ├── helloworld.pb.go</span><br><span class="line">    │   └── helloworld.proto</span><br><span class="line">    └── server</span><br><span class="line">        ├── server</span><br><span class="line">        └── server.go</span><br></pre></td></tr></table></figure><h3 id="gRPC跨语言调用"><a href="#gRPC跨语言调用" class="headerlink" title="gRPC跨语言调用"></a>gRPC跨语言调用</h3><p>接下来，我们演示一下如何使用gRPC实现跨语言的RPC调用。</p><p>我们使用<code>Python</code>语言编写<code>Client</code>，然后向上面使用<code>go</code>语言编写的<code>server</code>发送RPC请求。</p><h3 id="生成Python代码"><a href="#生成Python代码" class="headerlink" title="生成Python代码"></a>生成Python代码</h3><p>在<code>gRPC_demo</code>目录执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I helloworld/pb/ --python_out=helloworld/client/ --grpc_python_out=helloworld/client/ helloworld/pb/helloworld.proto</span><br></pre></td></tr></table></figure><p>上面的命令会在<code>gRPC_demo/helloworld/client/</code>目录生成如下两个python文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helloworld_pb2.py</span><br><span class="line">helloworld_pb2_grpc.py</span><br></pre></td></tr></table></figure><h3 id="编写Python版Client"><a href="#编写Python版Client" class="headerlink" title="编写Python版Client"></a>编写Python版Client</h3><p>在``gRPC_demo/helloworld/client/<code>目录闯将</code>client.py`文件，其内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> helloworld_pb2</span><br><span class="line"><span class="keyword">import</span> helloworld_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 注意(gRPC Python Team): .close()方法在channel上是可用的。</span></span><br><span class="line">    <span class="comment"># 并且应该在with语句不符合代码需求的情况下使用。</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">'localhost:8972'</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = helloworld_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="string">'q1mi'</span>))</span><br><span class="line">    print(<span class="string">"Greeter client received: &#123;&#125;!"</span>.format(response.message))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>将上面的代码保存执行，得到输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gRPC_demo $ python helloworld/client/client.py </span><br><span class="line">Greeter client received: Hello q1mi!</span><br></pre></td></tr></table></figure><p>这里我们就实现了，使用python代码编写的client去调用Go语言版本的server了。</p><p>点击右边的链接查看完整代码：<a href="https://github.com/Q1mi/gRPC_demo" target="_blank" rel="noopener">gRPC_demo完整代码</a></p>]]></content>
      
      
      <categories>
          
          <category> RPC和GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf</title>
      <link href="/2020/04/09/RPC%E5%92%8CGRPC/protobuf/"/>
      <url>/2020/04/09/RPC%E5%92%8CGRPC/protobuf/</url>
      
        <content type="html"><![CDATA[<h1 id="protobuf初识"><a href="#protobuf初识" class="headerlink" title="protobuf初识"></a>protobuf初识</h1><p>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。</p><a id="more"></a><h2 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h2><h3 id="protobuf介绍"><a href="#protobuf介绍" class="headerlink" title="protobuf介绍"></a>protobuf介绍</h3><p><code>Protobuf</code>是<code>Protocol Buffer</code>的简称，它是Google公司于2008年开源的一种高效的平台无关、语言无关、可扩展的数据格式，目前Protobuf作为接口规范的描述语言，可以作为Go语言RPC接口的基础工具。</p><h3 id="protobuf使用"><a href="#protobuf使用" class="headerlink" title="protobuf使用"></a>protobuf使用</h3><p><code>protobuf</code>是一个与语言无关的一个数据协议，所以我们需要先编写IDL文件然后借助专用工具生成指定语言的代码，从而实现数据的序列化与反序列化过程。</p><p>大致开发流程如下： 1. IDL编写 2. 生成指定语言的代码 3. 序列化和反序列化</p><h3 id="protobuf语法"><a href="#protobuf语法" class="headerlink" title="protobuf语法"></a>protobuf语法</h3><p><a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/" target="_blank" rel="noopener">protobuf3语法指南</a></p><h5 id="1-基本规范"><a href="#1-基本规范" class="headerlink" title="1.基本规范"></a>1.基本规范</h5><p> 文件以<strong>.proto</strong>做为文件后缀，除结构定义外的语句以分号结尾</p><p> 结构定义可以包含：<strong>message、service、enum</strong></p><p> rpc方法定义结尾的分号可有可无</p><p> Message命名采用<strong>驼峰</strong>命名方式，字段命名采用小写字母加下划线分隔方式</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SongServerRequest</span> </span>&#123;  </span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> song_name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Enums类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Foo</span> &#123; </span></span><br><span class="line">FIRST_VALUE = <span class="number">1</span>;  </span><br><span class="line">SECOND_VALUE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service与rpc方法名统一采用驼峰式命名</p><h5 id="2-字段规则"><a href="#2-字段规则" class="headerlink" title="2. 字段规则"></a><strong>2.</strong> 字段规则</h5><p>字段格式：限定修饰符 | 数据类型 | 字段名称 | = | 字段编码值 | [字段默认值]</p><ol><li><p>限定修饰符包含 <strong>required\optional\repeated</strong></p><p><strong>Required</strong>: 表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值，对于接收方，必须能够识别该字段的意思。发送之前没有设置required字段或者无法识别required字段都会引发编解码异常，导致消息被丢弃</p><p><strong>Optional</strong>：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值。对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。—因为optional字段的特性，很多接口在升级版本中都把后来添加的字段都统一的设置为optional字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡</p></li></ol><p><strong>Repeated</strong>：表示该字段可以包含0~N个元素。其特性和optional一样，但是每一次可以包含多个值。可以看作是在传递一个数组的值</p><p>2.<strong>数据类型</strong></p><p>n Protobuf定义了一套基本数据类型。几乎都可以映射到C++\Java等语言的基础数据类型</p><p><img src="./images/wps7.jpg" alt="img"> </p><p>n N 表示打包的字节并不是固定。而是根据数据的大小或者长度</p><p>n 关于 fixed32 和int32的区别。fixed32的打包效率比int32的效率高，但是使用的空间一般比int32多。因此一个属于时间效率高，一个属于空间效率高</p><p>l 字段名称</p><p>n 字段名称的命名与C、C++、Java等语言的变量命名方式几乎是相同的</p><p>n protobuf建议字段的命名采用以下划线分割的驼峰式。例如 first_name 而不是firstName</p><p>l 字段编码值</p><p>n 有了该值，通信双方才能互相识别对方的字段，相同的编码值，其限定修饰符和数据类型必须相同，编码值的取值范围为 1~2^32（4294967296）</p><p>n 其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低，所以建议把经常要传递的值把其字段编码设置为1-15之间的值</p><p>n 1900~2000编码值为Google protobuf 系统内部保留值，建议不要在自己的项目中使用</p><p>l 字段默认值</p><p>n 当在传递数据时，对于required数据类型，如果用户没有设置值，则使用默认值传递到对端</p><h5 id="3-service如何定义"><a href="#3-service如何定义" class="headerlink" title="3. service如何定义"></a><strong>3.</strong> service如何定义</h5><p>​     如果想要将消息类型用在RPC系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器会根据所选择的不同语言生成服务接口代码</p><p>​      例如，想要定义一个RPC服务并具有一个方法，该方法接收SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>生成的接口代码作为客户端与服务端的约定，服务端必须实现定义的所有接口方法，客户端直接调用同名方法向服务端发起请求，比较麻烦的是，即便业务上不需要参数也必须指定一个请求消息，一般会定义一个空message</p><h5 id="4-Message如何定义"><a href="#4-Message如何定义" class="headerlink" title="4. Message如何定义"></a>4. Message如何定义</h5><ul><li><p>一个message类型定义描述了一个请求或响应的消息格式，可以包含多种类型字段</p></li><li><p>例如定义一个搜索请求的消息格式，每个请求包含查询字符串、页码、每页数目</p></li><li><p>字段名用小写，转为go文件后自动变为大写，message就相当于结构体</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> query = <span class="number">1</span>;            <span class="comment">// 查询字符串</span></span><br><span class="line">    <span class="built_in">int32</span>  page_number = <span class="number">2</span>;     <span class="comment">// 页码</span></span><br><span class="line">    <span class="built_in">int32</span>  result_per_page = <span class="number">3</span>;   <span class="comment">// 每页条数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>l 首行声明使用的protobuf版本为proto3</p></li><li><p>l SearchRequest 定义了三个字段，每个字段声明以分号结尾，.proto文件支持双斜线 // 添加单行注释</p></li></ul><h5 id="5-添加更多Message类型"><a href="#5-添加更多Message类型" class="headerlink" title="5.添加更多Message类型"></a>5.添加更多Message类型</h5><p> 一个.proto文件中可以定义多个消息类型，一般用于同时定义多个相关的消息，例如在同一个.proto文件中同时定义搜索请求和响应消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SearchRequest 搜索请求</span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;            &#x2F;&#x2F; 查询字符串</span><br><span class="line">    int32  page_number &#x3D; 2;     &#x2F;&#x2F; 页码</span><br><span class="line">    int32  result_per_page &#x3D; 3;   &#x2F;&#x2F; 每页条数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SearchResponse 搜索响应</span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-如何使用其他Message"><a href="#6-如何使用其他Message" class="headerlink" title="6. 如何使用其他Message"></a><strong>6.</strong> 如何使用其他Message</h5><p>message支持嵌套使用，作为另一message中的字段类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">    repeated Result results &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">    string url &#x3D; 1;</span><br><span class="line">    string title &#x3D; 2;</span><br><span class="line">    repeated string snippets &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-Message嵌套的使用"><a href="#7-Message嵌套的使用" class="headerlink" title="7. Message嵌套的使用"></a><strong>7.</strong> Message嵌套的使用</h5><p> 支持嵌套消息，消息可以包含另一个消息作为其字段。也可以在消息内定义一个新的消息</p><p> 内部声明的message类型名称只可在内部直接使用</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 另外，还可以多层嵌套</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>&#123;                <span class="comment">// Level 0</span></span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>&#123;        <span class="comment">// Level 1</span></span><br><span class="line">        <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;        <span class="comment">// Level 2</span></span><br><span class="line">            <span class="built_in">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>&#123;         <span class="comment">// Level 1</span></span><br><span class="line">        <span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;         <span class="comment">// Level 2</span></span><br><span class="line">            <span class="built_in">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-proto3的Map类型"><a href="#8-proto3的Map类型" class="headerlink" title="8. proto3的Map类型"></a><strong>8.</strong> proto3的Map类型</h5><ul><li><p>proto3支持map类型声明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Project</span> </span>&#123;...&#125;</span><br><span class="line">map&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>键、值类型可以是内置的类型，也可以是自定义message类型</p></li><li><p>字段不支持repeated属性</p></li></ul><h5 id="9-proto文件编译"><a href="#9-proto文件编译" class="headerlink" title="9.   .proto文件编译"></a><strong>9.</strong>   .proto文件编译</h5><ol><li>通过定义好的.proto文件生成Java, Python, C++, Go, Ruby, JavaNano, Objective-C, or C# 代码，需要安装编译器protoc</li><li>当使用protocol buffer编译器运行.proto文件时，编译器将生成所选语言的代码，用于使用在.proto文件中定义的消息类型、服务接口约定等。不同语言生成的代码格式不同：</li></ol><ul><li>C++: 每个.proto文件生成一个.h文件和一个.cc文件，每个消息类型对应一个类</li><li>Java: 生成一个.java文件，同样每个消息对应一个类，同时还有一个特殊的Builder类用于创建消息接口</li><li>Python: 姿势不太一样，每个.proto文件中的消息类型生成一个含有静态描述符的模块，该模块与一个元类metaclass在运行时创建需要的Python数据访问类</li><li>Go: 生成一个.pb.go文件，每个消息类型对应一个结构体</li><li>Ruby: 生成一个.rb文件的Ruby模块，包含所有消息类型</li><li>JavaNano: 类似Java，但不包含Builder类</li><li>Objective-C: 每个.proto文件生成一个pbobjc.h和一个pbobjc.m文件</li><li>C#: 生成.cs文件包含，每个消息类型对应一个类</li></ul><h5 id="10-import导入定义"><a href="#10-import导入定义" class="headerlink" title="10. import导入定义"></a><strong>10.</strong> import导入定义</h5><ul><li>l 可以使用import语句导入使用其它描述文件中声明的类型</li><li>l protobuf 接口文件可以像C语言的h文件一个，分离为多个，在需要的时候通过 import导入需要对文件。其行为和C语言的#include或者java的import的行为大致相同，例如import “others.proto”;</li><li>l protocol buffer编译器会在 -I / –proto_path参数指定的目录中查找导入的文件，如果没有指定该参数，默认在当前目录中查找</li></ul><h5 id="11-包的使用"><a href="#11-包的使用" class="headerlink" title="11. 包的使用"></a><strong>11.</strong> 包的使用</h5><ul><li><p>在.proto文件中使用package声明包名，避免命名冲突</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>在其他的消息格式定义中可以使用包名+消息名的方式来使用类型，如</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在不同的语言中，包名定义对编译后生成的代码的影响不同</p></li><li><p>C++ 中：对应C++命名空间，例如Open会在命名空间foo::bar中</p></li><li><p>Java 中：package会作为Java包名，除非指定了option jave_package选项</p></li><li><p>Python 中：package被忽略</p></li><li><p>Go 中：默认使用package名作为包名，除非指定了option go_package选项</p></li><li><p>JavaNano 中：同Java</p></li><li><p>C# 中：package会转换为驼峰式命名空间，如Foo.Bar,除非指定了option csharp_namespace选项</p></li></ul><h3 id="编译器安装"><a href="#编译器安装" class="headerlink" title="编译器安装"></a>编译器安装</h3><h3 id="ptotoc"><a href="#ptotoc" class="headerlink" title="ptotoc"></a>ptotoc</h3><p><code>protobuf</code>协议编译器是用c++编写的，根据自己的操作系统下载对应版本的<code>protoc</code>编译器：<a href="https://github.com/protocolbuffers/protobuf/releases，解压后拷贝到`GOPATH/bin`目录下。" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases，解压后拷贝到`GOPATH/bin`目录下。</a></p><h3 id="protoc-gen-go"><a href="#protoc-gen-go" class="headerlink" title="protoc-gen-go"></a>protoc-gen-go</h3><p>安装生成Go语言代码的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><h3 id="编写IDL代码"><a href="#编写IDL代码" class="headerlink" title="编写IDL代码"></a>编写IDL代码</h3><p>在<code>protobuf_demo/address</code>目录下新建一个名为<code>person.proto</code>的文件具体内容如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定使用protobuf版本</span></span><br><span class="line"><span class="comment">// 此处使用v3版本</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包名，通过protoc生成go文件</span></span><br><span class="line"><span class="keyword">package</span> address;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性别类型</span></span><br><span class="line"><span class="comment">// 枚举类型第一个字段必须为0</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GenderType</span> </span>&#123;</span><br><span class="line">    SECRET = <span class="number">0</span>;</span><br><span class="line">    FEMALE = <span class="number">1</span>;</span><br><span class="line">    MALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int64</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">    GenderType gender = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联系簿</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ContactBook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> Person persons = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成go语言代码"><a href="#生成go语言代码" class="headerlink" title="生成go语言代码"></a>生成go语言代码</h3><p>在<code>protobuf_demo/address</code>目录下执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address $ protoc --go_out=. ./person.proto</span><br></pre></td></tr></table></figure><p>此时在当前目录下会生成一个<code>person.pb.go</code>文件，我们的Go语言代码里就是使用这个文件。 在<code>protobuf_demo/main.go</code>文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/Q1mi/studygo/code_demo/protobuf_demo/address"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// protobuf demo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> cb address.ContactBook</span><br><span class="line"></span><br><span class="line">p1 := address.Person&#123;</span><br><span class="line">Name:   <span class="string">"小王子"</span>,</span><br><span class="line">Gender: address.GenderType_MALE,</span><br><span class="line">Number: <span class="string">"7878778"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p1)</span><br><span class="line">cb.Persons = <span class="built_in">append</span>(cb.Persons, &amp;p1)</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">data, err := proto.Marshal(&amp;p1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"marshal failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ioutil.WriteFile(<span class="string">"./proto.dat"</span>, data, <span class="number">0644</span>)</span><br><span class="line"></span><br><span class="line">data2, err := ioutil.ReadFile(<span class="string">"./proto.dat"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"read file failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 address.Person</span><br><span class="line">proto.Unmarshal(data2, &amp;p2)</span><br><span class="line">fmt.Println(p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RPC和GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="/2020/04/09/RPC%E5%92%8CGRPC/RPC/"/>
      <url>/2020/04/09/RPC%E5%92%8CGRPC/RPC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-RPC简介"><a href="#1-RPC简介" class="headerlink" title="1. RPC简介"></a><strong>1.</strong> RPC简介</h3><ul><li><p>远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议</p></li><li><p>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</p></li><li><p>如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用</p><a id="more"></a></li></ul><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>而一旦踏入公司尤其是大型互联网公司就会发现，公司的系统都由成千上万大大小小的服务组成，各服务部署在不同的机器上，由不同的团队负责。到两个问题：<br>1）要建造一个新服务，免不了需要依赖他人的服务，而现在其他人的服务都在逐步，怎么调用？<br>2）其他团队要使用我们的服务，我们的服务该如何发布杀死他人呼吁？</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="./images/wps1.jpg" alt="img"></p><ol><li>服务消费方（客户）调用以本地调用方式调用服务；</li><li>客户端存根接收到调用后负责将方法，参数等组装成能够进行网络传输的消息体；</li><li>客户存根找到服务地址，转化为消息发送到服务端；</li><li>服务器存根收到消息后进行解码；</li><li>服务器存根根据解码结果调用本地的服务；</li><li>本地服务执行重新结果返回给服务器存根；</li><li>服务器存根将返回结果打包成消息并发送至消费方；</li><li>客户存根接收到消息，并进行解码；</li><li>服务消费方得到最终结果。</li></ol><p>RPC的目标就是要2〜8这些步骤都封装起来，让用户对这些细节透明 </p><h3 id="2-流行RPC框架的对比"><a href="#2-流行RPC框架的对比" class="headerlink" title="2.流行RPC框架的对比"></a>2.流行RPC框架的对比</h3><p><img src="./images/wps2.jpg" alt="img"> </p><h3 id="3-golang中如何实现RPC"><a href="#3-golang中如何实现RPC" class="headerlink" title="3.golang中如何实现RPC"></a>3.golang中如何实现RPC</h3><ol><li><p>golang中实现RPC非常简单，官方提供了封装好的库，还有一些第三方的库</p></li><li><p>golang官方的net/rpc库使用encoding/gob进行编解码，支持tcp和http数据传输方式，由于其他语言不支持gob编解码方式，所以golang的RPC只支持golang开发的服务器与客户端之间的交互</p></li><li><p>官方还提供了net/rpc/jsonrpc库实现RPC方法，jsonrpc采用JSON进行数据编解码，因而支持跨语言调用，目前jsonrpc库是基于tcp协议实现的，暂不支持http传输方式</p></li></ol><p><strong>例题：golang实现RPC程序，实现求矩形面积和周长</strong></p><p>l 服务端RPC/service/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"github.com/micro/go-log"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">   <span class="string">"net/rpc"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    例题：golang实现RPC程序，实现求矩形面积和周长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Params <span class="keyword">struct</span> &#123;</span><br><span class="line">   Width, Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC服务端方法，求矩形面积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rect)</span> <span class="title">Area</span><span class="params">(p Params, ret *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   *ret = p.Height * p.Width</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周长</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rect)</span> <span class="title">Perimeter</span><span class="params">(p Params, ret *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   *ret = (p.Height + p.Width) * <span class="number">2</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.注册服务</span></span><br><span class="line">   rect := <span class="built_in">new</span>(Rect)</span><br><span class="line">   <span class="comment">// 注册一个rect的服务</span></span><br><span class="line">   rpc.Register(rect)</span><br><span class="line">   <span class="comment">// 2.服务处理绑定到http协议上</span></span><br><span class="line">   rpc.HandleHTTP()</span><br><span class="line">   <span class="comment">// 3.监听服务</span></span><br><span class="line">   err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l 客户端RPC/client/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传的参数</span></span><br><span class="line"><span class="keyword">type</span> Params <span class="keyword">struct</span> &#123;</span><br><span class="line">   Width, Height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.连接远程rpc服务</span></span><br><span class="line">   conn, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">":8000"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.调用方法</span></span><br><span class="line">   <span class="comment">// 面积</span></span><br><span class="line">   ret := <span class="number">0</span></span><br><span class="line">   err2 := conn.Call(<span class="string">"Rect.Area"</span>, Params&#123;<span class="number">50</span>, <span class="number">100</span>&#125;, &amp;ret)</span><br><span class="line">   <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err2)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">"面积："</span>, ret)</span><br><span class="line">   <span class="comment">// 周长</span></span><br><span class="line">   err3 := conn.Call(<span class="string">"Rect.Perimeter"</span>, Params&#123;<span class="number">50</span>, <span class="number">100</span>&#125;, &amp;ret)</span><br><span class="line">   <span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err3)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">"周长："</span>, ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试过程及结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//第一个终端，开启服务</span><br><span class="line">huanggang@DESKTOP-C1VUL6T MINGW64 /c/Program Files/StudyGo/src/ginDemo/RPC/service (master)</span><br><span class="line">$ go run main.go</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//第二个终端，连接服务</span><br><span class="line">huanggang@DESKTOP-C1VUL6T MINGW64 /c/Program Files/StudyGo/src/ginDemo/RPC/client (master)</span><br><span class="line">$ go run main.go</span><br><span class="line">面积： 5000</span><br><span class="line">周长： 300</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>golang写RPC程序，必须符合4个基本条件，不然RPC用不了</p><ul><li><p>结构体字段首字母要大写，可以别人调用</p></li><li><p>函数名必须首字母大写</p></li><li><p>函数第一参数是接收参数，第二个参数是返回给客户端的参数，必须是指针类型</p></li><li><p>函数还必须有一个返回值error</p></li></ul><p>l <strong>练习：模仿前面例题，自己实现RPC程序，服务端接收2个参数，可以做乘法运算，也可以做商和余数的运算，客户端进行传参和访问，得到结果如下：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>*<span class="number">2</span>=<span class="number">18</span></span><br><span class="line"><span class="number">9</span>/<span class="number">2</span>，商=<span class="number">4</span>，余数=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>l 服务端service/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"errors"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">   <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 结构体，用于注册的</span></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明参数结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123; A, B <span class="keyword">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给客户端的结果</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pro <span class="keyword">int</span>  <span class="comment">// 乘积</span></span><br><span class="line">   Quo <span class="keyword">int</span> <span class="comment">// 商</span></span><br><span class="line">   Rem <span class="keyword">int</span>  <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Arith)</span> <span class="title">Multiply</span><span class="params">(req ArithRequest, res *ArithResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   res.Pro = req.A * req.B</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商和余数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Arith)</span> <span class="title">Divide</span><span class="params">(req ArithRequest, res *ArithResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> req.B == <span class="number">0</span> &#123;  <span class="keyword">return</span> errors.New(<span class="string">"除数不能为0"</span>)&#125;</span><br><span class="line">   res.Quo = req.A / req.B  <span class="comment">// 除</span></span><br><span class="line">   res.Rem = req.A % req.B     <span class="comment">// 取模</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   rect := <span class="built_in">new</span>(Arith)  <span class="comment">// 1.注册服务</span></span><br><span class="line">   rpc.Register(rect)     <span class="comment">// 注册一个rect的服务</span></span><br><span class="line">   rpc.HandleHTTP()    <span class="comment">// 2.服务处理绑定到http协议上</span></span><br><span class="line">   <span class="comment">// 3.监听服务</span></span><br><span class="line">   err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l 客户端client/main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">   <span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;A, B <span class="keyword">int</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给客户端的结果</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pro <span class="keyword">int</span>   <span class="comment">// 乘积</span></span><br><span class="line">   Quo <span class="keyword">int</span>      <span class="comment">// 商</span></span><br><span class="line">   Rem <span class="keyword">int</span>     <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   conn, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">":8000"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatal(err)&#125;</span><br><span class="line">   req := ArithRequest&#123;<span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> res ArithResponse</span><br><span class="line">   err2 := conn.Call(<span class="string">"Arith.Multiply"</span>, req, &amp;res)</span><br><span class="line">   <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err2)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">"%d * %d = %d\n"</span>, req.A, req.B, res.Pro)</span><br><span class="line">   err3 := conn.Call(<span class="string">"Arith.Divide"</span>, req, &amp;res)</span><br><span class="line">   <span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err3)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">"%d / %d 商 %d，余数 = %d\n"</span>, req.A, req.B, res.Quo, res.Rem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l 另外，<strong>net/rpc/jsonrpc库通过json格式编解码，支持跨语言调用</strong></p><p><strong>server</strong></p><p><img src="./images/wps4.jpg" alt="img"> </p><p><strong>client</strong></p><p><img src="file:///C:%5CUsers%5CHUANGG~1%5CAppData%5CLocal%5CTemp%5Cksohtml7300%5Cwps5.jpg" alt="img"> </p><h3 id="4-RPC调用流程"><a href="#4-RPC调用流程" class="headerlink" title="4.RPC调用流程"></a>4.RPC调用流程</h3><ul><li><p>微服务架构下数据交互一般是对内 RPC，对外 REST</p></li><li><p>将业务按功能模块拆分到各个微服务，具有提高项目协作效率、降低模块耦合度、提高系统可用性等优点，但是开发门槛比较高，比如 RPC 框架的使用、后期的服务监控等工作</p></li><li><p>一般情况下，我们会将功能代码在本地直接调用，微服务架构下，我们需要将这个函数作为单独的服务运行，客户端通过网络调用</p></li></ul><h3 id="5-网络传输数据格式"><a href="#5-网络传输数据格式" class="headerlink" title="5. 网络传输数据格式"></a><strong>5.</strong> 网络传输数据格式</h3><p> 两端要约定好数据包的格式</p><p> 成熟的RPC框架会有自定义传输协议，这里网络传输格式定义如下，前面是固定长度消息头，后面是变长消息体</p><p><strong><code>网络字节流:</code>      <code>header unit32</code>       <code>data []byte</code></strong></p><p>l自己定义数据格式的读写 reader_writer.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"encoding/binary"</span></span><br><span class="line">   <span class="string">"io"</span></span><br><span class="line">   <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试网络中读写数据的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会话连接的结构体</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">   conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(conn net.Conn)</span> *<span class="title">Session</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Session&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向连接中去写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义写数据的格式</span></span><br><span class="line">   <span class="comment">// 4字节头部 + 可变体的长度</span></span><br><span class="line">   buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>+<span class="built_in">len</span>(data))</span><br><span class="line">   <span class="comment">// 写入头部，记录数据长度</span></span><br><span class="line">   binary.BigEndian.PutUint32(buf[:<span class="number">4</span>], <span class="keyword">uint32</span>(<span class="built_in">len</span>(data)))</span><br><span class="line">   <span class="comment">// 将整个数据，放到4后边</span></span><br><span class="line">   <span class="built_in">copy</span>(buf[<span class="number">4</span>:], data)</span><br><span class="line">   _, err := s.conn.Write(buf)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Read</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 读取头部记录的长度</span></span><br><span class="line">   header := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">   <span class="comment">// 按长度读取消息</span></span><br><span class="line">   _, err := io.ReadFull(s.conn, header)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 读取数据</span></span><br><span class="line">   dataLen := binary.BigEndian.Uint32(header)</span><br><span class="line">   data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, dataLen)</span><br><span class="line">   _, err = io.ReadFull(s.conn, data)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l 测试类***_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"net"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">   <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSession_ReadWriter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义地址</span></span><br><span class="line">   addr := <span class="string">"127.0.0.1:8000"</span></span><br><span class="line">   my_data := <span class="string">"hello"</span></span><br><span class="line">   <span class="comment">// 等待组定义</span></span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   wg.Add(<span class="number">2</span>)</span><br><span class="line">   <span class="comment">// 写数据的协程</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      lis, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         t.Fatal(err)</span><br><span class="line">      &#125;</span><br><span class="line">      conn, _ := lis.Accept()</span><br><span class="line">      s := Session&#123;conn: conn&#125;</span><br><span class="line">      err = s.Write([]<span class="keyword">byte</span>(my_data))</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         t.Fatal(err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读数据的协程</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      conn, err := net.Dial(<span class="string">"tcp"</span>, addr)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         t.Fatal(err)</span><br><span class="line">      &#125;</span><br><span class="line">      s := Session&#123;conn: conn&#125;</span><br><span class="line">      data, err := s.Read()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         t.Fatal(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最后一层校验</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">string</span>(data) != my_data &#123;</span><br><span class="line">         t.Fatal(err)</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">   &#125;()</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>l 编码解码utils.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明服务端</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 地址</span></span><br><span class="line">addr <span class="keyword">string</span></span><br><span class="line"><span class="comment">// map 用于维护关系的</span></span><br><span class="line">funcs <span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Server&#123;addr: addr, funcs: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]reflect.Value)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端需要一个注册Register</span></span><br><span class="line"><span class="comment">// 第一个参数函数名，第二个传入真正的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Register</span><span class="params">(rpcName <span class="keyword">string</span>, f <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 维护一个map</span></span><br><span class="line"><span class="comment">// 若map已经有键了</span></span><br><span class="line"><span class="keyword">if</span> _, ok := s.funcs[rpcName]; ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若map中没值，则将映射加入map，用于调用</span></span><br><span class="line">fVal := reflect.ValueOf(f)</span><br><span class="line">s.funcs[rpcName] = fVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端等待调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, s.addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"监听 %s err :%v"</span>, s.addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 服务端循环等待调用</span></span><br><span class="line">conn, err := lis.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">serSession := NewSession(conn)</span><br><span class="line"><span class="comment">// 使用RPC方式读取数据</span></span><br><span class="line">b, err := serSession.Read()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据解码</span></span><br><span class="line">rpcData, err := decode(b)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据读到的name，得到要调用的函数</span></span><br><span class="line">f, ok := s.funcs[rpcData.Name]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"函数 %s 不存在"</span>, rpcData.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历解析客户端传来的参数,放切片里</span></span><br><span class="line">inArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(rpcData.Args))</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> rpcData.Args &#123;</span><br><span class="line">inArgs = <span class="built_in">append</span>(inArgs, reflect.ValueOf(arg))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反射调用方法</span></span><br><span class="line"><span class="comment">// 返回Value类型，用于给客户端传递返回结果,out是所有的返回结果</span></span><br><span class="line">out := f.Call(inArgs)</span><br><span class="line"><span class="comment">// 遍历out ，用于返回给客户端，存到一个切片里</span></span><br><span class="line">outArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(out))</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> out &#123;</span><br><span class="line">outArgs = <span class="built_in">append</span>(outArgs, o.Interface())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据编码，返回给客户端</span></span><br><span class="line">respRPCData := RPCData&#123;rpcData.Name, outArgs&#125;</span><br><span class="line">bytes, err := encode(respRPCData)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将服务端编码后的数据，写出到客户端</span></span><br><span class="line">err = serSession.Write(bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-实现RPC服务端"><a href="#6-实现RPC服务端" class="headerlink" title="6. 实现RPC服务端"></a><strong>6.</strong> 实现RPC服务端</h3><ul><li>服务端接收到的数据需要包括什么？</li></ul><p> 调用的函数名、参数列表，还有一个返回值error类型</p><ul><li>服务端需要解决的问题是什么？</li></ul><p> Map维护客户端传来调用函数，服务端知道去调谁</p><ul><li>服务端的核心功能有哪些？</li></ul><p> 维护函数map</p><p> 客户端传来的东西进行解析</p><p> 函数的返回值打包，传给客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明服务端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">   conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn net.Conn)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Client&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现通用的RPC客户端</span></span><br><span class="line"><span class="comment">// 传入访问的函数名</span></span><br><span class="line"><span class="comment">// fPtr指向的是函数原型</span></span><br><span class="line"><span class="comment">//var select fun xx(User)</span></span><br><span class="line"><span class="comment">//cli.callRPC("selectUser",&amp;select)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">callRPC</span><span class="params">(rpcName <span class="keyword">string</span>, fPtr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 通过反射，获取fPtr未初始化的函数原型</span></span><br><span class="line">   fn := reflect.ValueOf(fPtr).Elem()</span><br><span class="line">   <span class="comment">// 需要另一个函数，作用是对第一个函数参数操作</span></span><br><span class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">      <span class="comment">// 处理参数</span></span><br><span class="line">      inArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">      <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">         inArgs = <span class="built_in">append</span>(inArgs, arg.Interface())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 连接</span></span><br><span class="line">      cliSession := NewSession(c.conn)</span><br><span class="line">      <span class="comment">// 编码数据</span></span><br><span class="line">      reqRPC := RPCData&#123;Name: rpcName, Args: inArgs&#125;</span><br><span class="line">      b, err := encode(reqRPC)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      err = cliSession.Write(b)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 服务端发过来返回值，此时应该读取和解析</span></span><br><span class="line">      respBytes, err := cliSession.Read()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解码</span></span><br><span class="line">      respRPC, err := decode(respBytes)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理服务端返回的数据</span></span><br><span class="line">      outArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(respRPC.Args))</span><br><span class="line">      <span class="keyword">for</span> i, arg := <span class="keyword">range</span> respRPC.Args &#123;</span><br><span class="line">         <span class="comment">// 必须进行nil转换</span></span><br><span class="line">         <span class="keyword">if</span> arg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// reflect.Zero()会返回类型的零值的value</span></span><br><span class="line">            <span class="comment">// .out()会返回函数输出的参数类型</span></span><br><span class="line">            outArgs = <span class="built_in">append</span>(outArgs, reflect.Zero(fn.Type().Out(i)))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         outArgs = <span class="built_in">append</span>(outArgs, reflect.ValueOf(arg))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> outArgs</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 完成原型到函数调用的内部转换</span></span><br><span class="line">   <span class="comment">// 参数1是reflect.Type</span></span><br><span class="line">   <span class="comment">// 参数2 f是函数类型，是对于参数1 fn函数的操作</span></span><br><span class="line">   <span class="comment">// fn是定义，f是具体操作</span></span><br><span class="line">   v := reflect.MakeFunc(fn.Type(), f)</span><br><span class="line">   <span class="comment">// 为函数fPtr赋值，过程</span></span><br><span class="line">   fn.Set(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实现RPC客户端"><a href="#7-实现RPC客户端" class="headerlink" title="7. 实现RPC客户端"></a><strong>7.</strong> 实现RPC客户端</h3><p>客户端只有函数原型，使用reflect.MakeFunc() 可以完成原型到函数的调用</p><p> reflect.MakeFunc()是Client从函数原型到网络调用的关键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明服务端</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">   conn net.Conn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(conn net.Conn)</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Client&#123;conn: conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现通用的RPC客户端</span></span><br><span class="line"><span class="comment">// 传入访问的函数名</span></span><br><span class="line"><span class="comment">// fPtr指向的是函数原型</span></span><br><span class="line"><span class="comment">//var select fun xx(User)</span></span><br><span class="line"><span class="comment">//cli.callRPC("selectUser",&amp;select)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">callRPC</span><span class="params">(rpcName <span class="keyword">string</span>, fPtr <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 通过反射，获取fPtr未初始化的函数原型</span></span><br><span class="line">   fn := reflect.ValueOf(fPtr).Elem()</span><br><span class="line">   <span class="comment">// 需要另一个函数，作用是对第一个函数参数操作</span></span><br><span class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">      <span class="comment">// 处理参数</span></span><br><span class="line">      inArgs := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="built_in">len</span>(args))</span><br><span class="line">      <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">         inArgs = <span class="built_in">append</span>(inArgs, arg.Interface())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 连接</span></span><br><span class="line">      cliSession := NewSession(c.conn)</span><br><span class="line">      <span class="comment">// 编码数据</span></span><br><span class="line">      reqRPC := RPCData&#123;Name: rpcName, Args: inArgs&#125;</span><br><span class="line">      b, err := encode(reqRPC)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      err = cliSession.Write(b)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 服务端发过来返回值，此时应该读取和解析</span></span><br><span class="line">      respBytes, err := cliSession.Read()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解码</span></span><br><span class="line">      respRPC, err := decode(respBytes)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理服务端返回的数据</span></span><br><span class="line">      outArgs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="built_in">len</span>(respRPC.Args))</span><br><span class="line">      <span class="keyword">for</span> i, arg := <span class="keyword">range</span> respRPC.Args &#123;</span><br><span class="line">         <span class="comment">// 必须进行nil转换</span></span><br><span class="line">         <span class="keyword">if</span> arg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// reflect.Zero()会返回类型的零值的value</span></span><br><span class="line">            <span class="comment">// .out()会返回函数输出的参数类型</span></span><br><span class="line">            outArgs = <span class="built_in">append</span>(outArgs, reflect.Zero(fn.Type().Out(i)))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         outArgs = <span class="built_in">append</span>(outArgs, reflect.ValueOf(arg))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> outArgs</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 完成原型到函数调用的内部转换</span></span><br><span class="line">   <span class="comment">// 参数1是reflect.Type</span></span><br><span class="line">   <span class="comment">// 参数2 f是函数类型，是对于参数1 fn函数的操作</span></span><br><span class="line">   <span class="comment">// fn是定义，f是具体操作</span></span><br><span class="line">   v := reflect.MakeFunc(fn.Type(), f)</span><br><span class="line">   <span class="comment">// 为函数fPtr赋值，过程</span></span><br><span class="line">   fn.Set(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-实现RPC通信测试"><a href="#8-实现RPC通信测试" class="headerlink" title="8. 实现RPC通信测试"></a><strong>8.</strong> 实现RPC通信测试</h3><p> 给服务端注册一个查询用户的方法，客户端使用RPC方式调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rpc_</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    给服务端注册一个查询用户的方法，客户端使用RPC方式调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户对象</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于测试用户查询的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryUser</span><span class="params">(uid <span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span> &#123;</span><br><span class="line">   user := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]User)</span><br><span class="line">   <span class="comment">// 假数据</span></span><br><span class="line">   user[<span class="number">0</span>] = User&#123;<span class="string">"zs"</span>, <span class="number">20</span>&#125;</span><br><span class="line">   user[<span class="number">1</span>] = User&#123;<span class="string">"ls"</span>, <span class="number">21</span>&#125;</span><br><span class="line">   user[<span class="number">2</span>] = User&#123;<span class="string">"ww"</span>, <span class="number">22</span>&#125;</span><br><span class="line">   <span class="comment">// 模拟查询用户</span></span><br><span class="line">   <span class="keyword">if</span> u, ok := user[uid]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> u, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> User&#123;&#125;, fmt.Errorf(<span class="string">"%d err"</span>, uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRPC</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 编码中有一个字段是interface&#123;&#125;时，要注册一下</span></span><br><span class="line">   gob.Register(User&#123;&#125;)</span><br><span class="line">   addr := <span class="string">"127.0.0.1:8000"</span></span><br><span class="line">   <span class="comment">// 创建服务端</span></span><br><span class="line">   srv := NewServer(addr)</span><br><span class="line">   <span class="comment">// 将服务端方法，注册一下</span></span><br><span class="line">   srv.Register(<span class="string">"queryUser"</span>, queryUser)</span><br><span class="line">   <span class="comment">// 服务端等待调用</span></span><br><span class="line">   <span class="keyword">go</span> srv.Run()</span><br><span class="line">   <span class="comment">// 客户端获取连接</span></span><br><span class="line">   conn, err := net.Dial(<span class="string">"tcp"</span>, addr)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 创建客户端对象</span></span><br><span class="line">   cli := NewClient(conn)</span><br><span class="line">   <span class="comment">// 需要声明函数原型</span></span><br><span class="line">   <span class="keyword">var</span> query <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(User, error)</span></span></span><br><span class="line">   cli.callRPC(<span class="string">"queryUser"</span>, &amp;query)</span><br><span class="line">   <span class="comment">// 得到查询结果</span></span><br><span class="line">   u, err := query(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"err"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RPC和GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFT拜占庭问题</title>
      <link href="/2020/04/09/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/09/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="The-Byzantine-Generals-Problem"><a href="#The-Byzantine-Generals-Problem" class="headerlink" title="The Byzantine Generals Problem"></a><strong>The Byzantine Generals Problem</strong></h3><p>​        可靠的计算机系统必须处理会向系统的不同部分提供冲突信息的故障组件。这种情况可以用拜占庭军队的将军和他们的部队围困在敌方城市附近来概括地表达。 将军们只能通过使者交流，他们必须商定共同的战斗计划。 但是，其中一个或多个可能是叛徒，他们会试图混淆其他人。 问题是找到一种算法来确保忠实的将军们达成共识。 结果表明，仅在口头表达的情况下，只有并且只有三分之二以上的将军忠诚时，这个问题才能解决。 所以一个叛徒可以混淆两个忠实的将军。 有了不可伪造的书面信息，这个问题对于任何数量的将军和可能的叛徒来说都是可以解决的。 然后讨论该解决方案在可靠的计算机系统中的应用。</p><a id="more"></a><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p>​        可靠的计算机系统必须能够应对一个或多个组件的故障。 发生故障的组件可能表现出一种通常被忽略的行为，即，将冲突的信息发送到系统的不同部分。 应对此类故障的问题抽象表示为拜占庭将军问题。 我们将本文的主要部分专门讨论了这个抽象问题，并通过指出如何将我们的解决方案用于实现可靠的计算机系统来进行总结。 我们假设拜占庭军队的几个师驻扎在一个敌方城市之外，每个师由其自己的将军指挥。将军只能通过使者相互沟通。 观察敌人之后，他们必须决定共同的行动计划.但是，有些将军可能是叛徒，试图阻止忠实的将军达成协议。<br>将军们必须有一种算法来保证:</p><p><strong>A.所有忠实的将军都决定相同的行动计划。</strong></p><p>​      忠实的将军都会按照算法说的去做，但是叛徒可以做他们想做的任何事情。无论叛徒做什么，该算法都必须保证条件A。忠实的将军们不仅应该达成协议，而且应该就合理的计划达成协议。因此，我们还想确保</p><p><strong>B.少数叛徒不会使忠诚的将军们采取错误的计划。</strong><br>​       条件B很难形式化，因为它需要准确说出一个不好的计划，我们不会尝试这样做。相反，我们考虑将军们如何做出决定。每个将军观察敌人并将他的观察力传达给其他人。令v（i）为第i个将军传达的信息。每个将军使用某种方法将值v（1）….. v（n）组合到一个单独的行动计划中，其中n是将军的数量。<strong>条件A</strong>通过让所有将军使用相同的方法来组合信息来实现，条件B通过使用鲁棒的方法来实现。例如，如果要做出的唯一决定是进攻还是撤退，则v（i）将是通过将军 <code>i</code>认为哪种选择最好的决定，而最终决定可以基于其中的多数票。只有忠实的将军在两种可能性之间几乎均等地划分时，少数叛徒才会影响决策。</p><p>​       虽然这种方法可能不是满足条件 A 和 B 的唯一方法，但它是我们所知道的唯一方法。它假定将军们用一种方法彼此交流他们的信息V(i)。显而易见的方法是通过信使相互发送 v(i)。然而，这不起作用，因为满足条件 A要求每个忠诚的将军获得相同的值 v(1)..V(n)。一个叛国的将军可以给不同的将军发出不同的价值观。要满足条件 B，下列条件必须满足:</p><p><strong>1.每个忠诚的将军都必须获得相同的信息。</strong>一致性</p><p>​       条件 1 意味着一个将军不一定能直接使用从第一个将军那里得到的 v(i)值，因为一个叛国的将军可以给不同的将军发送不同的值。这意味着，如果我们不小心，在满足条件 1 的情况下，我们可能会引入一种可能性，即将军们使用的 v(i)值不同于第一个将军发出的 v(i)值——即使第一个将军是忠诚的。如果要满足条件 b，我们就不能允许这种情况发生。例如，如果每一个忠诚的将军都发出“进攻”的信号，我们就不能允许少数叛徒使忠诚将军以“撤退”、“……”、“撤退”的信号为基础作出决定。因此，我们对每个 i 都有以下要求:</p><p><strong>2.如果第i个将军是忠诚的，那么他发送的值必须被每个忠诚的将军用作 v(i)的值。</strong>正确性    </p><p>我们可以重写条件 i 作为条件，即对于每一个 i(不管第一个将军是否忠诚)，1’。任何两个忠诚的将军使用相同的价值 v(i)。条件 1’和 2 都是由第 i 个将军发送的单个值的条件。因此，我们可以考虑限制在一个将军如何把他的信息传递给其他将军的问题上。我们用一个指挥官向他的副官们发出命令的方式来表达这个意思，得到以下的问题。</p><p><strong>拜占庭将军问题指挥官必须向他的n-1中将下达命令</strong></p><p><strong>IC1. 所有忠诚的副官都遵守同样的命令。</strong></p><p><strong>IC2.如果指挥官是忠诚的，那么每个忠诚的中尉都会服从他发出的命令。</strong></p><p>​        条件 IC1 和 IC2 称为交互式一致性条件。请注意，如果指挥官是忠诚的，那么 IC1就跟随 IC2。然而，指挥官并不需要忠诚。<br>​        为了解决我们最初的问题，第一位将军用一个解决方案向拜占庭将军问题发出命令，“使用 v(i)作为我的信息”，其他将军充当中尉，从而发出 v(i)的价值。</p><h3 id="2-不可能的结果"><a href="#2-不可能的结果" class="headerlink" title="2.不可能的结果"></a>2.不可能的结果</h3><p>​        拜占庭将军问题看起来简单得让人难以置信。如果将军们只能发送口头信息，那么除非三分之二以上的将军们忠诚，否则任何解决方案都不会奏效。特别是，只有三个将军，没有任何解决办法可以在一个单一的叛徒存在。口头信息的内容完全在发送者的控制之下，因此叛国的发送者可以传递任何可能的信息。这种信息对应于计算机通常互相发送的信息类型。在第四部分，我们考虑签名的，书面的协议，因此这不是真的。</p><p>​        我们现在表明，口头信息没有解决三个将军可以处理一个叛徒。为简单起见，我们考虑这样一种情况，即唯一可能的决定是“进攻”或“撤退”。让我们首先看看图</p><ul><li>司令是忠诚的</li></ul><img src="./images/bft1.png" style="zoom:80%;" /><p>​        图1 中的场景，在这个场景中，指挥官是忠诚的，并且发出了一个“攻击”命令，但是中尉2 是一个叛徒，并且向中尉 1 报告他收到了一个“撤退”命令。为了满足<code>IC2</code> (所有忠诚的副官都遵守同样的命令)的要求，中尉 1 必须服从进攻命令。</p><ul><li>司令是叛徒</li></ul><img src="./images/bft2.png" style="zoom:80%;" /><p>​        现在考虑另一个场景，如图 2 所示，其中指挥官是一个叛徒，向中尉 1 发出一个“攻 击”命令，向中尉 2 发出一个“撤退”命令。中尉 1 不知道谁是叛徒，他不能告诉什么信息的指挥官实际上发送给中尉 2。因此，这两张图片中的场景在中尉 1 看来完全相同。如果叛徒一贯说谎，那么中尉 1 就没有办法区分这两种情况，所以他必须服从“攻击”命令在他们两个。因此，每当中尉一号接到指挥官的“攻击”命令时，他必须服从。<br>​        然而，一个类似的论点表明，如果中尉 2 接到指挥官的“撤退”命令，那么他必须服从命令，即使中尉 1 告诉他指挥官说“进攻”。因此，在图 2 的场景中，中尉 2 必须服从“撤退”命令，而中尉 1 服从“攻击”命令，因此违反了条件 IC1。因此，三个将军在一个叛徒面前工作是没有解决办法的。<br>​        这个论点可能看起来令人信服，但是我们强烈建议读者对这种非严格的推理非常怀疑。虽然这个结果确实是正确的，但我们已经看到了同样似是而非的无效结果的“证明”.我们知道在计算机科学或数学中，没有一个领域的非正式推理比这类算法的研究更容易导致错误。为了严格证明可以处理单个叛逆者的三通解是不可能的，我们请读者参考[3]。<br>​        <strong>利用这个结果，我们可以证明少于 3m+1 个将军的解决方案不能应付 m个 叛徒。</strong>更确切地说，三个或更多的将军不存在这样的解决方案，因为这个问题对两个将军来说是微不足道的。<br>​        解一组 3m 或更少的问题，然后用它构造一个拜占庭将军问题的三通解，这是我们知道不可能的。为了避免两种算法之间的混淆，我们称<strong>假设</strong>解的将军为阿尔巴尼亚将军，<strong>构造</strong>解的将军为拜占庭将军。因此，从允许 300 万或更少的阿尔巴尼亚将军对付 300 万叛徒的算法出发，我们构造了一个允许三个拜占庭将军对付一个叛徒的解决方案。</p><p>​        通过让拜占庭的每一位将军模拟大约三分之一的阿尔巴尼亚将军，得到三个一般解，这样每一位拜占庭将军模拟的阿尔巴尼亚将军最多不超过万人。拜占庭指挥官模拟阿尔巴尼亚指挥官和最多 m-1 阿尔巴尼亚中尉，两个拜占庭中尉模拟最多m 阿尔巴尼亚中尉。因为只有一个拜占庭将军可以成为叛徒，而且他假装最多亿阿尔巴尼亚人，最多亿阿尔巴尼亚将军是叛徒。因此，假定的解决办法保证了 IC1 和IC2 对阿尔巴尼亚将军们适用。通过 IC1，所有的阿尔巴尼亚中尉被忠诚的拜赞廷中尉模仿，服从同样的命令，这是他必须服从的命令。阿尔巴尼亚将军解的 IC1 和IC2 条件是否暗示了拜占庭将军解的相应条件是很容易验证的，因此我们构造了所需的不可能解。</p><p>​        有人可能会认为，解决拜占庭将军问题贸易协定的困难源于达成确切协议的要求。我们现在通过表明达成近似协议与达成确切协议同样困难来证明情况并非如此。让我们假设，将军们不是试图商定一个精确的作战计划，而是必须商定一个大约的进攻时间。更确切地说，我们假设指挥官命令进攻的时间，我们要求保持以下两个条件：</p><p>​        IC1’. 所有忠诚的副官在 10 分钟内互相攻击。</p><p>​        IC2’.如果指挥官是忠诚的，那么每个忠诚的中尉都会在指挥官命令的 10 分钟内发动攻击。</p><p>(我们假设命令是在攻击前一天发出和处理的，接收命令的时间与此无关——只是命令中给出的攻击时间有关。)</p><p>​        像拜占庭将军问题一样，这个问题是无法解决的，除非超过三分之二的将军是忠诚的。我们首先证明了这一点，如果对付一个叛徒的三个将军有一个解决方案，那么我们就可以构造一个对付一个叛徒的拜占庭将军问题的三个通用解决方案。假设指挥官希望发出“进攻”或“撤退”的命令。他通过发送 1:00 的攻击时间命令攻击，并使用假定的算法发送 2:00 的攻击时间命令撤退。每个中尉使用以下程序获得他的命令。</p><p>​    (1) 在收到指挥官的攻击时间后，一名中尉做了以下事情之一:</p><p>​        (a) 如果时间是 1:10 或更早，然后攻击。</p><p>​        (b) 如果时间是 1:50 或更晚，那么就撤退。</p><p>​        (c)否则，继续步骤(2)。IC2`</p><p>​    (2) 问问另一个中尉，他在第(1)步做了什么决定。</p><p>​        (a)如果另一个中尉做出了决定，那么就做出和他一样的决定。</p><p>​        (b) 否则，就撤退。</p><p>​        根据 IC2’，如果指挥官是忠诚的，那么忠诚的中尉将在步骤(1)中获得正确的顺序，因此 IC2 是满意的。如果指挥官是忠诚的，那么 IC1 就跟随 IC2，所以我们只需要在指挥官是叛徒的假设下证明 IC1。因为最多只有一个叛徒，这意味着两个副手都是忠诚的。因此，如果一个中尉决定第(1)步进攻，那么另一个中尉不能决定第(1)步撤退。因此，要么他们都会在步骤(1)中做出相同的决定，要么他们中至少有一个会推迟到步骤(2)再做决定。在这种情况下，很容易看到它们都得到了相同的决定，因此 IC1 是满意的。因此，我们构建了一个拜占庭将军问题的三通解决方案来处理一个叛徒，这是不可能的。因此，我们不能有一个三通用的算法来维护 ICI’和 IC2’的存在一个叛徒。</p><p>现在可以用一般模拟法证明少于 3m+1 的解决方案不能对付 m 个叛徒。这个证明与原始拜占庭将军问题的证明相似，由读者自己去证明。</p><h3 id="3-口头信息的解决方案"><a href="#3-口头信息的解决方案" class="headerlink" title="3.口头信息的解决方案"></a>3.口头信息的解决方案</h3><p>​        我们在上面展示了一个用口头信息来对付拜占庭将军问题叛徒的解决方案，必须至少有 3 百万+1 个将军。我们现在给出了一个对 3 百万+1 或更多的将军有效的解决方案。然而，我们首先确切地说明“口头信息”是什么意思。每个将军都应该执行一些算法，包括向其他将军发送消息，我们假设一个忠诚的将军正确地执行他的算法。<strong>定义口头信息</strong>体现在我们对将军信息系统的下列假设中:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A1</span>. 每条发送的信息都被正确传递。</span><br><span class="line"><span class="built_in">A2</span>. 信息的接收者知道是谁发送的。</span><br><span class="line"><span class="built_in">A3</span>. 可以检测到消息的缺失。</span><br></pre></td></tr></table></figure><p>假设 A1 和 A2 防止叛徒干扰其他两位将军之间的通讯，因为通过 A1 他不能干扰他们发送的信息，通过 A2 他不能通过引入虚假信息来混淆他们之间的交流。假设 A3 将挫败一个试图仅仅通过不发送信息来阻止一个决定的叛徒。这些假设的实际应用将在第 6 节中讨论。</p><p>​        本节和下面的算法要求每个通用程序都能够直接向其他通用程序发送消息。在第 5节中，我们描述了不具备这一要求的算法。叛国指挥官可以决定不下达任何命令。由于中尉们必须服从一些命令，在这种情况下，他们需要一些默认命令来服从。我们让 retreat 是这个默认顺序。</p><p>​        我们归纳性地定义了所有非负整数的<strong>口头协议算法 OM(m)</strong>，通过这些算法，指挥官可以向 n-1 中尉发送命令。我们证明 OM(m)在最多 m 叛徒面前解决 3m+1 或更多的将军的拜占庭将军问题。我们发现用“获得一个值”而不是“服从一个值”来描述这个算法更方便排序”.</p><p>该算法假设函数 majority 具有如下性质:如果大多数值 vi = v，则 majority(V1,…..,Vn)=v .(实际上，它假定了一系列这样的函数——每个 n )对于函数majority(V1,…Vn)的值有<strong>两个自然的选择:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 如果大多数值中存在vi，否则为 retreat;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 假设它们来自一个有序集合,选择中位数 vi 。</span><br></pre></td></tr></table></figure><p>下面的算法只需要上述的majority（）性质。</p><p><code>Algorithm OM(0).</code></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 指挥官把他的价值传递给每个中尉。</span><br><span class="line">(<span class="number">2</span>) 每个中尉使用他从指挥官那里得到的价值，或者如果他没有得到价值就使用 RETREAT。</span><br></pre></td></tr></table></figure><p><code>Algorithm OM(m), m &gt; O</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 指挥官把他的价值传递给每个中尉。</span><br><span class="line">(<span class="number">2</span>)对每一个中尉<span class="built_in">i</span>,令vi为中尉<span class="built_in">i</span>收到的命令，如果没有收到则使用撤退。中尉<span class="built_in">i</span>作为算法OM(m<span class="number">-1</span>) 的指挥官，发送vi给余下的n<span class="number">-2</span>个将领。</span><br><span class="line">(<span class="number">3</span>)对每一个 <span class="built_in">i</span>和<span class="built_in">j</span>(<span class="built_in">i</span>！=<span class="built_in">j</span>),令vj为第二步（<span class="number">2</span>）将领<span class="built_in">i</span>从将领<span class="built_in">j</span>获得的信息，如果没有收到则使用撤退。将领<span class="built_in">i</span>使用majority（v1 ,…,vn<span class="number">-1</span>）的值作为最终命令值。</span><br></pre></td></tr></table></figure><p>​        为了理解这个算法是如何工作的，我们考虑 m=1，n=4 的情况。图 3 展示了当指挥官发送值v 而中尉 3 是叛徒时，中尉 2 接收到的消息。在 OM(1)的第一步中，指挥官向所有三名中尉发送 v。在第二步中，Lieutenant1 使用平凡算法 OM(0)将值 v 发送给 Lieutenant2。同样在第二个步骤中，叛变的中尉 3 给中尉 2 一些其他的值 x。在步骤 3 中，中尉 2 然后有 v1=v2 和v3=x，所以他得到正确的value  v = majority ( v , v, x) .值 v=majorty(v，v，x)。证明过程<a href="https://www.jianshu.com/p/538e6c9fac81" target="_blank" rel="noopener">https://www.jianshu.com/p/538e6c9fac81</a></p><p>​        接下来，我们看看如果指挥官是叛徒会发生什么。图 4 显示了如果一个叛变的指挥官将三个任意值 x、y 和 z 发送给三个中尉，中尉们所接收到的值。每个中尉得到v1 = x, v2 = y, and v3 = z, 因此在步骤(3)中它们都得到相同的值majority(x，y，z)，不管这三个值 x，y 和 z 是否相等。</p><p>图3：副官是叛徒</p><p><strong>第一步</strong>：司令向每个副官发送他的值vvv给每个副官；<br><strong>第二步</strong>：副官1执行OM(0)，作为司令向副官2发送v；由于副官3是叛徒，其执行OM(0)向副官2发送了不同的值，假设为x；<br><strong>第三步</strong>：副官2拥有的行动值集为{v1,v2,v3}={v,v,x}，采用majority函数，副官2采取的行动v=majority{v1,v2,v3}</p><p>同理，副官1采取的行动指令也是v，即满足拜占庭将军问题一致性条件IC1和IC2。</p><img src="./images/bft3.png" style="zoom:150%;" /><p>图4：将军是叛徒</p><p><strong>第一步</strong>：司令为了阻止忠诚副官达成一致，分别向三位副官发送值{x,y,z}{x, y, z}{x,y,z};<br><strong>第二步</strong>：每个副官从司令收到的值作为自己的值，并执行OM(0)向其他副官发送；<br><strong>第三步</strong>：在第三步中，每个副官拥有的值集均为{x,y,z}{x, y, z}{x,y,z}，因此，副官执行行动函数majority得到的结果是一样的。</p><p>由于三位忠诚的将军采取同样的行动，满足拜占庭将军一致性条件IC1。</p><p><strong>从m=1, n=4的例子可以看出，OM(m)算法能够处理拜占庭将军问题。递归算法 OM(m)调用算法 OM(m-1)的 n-1 个独立执行，每个执行都调用 OM(m-2)等的 n- 2 个执行。</strong>这意味着，对于 m&gt;1，一个中尉会给彼此发送许多不同的信息。必须有某种方法来区分这些不同的信息。读者可以验证，如果每个中尉 i 在步骤(2)中将数字 i 前缀为他发送的值 vi，那么所有的模糊性都消除了。随着递归的“展开”，算法 OM(m-k)将被调用(n-1)…(n-k)次，以发送一个以 k 中尉的数字序列为前缀的值。</p><p><strong>为了证明算法<em>OM</em>(<em>m</em>)，</strong>对任意的<em>m</em>,的正确性。首先证明以下引理。<br>Lemma1. 对任意的<em>m</em>和<em>k</em>,如果将军个数大于2<em>k</em>+<em>m</em>，有最多<em>k</em>个叛徒，算法 <em>OM</em>(<em>m</em>)满足IC2 。<br><strong>证明：针对<em>m</em>的取值情况进行分析。</strong><br>    1.<em>m</em>= 0，忠诚的将军只要服从将军的命令就可以了，引理成立。<br>    2.假设<em>m</em>-1，<em>m</em>&gt;0,时算法满足IC2，证明对<em>m</em> 成立。（归纳法）<br>算法第一步（1），忠诚的司令发送值<em>v</em>给<em>n</em>-1个将领。第二步（2），每一个忠诚的将领调用算法OM(<em>m</em>-1)。<br><em>n</em>&gt;2<em>k</em>+<em>m</em> =&gt; <em>n</em>-1&gt;2<em>k</em>+(<em>m</em> -1)&gt;2<em>k</em>，多数的将领是忠诚的，每一个忠诚的将领得到一个<em>v</em>i=<em>v</em> 从<em>n</em>-1个值<em>i</em>中，在第三步majority(<em>v</em>1,…,<em>v</em>n-1)=<em>v</em>，满足IC2.</p><p>证明算法成立的定理1：<br>Theorem1.对任意的<em>m</em>,在人数大于3<em>m</em>，有<em>m</em>个叛徒的情况下，算法<em>OM</em>(<em>m</em>)满足条件IC1和条件IC2。<br><strong>证明：针对<em>m</em>的取值情况进行分析</strong>。<br>    1.<em>m</em>= 0，定理成立。<br>    2.假设<em>m</em>-1，<em>m</em>&gt;0,时成立，证明对<em>m</em> 成立。（归纳法）<br>在司令忠诚的情况下，令<em>m</em>=<em>k</em>,根据引理1可知，IC2成立从而IC1成立。<br>所以只需要证明司令是叛徒的情况。有最多<em>m</em>个叛徒，司令为其中一个，所以还有<em>m</em>-1个将领是叛徒。人数大于3<em>m</em>,所以将领人数大于3<em>m</em>-1。<br>3<em>m</em>-1&gt;3(<em>m</em>-1)<br>使用归纳假设法证明<em>OM</em>(<em>m</em>-1)满足条件CI1和CI2。因此，在第三步，对每一个<em>j</em>,任意两个忠诚的将军获得相同的值<em>vj<em>。从而任意两个忠诚的将军获得相同的值 在函数majority(</em>v<em>1,…,</em>v**n</em>-1)在第三步，IC1的证。</p><h3 id="4-带签名信息的解决方案"><a href="#4-带签名信息的解决方案" class="headerlink" title="4.带签名信息的解决方案"></a>4.带签名信息的解决方案</h3><p>正如我们在图 1 和图 2 中看到的场景，正是叛徒撒谎的能力使得拜占庭将军问题变得如此困难。如果我们能够限制这种能力，问题就会变得更容易解决。一种方法是允许将军们发送不可伪造的签名信息。更确切地说，我们在 A1-A3以下假设:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A<span class="number">4</span> <span class="comment">(a)</span> 忠诚的将军的签名是不能伪造的，并且可以检测到他签名信息内容的任何变更。</span><br><span class="line">   <span class="comment">(b)</span> 任何人都可以核实将军签字的真实性。</span><br><span class="line">   请注意，我们对叛国将军的签名不做任何假设。特别是，我们允许另一个叛徒伪造他的签名，从而允许叛徒之间相互勾结。</span><br></pre></td></tr></table></figure><p>现在，我们已经介绍了签名信息，我们以前的论点，即四个将军必须处理一个叛徒不再成立。事实上，确实存在三个通用解决方案。我们现在给出了一个算法，可以处理任意数量的将军的万叛徒。(如果少于 m+2 个将军，问题就是空洞的。)<br>在我们的算法中，指挥官向每个副官发送一个签名命令。然后每个中尉在命令上签名，并将其发送给其他中尉，中尉再加上他们的签名，然后再发送给其他人，如此类推。这意味着中尉必须有效地接收一条签名信息，复制几份，并签名和发送这些副本。如何获得这些副本并不重要;一条消息可能是复印的，或者每条消息可能由一堆相同的消息组成，这些消息根据需要进行了签名和分发。</p><p>算法定义一个选择函数choice,其在一个集合命令信息中选出一个，如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果集合V只有一个值v,Choice<span class="comment">(V)</span> = v。</span><br><span class="line"><span class="number">2.</span>choice<span class="comment">(∅)</span> = RETREAT<span class="comment">(撤退)</span>。空集情况下。</span><br></pre></td></tr></table></figure><p>​    可以注意到，可选择中值为函数的值。                                </p><p><strong>定义</strong></p><p><em>x</em>:<em>i</em> 表示被将军<em>i</em>签名的值<em>x</em> ，则<em>v</em>:<em>j</em>:<em>i</em> 表示值<em>v</em>被将军<em>j</em>签名以后，然后又被将军<em>i</em>签名。令将军0号为命令的发送者。在算法里每一个将领<em>i</em>都有一个集合<em>Vi</em> ,集合里面包括他收到的被其他将军签名的信息。<br>算法<em>SM</em>(<em>m</em>).<br>初始化 <em>Vi</em> =∅.<br><strong>(1)司令发送其签名信息<em>v</em>:0给每一个将领。</strong><br><strong>(2)对每一个将领<em>i</em> ：</strong><br>    (A)如果将领 <em>i</em> 收到从司令<em>v</em>:0，且其<em>Vi</em> =∅。 其操作如下：</p><p>​        (i)他令其<em>Vi</em> ={<em>v</em>}；<br>​        (ii)他发送<em>v</em>:0：<em>i</em>给每一个其他的将领.<br>​    (B)如果将领 <em>i</em> 收到信息<em>v</em>:0：<em>j1</em>:…:<em>jk</em> ,且<em>v</em>∉<em>Vi<em>，则：<br>​        (i)他将</em>v<em>加入自己的集合</em>Vi<em>；<br>​        (ii)如果</em>k</em>&lt;<em>m</em>,则其发送<em>v</em>:0：<em>j1</em>:…:<em>jk</em>:<em>i</em> 给其他的将领∉<em>j1</em>，…，<em>jk</em>。</p><p><strong>(3)对每一个将领<em>i</em> ：当将领<em>i</em> 不再收到信息后，其遵守choice(<em>Vi</em>)</strong></p><p>注意，在第二步中，副官i将忽略任意值已经在Vi出现的消息。通过对k的归纳，对于每个副官序列j1,…,jk , 且k&lt;m，每个副官至多收到一条v:0:j1:…:jk 消息。在第(3)步中可以使用超时来判断没有消息再回到来。</p><p><strong>举例： m=1, n=3</strong></p><p><img src="./images/bft4.png" alt="">        注意在第(1)步，司令发送发送“attack”给副官1并发送“retreat”给副官2；<br>在第(2)步，每个副官将收到两个命令值，即V1=V2={&quot;attack&quot;,&quot;retreat&quot;}<br>在第(3)步，两个忠诚的副官执行choice(Vi得到的结果也是一样的。</p><p>因此，当司令叛徒时，算法满足条件IC1。</p><p>当司令是忠诚的时，叛徒副官无法篡改司令的命令，因此忠诚的副官的行动值集Vi只有一个元素，即司令发送的命令。因此，SM(m)算法满足条件IC1和IC2。</p><p><strong>定理2</strong>.对任意的<em>m</em>，在至多<em>m</em>个叛徒的情况下，算法<em>SM</em>(<em>m</em>)解决拜占庭问题。<br>证明，在司令是忠诚的情况下，没有信息可被篡改。显然成立。<br>在司令是叛徒的情况下，需要证明IC1成立，则任意两个忠诚的将领<em>i</em>和<em>j</em>将遵循第三步获得的一致的命令。所以必须证明 将领<em>i</em>和<em>j</em>在第二步将相同的命令信息放进自己的集合。情况分析,可得有以下两种情况，如果将军<em>i</em>获得信息<em>v</em>,他把信息发送给将军<em>j</em>。如果将军<em>i</em>获得信息<em>v</em>：0：<em>j1</em>:…:<em>jk</em> ，且<em>j</em>在签名当中，则<em>j</em>已经把值<em>v</em>放进自己的集合。如果<em>j</em>不在签名当中,分析两种情况：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>k&lt;m.将军<span class="built_in">i</span>将会发送信息v：<span class="number">0</span>：j1:…:jk :<span class="built_in">i</span>给将军<span class="built_in">j</span> ,所以<span class="built_in">j</span>获得信息v.</span><br><span class="line"><span class="number">2.</span>k=m.因为司令是叛徒，且有m<span class="number">-1</span>个将领也是叛徒。所以在j1,…,jm 至少有一个将领是忠诚的。这个忠诚的将领必定有将获得的v值发送给将领 <span class="built_in">j</span>，当他第一次收到这个信息的时候，将领<span class="built_in">j</span>,必定收到信息。</span><br></pre></td></tr></table></figure><p>证明结束。</p><h3 id="5-通讯路径缺失"><a href="#5-通讯路径缺失" class="headerlink" title="5.通讯路径缺失"></a>5.通讯路径缺失</h3><p>​    到目前为止，我们假设一个将军可以直接向其他所有将军发送消息。我们现在移除这个假设。相反，我们认为物理障碍对谁可以向谁发送信息设置了一些限制。我们认为将军构成一个简单的 2 个有限无向图 g 的节点，其中两个节点之间的弧表示这两个将军可以发送消息</p><p>2 一个简单图是这样一个图，其中最多有一条弧连接任意两个节点，每条弧连接两个不同的节点。</p><p>接下来 对算法<em>OM</em>(<em>m</em>)和<em>SM</em>(<em>m</em>)进行拓展，<em>G</em> 为全联通图。<br>首先对算法<em>OM</em>(<em>m</em>)进行拓展，给出以下定义：</p><p><strong>定义1.</strong></p><p>(a)节点集合{<em>i</em>1 ,…,<em>ip</em>}为节点<em>i</em>的正则邻接集，满足：<br>        (i)每一个<em>i j*都邻接点 *i</em><br>        (ii)对任意的将军 <em>k</em> （<em>k</em> 和 <em>i</em> 不相等），则有路径 <em>γj,k</em> ,从 <em>ij</em> 到 <em>k</em> 无需通过 <em>i</em>，且任意两条路径 <em>γj,k</em> 除了节点 <em>k</em> 没        有共同节点。<br>(b)图 <em>G</em> 是 <em>p</em>正则的 ，如果每个节点的正则集都有 <em>p</em> 个不同的节点。<br>如图所示，图六是 3-正则图，每个节点有三个度（三条边）。<br>图七 不是 3-正则图 ，中间节点有四条边。</p><p><img src="./images/bft5.png" alt=""></p><p><strong>拓展的<em>OM</em>(<em>m</em>,<em>p</em>)算法</strong></p><p><em>m</em>个叛徒 ，<em>G</em> 为 3-正则图。（注意到， 3<em>m</em>-正则图 必至少含有 3<em>m</em> +1 个节点 ）。对任意的正整数 <em>m</em> , <em>p</em> 。且将军通信情况构成 <em>p</em>-正则图。通过分析 <em>m</em> 如下：<br>算法 <em>OM</em>(<em>m</em>,<em>p</em>).<br>        (0)选择司令（commander）的正则邻接集 <em>N</em> (含有 <em>p</em> 个 将领)。p为3<br>        (1) 司令将信息发送给集合 <em>N</em> 里的每一个将领。<br>        (2)对每一个 <em>i</em> ∈ <em>N</em> ，令 <em>vi</em> 为 将领 <em>i</em> 收到的从司令发过来的命令，或者没有收到信息则默认为 撤退    （RETREAT）。将领 <em>i</em> 按照以下规则将 <em>vi</em> 发送给其他将领 <em>k</em>：<br>                    (A) 如果 <em>m</em> = 1 通过路径 <em>γj,k</em> 发送信息，路径存在定义1由(a)(ii)保证.<br>                    (B)如果 <em>m</em> &gt; 1 ,则 将领 <em>i</em>扮演司令的角色在<em>OM</em>(<em>m</em>-1,<em>p</em>-1)，图由去掉原先的司令构成。<br>        (3)对 每一个 <em>k</em> ，和 <em>i</em> ∈ <em>N</em> ， <em>k</em> ≠ <em>i</em> 。令 <em>vi</em> 为将领 <em>k</em> 从 <em>i</em> （<em>i</em> 在第二步（2））） 收到的信息，或者 RETREAT 如        果没有收到信息。将领 <em>k</em> 使用 函数值 <em>majority</em>(<em>vi<em>，… ,</em>v <del>i p</del></em>), <em>N</em> = {<em>i</em>1 ，… , <em>ip</em> }.</p><p>接下来证明 在至多 <em>m</em> 个叛徒的情况下 ，<em>OM</em>(<em>m</em>,<em>3m</em>) 解决拜占庭将军问题 。首先对引理1 进行拓展（见 一）。<br>定理2：<br>Lemma 2 .对任意的 <em>m</em> &gt;0 和任意的 <em>p</em> ≥ 2<em>k</em> + <em>m</em> ，如果至多有 <em>k</em> 个叛徒 ，算法 <em>OM</em>(<em>m</em>,<em>p</em>)满足条件IC2(见一)。</p><p><strong>证明</strong></p><p>​        当 <em>m</em> = 1, 注意到 一个将领获得的值 <em>majority</em>(<em>v1<em>，… ,</em>v p</em>) 中，每一个 <em>vi</em> 的命令发送者是通过不相交的路径发送的信息。且至多有 <em>k</em> 个叛徒. 在 <em>p</em> ≥ 2<em>k</em> + <em>m</em> 的情况下知道 忠诚将军的人数超过半数。当将军是忠诚的情况下，算法保证IC2 从而的证。运用归纳法可得对 <em>m</em> -1, <em>m</em> &gt;1 .引理成立。<br>继续证明…<br>定理 3：<br>Theorem 3. 对任意的 <em>m</em> &gt;0 和对任意的 <em>p</em> ≥ 3<em>m</em> ,在至多 m 叛徒的情况下 ，算法<em>OM</em>(<em>m</em>,<em>p</em>) 解决拜占庭问题。<br>证明。根据引理2，令 <em>k</em> = <em>m</em> ,可知算法满足IC2，在司令是忠诚的情况下。现在只需要证明司令为叛徒的情况。假设所有忠诚的将领再第三步（3）要获得一致的值 <em>v i</em> 集合.<br>​        如果 <em>m</em> = 1,则所有将领都是忠诚的，成立。<br>​        如果 <em>m</em> &gt;1 ,简单的归纳 <em>p</em> ≥ 3<em>m</em> 可得 <em>p</em> -1 ≥ 3 (<em>m</em> -1) ，算法成立。<br>​        证毕。</p><p>算法假设图<em>G</em> 为3-正则 ，是一个条件很强的连通假设。事实上当总共有3<em>m</em> +1人时，3 <em>m</em>-正则意味着全连通，算法<em>OM</em>(<em>m</em>,3<em>m</em>) 可推出 <em>OM</em>(<em>m</em>）。可以看出，拓展算法 <em>SM</em>(<em>m</em>) 只需要更弱的连通条件。</p><p>​        分析多少连通条件能解决拜占庭问题。IC2 要求 忠诚的将领服从忠诚的司令，这要求他们之间要能够通信。特别地，当每一条信息都会通过一个叛徒中转的时候，不能保证将领能获得司令的信息。类似的，如果两个将领只能通过有叛徒的路径通信则IC1无法保证。<br>拜占庭将军的弱连通假设为，忠诚将军构成的<em>G</em> 的子图要互相连接。在这个条件下，总人数为 <em>n</em> ，不管叛徒的个数，算法 <em>SM</em>(<em>n</em>-2)成立。</p><p>接下来证明更加普遍的结果。定义一个图的半径为最小的数 <em>d</em> ,任意两个节点相连至多需要 <em>d</em> 条边。</p><p>定理4.<br>Theorem4. 对任意的 <em>m</em> 和 <em>d</em> ,如果有 <em>m</em> 个叛徒且 忠诚将军构成的子图有直径 <em>d</em>, 则 <em>SM</em>(<em>m</em> + <em>d</em> - 1) 解决拜占庭问题。</p><p>证明和定理2的证明类似（略）。</p><p>推论.如果忠诚将军构成的子图是连接的，则 <em>SM</em>(<em>n</em> - 2)可解决拜占庭问题。<br>证明，令 <em>d</em> 为忠诚将军构成的图的直径。且已知 <em>d</em> 小于 节点数，所以忠诚将军的人数大于<em>d</em> ，叛徒人数少于 <em>n</em> - <em>d</em> 。令 <em>m</em> = <em>n</em> - <em>d</em> -1 可的证。</p><p>可靠的系统大多使用多数票方法保证可靠性，其使用多个处理器得出一致的结果，然后使用多数票表决的方法得到单个值。<br>使用多数票方法是基于假设不出错的处理器将得到一致的结果。这在它们获得一致的输入时成立。其基于假设出错的处理器不会得到一致的错误结果。但是也有很多其他的情况，无法获得一致的输入，比如出错的程序发送不同的值给其他处理器。比如获取时钟值的时候，很难保证两个处理器获取相同的值等等。所以给出以下前提条件：<br>        1.所有无故障的处理器使用相同的输入。（可以获得相同的输出）<br>        2.如果只输入单元无故障，那么所有无故障的处理器要使用其提供的值作为输入。</p><p>这里，司令是作为 输入值的提供者，将领是处理器，忠诚为无故障。</p><h3 id="6-可靠的系统"><a href="#6-可靠的系统" class="headerlink" title="6.可靠的系统"></a>6.可靠的系统</h3><p>​        除了使用本质上可靠的电路元件，我们知道实现一个可靠的计算机系统的唯一方法是使用几个不同的“处理器”来计算相同的结果，然后对它们的输出进行多数表决，以获得一个单一的值。(投票可以在系统内进行，也可以由输出的用户在外部进行。)无论是使用冗余电路来防止单个芯片故障的可靠计算机，还是使用冗余计算站点来防止单个站点被核攻击破坏的弹道导弹防御系统，都是如此。唯一的区别在于复制的“处理器”的大小。</p><p>使用多数表决来实现可靠性是基于所有非故障处理器将产生相同的输出的假设。只要它们都使用相同的输入，这就是正确的。然而，任何单个输入数据都来自单个物理元件——例如，来自可靠计算机中的其他电路，或者来自导弹防御系统中的某个雷达站点——和一个故障定位元件，可以为不同的处理器提供不同的值。此外，不同的处理器可以获得不同的值，甚至从一个非故障的输入单元，如果他们读取的值，而它正在变化。例如，如果两个处理器在时钟前进时读取时钟，那么一个处理器可能获得旧时间，另一个处理器获得新时间。这只能通过与时钟推进同步读操作来防止。可靠的制度，必须满足以下两个条件:</p><ol><li><p><strong>所有非故障处理器必须使用相同的输入值(因此它们产生相同的输出)。</strong></p></li><li><p><strong>如果输入单元是非故障的，那么所有非故障进程都使用它提供的值作为输入(因此它们产生正确的输出)。</strong></p></li></ol><p>这些只是我们的交互式一致性条件 IC1 和 IC2，其中“指挥官”是产生输入的单位，“中尉”是程序，“忠诚”意味着没有错误。</p><p>​        尝试用“硬件”解决方案来规避这个问题是很诱人的。例如，可以尝试通过让所有处理器都从相同的线路读取输入值来确保所有处理器获得相同的输入值。然而，一个错误的输入单元可以沿着线路发送一个边际信号—-这个信号可以被某些处理器解释为 0，而其他处理器可以解释为 1。没有办法保证不同的处理器将从一个可能出错的输入设备获得相同的值，除非让处理器相互通信来解决拜占庭将军问题。</p><p>​        当然，有故障的输入设备可能提供无意义的输入值。一个拜占庭将军解决方案所能做的就是保证所有处理器使用相同的输入值。如果输入是重要的，那么应该有几个独立的输入设备提供冗余值。例如，在导弹防御系统中应该有冗余雷达和冗余处理站点。然而，冗余输入不能实现可靠性，仍然需要确保非故障处理器使用冗余数据产生相同的输出。</p><p>​        如果输入设备是非故障的，但是由于它在值变化时被读取而给出不同的值，我们仍然希望非故障处理器获得一个合理的输入值。可以证明，如果多数函数和选择函数都是中值函数，那么我们的算法具有这样的性质，即非故障处理器获得的值在输入单元提供的值范围之内。因此，只要输入单元产生合理的值范围，非故障处理器将获得合理的值。</p><p>​        我们已经给出了几种解决方案，但是它们都是用拜占庭式的将军而不是用计算系统来表述的。我们现在研究如何将这些解决方案应用于可靠的计算系统。当然，用处理器实现“通用”算法是没有问题的。问题在于实现满足 A1-A3(算法 SM(m)的 A1-A4 假设)假设的消息传递系统。我们现在按顺序考虑这些假设。</p><p><strong>A 1</strong>。假设 A1 指出，没有错误的处理器发送的每条消息都是正确的。</p><p>在实际系统中，通信线路可能会失灵。对于口信算法 OM(m)和 OM(m，p)，连接两个处理器的通信线路的故障与其中一个处理器的故障是无法区分的。因此，我们只能保证这些算法将工作在存在多达亿故障，无论是处理器或通信线路故障。(当然，连接到同一个处理器的多条通信线路的故障相当于单个处理器的故障。)如果我们假设失败的通信线路不会导致伪造有符号消息——我们将在下面看到这个假设是相当合理的，那么我们的有符号消息算法 SM(m)对通信线路失败不敏感。更准确地说，定理 4 即使在通信线路故障的情况下仍然有效。失败的通信线路与简单地删除通信线路具有同样的效果——它降低了处理器图形的连接性。</p><p><strong>A 2</strong>。假设 A2 指出，处理器可以确定它所接收的任何消息的发出者。</p><p>实际上需要的是有故障的处理器不能模拟一个没有故障的处理器。在实践中，这意味着进程间通信是通过固定的线路而不是通过某些报文交换网络进行的。(如果使用交换网络，那么必须考虑有故障的网络节点，然后拜占庭将军问题节点再次出现。)请注意，如果假设A4 并且所有消息都有签名，则不需要假设 A2，因为模拟另一个处理器将意味着伪造其消息。</p><p><strong>A 3</strong>。假设 A3 要求可以检测到消息的缺失。</p><p>消息的缺失只能通过其未能在某个固定时间内到达来检测——换句话说，通过使用某种超时限制。使用超时来满足 A3 需要两个假设:</p><ol><li><p>生成和传输消息所需的最长时间是固定的。</p></li><li><p>发送方和接收方都有时钟，这些时钟在某个固定的最大误差范围内同步。</p></li></ol><p>第一个假设的必要性是相当明显的，因为接受者必须知道他需要等多久才能收到消息。(生成时间是处理器在接收到生成消息所需的所有输入之后发送消息所需的时间。)第二个假设的必要性就不那么明显了。然而，可以证明这个假设或者一个等价的假设对于解决拜占庭将军问题问题是必要的。更确切地说，假设我们允许算法，将军们只在下列情况下采取行动:</p><ol><li><p>在某个固定的初始时间(所有的将军都一样)。</p></li><li><p>在收到信息后。</p></li><li><p>当一段随机选择的时间过去时。(也就是说，一个普通人可以将计时器设置为一个随机值，并在计时器结束时行动。)</p></li></ol><p>{这产生了我们可以想象到的最一般的算法类别，它们不允许构造同步的时钟。)可以证明，如果消息可以任意快速地传递，即使存在消息传递延迟的上界，这种算法也不能解决拜占庭将军问题问题。而且，即使我们限制叛徒，只允许他们不正确的行为是不发送信息，也不可能有解决办法。这个结果的证明超出了本文的范围。请注意，在传输延迟上设置一个下限和一个上限，将使处理器通过来回发送消息来实现时钟。</p><p>​        以上两个假设使得检测未发送的消息变得容易。假设/z 是最大的消息生成和传输延迟，并且假设没有故障的处理器的时钟在任何时候最多相差 t。然后，任何非故障进程应该开始在其时钟上按时间 t 生成的消息将在接收方时钟上的时间 t+#+t 到达其目的地。因此，如果接收者到那时还没有接收到消息，那么它可能假设消息没有被发送。(如果它晚一点到达，那么发送者一定是错误的，因此我们的算法的正确性并不取决于发送的消息。)通过对输入处理器发送其值的时间进行 fLxing，可以计算出处理器在自己的时钟上必须等待每条消息的时间。例如，在算法 SM(m)中，处理器必须等到对于任何有+ k(# +~) 签名的消息，其中 To 是指挥官开始执行算法的时间(在他的时钟上)。没有两个时钟以完全相同的速率运行，所以无论最初处理器的时钟同步得多么精确，它们最终会偏离得任意远，除非它们周期性地重新同步。因此，我们面临的问题是，即使有些处理器出现故障，也要保持处理器的时钟同步到某个固定的数量。这是一个和拜占庭将军问题本身一样困难的问题。时钟同步问题的解决方案与我国拜占庭式的解决方案密切相关。它们将在未来的论文中加以描述。</p><p><strong>A 4</strong>。假设 A4 要求处理器能够以这样一种方式对其消息进行签名，即不能伪造没有错误的处理器签名。</p><p>签名是由进程 i 从数据项 m 生成的一段冗余信息 Si(m)。由 i 签名的消息由一对(m，Si(m))组成。满足部分(a)和(b)对于 A4，Si 函数必须具有以下两个性质:</p><p>​        (a)如果处理器 i 是非故障的，那么没有故障的处理器可以生成 Si(m)。</p><p>​        (b)给定 M 和 X，任何过程都可以确定 ifX 等于 Si(m)。</p><p>属性(a)永远不能得到保证，因为 Si(m)只是一个数据项，故障处理器可能生成任何数据项。然而，我们可以使违反它的概率小到我们所希望的程度，从而使系统如我们所希望的那样可靠。如何做到这一点取决于我们预期会遇到的故障类型。有两个令人感兴趣的案例:</p><p>1.随机故障。通过使Si 成为一个适当的“随机化”函数，我们可以使处理器中的一个随机故障产生正确签名的概率本质上等于它通过一个随机选择过程产生正<em>确签名的概率<strong>——</strong>即可能签名数目的倒数。下面是一个实现这一点的方法。假设消息被编码为小于</em> <em>p</em> 的正整数，其中 <em>p</em> <em>是</em> <em>2</em> <em>的幂。设</em> <em>Si(m)等于</em> m <em>Ki mod p，其中 Ki *是小于</em> <em>p</em> <em>的一个随机选择的奇数。如果另一个处理器的内存中没有</em> <em>Ki<strong>，</strong>那么它为单个<strong>(</strong>非零<strong>)</strong>消息</em> <em>m</em> <em>生成正确签名</em> <em>m*Ki</em> <em>的概率应该是</em> <em>l/p:它通过随机选</em>择生成正确签名 mKi <em>的概率。*</em>(*<em>注意，如果处理器可以通过一些简单的程序获</em>得 Ki，那么在计算时用Ki 代替 k，可能会有更大的可能性出现处理器错误地伪造 i 的签名 Sj(M).)律政司(m))</p><p>2.<em>恶意情报。如果错误的处理器被恶意的智能引导<strong>—-</strong>例如，如果一个完美的<strong>处理器被一个试图破坏系统的人操作</strong>—-那么信号函数</em> <em>Si</em> <em>的构造就成了一个密<strong>码学问题。我们建议读者参阅</strong>[1]<strong>和</strong>[4]来讨论如何解决这个问题。</em></p><p>请注意，如果进程已经看到签名，则很容易生成签名 Si(m)。因此，重要的是，相同的消息永远不必被签名两次。这意味着，当重复使用 SM(m)分发一个值序列时，序列号应该附加到值上以保证唯一性。</p><h3 id="7-结论"><a href="#7-结论" class="headerlink" title="7.结论"></a>7.结论</h3><p>​        在各种假设下，我们已经向拜占庭将军问题提出了几种解决方案，并展示了如何使用它们来实现可靠的计算机系统。这些解决方案在时间量和所需的消息数量上都很昂贵。算法 OM(m)和 SM(m)都要求消息路径的长度达到 m+1。换句话说，每个中尉可能不得不等待来自指挥官的信息，然后通过其他名中尉转发。费舍尔和林奇已经证明，这对任何可以对付万叛徒的解决方案都是正确的，所以我们的解决方案在这方面是最佳的。对于不完全连通的图，我们的算法需要长度为 m+d 的消息路径，其中 d 是忠诚将军子图的直径。我们认为这也是最佳选择。</p><p>​        算法 OM(m)和 SM(m)包括发送到(n-1)(n-2)..。(n-m-1)信息。通过组合消息，必然可以减少所需的单独消息的数量。也许还可以减少传输的信息量，但这一点尚未得到详细研究。但是，我们预计仍然需要大量的消息。</p><p>​        在任意故障的情况下实现可靠性是一个困难的问题，其解决方案似乎本身就代价高昂。降低成本的唯一方法是对可能发生的故障类型进行假设。例如，通常假设计算机可能无法响应，但是绝不会错误响应。然而，当需要极高的可靠性时，这样的假设是不可能做出的，并且需要一个拜占庭将军解决方案的全部费用。</p>]]></content>
      
      
      <categories>
          
          <category> 论文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用grpc构建为服务包括proto生成go</title>
      <link href="/2020/04/09/RPC%E5%92%8CGRPC/%E4%BD%BF%E7%94%A8gRPC%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/04/09/RPC%E5%92%8CGRPC/%E4%BD%BF%E7%94%A8gRPC%E6%9E%84%E5%BB%BA%E4%B8%BA%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、使用gRPC构建微服务"><a href="#一、使用gRPC构建微服务" class="headerlink" title="一、使用gRPC构建微服务"></a>一、使用gRPC构建微服务</h2><p>文件夹结构</p><p>gRPC/proto/user.pb.go</p><p>gRPC/proto/user.proto</p><p>gRPC/server.go</p><p>gRPC/client.go            </p><h3 id="1-编写proto文件-gRPC-proto-user-proto"><a href="#1-编写proto文件-gRPC-proto-user-proto" class="headerlink" title="1. 编写proto文件  gRPC/proto/user.proto"></a><strong>1.</strong> 编写proto文件  gRPC/proto/user.proto</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本号</span></span><br><span class="line">syntax=<span class="string">"proto3"</span>;</span><br><span class="line"><span class="comment">//指定包名</span></span><br><span class="line"><span class="keyword">package</span> proto;</span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line">message UserRequest&#123;</span><br><span class="line">    <span class="comment">//定义用户名</span></span><br><span class="line">    <span class="keyword">string</span> name =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相应结构体</span></span><br><span class="line">message UserResponse&#123;</span><br><span class="line">    <span class="keyword">int32</span> id =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> name =<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int32</span>  age=<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//repeated 修饰符是可变数组，go转切片</span></span><br><span class="line">    repeated <span class="keyword">string</span> hobby=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service 定义方法  接口</span></span><br><span class="line">service UserInfoService &#123;</span><br><span class="line">      rpc GetUserInfo (UserRequest) returns (UserResponse)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-生成go文件-gRPC-proto-user-pb-go"><a href="#2-生成go文件-gRPC-proto-user-pb-go" class="headerlink" title="2. 生成go文件   gRPC/proto/user.pb.go"></a><strong>2.</strong> 生成go文件   gRPC/proto/user.pb.go</h3><p> pycharm中打开命令行，输入命令生成接口文件：</p><p>$ protoc -I . –go_out=plugins=grpc:. ./user.proto  (文件名及位置)</p><h3 id="3-编写服务端-gRPC-server-go"><a href="#3-编写服务端-gRPC-server-go" class="headerlink" title="3. 编写服务端    gRPC/server.go"></a><strong>3.</strong> 编写服务端    gRPC/server.go</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.需要监听</span></span><br><span class="line"><span class="comment">//2.需要实例化gRPC</span></span><br><span class="line"><span class="comment">//3.在gRPC商注册为服务</span></span><br><span class="line"><span class="comment">//4.启动服务端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">pb <span class="string">"ginDemo/gRPC/proto"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义空接口</span></span><br><span class="line"><span class="keyword">type</span> UserInfoService <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u=UserInfoService&#123;&#125;</span><br><span class="line"><span class="comment">//实现方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserInfoService)</span><span class="title">GetUserInfo</span><span class="params">(ctx context.Context,req *pb.UserRequest)</span><span class="params">(resp *pb.UserResponse,err error)</span></span>&#123;</span><br><span class="line"><span class="comment">//同过用户名查询用户信息</span></span><br><span class="line">name :=req.Name</span><br><span class="line"><span class="comment">//数据里查用户的信息</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"zs"</span>&#123;</span><br><span class="line">resp =&amp;pb.UserResponse&#123;</span><br><span class="line">Id:<span class="number">1</span>,</span><br><span class="line">Name:name,</span><br><span class="line">Age:<span class="number">22</span>,</span><br><span class="line">Hobby:[]<span class="keyword">string</span>&#123;<span class="string">"sing"</span>,<span class="string">"Run"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">addr :=<span class="string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="comment">//1.监听</span></span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"监听异常：%s\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"监听端口:%s\n"</span>,addr)</span><br><span class="line"><span class="comment">//2.实例化gRPC</span></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"><span class="comment">//3.在grpc上注册微服务</span></span><br><span class="line">pb.RegisterUserInfoServiceServer(s,&amp;u)</span><br><span class="line"><span class="comment">//4.启动服务</span></span><br><span class="line">s.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编写客户端-gPRC-client-go"><a href="#4-编写客户端-gPRC-client-go" class="headerlink" title="4. 编写客户端  gPRC/client.go"></a><strong>4.</strong> 编写客户端  gPRC/client.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">pb <span class="string">"ginDemo/gRPC/proto"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.链接服务端</span></span><br><span class="line"><span class="comment">//2.实例gRPC客户端 ，RPC使用Call（）方法</span></span><br><span class="line"><span class="comment">//3.调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.连接</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">"127.0.0.1:8080"</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"连接异常，%s\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//2.实例化gRPC客户端</span></span><br><span class="line">client := pb.NewUserInfoServiceClient(conn)</span><br><span class="line"><span class="comment">//3.组装请求参数</span></span><br><span class="line">req :=<span class="built_in">new</span>(pb.UserRequest)</span><br><span class="line">req.Name=<span class="string">"zs"</span></span><br><span class="line"><span class="comment">//4.调用接口</span></span><br><span class="line">response, err := client.GetUserInfo(context.Background(), req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"响应异常：%s\n"</span>,err )</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"响应结果：%s\n"</span>,response)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><ol><li>go build run server.go</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听端口:127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>2.go build run client.go</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">响应结果：id:1 name:&quot;zs&quot; age:22 hobby:&quot;sing&quot; hobby:&quot;Run&quot; </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RPC和GRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间的几种通信方式</title>
      <link href="/2020/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间的几种通信方式"><a href="#进程间的几种通信方式" class="headerlink" title="进程间的几种通信方式"></a>进程间的几种通信方式</h1><p>​    进程间通信就是在不同进程之间传播或交换信息，那么不同进程之间存在着什么双方都可以访问的介质呢？进程的用户空间是互相独立的，一般而言是不能互相访问的，唯一的例外是共享内存区。但是，系统空间却是“公共场所”，所以内核显然可以提供这样的条件。除此以外，那就是双方都可以访问的外设了。在这个意义上，两个进程当然也可以通过磁盘上的普通文件交换信息，或者通过“注册表”或其它数据库中的某些表项和记录交换信息。广义上这也是进程间通信的手段，但是一般都不把这算作“进程间通信”。因为那些通信手段的效率太低了，而人们对进程间通信的要求是要有一定的实时性。 </p><a id="more"></a><p>　　进程间通信主要包括<strong>管道</strong>, <strong>系统IPC</strong>(包括消息队列,信号量,共享存储), <strong>SOCKET</strong>.</p><p>　　<strong>管道包括三种</strong>:1)普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用. 2)流管道s_pipe: 去除了第一种限制,可以双向传输. 3)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.</p><p>　　<strong>系统IPC</strong>的三种方式类同,都是使用了内核里的标识符来识别. </p><p><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p><strong>有名管道</strong> (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p><strong>信号量</strong>( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p><strong>消息队列</strong>( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p><strong>信号</strong> ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p><strong>共享内存</strong>( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p><strong>套接字</strong>( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p><h5 id="FAQ1-管道与文件描述符-文件指针的关系"><a href="#FAQ1-管道与文件描述符-文件指针的关系" class="headerlink" title="FAQ1: 管道与文件描述符,文件指针的关系?"></a>FAQ1: 管道与文件描述符,文件指针的关系?</h5><p>　　答: 其实管道的使用方法与文件类似,都能使用read,write,open等普通IO函数. 管道描述符来类似于文件描述符. 事实上, 管道使用的描述符, 文件指针和文件描述符最终都会转化成系统中SOCKET描述符. 都受到系统内核中SOCKET描述符的限制. 本质上LINUX内核源码中管道是通过空文件来实现.</p><h5 id="FAQ2-管道的使用方法"><a href="#FAQ2-管道的使用方法" class="headerlink" title="FAQ2: 管道的使用方法?"></a>FAQ2: 管道的使用方法?</h5><p>　　答: 主要有下面几种方法: 1)pipe, 创建一个管道,返回2个管道描述符.通常用于父子进程之间通讯. 2)popen, pclose: 这种方式只返回一个管道描述符,常用于通信另一方是stdin or stdout; 3)mkpipe: 命名管道, 在许多进程之间进行交互.</p><h5 id="FAQ3-管道与系统IPC之间的优劣比较"><a href="#FAQ3-管道与系统IPC之间的优劣比较" class="headerlink" title="FAQ3: 管道与系统IPC之间的优劣比较?"></a>FAQ3: 管道与系统IPC之间的优劣比较?</h5><p>　　答: 管道: 优点是所有的UNIX实现都支持, 并且在最后一个访问管道的进程终止后,管道就被完全删除;缺陷是管道只允许单向传输或者用于父子进程之间.</p><p>　　 系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是关键字KEY_T使用了内核标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.</p><h5 id="FAQ4-WINDOS进程间通信与LINUX进程间通信的关系"><a href="#FAQ4-WINDOS进程间通信与LINUX进程间通信的关系" class="headerlink" title="FAQ4: WINDOS进程间通信与LINUX进程间通信的关系?"></a>FAQ4: WINDOS进程间通信与LINUX进程间通信的关系?</h5><p>　　答: 事实上,WINDOS的进程通信大部分移植于UNIX, WINDOS的剪贴板,文件映射等都可从UNIX进程通信的共享存储中找到影子. </p><h5 id="FAQ5-进程间通信与线程间通信之间的关系"><a href="#FAQ5-进程间通信与线程间通信之间的关系" class="headerlink" title="FAQ5: 进程间通信与线程间通信之间的关系?"></a>FAQ5: 进程间通信与线程间通信之间的关系?</h5><p>　　答: 因为WINDOWS运行的实体是线程, 狭义上的进程间通信其实是指分属于不同进程的线程之间的通讯.而单个进程之间的线程同步问题可归并为一种特殊的进程通信.它要用到内核支持的系统调用来保持线程之间同步. 通常用到的一些线程同步方法包括:Event, Mutex, 信号量Semaphore, 临界区资源等.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01两数之和</title>
      <link href="/2020/04/05/LeetCode/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/04/05/LeetCode/01%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><a id="more"></a><p>给定一个整数数组 <strong>nums</strong> 和一个目标值 <strong>target</strong>，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><ol><li><h4 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1：暴力破解法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum1</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i]+nums[j] == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;i, j&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：O(N^2)<br>空间复杂度：O(1)O(1)</p></li><li><h4 id="map法"><a href="#map法" class="headerlink" title="map法"></a>map法</h4><p>1.创建map映射，用于存放目标数组的相关信息；<br>2.遍历目标数组，并获取目标值（target）与数组元素（nums[i]）的差值；<br>3.将差值当作map的key，目标数组的角标当作value；<br>4.判断map中是否包含，如果包含，则返回map的key为差值的value与i；<br>5.如果map中不包含，放入map中。</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法2：map法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum2</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> k, ok := m[target-v]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;k, i&#125;</span><br><span class="line">&#125;</span><br><span class="line">m[v] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：O(N)<br>空间复杂度：O(N)</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">nums :=[]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;</span><br><span class="line">target :=<span class="number">9</span></span><br><span class="line">fmt.Println(twoSum(nums,target))</span><br><span class="line">    fmt.Println(twoSum2(nums,target))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"> ········</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"> ········</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP</title>
      <link href="/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP/"/>
      <url>/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCPIP/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>TCP/IP 是因特网的通信协议。</p><p>TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。</p><a id="more"></a><h3 id="TCP-IP应用"><a href="#TCP-IP应用" class="headerlink" title="TCP/IP应用"></a>TCP/IP应用</h3><ul><li><h5 id="您的浏览器与服务器都在使用-TCP-IP-协议"><a href="#您的浏览器与服务器都在使用-TCP-IP-协议" class="headerlink" title="您的浏览器与服务器都在使用 TCP/IP 协议"></a>您的浏览器与服务器都在使用 TCP/IP 协议</h5><p>浏览器与服务器使用 TCP/IP 协议来链接因特网。</p><p>浏览器使用 TCP/IP 协议进入服务器，服务器使用 TCP/IP 协议来发送 HTML 到浏览器。</p></li><li><h5 id="您的-E-Mail-使用-TCP-IP-协议"><a href="#您的-E-Mail-使用-TCP-IP-协议" class="headerlink" title="您的 E-Mail 使用 TCP/IP 协议"></a>您的 E-Mail 使用 TCP/IP 协议</h5><p>您的电子邮件也通过 TCP/IP 协议来发送和接收邮件。</p></li><li><h5 id="因特网地址是-TCP-IP-协议"><a href="#因特网地址是-TCP-IP-协议" class="headerlink" title="因特网地址是 TCP/IP 协议"></a>因特网地址是 TCP/IP 协议</h5><p>因特网地址比如 “42.120.45.233” 就是一个 TCP/IP 协议。</p></li></ul><h1 id="什么是-TCP-IP？"><a href="#什么是-TCP-IP？" class="headerlink" title="什么是 TCP/IP？"></a>什么是 TCP/IP？</h1><p>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</p><p>TCP/IP 指传输控制协议/网际协议（<strong>Transmission  Control  Protocol</strong> /<strong>Internet Protocol</strong>）。</p><p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。</p><hr><h2 id="在-TCP-IP-内部"><a href="#在-TCP-IP-内部" class="headerlink" title="在 TCP/IP 内部"></a>在 TCP/IP 内部</h2><p>在 TCP/IP 中包含一系列用于处理数据通信的协议：</p><ul><li>TCP (传输控制协议) - 应用程序之间通信</li><li>UDP (用户数据报协议) - 应用程序之间的简单通信</li><li>IP (网际协议) - 计算机之间的通信</li><li>ICMP (因特网消息控制协议) - 针对错误和状态</li><li>DHCP (动态主机配置协议) - 针对动态寻址</li></ul><hr><h2 id="TCP-使用固定的连接"><a href="#TCP-使用固定的连接" class="headerlink" title="TCP 使用固定的连接"></a>TCP 使用固定的连接</h2><p>TCP 用于应用程序之间的通信。</p><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方”握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p><p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><p>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p><hr><h2 id="IP-是无连接的"><a href="#IP-是无连接的" class="headerlink" title="IP 是无连接的"></a>IP 是无连接的</h2><p>IP 用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包路由至它的目的地。</p><hr><h2 id="IP-路由器"><a href="#IP-路由器" class="headerlink" title="IP 路由器"></a>IP 路由器</h2><p>当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。</p><p>IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。</p><p>在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。</p><hr><h2 id="TCP-IP-1"><a href="#TCP-IP-1" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p><p>TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。</p><p>IP 负责计算机之间的通信。</p><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p><p>IP 负责将包发送至接受者。</p><h1 id="TCP-IP-寻址"><a href="#TCP-IP-寻址" class="headerlink" title="TCP/IP 寻址"></a>TCP/IP 寻址</h1><p>TCP/IP 使用 32 个比特或者 4 组 0 到 255 之间的数字来为计算机编址。</p><hr><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>在本教程下一节，您会学习到更多关于 IP 地址和 IP 名称的知识。</p><hr><h2 id="IP-地址包含-4-组数字："><a href="#IP-地址包含-4-组数字：" class="headerlink" title="IP 地址包含 4 组数字："></a>IP 地址包含 4 组数字：</h2><p>TCP/IP 使用 4 组数字来为计算机编址。每个计算机必须有一个唯一的 4 组数字的地址。</p><p>每组数字必须在 0 到 255 之间，并由点号隔开，比如：192.168.1.60。</p><hr><h2 id="32-比特-4-字节"><a href="#32-比特-4-字节" class="headerlink" title="32 比特 = 4 字节"></a>32 比特 = 4 字节</h2><p>TCP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。</p><p>一个计算机字节可以包含 256 个不同的值：</p><p>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。</p><p>现在，您应该知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 组数字。</p><hr><h2 id="IP-V6"><a href="#IP-V6" class="headerlink" title="IP V6"></a>IP V6</h2><p>IPv6 是 “Internet Protocol Version 6” 的缩写，也被称作下一代互联网协议，它是由 IETF 小组（Internet 工程任务组Internet Engineering Task Force）设计的用来替代现行的 IPv4（现行的）协议的一种新的 IP 协议。</p><p>我们知道，Internet 的主机都有一个唯一的 IP 地址，IP 地址用一个 32 位二进制的数表示一个主机号码，但 32 位地址资源有限，已经不能满足用户的需求了，因此 Internet 研究组织发布新的主机标识方法，即 IPv6。</p><p>在 RFC1884 中（RFC 是 Request for Comments document 的缩写。RFC 实际上就是 Internet 有关服务的一些标准），规定的标准语法建议把 IPv6 地址的 128 位（16 个字节）写成 8 个 16 位的无符号整数，每个整数用 4 个十六进制位表示，这些数之间用冒号（:）分开，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">686</span>E：<span class="number">8</span>C64：FFFF：FFFF：<span class="number">0</span>：<span class="number">1180</span>：<span class="number">96</span>A：FFFF</span><br></pre></td></tr></table></figure><p>冒号十六进制记法允许零压缩，即一串连续的0可以用一对冒号取代，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FF05：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：B3可以定成：FF05：：B3</span><br></pre></td></tr></table></figure><p>为了保证零压缩有一个清晰的解释，建议中规定，在任一地址中，只能使用一次零压缩。该技术对已建议的分配策略特别有用，因为会有许多地址包含连续的零串。</p><p>冒号十六进制记法结合有点十进制记法的后缀。这种结合在IPv4向IPv6换阶段特别有用。例如，下面的串是一个合法的冒号十六进制记法：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span>：<span class="number">128.10</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>这种记法中，虽然冒号所分隔的每一个值是一个16位的量，但每个分点十进制部分的值则指明一个字节的值。再使用零压缩即可得出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：：<span class="number">128.10</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><hr><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>12 个阿拉伯数字很难记忆。使用一个名称更容易。</p><p>用于 TCP/IP 地址的名字被称为域名。runoob.com 就是一个域名。</p><p>当你键入一个像 <a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a> 这样的域名，域名会被一种 DNS 程序翻译为数字。</p><p>在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。</p><p>当一个新的域名连同其 TCP/IP 地址一起注册后，全世界的 DNS 服务器都会对此信息进行更新。</p><h1 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h1><hr><p>TCP/IP 是不同的通信协议的大集合。</p><hr><h2 id="协议族"><a href="#协议族" class="headerlink" title="协议族"></a>协议族</h2><p>TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。</p><hr><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP - 传输控制协议"></a>TCP - 传输控制协议</h2><p>TCP 用于从应用程序到网络的数据传输控制。</p><p>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p><hr><h2 id="IP-网际协议（Internet-Protocol）"><a href="#IP-网际协议（Internet-Protocol）" class="headerlink" title="IP - 网际协议（Internet Protocol）"></a>IP - 网际协议（Internet Protocol）</h2><p>IP 负责计算机之间的通信。</p><p>IP 负责在因特网上发送和接收数据包。</p><hr><h2 id="HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol"><a href="#HTTP-超文本传输协议-Hyper-Text-Transfer-Protocol" class="headerlink" title="HTTP - 超文本传输协议(Hyper Text Transfer Protocol)"></a>HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</h2><p>HTTP 负责 web 服务器与 web 浏览器之间的通信。</p><p>HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</p><hr><h2 id="HTTPS-安全的-HTTP（HTTP-Secure）"><a href="#HTTPS-安全的-HTTP（HTTP-Secure）" class="headerlink" title="HTTPS - 安全的 HTTP（HTTP Secure）"></a>HTTPS - 安全的 HTTP（HTTP Secure）</h2><p>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。</p><p>作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。</p><hr><h2 id="SSL-安全套接字层（Secure-Sockets-Layer）"><a href="#SSL-安全套接字层（Secure-Sockets-Layer）" class="headerlink" title="SSL - 安全套接字层（Secure Sockets Layer）"></a>SSL - 安全套接字层（Secure Sockets Layer）</h2><p>SSL 协议用于为安全数据传输加密数据。</p><hr><h2 id="SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）"><a href="#SMTP-简易邮件传输协议（Simple-Mail-Transfer-Protocol）" class="headerlink" title="SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）"></a>SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）</h2><p>SMTP 用于电子邮件的传输。</p><hr><h2 id="MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）"><a href="#MIME-多用途因特网邮件扩展（Multi-purpose-Internet-Mail-Extensions）" class="headerlink" title="MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）"></a>MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</h2><p>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</p><hr><h2 id="IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）"><a href="#IMAP-因特网消息访问协议（Internet-Message-Access-Protocol）" class="headerlink" title="IMAP - 因特网消息访问协议（Internet Message Access Protocol）"></a>IMAP - 因特网消息访问协议（Internet Message Access Protocol）</h2><p>IMAP 用于存储和取回电子邮件。</p><hr><h2 id="POP-邮局协议（Post-Office-Protocol）"><a href="#POP-邮局协议（Post-Office-Protocol）" class="headerlink" title="POP - 邮局协议（Post Office Protocol）"></a>POP - 邮局协议（Post Office Protocol）</h2><p>POP 用于从电子邮件服务器向个人电脑下载电子邮件。</p><hr><h2 id="FTP-文件传输协议（File-Transfer-Protocol）"><a href="#FTP-文件传输协议（File-Transfer-Protocol）" class="headerlink" title="FTP - 文件传输协议（File Transfer Protocol）"></a>FTP - 文件传输协议（File Transfer Protocol）</h2><p>FTP 负责计算机之间的文件传输。</p><hr><h2 id="NTP-网络时间协议（Network-Time-Protocol）"><a href="#NTP-网络时间协议（Network-Time-Protocol）" class="headerlink" title="NTP - 网络时间协议（Network Time Protocol）"></a>NTP - 网络时间协议（Network Time Protocol）</h2><p>NTP 用于在计算机之间同步时间（钟）。</p><hr><h2 id="DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）"><a href="#DHCP-动态主机配置协议（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）"></a>DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）</h2><p>DHCP 用于向网络中的计算机分配动态 IP 地址。</p><hr><h2 id="SNMP-简单网络管理协议（Simple-Network-Management-Protocol）"><a href="#SNMP-简单网络管理协议（Simple-Network-Management-Protocol）" class="headerlink" title="SNMP - 简单网络管理协议（Simple Network Management Protocol）"></a>SNMP - 简单网络管理协议（Simple Network Management Protocol）</h2><p>SNMP 用于计算机网络的管理。</p><hr><h2 id="LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）"><a href="#LDAP-轻量级的目录访问协议（Lightweight-Directory-Access-Protocol）" class="headerlink" title="LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）"></a>LDAP - 轻量级的目录访问协议（Lightweight Directory Access Protocol）</h2><p>LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。</p><hr><h2 id="ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）"><a href="#ICMP-因特网消息控制协议（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP - 因特网消息控制协议（Internet Control Message Protocol）"></a>ICMP - 因特网消息控制协议（Internet Control Message Protocol）</h2><p>ICMP 负责网络中的错误处理。</p><hr><h2 id="ARP-地址解析协议（Address-Resolution-Protocol）"><a href="#ARP-地址解析协议（Address-Resolution-Protocol）" class="headerlink" title="ARP - 地址解析协议（Address Resolution Protocol）"></a>ARP - 地址解析协议（Address Resolution Protocol）</h2><p>ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。</p><hr><h2 id="RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）"><a href="#RARP-反向地址转换协议（Reverse-Address-Resolution-Protocol）" class="headerlink" title="RARP - 反向地址转换协议（Reverse Address Resolution Protocol）"></a>RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</h2><p>RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。</p><hr><h2 id="BOOTP-自举协议（Boot-Protocol）"><a href="#BOOTP-自举协议（Boot-Protocol）" class="headerlink" title="BOOTP - 自举协议（Boot Protocol）"></a>BOOTP - 自举协议（Boot Protocol）</h2><p>BOOTP 用于从网络启动计算机。</p><hr><h2 id="PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）"><a href="#PPTP-点对点隧道协议（Point-to-Point-Tunneling-Protocol）" class="headerlink" title="PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）"></a>PPTP - 点对点隧道协议（Point to Point Tunneling Protocol）</h2><p>PPTP 用于私人网络之间的连接（隧道）。</p><h1 id="TCP-IP-邮件"><a href="#TCP-IP-邮件" class="headerlink" title="TCP/IP 邮件"></a>TCP/IP 邮件</h1><hr><p>电子邮件是 TCP/IP 最重要的应用之一。</p><hr><h2 id="您不会用到…"><a href="#您不会用到…" class="headerlink" title="您不会用到…"></a>您不会用到…</h2><p>当您写邮件时，您不会用到 TCP/IP。</p><p>当您写邮件时，您用到的是电子邮件程序，例如莲花软件的 Notes，微软公司出品的 Outlook，或者 Netscape Communicator 等等。</p><hr><h2 id="邮件程序会用到…"><a href="#邮件程序会用到…" class="headerlink" title="邮件程序会用到…"></a>邮件程序会用到…</h2><p>您的电子邮件程序使用不同的 TCP/IP 协议：</p><ul><li>使用 SMTP 来发送邮件</li><li>使用 POP 从邮件服务器下载邮件</li><li>使用 IMAP 连接到邮件服务器</li></ul><hr><h2 id="SMTP-简单邮件传输协议"><a href="#SMTP-简单邮件传输协议" class="headerlink" title="SMTP - 简单邮件传输协议"></a>SMTP - 简单邮件传输协议</h2><p>SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。</p><p>通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。</p><p>SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。</p><p>SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。</p><hr><h2 id="POP-邮局协议"><a href="#POP-邮局协议" class="headerlink" title="POP - 邮局协议"></a>POP - 邮局协议</h2><p>POP 协议被邮件程序用来取回邮件服务器上面的邮件。</p><p>假如您的邮件程序使用 POP，那么一旦它连接上邮件服务器，您的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。</p><hr><h2 id="IMAP-因特网消息访问协议"><a href="#IMAP-因特网消息访问协议" class="headerlink" title="IMAP - 因特网消息访问协议"></a>IMAP - 因特网消息访问协议</h2><p>与 POP 类似，IMAP 协议同样被邮件程序使用。</p><p>IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。</p><p>IMAP 使您有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，您可以选择下载这些邮件或者仅仅是删除它们。比方说您需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTPP</title>
      <link href="/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTPP/"/>
      <url>/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTPP/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><a id="more"></a><hr><h2 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h2><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><p><strong>HTTP三点注意事项：</strong></p><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><p>以下图表展示了HTTP协议通信流程：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/cgiarch.gif" alt="cgiarch"></p><h1 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h1><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p><p>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p><p>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p><hr><h2 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。<img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="img"></p><h2 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h2><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt="img"></p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面实例是一点典型的使用GET来传递数据的实例：</p><p>客户端请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.txt HTTP/1.1</span><br><span class="line">User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Language: en, mi</span><br></pre></td></tr></table></figure><p>服务端响应:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">ETag: <span class="string">"34aa387-d-1568eb00"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! My payload includes a trailing CRLF.</span><br></pre></td></tr></table></figure><h1 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h1><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h1 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h1><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p><p>在本章节中我们将具体来介绍HTTP响应头信息。</p><table><thead><tr><th align="left">应答头</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Allow</td><td align="left">服务器支持哪些请求方法（如GET、POST等）。</td></tr><tr><td align="left">Content-Encoding</td><td align="left">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td></tr><tr><td align="left">Content-Length</td><td align="left">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td></tr><tr><td align="left">Content-Type</td><td align="left">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td></tr><tr><td align="left">Date</td><td align="left">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td></tr><tr><td align="left">Expires</td><td align="left">应该在什么时候认为文档已经过期，从而不再缓存它？</td></tr><tr><td align="left">Last-Modified</td><td align="left">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td></tr><tr><td align="left">Location</td><td align="left">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td></tr><tr><td align="left">Refresh</td><td align="left">表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="noopener">http://host/path&quot;)让浏览器读取指定的页面。</a> 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="noopener">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a>  注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td></tr><tr><td align="left">Server</td><td align="left">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td></tr></tbody></table><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。</p><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><h2 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>HTTP状态码列表:</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h1 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h1><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p><p>Content-Type 标头告诉客户端实际返回的内容的内容类型。</p><p>语法格式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Content-<span class="keyword">Type</span>: multipart/<span class="keyword">form</span>-<span class="keyword">data</span>; boundary=something</span><br></pre></td></tr></table></figure><p>实例：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/F7E193D6-3C08-4B97-BAF2-FF340DAA5C6E.jpg" alt="img"></p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ： XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml： XML数据格式</li><li>application/atom+xml ：Atom XML聚合格式</li><li>application/json： JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><hr><h2 id="HTTP-content-type-对照表"><a href="#HTTP-content-type-对照表" class="headerlink" title="HTTP content-type 对照表"></a>HTTP content-type 对照表</h2><table><thead><tr><th align="left">文件扩展名</th><th align="left">Content-Type(Mime-Type)</th><th align="left">文件扩展名</th><th align="left">Content-Type(Mime-Type)</th></tr></thead><tbody><tr><td align="left">.*（ 二进制流，不知道下载文件类型）</td><td align="left">application/octet-stream</td><td align="left">.tif</td><td align="left">image/tiff</td></tr><tr><td align="left">.001</td><td align="left">application/x-001</td><td align="left">.301</td><td align="left">application/x-301</td></tr><tr><td align="left">.323</td><td align="left">text/h323</td><td align="left">.906</td><td align="left">application/x-906</td></tr><tr><td align="left">.907</td><td align="left">drawing/907</td><td align="left">.a11</td><td align="left">application/x-a11</td></tr><tr><td align="left">.acp</td><td align="left">audio/x-mei-aac</td><td align="left">.ai</td><td align="left">application/postscript</td></tr><tr><td align="left">.aif</td><td align="left">audio/aiff</td><td align="left">.aifc</td><td align="left">audio/aiff</td></tr><tr><td align="left">.aiff</td><td align="left">audio/aiff</td><td align="left">.anv</td><td align="left">application/x-anv</td></tr><tr><td align="left">.asa</td><td align="left">text/asa</td><td align="left">.asf</td><td align="left">video/x-ms-asf</td></tr><tr><td align="left">.asp</td><td align="left">text/asp</td><td align="left">.asx</td><td align="left">video/x-ms-asf</td></tr><tr><td align="left">.au</td><td align="left">audio/basic</td><td align="left">.avi</td><td align="left">video/avi</td></tr><tr><td align="left">.awf</td><td align="left">application/vnd.adobe.workflow</td><td align="left">.biz</td><td align="left">text/xml</td></tr><tr><td align="left">.bmp</td><td align="left">application/x-bmp</td><td align="left">.bot</td><td align="left">application/x-bot</td></tr><tr><td align="left">.c4t</td><td align="left">application/x-c4t</td><td align="left">.c90</td><td align="left">application/x-c90</td></tr><tr><td align="left">.cal</td><td align="left">application/x-cals</td><td align="left">.cat</td><td align="left">application/vnd.ms-pki.seccat</td></tr><tr><td align="left">.cdf</td><td align="left">application/x-netcdf</td><td align="left">.cdr</td><td align="left">application/x-cdr</td></tr><tr><td align="left">.cel</td><td align="left">application/x-cel</td><td align="left">.cer</td><td align="left">application/x-x509-ca-cert</td></tr><tr><td align="left">.cg4</td><td align="left">application/x-g4</td><td align="left">.cgm</td><td align="left">application/x-cgm</td></tr><tr><td align="left">.cit</td><td align="left">application/x-cit</td><td align="left">.class</td><td align="left">java/*</td></tr><tr><td align="left">.cml</td><td align="left">text/xml</td><td align="left">.cmp</td><td align="left">application/x-cmp</td></tr><tr><td align="left">.cmx</td><td align="left">application/x-cmx</td><td align="left">.cot</td><td align="left">application/x-cot</td></tr><tr><td align="left">.crl</td><td align="left">application/pkix-crl</td><td align="left">.crt</td><td align="left">application/x-x509-ca-cert</td></tr><tr><td align="left">.csi</td><td align="left">application/x-csi</td><td align="left">.css</td><td align="left">text/css</td></tr><tr><td align="left">.cut</td><td align="left">application/x-cut</td><td align="left">.dbf</td><td align="left">application/x-dbf</td></tr><tr><td align="left">.dbm</td><td align="left">application/x-dbm</td><td align="left">.dbx</td><td align="left">application/x-dbx</td></tr><tr><td align="left">.dcd</td><td align="left">text/xml</td><td align="left">.dcx</td><td align="left">application/x-dcx</td></tr><tr><td align="left">.der</td><td align="left">application/x-x509-ca-cert</td><td align="left">.dgn</td><td align="left">application/x-dgn</td></tr><tr><td align="left">.dib</td><td align="left">application/x-dib</td><td align="left">.dll</td><td align="left">application/x-msdownload</td></tr><tr><td align="left">.doc</td><td align="left">application/msword</td><td align="left">.dot</td><td align="left">application/msword</td></tr><tr><td align="left">.drw</td><td align="left">application/x-drw</td><td align="left">.dtd</td><td align="left">text/xml</td></tr><tr><td align="left">.dwf</td><td align="left">Model/vnd.dwf</td><td align="left">.dwf</td><td align="left">application/x-dwf</td></tr><tr><td align="left">.dwg</td><td align="left">application/x-dwg</td><td align="left">.dxb</td><td align="left">application/x-dxb</td></tr><tr><td align="left">.dxf</td><td align="left">application/x-dxf</td><td align="left">.edn</td><td align="left">application/vnd.adobe.edn</td></tr><tr><td align="left">.emf</td><td align="left">application/x-emf</td><td align="left">.eml</td><td align="left">message/rfc822</td></tr><tr><td align="left">.ent</td><td align="left">text/xml</td><td align="left">.epi</td><td align="left">application/x-epi</td></tr><tr><td align="left">.eps</td><td align="left">application/x-ps</td><td align="left">.eps</td><td align="left">application/postscript</td></tr><tr><td align="left">.etd</td><td align="left">application/x-ebx</td><td align="left">.exe</td><td align="left">application/x-msdownload</td></tr><tr><td align="left">.fax</td><td align="left">image/fax</td><td align="left">.fdf</td><td align="left">application/vnd.fdf</td></tr><tr><td align="left">.fif</td><td align="left">application/fractals</td><td align="left">.fo</td><td align="left">text/xml</td></tr><tr><td align="left">.frm</td><td align="left">application/x-frm</td><td align="left">.g4</td><td align="left">application/x-g4</td></tr><tr><td align="left">.gbr</td><td align="left">application/x-gbr</td><td align="left">.</td><td align="left">application/x-</td></tr><tr><td align="left">.gif</td><td align="left">image/gif</td><td align="left">.gl2</td><td align="left">application/x-gl2</td></tr><tr><td align="left">.gp4</td><td align="left">application/x-gp4</td><td align="left">.hgl</td><td align="left">application/x-hgl</td></tr><tr><td align="left">.hmr</td><td align="left">application/x-hmr</td><td align="left">.hpg</td><td align="left">application/x-hpgl</td></tr><tr><td align="left">.hpl</td><td align="left">application/x-hpl</td><td align="left">.hqx</td><td align="left">application/mac-binhex40</td></tr><tr><td align="left">.hrf</td><td align="left">application/x-hrf</td><td align="left">.hta</td><td align="left">application/hta</td></tr><tr><td align="left">.htc</td><td align="left">text/x-component</td><td align="left">.htm</td><td align="left">text/html</td></tr><tr><td align="left">.html</td><td align="left">text/html</td><td align="left">.htt</td><td align="left">text/webviewhtml</td></tr><tr><td align="left">.htx</td><td align="left">text/html</td><td align="left">.icb</td><td align="left">application/x-icb</td></tr><tr><td align="left">.ico</td><td align="left">image/x-icon</td><td align="left">.ico</td><td align="left">application/x-ico</td></tr><tr><td align="left">.iff</td><td align="left">application/x-iff</td><td align="left">.ig4</td><td align="left">application/x-g4</td></tr><tr><td align="left">.igs</td><td align="left">application/x-igs</td><td align="left">.iii</td><td align="left">application/x-iphone</td></tr><tr><td align="left">.img</td><td align="left">application/x-img</td><td align="left">.ins</td><td align="left">application/x-internet-signup</td></tr><tr><td align="left">.isp</td><td align="left">application/x-internet-signup</td><td align="left">.IVF</td><td align="left">video/x-ivf</td></tr><tr><td align="left">.java</td><td align="left">java/*</td><td align="left">.jfif</td><td align="left">image/jpeg</td></tr><tr><td align="left">.jpe</td><td align="left">image/jpeg</td><td align="left">.jpe</td><td align="left">application/x-jpe</td></tr><tr><td align="left">.jpeg</td><td align="left">image/jpeg</td><td align="left">.jpg</td><td align="left">image/jpeg</td></tr><tr><td align="left">.jpg</td><td align="left">application/x-jpg</td><td align="left">.js</td><td align="left">application/x-javascript</td></tr><tr><td align="left">.jsp</td><td align="left">text/html</td><td align="left">.la1</td><td align="left">audio/x-liquid-file</td></tr><tr><td align="left">.lar</td><td align="left">application/x-laplayer-reg</td><td align="left">.latex</td><td align="left">application/x-latex</td></tr><tr><td align="left">.lavs</td><td align="left">audio/x-liquid-secure</td><td align="left">.lbm</td><td align="left">application/x-lbm</td></tr><tr><td align="left">.lmsff</td><td align="left">audio/x-la-lms</td><td align="left">.ls</td><td align="left">application/x-javascript</td></tr><tr><td align="left">.ltr</td><td align="left">application/x-ltr</td><td align="left">.m1v</td><td align="left">video/x-mpeg</td></tr><tr><td align="left">.m2v</td><td align="left">video/x-mpeg</td><td align="left">.m3u</td><td align="left">audio/mpegurl</td></tr><tr><td align="left">.m4e</td><td align="left">video/mpeg4</td><td align="left">.mac</td><td align="left">application/x-mac</td></tr><tr><td align="left">.man</td><td align="left">application/x-troff-man</td><td align="left">.math</td><td align="left">text/xml</td></tr><tr><td align="left">.mdb</td><td align="left">application/msaccess</td><td align="left">.mdb</td><td align="left">application/x-mdb</td></tr><tr><td align="left">.mfp</td><td align="left">application/x-shockwave-flash</td><td align="left">.mht</td><td align="left">message/rfc822</td></tr><tr><td align="left">.mhtml</td><td align="left">message/rfc822</td><td align="left">.mi</td><td align="left">application/x-mi</td></tr><tr><td align="left">.mid</td><td align="left">audio/mid</td><td align="left">.midi</td><td align="left">audio/mid</td></tr><tr><td align="left">.mil</td><td align="left">application/x-mil</td><td align="left">.mml</td><td align="left">text/xml</td></tr><tr><td align="left">.mnd</td><td align="left">audio/x-musicnet-download</td><td align="left">.mns</td><td align="left">audio/x-musicnet-stream</td></tr><tr><td align="left">.mocha</td><td align="left">application/x-javascript</td><td align="left">.movie</td><td align="left">video/x-sgi-movie</td></tr><tr><td align="left">.mp1</td><td align="left">audio/mp1</td><td align="left">.mp2</td><td align="left">audio/mp2</td></tr><tr><td align="left">.mp2v</td><td align="left">video/mpeg</td><td align="left">.mp3</td><td align="left">audio/mp3</td></tr><tr><td align="left">.mp4</td><td align="left">video/mpeg4</td><td align="left">.mpa</td><td align="left">video/x-mpg</td></tr><tr><td align="left">.mpd</td><td align="left">application/vnd.ms-project</td><td align="left">.mpe</td><td align="left">video/x-mpeg</td></tr><tr><td align="left">.mpeg</td><td align="left">video/mpg</td><td align="left">.mpg</td><td align="left">video/mpg</td></tr><tr><td align="left">.mpga</td><td align="left">audio/rn-mpeg</td><td align="left">.mpp</td><td align="left">application/vnd.ms-project</td></tr><tr><td align="left">.mps</td><td align="left">video/x-mpeg</td><td align="left">.mpt</td><td align="left">application/vnd.ms-project</td></tr><tr><td align="left">.mpv</td><td align="left">video/mpg</td><td align="left">.mpv2</td><td align="left">video/mpeg</td></tr><tr><td align="left">.mpw</td><td align="left">application/vnd.ms-project</td><td align="left">.mpx</td><td align="left">application/vnd.ms-project</td></tr><tr><td align="left">.mtx</td><td align="left">text/xml</td><td align="left">.mxp</td><td align="left">application/x-mmxp</td></tr><tr><td align="left">.net</td><td align="left">image/pnetvue</td><td align="left">.nrf</td><td align="left">application/x-nrf</td></tr><tr><td align="left">.nws</td><td align="left">message/rfc822</td><td align="left">.odc</td><td align="left">text/x-ms-odc</td></tr><tr><td align="left">.out</td><td align="left">application/x-out</td><td align="left">.p10</td><td align="left">application/pkcs10</td></tr><tr><td align="left">.p12</td><td align="left">application/x-pkcs12</td><td align="left">.p7b</td><td align="left">application/x-pkcs7-certificates</td></tr><tr><td align="left">.p7c</td><td align="left">application/pkcs7-mime</td><td align="left">.p7m</td><td align="left">application/pkcs7-mime</td></tr><tr><td align="left">.p7r</td><td align="left">application/x-pkcs7-certreqresp</td><td align="left">.p7s</td><td align="left">application/pkcs7-signature</td></tr><tr><td align="left">.pc5</td><td align="left">application/x-pc5</td><td align="left">.pci</td><td align="left">application/x-pci</td></tr><tr><td align="left">.pcl</td><td align="left">application/x-pcl</td><td align="left">.pcx</td><td align="left">application/x-pcx</td></tr><tr><td align="left">.pdf</td><td align="left">application/pdf</td><td align="left">.pdf</td><td align="left">application/pdf</td></tr><tr><td align="left">.pdx</td><td align="left">application/vnd.adobe.pdx</td><td align="left">.pfx</td><td align="left">application/x-pkcs12</td></tr><tr><td align="left">.pgl</td><td align="left">application/x-pgl</td><td align="left">.pic</td><td align="left">application/x-pic</td></tr><tr><td align="left">.pko</td><td align="left">application/vnd.ms-pki.pko</td><td align="left">.pl</td><td align="left">application/x-perl</td></tr><tr><td align="left">.plg</td><td align="left">text/html</td><td align="left">.pls</td><td align="left">audio/scpls</td></tr><tr><td align="left">.plt</td><td align="left">application/x-plt</td><td align="left">.png</td><td align="left">image/png</td></tr><tr><td align="left">.png</td><td align="left">application/x-png</td><td align="left">.pot</td><td align="left">application/vnd.ms-powerpoint</td></tr><tr><td align="left">.ppa</td><td align="left">application/vnd.ms-powerpoint</td><td align="left">.ppm</td><td align="left">application/x-ppm</td></tr><tr><td align="left">.pps</td><td align="left">application/vnd.ms-powerpoint</td><td align="left">.ppt</td><td align="left">application/vnd.ms-powerpoint</td></tr><tr><td align="left">.ppt</td><td align="left">application/x-ppt</td><td align="left">.pr</td><td align="left">application/x-pr</td></tr><tr><td align="left">.prf</td><td align="left">application/pics-rules</td><td align="left">.prn</td><td align="left">application/x-prn</td></tr><tr><td align="left">.prt</td><td align="left">application/x-prt</td><td align="left">.ps</td><td align="left">application/x-ps</td></tr><tr><td align="left">.ps</td><td align="left">application/postscript</td><td align="left">.ptn</td><td align="left">application/x-ptn</td></tr><tr><td align="left">.pwz</td><td align="left">application/vnd.ms-powerpoint</td><td align="left">.r3t</td><td align="left">text/vnd.rn-realtext3d</td></tr><tr><td align="left">.ra</td><td align="left">audio/vnd.rn-realaudio</td><td align="left">.ram</td><td align="left">audio/x-pn-realaudio</td></tr><tr><td align="left">.ras</td><td align="left">application/x-ras</td><td align="left">.rat</td><td align="left">application/rat-file</td></tr><tr><td align="left">.rdf</td><td align="left">text/xml</td><td align="left">.rec</td><td align="left">application/vnd.rn-recording</td></tr><tr><td align="left">.red</td><td align="left">application/x-red</td><td align="left">.rgb</td><td align="left">application/x-rgb</td></tr><tr><td align="left">.rjs</td><td align="left">application/vnd.rn-realsystem-rjs</td><td align="left">.rjt</td><td align="left">application/vnd.rn-realsystem-rjt</td></tr><tr><td align="left">.rlc</td><td align="left">application/x-rlc</td><td align="left">.rle</td><td align="left">application/x-rle</td></tr><tr><td align="left">.rm</td><td align="left">application/vnd.rn-realmedia</td><td align="left">.rmf</td><td align="left">application/vnd.adobe.rmf</td></tr><tr><td align="left">.rmi</td><td align="left">audio/mid</td><td align="left">.rmj</td><td align="left">application/vnd.rn-realsystem-rmj</td></tr><tr><td align="left">.rmm</td><td align="left">audio/x-pn-realaudio</td><td align="left">.rmp</td><td align="left">application/vnd.rn-rn_music_package</td></tr><tr><td align="left">.rms</td><td align="left">application/vnd.rn-realmedia-secure</td><td align="left">.rmvb</td><td align="left">application/vnd.rn-realmedia-vbr</td></tr><tr><td align="left">.rmx</td><td align="left">application/vnd.rn-realsystem-rmx</td><td align="left">.rnx</td><td align="left">application/vnd.rn-realplayer</td></tr><tr><td align="left">.rp</td><td align="left">image/vnd.rn-realpix</td><td align="left">.rpm</td><td align="left">audio/x-pn-realaudio-plugin</td></tr><tr><td align="left">.rsml</td><td align="left">application/vnd.rn-rsml</td><td align="left">.rt</td><td align="left">text/vnd.rn-realtext</td></tr><tr><td align="left">.rtf</td><td align="left">application/msword</td><td align="left">.rtf</td><td align="left">application/x-rtf</td></tr><tr><td align="left">.rv</td><td align="left">video/vnd.rn-realvideo</td><td align="left">.sam</td><td align="left">application/x-sam</td></tr><tr><td align="left">.sat</td><td align="left">application/x-sat</td><td align="left">.sdp</td><td align="left">application/sdp</td></tr><tr><td align="left">.sdw</td><td align="left">application/x-sdw</td><td align="left">.sit</td><td align="left">application/x-stuffit</td></tr><tr><td align="left">.slb</td><td align="left">application/x-slb</td><td align="left">.sld</td><td align="left">application/x-sld</td></tr><tr><td align="left">.slk</td><td align="left">drawing/x-slk</td><td align="left">.smi</td><td align="left">application/smil</td></tr><tr><td align="left">.smil</td><td align="left">application/smil</td><td align="left">.smk</td><td align="left">application/x-smk</td></tr><tr><td align="left">.snd</td><td align="left">audio/basic</td><td align="left">.sol</td><td align="left">text/plain</td></tr><tr><td align="left">.sor</td><td align="left">text/plain</td><td align="left">.spc</td><td align="left">application/x-pkcs7-certificates</td></tr><tr><td align="left">.spl</td><td align="left">application/futuresplash</td><td align="left">.spp</td><td align="left">text/xml</td></tr><tr><td align="left">.ssm</td><td align="left">application/streamingmedia</td><td align="left">.sst</td><td align="left">application/vnd.ms-pki.certstore</td></tr><tr><td align="left">.stl</td><td align="left">application/vnd.ms-pki.stl</td><td align="left">.stm</td><td align="left">text/html</td></tr><tr><td align="left">.sty</td><td align="left">application/x-sty</td><td align="left">.svg</td><td align="left">text/xml</td></tr><tr><td align="left">.swf</td><td align="left">application/x-shockwave-flash</td><td align="left">.tdf</td><td align="left">application/x-tdf</td></tr><tr><td align="left">.tg4</td><td align="left">application/x-tg4</td><td align="left">.tga</td><td align="left">application/x-tga</td></tr><tr><td align="left">.tif</td><td align="left">image/tiff</td><td align="left">.tif</td><td align="left">application/x-tif</td></tr><tr><td align="left">.tiff</td><td align="left">image/tiff</td><td align="left">.tld</td><td align="left">text/xml</td></tr><tr><td align="left">.top</td><td align="left">drawing/x-top</td><td align="left">.torrent</td><td align="left">application/x-bittorrent</td></tr><tr><td align="left">.tsd</td><td align="left">text/xml</td><td align="left">.txt</td><td align="left">text/plain</td></tr><tr><td align="left">.uin</td><td align="left">application/x-icq</td><td align="left">.uls</td><td align="left">text/iuls</td></tr><tr><td align="left">.vcf</td><td align="left">text/x-vcard</td><td align="left">.vda</td><td align="left">application/x-vda</td></tr><tr><td align="left">.vdx</td><td align="left">application/vnd.visio</td><td align="left">.vml</td><td align="left">text/xml</td></tr><tr><td align="left">.vpg</td><td align="left">application/x-vpeg005</td><td align="left">.vsd</td><td align="left">application/vnd.visio</td></tr><tr><td align="left">.vsd</td><td align="left">application/x-vsd</td><td align="left">.vss</td><td align="left">application/vnd.visio</td></tr><tr><td align="left">.vst</td><td align="left">application/vnd.visio</td><td align="left">.vst</td><td align="left">application/x-vst</td></tr><tr><td align="left">.vsw</td><td align="left">application/vnd.visio</td><td align="left">.vsx</td><td align="left">application/vnd.visio</td></tr><tr><td align="left">.vtx</td><td align="left">application/vnd.visio</td><td align="left">.vxml</td><td align="left">text/xml</td></tr><tr><td align="left">.wav</td><td align="left">audio/wav</td><td align="left">.wax</td><td align="left">audio/x-ms-wax</td></tr><tr><td align="left">.wb1</td><td align="left">application/x-wb1</td><td align="left">.wb2</td><td align="left">application/x-wb2</td></tr><tr><td align="left">.wb3</td><td align="left">application/x-wb3</td><td align="left">.wbmp</td><td align="left">image/vnd.wap.wbmp</td></tr><tr><td align="left">.wiz</td><td align="left">application/msword</td><td align="left">.wk3</td><td align="left">application/x-wk3</td></tr><tr><td align="left">.wk4</td><td align="left">application/x-wk4</td><td align="left">.wkq</td><td align="left">application/x-wkq</td></tr><tr><td align="left">.wks</td><td align="left">application/x-wks</td><td align="left">.wm</td><td align="left">video/x-ms-wm</td></tr><tr><td align="left">.wma</td><td align="left">audio/x-ms-wma</td><td align="left">.wmd</td><td align="left">application/x-ms-wmd</td></tr><tr><td align="left">.wmf</td><td align="left">application/x-wmf</td><td align="left">.wml</td><td align="left">text/vnd.wap.wml</td></tr><tr><td align="left">.wmv</td><td align="left">video/x-ms-wmv</td><td align="left">.wmx</td><td align="left">video/x-ms-wmx</td></tr><tr><td align="left">.wmz</td><td align="left">application/x-ms-wmz</td><td align="left">.wp6</td><td align="left">application/x-wp6</td></tr><tr><td align="left">.wpd</td><td align="left">application/x-wpd</td><td align="left">.wpg</td><td align="left">application/x-wpg</td></tr><tr><td align="left">.wpl</td><td align="left">application/vnd.ms-wpl</td><td align="left">.wq1</td><td align="left">application/x-wq1</td></tr><tr><td align="left">.wr1</td><td align="left">application/x-wr1</td><td align="left">.wri</td><td align="left">application/x-wri</td></tr><tr><td align="left">.wrk</td><td align="left">application/x-wrk</td><td align="left">.ws</td><td align="left">application/x-ws</td></tr><tr><td align="left">.ws2</td><td align="left">application/x-ws</td><td align="left">.wsc</td><td align="left">text/scriptlet</td></tr><tr><td align="left">.wsdl</td><td align="left">text/xml</td><td align="left">.wvx</td><td align="left">video/x-ms-wvx</td></tr><tr><td align="left">.xdp</td><td align="left">application/vnd.adobe.xdp</td><td align="left">.xdr</td><td align="left">text/xml</td></tr><tr><td align="left">.xfd</td><td align="left">application/vnd.adobe.xfd</td><td align="left">.xfdf</td><td align="left">application/vnd.adobe.xfdf</td></tr><tr><td align="left">.xhtml</td><td align="left">text/html</td><td align="left">.xls</td><td align="left">application/vnd.ms-excel</td></tr><tr><td align="left">.xls</td><td align="left">application/x-xls</td><td align="left">.xlw</td><td align="left">application/x-xlw</td></tr><tr><td align="left">.xml</td><td align="left">text/xml</td><td align="left">.xpl</td><td align="left">audio/scpls</td></tr><tr><td align="left">.xq</td><td align="left">text/xml</td><td align="left">.xql</td><td align="left">text/xml</td></tr><tr><td align="left">.xquery</td><td align="left">text/xml</td><td align="left">.xsd</td><td align="left">text/xml</td></tr><tr><td align="left">.xsl</td><td align="left">text/xml</td><td align="left">.xslt</td><td align="left">text/xml</td></tr><tr><td align="left">.xwd</td><td align="left">application/x-xwd</td><td align="left">.x_b</td><td align="left">application/x-x_b</td></tr><tr><td align="left">.sis</td><td align="left">application/vnd.symbian.install</td><td align="left">.sisx</td><td align="left">application/vnd.symbian.install</td></tr><tr><td align="left">.x_t</td><td align="left">application/x-x_t</td><td align="left">.ipa</td><td align="left">application/vnd.iphone</td></tr><tr><td align="left">.apk</td><td align="left">application/vnd.android.package-archive</td><td align="left">.xap</td><td align="left">application/x-silverlight-app</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章web应用实现</title>
      <link href="/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC12%E7%AB%A0Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC12%E7%AB%A0Web%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="MVC是什么：合理的设计我们的应用"><a href="#MVC是什么：合理的设计我们的应用" class="headerlink" title="MVC是什么：合理的设计我们的应用"></a>MVC是什么：合理的设计我们的应用</h3><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>理解 MVC 架构的概念</li><li>能够在项目中应用 MVC 架构模式</li></ol><a id="more"></a><h2 id="12-1-MVC"><a href="#12-1-MVC" class="headerlink" title="12.1 MVC"></a>12.1 MVC</h2><p>应用程序开发人员在工作中都需要考虑一些问题，如：</p><ul><li>如何简化开发</li><li>如何降低应用程序的耦合性</li><li>如何提高代码的重用性</li><li>如何提高应用程序的可扩展性及维护性</li><li>……</li></ul><p>1979年，由 Trygve Reenskaug 在 Smalltalk-80 系统上首次提出了 MVC 的概念，主要核心就是由专业的人做专业的事。MVC 模式代表 Model（模型）－View（视图）－Controller（控制器）模式。这种模式主要应用于应用程序的分层开发。将应用程序中显示什么数据、数据由谁处理、怎么处理进行分离，可以由不同的开发人员专注于自己的领域，而无需关注其它。</p><h3 id="12-1-1-MVC架构概念"><a href="#12-1-1-MVC架构概念" class="headerlink" title="12.1.1 MVC架构概念"></a>12.1.1 MVC架构概念</h3><p>MVC将应用程序划分为三种组件，并明确定义了它们之间的相互作用：</p><ul><li><strong>模型（Model）：</strong>用于封装与应用程序的业务逻辑相关的数据以及对数据的处理法。”Model”有对数据直接访问的权力，例如对数据库的访问。”Model”不依赖”View”和”Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变</li><li><strong>视图（View）：</strong>能够实现数据有目的的显示。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册</li><li><strong>控制器（Controller）：</strong>可以将控制器理解为一个桥梁，处理事件并作出响应。负责从视图读取数据，控制用户输入，并向模型发送数据</li></ul><h3 id="12-1-2-MVC架构优缺点"><a href="#12-1-2-MVC架构优缺点" class="headerlink" title="12.1.2 MVC架构优缺点"></a>12.1.2 MVC架构优缺点</h3><p>不论是什么技术，使用什么理念，尤其是能够经过长时间的应用实践，都有其显著的优点，有优点，也必然存在一些缺点，下面我们来看一下 MVC 模式的优缺点。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>高内聚性 － MVC可以在控制器上对相关操作进行逻辑分组。特定模型的视图也可以组合在一起。</li><li>耦合性低 － MVC框架的本质是模型，视图或控制器之间的耦合较低</li><li>重用性高 －允许使用各种不同样式的视图来访问同一个服务器端的代码；将数据和业务规则从表示层分开，可以最大化的重用代码。模型也有状态管理和数据持久性处理的功能</li><li>提高可扩展性与可维护性 － 由于分离视图层和业务逻辑层也使得WEB应用更易于维护和修改</li><li>利于项目的管理 － 由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化管理程序代码。控制器也提供了一个好处，就是可以使用控制器来联接不同的模型和视图去完成用户的需求</li><li>简化了分组开发－不同的开发人员可同步开发应用项目中的视图、控制器逻辑和业务逻辑</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加系统结构及代码量－对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性及相应的代码量</li><li>不适用于中小型应用项目 － 将MVC应用到规模并不是很大的应用程序通常会降低开发效率，增加开发成本</li><li>显著的学习曲线 － 关于掌握多种技术的知识成为常态。使用MVC的开发人员需要熟练掌握多种技术</li></ul><h3 id="12-1-3-MVC架构的实际应用"><a href="#12-1-3-MVC架构的实际应用" class="headerlink" title="12.1.3 MVC架构的实际应用"></a>12.1.3 MVC架构的实际应用</h3><p>MVC 不是一种技术，而是一种理念。下面是一个通过 JavaScript 所实现的基于 MVC 模型，在这个简短的代码中就写成了一个具有完整 MVC 架构模式概念的示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 模拟 Model, View, Controller */</span></span><br><span class="line"><span class="keyword">var</span> M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Model 负责存储数据 */</span></span><br><span class="line">M.data = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** View 负责将数据显示在屏幕上 */</span></span><br><span class="line">V.render = <span class="function">(<span class="params">M</span>) =&gt;</span> &#123; alert(M.data); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Controller 作为一个 M 和 V 的桥梁 */</span></span><br><span class="line">C.handleOnload = <span class="function"><span class="params">()</span> =&gt;</span> &#123; V.render(M); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在网页加载时调用 Controller */</span></span><br><span class="line"><span class="built_in">window</span>.onload = C.handleOnload;</span><br></pre></td></tr></table></figure><h3 id="调用链码－设计业务层"><a href="#调用链码－设计业务层" class="headerlink" title="调用链码－设计业务层"></a>调用链码－设计业务层</h3><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ol><li>实现应用业务层</li><li>掌握SDK调用链码的相关API</li></ol><h2 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h2><p><code>fabric-sdk</code> 不仅提供了相应的强大功能，而且还给开发人员设计提供了相应的API 接口，以方便开发人员随时调用。做为开发设计人员，我们不仅要考虑用户操作的方便性及可交互性，还需要考虑应用程序后期的可扩展性及维护性，为此我们将为应用增加一个业务层，所有的客户请求都由业务层发送给链码，通过对链码的调用，进而实现对分类账本状态的操作。</p><h3 id="12-2-1-事件处理"><a href="#12-2-1-事件处理" class="headerlink" title="12.2.1 事件处理"></a>12.2.1 事件处理</h3><p>在项目根目录下创建一个 <code>service</code> 目录作为业务层，在业务层中，我们使用 <code>Fabric-SDK-Go</code> 提供的接口对象调用相应的 API 以实现对链码的访问，最终实现对分类账本中的状态进行操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir service</span></span><br></pre></td></tr></table></figure><p>在 <code>service</code> 目录下创建 <code>domain.go</code> 文件并进行编辑， 声明一个结构体及对事件相关而封装的源代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/domain.go</span></span><br></pre></td></tr></table></figure><p><code>domain.go</code> 文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/fab"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceSetup <span class="keyword">struct</span> &#123;</span><br><span class="line">    ChaincodeID    <span class="keyword">string</span></span><br><span class="line">    Client    *channel.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">regitserEvent</span><span class="params">(client *channel.Client, chaincodeID, eventID <span class="keyword">string</span>)</span> <span class="params">(fab.Registration, &lt;-<span class="keyword">chan</span> *fab.CCEvent)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    reg, notifier, err := client.RegisterChaincodeEvent(chaincodeID, eventID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"注册链码事件失败: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reg, notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eventResult</span><span class="params">(notifier &lt;-<span class="keyword">chan</span> *fab.CCEvent, eventID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ccEvent := &lt;-notifier:</span><br><span class="line">        fmt.Printf(<span class="string">"接收到链码事件: %v\n"</span>, ccEvent)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">20</span>):</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"不能根据指定的事件ID接收到相应的链码事件(%s)"</span>, eventID)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-2-调用链码添加状态"><a href="#12-2-2-调用链码添加状态" class="headerlink" title="12.2.2 调用链码添加状态"></a>12.2.2 调用链码添加状态</h3><p>在 <code>service</code> 目录下创建 <code>SimpleService.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/SimpleService.go</span></span><br></pre></td></tr></table></figure><p>在 <code>SimpleService.go</code> 文件中编写内容如下，通过一个 <code>SetInfo</code> 函数实现链码的调用，向分类账本中添加状态的功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">SetInfo</span><span class="params">(name, num <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    eventID := <span class="string">"eventSetInfo"</span></span><br><span class="line">    reg, notifier := regitserEvent(t.Client, t.ChaincodeID, eventID)</span><br><span class="line">    <span class="keyword">defer</span> t.Client.UnregisterChaincodeEvent(reg)</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"set"</span>, Args: [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(name), []<span class="keyword">byte</span>(num), []<span class="keyword">byte</span>(eventID)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Execute(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = eventResult(notifier, eventID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(respone.TransactionID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试添加状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p><code>main.go</code> 中创建一个对象，并调用 <code>SetInfo</code> 函数，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    [......]</span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/service"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[......]</span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">    serviceSetup := service.ServiceSetup&#123;</span><br><span class="line">        ChaincodeID:SimpleCC,</span><br><span class="line">        Client:channelClient,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg, err := serviceSetup.SetInfo(<span class="string">"hanxiaodong"</span>, <span class="string">"kongyixueyuan"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/12.1_7_1.png/mark" alt="测试添加状态"></p><h3 id="12-2-3-调用链码查询状态"><a href="#12-2-3-调用链码查询状态" class="headerlink" title="12.2.3 调用链码查询状态"></a>12.2.3 调用链码查询状态</h3><p>通过上面的 <code>setInfo(name, num string)</code> 函数，实现了向分类账本中添加状态，那么我们还需要实现从该分类账本中根据指定的 key 查询出相应的状态，编辑 <code>service/SimpleService.go</code> 文件，向该文件中添加实现查询状态的相应代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/SimpleService.go</span></span><br></pre></td></tr></table></figure><p>定义一个 <code>GetInfo</code> 函数，接收一个字符串类型的参数，该函数实现通过调用链码而查询状态的功能，该函数完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">GetInfo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"get"</span>, Args: [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(name)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Query(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(respone.Payload), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试查询状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    msg, err = serviceSetup.GetInfo(<span class="string">"hanxiaodong"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/12.1_7_2.png/mark" alt="业务层测试"></p><p>未经授权禁止转载、改编，转载请注明出处！</p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/219" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/219</a></p><h3 id="MVC架构应用实现"><a href="#MVC架构应用实现" class="headerlink" title="MVC架构应用实现"></a>MVC架构应用实现</h3><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ol><li>完成Web应用</li><li>理解Goweb应用开发重点</li></ol><h2 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h2><h3 id="12-3-1-目录结构"><a href="#12-3-1-目录结构" class="headerlink" title="12.3.1 目录结构"></a>12.3.1 目录结构</h3><p>通过业务层已经实现了利用 <code>fabric-sdk-go</code> 调用链码查询或操作分类账本状态，但是开发人员的工作不可能就此而止，需要考虑用户该如何使用此应用程序，一般情况下，交给用户使用的应用程序有以下两种方式：</p><ol><li>桌面应用：传统实现方式，将应用程序打包成为一个可执行的安装程序之后，由用户安装在本地然后运行（可能需要特定的环境），进而进行相关操作。</li><li>Web浏览器应用：此方式相对于用户而言，非常方便，用户只需要在本地的浏览器中就可以使用应用程序的相关功能。</li></ol><p>为了方便用户的操作使用，我们使用第二种方式来实现。以便于让用户通过浏览器就可以实现对分类账的操作。同样我们需要考虑应用程序后期的可扩展性及维护性，为此我们将应用程序进行了分层管理，设计增加了控制层及视图层。</p><p>视图层提供用户的可视界面与交互，控制层接收用户的请求，由控制层访问业务层，进而调用链码对分类账进行操作，之后将操作结果响应给客户端浏览器。</p><p>Go 语言本身提供了一个 Web 服务器来处理 HTTP 请求，并为 HTML 页面提供模板。下面我们来实现 Web 应用程序。</p><p>新建web目录，包含三个其他目录的目录。将使用 MVC（Model（模型）－View（视图） - Controller（控制器））模式使其更具可读性及扩展性、维护性。模型将是区块链部分，视图是模板，控制器由<code>controllers</code>目录中的功能提供。</p><ul><li><code>web/tpl</code>：包含所有的HTML页面</li><li><code>web/static</code>：包含所有静态CSS，Javascript，图片等文件</li><li><code>web/controllers</code> ：包含将呈现模板的所有函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br></pre></td></tr></table></figure><p>创建相应的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/controller</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/css</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/img</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/tpl</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：可以直接使用 <code>git clone https://github.com/kevin-hf/hfsdkgoweb.git</code> 命令克隆完整的内容到项目的根目录中，然后将文件夹重命名： <code>mv hfsdkgoweb/ web</code> ，重新命名后直接跳至 8.6 步骤执行。</p></blockquote><p><strong><code>web/controller</code> 目录</strong></p><p><code>controller/controllerHandler.go</code> ： 用于接收并处理各种客户端请求的源代码文件</p><p><code>controller/controllerResponse</code>：用于编写响应客户端请求的源代码文件</p><p><strong><code>web/static</code>目录下包括三个子目录，分别为：</strong></p><p><code>web/static/css</code> ：用于存放页面布局及显示样式所需的 <code>CSS</code> 文件</p><p><code>web/static/js</code> ：用于存放编写的与用户交互的 <code>JavaScript</code> 源码文件</p><p><code>web/static/img</code>：用户存放页面显示所需的所有图片文件</p><p><strong><code>web/tpl</code> 目录下包括三个静态 HTML 页面文件，分别为：</strong></p><p><code>web/tpl/index.html</code>： 用户访问的首页面</p><p><code>web/tpl/queryReq.html</code>： 用于显示显示查询结果的页面</p><p><code>web/tpl/setInfo.html</code>： 用户设置/修改状态的页面</p><p><strong><code>web/webServer.go</code></strong>：用于指定启动Web服务及相应的路由信息</p><p>具体目录结构如下图所示：</p><p><img src="http://image.chaindesk.cn/12.1_a.png/mark" alt="web应用目录结构"></p><h3 id="12-3-2-指定响应处理文件"><a href="#12-3-2-指定响应处理文件" class="headerlink" title="12.3.2 指定响应处理文件"></a>12.3.2 指定响应处理文件</h3><p>在 <code>web/controller</code> 目录下创建 <code>controllerResponse.go</code> 文件，用于响应客户端的请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/controllerResponse.go</span></span><br></pre></td></tr></table></figure><p><code>controllerResponse.go</code> 内容参见：</p><ul><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/controller/controllerResponse.go" target="_blank" rel="noopener">web/controller/controllerResponse.go</a></li></ul><h3 id="12-3-3-请求处理控制器"><a href="#12-3-3-请求处理控制器" class="headerlink" title="12.3.3 请求处理控制器"></a>12.3.3 请求处理控制器</h3><p>在 <code>web/controller</code> 目录下添加 <code>controllerHandler.go</code> 文件，用于接收客户端请求并做出相应的处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/controllerHandler.go</span></span><br></pre></td></tr></table></figure><p><code>controllerHandler.go</code> 文件中添加内容参见：</p><ul><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/controller/controllerHandler.go" target="_blank" rel="noopener">web/controller/controllerHandler.go</a></li></ul><h3 id="12-3-4-编写页面"><a href="#12-3-4-编写页面" class="headerlink" title="12.3.4 编写页面"></a>12.3.4 编写页面</h3><p>页面详细内容参见：</p><ul><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/tpl/index.html" target="_blank" rel="noopener">web/tpl/index.html</a></li><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/tpl/queryReq.html" target="_blank" rel="noopener">web/tpl/queryReq.html</a></li><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/tpl/setInfo.html" target="_blank" rel="noopener">web/tpl/setInfo.html</a></li></ul><h3 id="12-3-5-添加路由信息"><a href="#12-3-5-添加路由信息" class="headerlink" title="12.3.5 添加路由信息"></a>12.3.5 添加路由信息</h3><p>在 <code>web</code> 目录中添加 <code>webServer.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/webServer.go</span></span><br></pre></td></tr></table></figure><p>编辑 <code>webServer.go</code> 文件，内容参见：</p><ul><li><a href="https://github.com/kevin-hf/hfsdkgoweb/blob/master/webServer.go" target="_blank" rel="noopener">web/webServer.go</a></li></ul><h3 id="12-3-6-启动Web服务"><a href="#12-3-6-启动Web服务" class="headerlink" title="12.3.6 启动Web服务"></a>12.3.6 启动Web服务</h3><p>最后编辑 <code>main.go</code> ，以便启动Web界面实现Web应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>添加如下内容:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    [......]</span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/web"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/web/controller"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    [......]</span><br><span class="line"></span><br><span class="line">    app := controller.Application&#123;</span><br><span class="line">        Fabric: &amp;serviceSetup,</span><br><span class="line">    &#125;</span><br><span class="line">    web.WebStart(&amp;app)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令启动Web应用：</p><p><img src="http://image.chaindesk.cn/12.1_8.png/mark" alt="启动Web应用"></p><h3 id="12-3-7-页面访问"><a href="#12-3-7-页面访问" class="headerlink" title="12.3.7 页面访问"></a>12.3.7 页面访问</h3><p>打开浏览器访问: <a href="http://localhost:9000/" target="_blank" rel="noopener">htt://localhost:9000/</a></p><p>因为我们这是一个简单的 Web 应用示例，所以页面不会要求达到多么美观的地步，只是能够实现相应的功能即可。根据访问的地址，首先进入 <code>index.html</code> 页面，该 <code>index.html</code> 页面提供了两个链接（也可以通过页面顶部的菜单中访问），用于实现在在分类账本中进行状态查询或对分类账本中的状态进行修改的操作（在此不实现添加状态的操作）。</p><p><img src="http://image.chaindesk.cn/index.png/mark" alt="index"></p><p>因为我们在业务层中测试过一次，通过调用业务层向分类账中添加了一条状态， 所以现在分类帐中有一个 <code>key 为 Hanxiaodong</code>，<code>value 为 Kongyixueyuan</code> 的键值对数据，可以点击 <code>查询信息</code> 的链接实现查询</p><p><img src="http://image.chaindesk.cn/queryReq.png/mark" alt="queryReq"></p><p>点击页面中的 <code>设置/修改</code> 链接后进入一个表单页面，该页面提供了一个更改状态的表单，表单中的 key 为固定值，用户需要输入对应的 Val，之后点击提交按钮发送请求。</p><p><img src="http://image.chaindesk.cn/setInfo.png/mark" alt="setInfo"></p><p>在 Val 输入框中输入一个值，如 <code>ChainDesk</code> 后点击提交按钮，表单被提交到服务器，服务器处理完毕将返回操作成功的交易ID并将其显示在页面中。</p><p><img src="http://image.chaindesk.cn/setResponse.png/mark" alt="setResponse"></p><p>我们可以通过点击页面中的 <code>查询信息</code> 链接来查看状态是否更改成功</p><p><img src="http://image.chaindesk.cn/query2.png/mark" alt="query2"></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>为什么要将客户端请求与响应的代码分开写在不同的文件中？</p><p>一个文件中的编写的代码不宜过多，如果合理设计，分开写在不同的文件中有利于提高代码的可读性还可以提高应用程序的可维护性与可扩展性。</p></li><li><p>路由指的是什么意思？</p><p>路由其实就是设定客户端不同的请求访问地址。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章Fabric-SDK-Goweb项目</title>
      <link href="/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC10%E7%AB%A0Fabric-SDK-Go%E7%9A%84Web%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC10%E7%AB%A0Fabric-SDK-Go%E7%9A%84Web%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、项目引言"><a href="#一、项目引言" class="headerlink" title="一、项目引言"></a>一、项目引言</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><p>明确项目的所需环境及实现目的</p></li><li><p>构建基于 Fabric-SDK-Go 项目的所需环境</p><a id="more"></a></li></ol><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>此项目是一个使用 <code>Hyperledger Fabric</code> 平台作为网络环境底层，在业务层利用 fabric-sdk-go 相关API实现对链码的调用，并且使用GoWeb实现的一个Web应用示例程序。为了提高应用程序的可扩展性及可维护性，我们使用了基于 <code>MVC</code> 的架构模式，对项目进行分层设计。</p><p>此应用示例是为了帮助读者能够快速掌握基于 <code>fabric-sdk-go</code> 的开发方式与技巧，所以我们的链码业务只是简单的实现了对分类账本状态的读写操作。</p><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>在之前的内容中，我们详细的介绍了 <code>Hyperledger Fabric</code> 的系统架构及相关的组件。包括 Fabric 网络环境搭建，链码开发及测试及分布式账本数据的存储方式。所以我们不会在此项目详细解释 Hyperledger Fabric 的工作原理。在学习本项目之前，您应该通过要本书的前几章或通过Hyperledger Fabric <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/whatis.html" target="_blank" rel="noopener">官网</a> 或其它渠道学习并掌握 Hyperledger Fabric 的一些知识，以具备 Hyperledger Fabric 操作基础。</p><p>本应用实现是在基于 <strong>Ubuntu 16.04（推荐）</strong> 系统的基础上完成的，但 Hyperledger Fabric 与Mac OS X、Windows和其他Linux发行版相兼容。</p><h3 id="1-2-所需环境及工具"><a href="#1-2-所需环境及工具" class="headerlink" title="1.2 所需环境及工具"></a>1.2 所需环境及工具</h3><p>现在我们重新安装一个干净的 <strong>Ubuntu 16.04</strong> 操作系统（如果之前有备份，直接恢复为系统刚安装时的状态即可），实现从零到壹的 Hyperledger Fabric 网络环境搭建、SDK-Go 的应用、链码开发及最后的Web应用体验。</p><ul><li><strong>Ubuntu 16.04</strong></li><li><strong>vim、git</strong></li><li><strong>docker 17.03.0-ce+</strong></li><li><strong>docker-compose 1.8</strong>+</li><li><strong>Golang 1.10.x+</strong></li></ul><h2 id="2-先决条件"><a href="#2-先决条件" class="headerlink" title="2 先决条件"></a>2 先决条件</h2><p>如下环境及工具如果在系统没有安装，请按照步骤进行安装，如果系统中已成功安装且符合相应的版本要求，则无须重复执行。如果已安装版本低于指定要求的版本，请报载之后重新安装符合要求的版本。</p><h3 id="2-1-安装-vim、git"><a href="#2-1-安装-vim、git" class="headerlink" title="2.1 安装 vim、git"></a>2.1 安装 vim、git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install vim</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install git</span></span><br></pre></td></tr></table></figure><h3 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装docker</h3><p><strong>需要Docker版本17.03.0-ce或更高版本。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install docker.io</span></span><br></pre></td></tr></table></figure><p>安装完成后执行版本查询命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker version</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/docker_1.png/mark" alt="docker版本"></p><h3 id="2-3-安装docker-compose"><a href="#2-3-安装docker-compose" class="headerlink" title="2.3 安装docker-compose"></a>2.3 安装docker-compose</h3><p><strong>docker-compose 1.8或更高版本是必需的。</strong></p><p>我们目前无法一次性轻松管理多个容器。 为了解决这个问题，需要<strong>docker-compose</strong> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose version </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install docker-compose</span></span><br></pre></td></tr></table></figure><p>安装完成后查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose version</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/docker_2.png/mark" alt="docker-compose版本"></p><p>将当前用户添加到 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker kevin</span></span><br></pre></td></tr></table></figure><p>添加成功后<strong>必须注销/退出并重新登录</strong>(退出终端重新连接即可)</p><blockquote><p>如果没有将当前用户添加到 docker 组中，在后期执行make命令时会造成错误: <code>ERROR: Couldn&#39;t connect to Docker daemon at http+docker://localunixsocket - is it running?</code></p></blockquote><h3 id="2-4-安装Golang"><a href="#2-4-安装Golang" class="headerlink" title="2.4 安装Golang"></a>2.4 安装Golang</h3><p><strong>需要版本1.10.x或更高。</strong>如果您使用的是 Hyperledger Fabric 1.1.x 版本，那么 Golang 版本在 1.9.x 以上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go version </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><blockquote><p>下载受网络环境影响，如果您本地有相应的 tar 包，则直接解压到指定的路径下即可。</p></blockquote><p>使用 tar 命令将下载后的压缩包文件解压到指定的 /usr/local/ 路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf go1.10.3.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>/</span></span><br></pre></td></tr></table></figure><p>设置GOPATH &amp; GOROOT环境变量, 通过 <code>go env</code> 查看GOPATH路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/profile</span></span><br></pre></td></tr></table></figure><blockquote><p>如果只想让当前登录用户使用Golang， 其它用户不能使用， 则编辑当前用户$HOME目录下的 .bashrc 或 .profile 文件， 在该文件中添加相应的环境变量即可。</p></blockquote><p>在profile文件最后添加如下内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/go</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br></pre></td></tr></table></figure><p>使用 source 命令，使刚刚添加的配置信息生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><p>通过 go version命令验证是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/go_version.png/mark" alt="Go版本"></p><h2 id="二、网络环境"><a href="#二、网络环境" class="headerlink" title="二、网络环境"></a>二、网络环境</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>使用提供的 Crypto 构建项目所需的网络环境</li><li>确保网络启动成功</li></ol><h2 id="1-网络环境"><a href="#1-网络环境" class="headerlink" title="1 网络环境"></a>1 网络环境</h2><h3 id="1-1-网络环境准备"><a href="#1-1-网络环境准备" class="headerlink" title="1.1 网络环境准备"></a>1.1 网络环境准备</h3><p>Hyperledger Fabric 处理交易时需要大量的证书来确保在整个端到端流程（TSL，身份验证，签名块……）期间进行加密。 为了直接了解问题的核心，我们已经在 github 上为您的网络环境准备了所有相关的内容， 不在此教程中讲解。</p><blockquote><p>Crypto 材料已使用 Hyperledger Fabric 中的 <strong>cryptogen</strong> 工具生成，并保存在 hf-fixtures/crypto-config 目录中。有关 <strong>cryptogen</strong> 工具的更多详细信息，请 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/commands/cryptogen.html" target="_blank" rel="noopener">点击此处</a>。</p><p>初始区块（genesis.block）和通道配置事务（channel.tx）已使用 Hyperledger Fabric中 的 <strong>configtxgen</strong> 工具生成，并保存在 hf-fixtures/artifacts 目录中。有关 <strong>configtxgen</strong> 工具的更多详细信息，请 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/commands/configtxgen.html" target="_blank" rel="noopener">点击此处</a>。</p></blockquote><p>在<code>GOPATH</code>的<code>src</code>文件夹中新建一个目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br></pre></td></tr></table></figure><p>使用 <code>git</code> 命令克隆 hf-fixtures 目录当前路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/kevin-hf/hf-fixtures.git</span></span><br></pre></td></tr></table></figure><p>将 hf-fixtures 文件夹重命名为 fixtures</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv hf-fixtures/ fixtures</span></span><br></pre></td></tr></table></figure><p>修改<code>fixtures</code> 文件夹的所属关系为当前用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R hg:hg ./fixtures   //原先sudo chown -R kevin:kevin ./fixtures</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： kevin 为安装 Ubuntu 16.04 系统时创建的用户</p></blockquote><p>进入 <code>fixtures</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fixtures</span></span><br></pre></td></tr></table></figure><p>为了构建区块链网络，使用 <code>docker</code> 构建处理不同角色的虚拟计算机。 在这里我们将尽可能保持简单。如果确定您的系统中已经存在相关的所需容器，或可以使用其它方式获取，则无需执行如下命令。否则请将 <code>fixtures</code> 目录下的 <code>pull_images.sh</code> 文件添加可执行权限后直接执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 777 ./pull_images.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./pull_images.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：<code>pull_images.sh</code> 文件是下载 Fabric 环境所需容器的一个可执行脚本，下载过程需要一段时间（视网速情况而定），请耐心等待。另：请确定您的系统支持虚拟技术。</p></blockquote><h3 id="1-2-配置docker-compose-yml文件"><a href="#1-2-配置docker-compose-yml文件" class="headerlink" title="1.2 配置docker-compose.yml文件"></a>1.2 配置docker-compose.yml文件</h3><p>在 <code>fixtures</code> 目录下创建一个 <code>docker-compose.yml</code> 文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim docker-compose.yml</span></span><br></pre></td></tr></table></figure><ol><li><p>将 <code>network下的basic</code> 修改为 <code>default</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br></pre></td></tr></table></figure></li><li><p>编辑 orderer 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">orderer.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=debug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENPORT=7050</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISPROFILE=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./artifacts/genesis.block:/var/hyperledger/orderer/genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/orderers/orderer.kevin.kongyixueyuan.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/orderers/orderer.kevin.kongyixueyuan.com/tls:/var/hyperledger/orderer/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7050</span><span class="string">:7050</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>编辑 ca 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ca.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-ca</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_NAME=ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/727e69ed4a01a204cd53bf4a97c2c1cb947419504f82851f6ae563c3c96dea3a_sk</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_KEYFILE=/etc/hyperledger/fabric-ca-server-config/727e69ed4a01a204cd53bf4a97c2c1cb947419504f82851f6ae563c3c96dea3a_sk</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7054</span><span class="string">:7054</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'fabric-ca-server start -b admin:adminpw -d'</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/ca/:/etc/hyperledger/fabric-ca-server-config</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>编辑Peer部分</p><ol><li><p><code>peer0.org1.example.com</code> 内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-peer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_DOCKER_ATTACHSTDOUT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_NETWORKID=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_PROFILE_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/var/hyperledger/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/var/hyperledger/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESSAUTODETECT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_SKIPHANDSHAKE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_SERVERHOSTOVERRIDE=peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">peer</span> <span class="string">node</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer0.org1.kevin.kongyixueyuan.com/msp:/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer0.org1.kevin.kongyixueyuan.com/tls:/var/hyperledger/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>peer1.org1.example.com 内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-peer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_DOCKER_ATTACHSTDOUT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_NETWORKID=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_PROFILE_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/var/hyperledger/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/var/hyperledger/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESSAUTODETECT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_SKIPHANDSHAKE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_SERVERHOSTOVERRIDE=peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">peer</span> <span class="string">node</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer1.org1.kevin.kongyixueyuan.com/msp:/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer1.org1.kevin.kongyixueyuan.com/tls:/var/hyperledger/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7151</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7153</span><span class="string">:7053</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>其余可根据实际情况进行添加</p></li></ol><h2 id="2-测试网络环境"><a href="#2-测试网络环境" class="headerlink" title="2 测试网络环境"></a>2 测试网络环境</h2><p>为了检查网络是否正常工作，使用<code>docker-compose</code>同时启动或停止所有容器。 进入<code>fixtures</code>文件夹，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br></pre></td></tr></table></figure><p>如果在您的系统中没有相关的容器，那么会自动下载docker镜像。下载完毕后自动启动，控制台会输出很多不同颜色的日志（红色不等于错误）</p><p><img src="http://image.chaindesk.cn/10.1_1.png/mark" alt="启动网络"></p><p>打开一个新终端并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/10.1_2.png/mark" alt="查看容器"></p><p>将看到：两个peer，一个orderer和一个CA容器。 代表已成功创建了一个新的网络，可以随SDK一起使用。 要停止网络，请返回到上一个终端，按<code>Ctrl+C</code>并等待所有容器都停止。</p><blockquote><p><strong>提示</strong> ：当网络成功启动后，所有处于活动中的容器都可以访问。 也可以查看指定容器的详细日志内容。 如果想删除这些容器，需要使用<code>docker rm $(docker ps -aq)</code>将其删除 ，但在删除容器之前需要确定其在网络环境中已不再使用。</p><p>如果在网络环境启动过程中不想看到大量的日志信息，请在该启动命令中添加参数 <code>-d</code> ，如下所示： <code>docker-compose up -d</code> 。 如果要停止网络，请务必在 <code>docker-compose.yaml</code> 所在的文件夹中运行命令： <code>docker-compose stop</code> （或 使用<code>docker-compose down</code> 进行清理停止所有容器）。</p></blockquote><p>最后在终端2中执行如下命令关闭网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose down</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/10.1_3.png/mark" alt="关闭网络"></p><p>终端1窗口中输出如下：</p><p><img src="http://image.chaindesk.cn/10.1_4.png/mark" alt="关闭网络过程"></p><p>未经授权禁止转载、改编，转载请注明出处！</p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/213" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/213</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章Fabric-SDK-Go</title>
      <link href="/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC11%E7%AB%A0Web%E5%AE%9E%E6%88%98-%E4%BD%BF%E7%94%A8Fabric-SDK-Go/"/>
      <url>/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC11%E7%AB%A0Web%E5%AE%9E%E6%88%98-%E4%BD%BF%E7%94%A8Fabric-SDK-Go/</url>
      
        <content type="html"><![CDATA[<h3 id="配置Fabric－SDK"><a href="#配置Fabric－SDK" class="headerlink" title="配置Fabric－SDK"></a>配置Fabric－SDK</h3><h2 id="一、配置Fabric－SDK"><a href="#一、配置Fabric－SDK" class="headerlink" title="一、配置Fabric－SDK"></a>一、配置Fabric－SDK</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>明确SDK-GO的相关配置</li><li>使用SDK提供的相关API创建通道并通过测试</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><p>Hyperledger Fabric 提供了许多 SDK 来支持各种不同的编程语言，但是因为 Hyperledger Fabric 是使用 Golang 构建的，所以我们将使用 Go 语言来设计应用程序，包括链码（智能合约）。如果您想使用其它 SDK，如 Fabric-SDK-Java，Fabric-SDK-Node等等，这些都可以通过在线文档进行学习，我们不在这里讨论。</p><a id="more"></a><h3 id="1-配置Fabric－SDK"><a href="#1-配置Fabric－SDK" class="headerlink" title="1 配置Fabric－SDK"></a>1 配置Fabric－SDK</h3><p>确认 Hyperledger Fabric 基础网络环境运行没有问题后，现在我们通过创建一个新的 config.yaml 配置文件给应用程序所使用的 Fabric-SDK-Go 配置相关参数及 Fabric 组件的通信地址</p><p>进入项目的根目录中创建一个 <code>config.yaml</code> 文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim config.yaml</span></span><br></pre></td></tr></table></figure><p>config.yaml 文件完整内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">"kongyixueyuan-network"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Schema version of the content. Used by the SDK to apply the corresponding parsing rules.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The client section used by GO SDK.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Which organization does this application instance belong to? The value must be the name of an org</span></span><br><span class="line">  <span class="comment"># defined under "organizations"</span></span><br><span class="line">  <span class="attr">organization:</span> <span class="string">Org1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">logging:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global configuration for peer, event service and orderer timeouts</span></span><br><span class="line">  <span class="comment"># if this this section is omitted, then default values will be used (same values as below)</span></span><br><span class="line"><span class="comment">#  peer:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 10s</span></span><br><span class="line"><span class="comment">#      response: 180s</span></span><br><span class="line"><span class="comment">#      discovery:</span></span><br><span class="line"><span class="comment">#        # Expiry period for discovery service greylist filter</span></span><br><span class="line"><span class="comment">#        # The channel client will greylist peers that are found to be offline</span></span><br><span class="line"><span class="comment">#        # to prevent re-selecting them in subsequent retries.</span></span><br><span class="line"><span class="comment">#        # This interval will define how long a peer is greylisted</span></span><br><span class="line"><span class="comment">#        greylistExpiry: 10s</span></span><br><span class="line"><span class="comment">#  eventService:</span></span><br><span class="line"><span class="comment">#    # Event service type (optional). If not specified then the type is automatically</span></span><br><span class="line"><span class="comment">#    # determined from channel capabilities.</span></span><br><span class="line"><span class="comment">#    type: (deliver|eventhub)</span></span><br><span class="line">    <span class="comment"># the below timeouts are commented out to use the default values that are found in</span></span><br><span class="line">    <span class="comment"># "pkg/fab/endpointconfig.go"</span></span><br><span class="line">    <span class="comment"># the client is free to override the default values by uncommenting and resetting</span></span><br><span class="line">    <span class="comment"># the values as they see fit in their config file</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 15s</span></span><br><span class="line"><span class="comment">#      registrationResponse: 15s</span></span><br><span class="line"><span class="comment">#  orderer:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 15s</span></span><br><span class="line"><span class="comment">#      response: 15s</span></span><br><span class="line"><span class="comment">#  global:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      query: 180s</span></span><br><span class="line"><span class="comment">#      execute: 180s</span></span><br><span class="line"><span class="comment">#      resmgmt: 180s</span></span><br><span class="line"><span class="comment">#    cache:</span></span><br><span class="line"><span class="comment">#      connectionIdle: 30s</span></span><br><span class="line"><span class="comment">#      eventServiceIdle: 2m</span></span><br><span class="line"><span class="comment">#      channelConfig: 30m</span></span><br><span class="line"><span class="comment">#      channelMembership: 30s</span></span><br><span class="line"><span class="comment">#      discovery: 10s</span></span><br><span class="line"><span class="comment">#      selection: 10m</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Root of the MSP directories with keys and certs.</span></span><br><span class="line">  <span class="attr">cryptoconfig:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/crypto-config</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Some SDKs support pluggable KV stores, the properties under "credentialStore"</span></span><br><span class="line">  <span class="comment"># are implementation specific</span></span><br><span class="line">  <span class="attr">credentialStore:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/kongyixueyuan-store</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Specific to the CryptoSuite implementation used by GO SDK. Software-based implementations</span></span><br><span class="line">    <span class="comment"># requiring a key store. PKCS#11 based implementations does not.</span></span><br><span class="line">    <span class="attr">cryptoStore:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/kongyixueyuan-msp</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># BCCSP config for the client. Used by GO SDK.</span></span><br><span class="line">  <span class="attr">BCCSP:</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">     <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">     <span class="attr">default:</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">"SW"</span></span><br><span class="line">     <span class="attr">hashAlgorithm:</span> <span class="string">"SHA2"</span></span><br><span class="line">     <span class="attr">softVerify:</span> <span class="literal">true</span></span><br><span class="line">     <span class="attr">level:</span> <span class="number">256</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tlsCerts:</span></span><br><span class="line">    <span class="comment"># [Optional]. Use system certificate pool when connecting to peers, orderers (for negotiating TLS) Default: false</span></span><br><span class="line">    <span class="attr">systemCertPool:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Client key and cert for TLS handshake with peers and orderers</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">key:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">      <span class="attr">cert:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [Optional]. But most apps would have this section so that channel objects can be constructed</span></span><br><span class="line"><span class="comment"># based on the content below. If an app is creating channels, then it likely will not need this</span></span><br><span class="line"><span class="comment"># section.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="comment"># name of the channel</span></span><br><span class="line">  <span class="attr">kevinkongyixueyuan:</span></span><br><span class="line">    <span class="comment"># Required. list of orderers designated by the application to use for transactions on this</span></span><br><span class="line">    <span class="comment"># channel. This list can be a result of access control ("org1" can only access "ordererA"), or</span></span><br><span class="line">    <span class="comment"># operational decisions to share loads from applications among the orderers.  The values must</span></span><br><span class="line">    <span class="comment"># be "names" of orgs defined under "organizations/peers"</span></span><br><span class="line">    <span class="comment"># deprecated: not recommended, to override any orderer configuration items, entity matchers should be used.</span></span><br><span class="line">    <span class="comment"># orderers:</span></span><br><span class="line">    <span class="comment">#  - orderer.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required. list of peers from participating orgs</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent transaction proposals for endorsement? The peer must</span></span><br><span class="line">        <span class="comment"># have the chaincode installed. The app can also use this property to decide which peers</span></span><br><span class="line">        <span class="comment"># to send the chaincode install request. Default: true</span></span><br><span class="line">        <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent query proposals? The peer must have the chaincode</span></span><br><span class="line">        <span class="comment"># installed. The app can also use this property to decide which peers to send the</span></span><br><span class="line">        <span class="comment"># chaincode install request. Default: true</span></span><br><span class="line">        <span class="attr">chaincodeQuery:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent query proposals that do not require chaincodes, like</span></span><br><span class="line">        <span class="comment"># queryBlock(), queryTransaction(), etc. Default: true</span></span><br><span class="line">        <span class="attr">ledgerQuery:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be the target of the SDK's listener registration? All peers can</span></span><br><span class="line">        <span class="comment"># produce events but the app typically only needs to connect to one to listen to events.</span></span><br><span class="line">        <span class="comment"># Default: true</span></span><br><span class="line">        <span class="attr">eventSource:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">        <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">chaincodeQuery:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ledgerQuery:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">eventSource:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="comment">#[Optional] options for retrieving channel configuration blocks</span></span><br><span class="line">      <span class="attr">queryChannelConfig:</span></span><br><span class="line">        <span class="comment">#[Optional] min number of success responses (from targets/peers)</span></span><br><span class="line">        <span class="attr">minResponses:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#[Optional] channel config will be retrieved for these number of random targets</span></span><br><span class="line">        <span class="attr">maxTargets:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#[Optional] retry options for query config block</span></span><br><span class="line">        <span class="attr">retryOpts:</span></span><br><span class="line">          <span class="comment">#[Optional] number of retry attempts</span></span><br><span class="line">          <span class="attr">attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment">#[Optional] the back off interval for the first retry attempt</span></span><br><span class="line">          <span class="attr">initialBackoff:</span> <span class="string">500ms</span></span><br><span class="line">          <span class="comment">#[Optional] the maximum back off interval for any retry attempt</span></span><br><span class="line">          <span class="attr">maxBackoff:</span> <span class="string">5s</span></span><br><span class="line">          <span class="comment">#[Optional] he factor by which the initial back off period is exponentially incremented</span></span><br><span class="line">          <span class="attr">backoffFactor:</span> <span class="number">2.0</span></span><br><span class="line">      <span class="comment">#[Optional] options for retrieving discovery info</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#[Optional] discovery info will be retrieved for these number of random targets</span></span><br><span class="line">        <span class="attr">maxTargets:</span> <span class="number">2</span></span><br><span class="line">        <span class="comment">#[Optional] retry options for retrieving discovery info</span></span><br><span class="line">        <span class="attr">retryOpts:</span></span><br><span class="line">          <span class="comment">#[Optional] number of retry attempts</span></span><br><span class="line">          <span class="attr">attempts:</span> <span class="number">4</span></span><br><span class="line">          <span class="comment">#[Optional] the back off interval for the first retry attempt</span></span><br><span class="line">          <span class="attr">initialBackoff:</span> <span class="string">500ms</span></span><br><span class="line">          <span class="comment">#[Optional] the maximum back off interval for any retry attempt</span></span><br><span class="line">          <span class="attr">maxBackoff:</span> <span class="string">5s</span></span><br><span class="line">          <span class="comment">#[Optional] he factor by which the initial back off period is exponentially incremented</span></span><br><span class="line">          <span class="attr">backoffFactor:</span> <span class="number">2.0</span></span><br><span class="line">      <span class="comment">#[Optional] options for the event service</span></span><br><span class="line">      <span class="attr">eventService:</span></span><br><span class="line">        <span class="comment"># [Optional] resolverStrategy specifies the peer resolver strategy to use when connecting to a peer</span></span><br><span class="line">        <span class="comment"># Possible values: [PreferOrg (default), MinBlockHeight, Balanced]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># PreferOrg:</span></span><br><span class="line">        <span class="comment">#   Determines which peers are suitable based on block height lag threshold, although will prefer the peers in the</span></span><br><span class="line">        <span class="comment">#   current org (as long as their block height is above a configured threshold). If none of the peers from the current org</span></span><br><span class="line">        <span class="comment">#   are suitable then a peer from another org is chosen.</span></span><br><span class="line">        <span class="comment"># MinBlockHeight:</span></span><br><span class="line">        <span class="comment">#   Chooses the best peer according to a block height lag threshold. The maximum block height of all peers is</span></span><br><span class="line">        <span class="comment">#   determined and the peers whose block heights are under the maximum height but above a provided "lag" threshold are load</span></span><br><span class="line">        <span class="comment">#   balanced. The other peers are not considered.</span></span><br><span class="line">        <span class="comment"># Balanced:</span></span><br><span class="line">        <span class="comment">#   Chooses peers using the configured balancer.</span></span><br><span class="line">        <span class="attr">resolverStrategy:</span> <span class="string">PreferOrg</span></span><br><span class="line">        <span class="comment"># [Optional] balancer is the balancer to use when choosing a peer to connect to</span></span><br><span class="line">        <span class="comment"># Possible values: [Random (default), RoundRobin]</span></span><br><span class="line">        <span class="attr">balancer:</span> <span class="string">Random</span></span><br><span class="line">        <span class="comment"># [Optional] blockHeightLagThreshold sets the block height lag threshold. This value is used for choosing a peer</span></span><br><span class="line">        <span class="comment"># to connect to. If a peer is lagging behind the most up-to-date peer by more than the given number of</span></span><br><span class="line">        <span class="comment"># blocks then it will be excluded from selection.</span></span><br><span class="line">        <span class="comment"># If set to 0 then only the most up-to-date peers are considered.</span></span><br><span class="line">        <span class="comment"># If set to -1 then all peers (regardless of block height) are considered for selection.</span></span><br><span class="line">        <span class="comment"># Default: 5</span></span><br><span class="line">        <span class="attr">blockHeightLagThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># [Optional] reconnectBlockHeightLagThreshold - if &gt;0 then the event client will disconnect from the peer if the peer's</span></span><br><span class="line">        <span class="comment"># block height falls behind the specified number of blocks and will reconnect to a better performing peer.</span></span><br><span class="line">        <span class="comment"># If set to 0 then this feature is disabled.</span></span><br><span class="line">        <span class="comment"># Default: 10</span></span><br><span class="line">        <span class="comment"># NOTES:</span></span><br><span class="line">        <span class="comment">#   - peerMonitorPeriod must be &gt;0 to enable this feature</span></span><br><span class="line">        <span class="comment">#   - Setting this value too low may cause the event client to disconnect/reconnect too frequently, thereby</span></span><br><span class="line">        <span class="comment">#     affecting performance.</span></span><br><span class="line">        <span class="attr">reconnectBlockHeightLagThreshold:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># [Optional] peerMonitorPeriod is the period in which the connected peer is monitored to see if</span></span><br><span class="line">        <span class="comment"># the event client should disconnect from it and reconnect to another peer.</span></span><br><span class="line">        <span class="comment"># Default: 0 (disabled)</span></span><br><span class="line">        <span class="attr">peerMonitorPeriod:</span> <span class="string">5s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># list of participating organizations in this network</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="attr">Org1:</span></span><br><span class="line">    <span class="attr">mspid:</span> <span class="string">org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="attr">cryptoPath:</span> <span class="string">peerOrganizations/org1.kevin.kongyixueyuan.com/users/&#123;userName&#125;@org1.kevin.kongyixueyuan.com/msp</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Certificate Authorities issue certificates for identification purposes in a Fabric based</span></span><br><span class="line">    <span class="comment"># network. Typically certificates provisioning is done in a separate process outside of the</span></span><br><span class="line">    <span class="comment"># runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for</span></span><br><span class="line">    <span class="comment"># dynamic certificate management (enroll, revoke, re-enroll). The following section is only for</span></span><br><span class="line">    <span class="comment"># Fabric-CA servers.</span></span><br><span class="line">    <span class="attr">certificateAuthorities:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># List of orderers to send transaction and channel create/update requests to. For the time</span></span><br><span class="line"><span class="comment"># being only one orderer is needed. If more than one is defined, which one get used by the</span></span><br><span class="line"><span class="comment"># SDK is implementation specific. Consult each SDK's documentation for its handling of orderers.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">orderers:</span></span><br><span class="line">  <span class="attr">orderer.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7050</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># these are standard properties defined by the gRPC library</span></span><br><span class="line">    <span class="comment"># they will be passed in as-is to gRPC client constructor</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/tlsca/tlsca.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># List of peers to send various requests to, including endorsement, query</span></span><br><span class="line"><span class="comment"># and event listener registration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line">  <span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="comment"># this URL is used to send endorsement and query requests</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7051</span></span><br><span class="line">    <span class="comment"># eventUrl is only needed when using eventhub (default is delivery service)</span></span><br><span class="line">    <span class="attr">eventUrl:</span> <span class="string">localhost:7053</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/tlsca/tlsca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="comment"># this URL is used to send endorsement and query requests</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7151</span></span><br><span class="line">    <span class="comment"># eventUrl is only needed when using eventhub (default is delivery service)</span></span><br><span class="line">    <span class="attr">eventUrl:</span> <span class="string">localhost:7153</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/tlsca/tlsca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fabric-CA is a special kind of Certificate Authority provided by Hyperledger Fabric which allows</span></span><br><span class="line"><span class="comment"># certificate management to be done via REST APIs. Application may choose to use a standard</span></span><br><span class="line"><span class="comment"># Certificate Authority instead of Fabric-CA, in which case this section would not be specified.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line">  <span class="attr">ca.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/ca/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fabric-CA supports dynamic user enrollment via REST APIs. A "root" user, a.k.a registrar, is</span></span><br><span class="line">    <span class="comment"># needed to enroll and invoke new users.</span></span><br><span class="line">    <span class="attr">registrar:</span></span><br><span class="line">      <span class="attr">enrollId:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">enrollSecret:</span> <span class="string">adminpw</span></span><br><span class="line">    <span class="comment"># [Optional] The optional name of the CA.</span></span><br><span class="line">    <span class="attr">caName:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entityMatchers:</span></span><br><span class="line">  <span class="attr">peer:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)peer0.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7051</span></span><br><span class="line">      <span class="attr">eventUrlSubstitutionExp:</span> <span class="string">localhost:7053</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)peer1.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7151</span></span><br><span class="line">      <span class="attr">eventUrlSubstitutionExp:</span> <span class="string">localhost:7153</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)orderer.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7050</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">certificateAuthorities:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)ca.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure><h3 id="2-定义所需结构体"><a href="#2-定义所需结构体" class="headerlink" title="2 定义所需结构体"></a>2 定义所需结构体</h3><p>配置文件完成指定的配置信息之后，我们开始编写代码。</p><p>在项目的根目录下添加一个名为 <code>sdkInit</code> 的新目录，我们将在这个文件夹中创建 SDK，并根据配置信息创建应用通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir sdkInit</span></span><br></pre></td></tr></table></figure><p>为了方便管理 Hyperledger Fabric 网络环境，我们将在 <code>sdkInit</code> 目录中创建一个 <code>fabricInitInfo.go</code> 的源代码文件，用于定义一个结构体，包括 Fabric SDK 所需的各项相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim sdkInit/fabricInitInfo.go</span></span><br></pre></td></tr></table></figure><p><code>fabricInitInfo.go</code> 源代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> sdkInit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/resmgmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InitInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ChannelID     <span class="keyword">string</span></span><br><span class="line">    ChannelConfig <span class="keyword">string</span></span><br><span class="line">    OrgName      <span class="keyword">string</span></span><br><span class="line">    OrgAdmin       <span class="keyword">string</span></span><br><span class="line">    OrdererOrgName    <span class="keyword">string</span></span><br><span class="line">    OrgResMgmt *resmgmt.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中包含成员解释如下：</p><ul><li><strong>ChannelID：</strong>通道名称</li><li><strong>ChannelConfig：</strong>通道交易配置文件所在路径</li><li><strong>OrgName：</strong>组织名称</li><li><strong>OrgAdmin：</strong>组织管理员名称</li><li><strong>OrdererOrgName：</strong>Orderer名称</li><li><strong>OrgResMgmt：</strong>资源管理端实例</li></ul><p>声明好结构体中的相应成员之后，就可以使用 <code>fabric-sdk-go</code> 相关的API来创建SDK实例，并使用该SDK实例进行一系列的操作，如：</p><ul><li>创建通道</li><li>将组织中的peers加入已创建的通道中</li><li>安装链码</li><li>实例化链码</li><li>创建客户端实例</li></ul><h3 id="3-创建SDK"><a href="#3-创建SDK" class="headerlink" title="3 创建SDK"></a>3 创建SDK</h3><p>首先，我们先来完成SDK的创建及通道的创建，通道创建完成之后，就可以将peers加入到该通道中。</p><p>在 <code>sdkInit</code> 目录下新创建一个名为 <code>start.go</code> 的源代码文件利用 vim 编辑器进行编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim sdkInit/start.go</span></span><br></pre></td></tr></table></figure><p><code>start.go</code> 的完整代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sdkInit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/fabsdk"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/core/config"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/resmgmt"</span></span><br><span class="line">    mspclient <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/msp"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/msp"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/common/errors/retry"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChaincodeVersion  = <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupSDK</span><span class="params">(ConfigFile <span class="keyword">string</span>, initialized <span class="keyword">bool</span>)</span> <span class="params">(*fabsdk.FabricSDK, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initialized &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Fabric SDK已被实例化"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdk, err := fabsdk.New(config.FromFile(ConfigFile))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"实例化Fabric SDK失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Fabric SDK初始化成功"</span>)</span><br><span class="line">    <span class="keyword">return</span> sdk, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateChannel</span><span class="params">(sdk *fabsdk.FabricSDK, info *InitInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    clientContext := sdk.Context(fabsdk.WithUser(info.OrgAdmin), fabsdk.WithOrg(info.OrgName))</span><br><span class="line">    <span class="keyword">if</span> clientContext == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"根据指定的组织名称与管理员创建资源管理客户端Context失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// New returns a resource management client instance.</span></span><br><span class="line">    resMgmtClient, err := resmgmt.New(clientContext)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"根据指定的资源管理客户端Context创建通道管理客户端失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// New creates a new Client instance</span></span><br><span class="line">    mspClient, err := mspclient.New(sdk.Context(), mspclient.WithOrg(info.OrgName))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"根据指定的 OrgName 创建 Org MSP 客户端实例失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Returns: signing identity</span></span><br><span class="line">    adminIdentity, err := mspClient.GetSigningIdentity(info.OrgAdmin)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"获取指定id的签名标识失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SaveChannelRequest holds parameters for save channel request</span></span><br><span class="line">    channelReq := resmgmt.SaveChannelRequest&#123;ChannelID:info.ChannelID, ChannelConfigPath:info.ChannelConfig, SigningIdentities:[]msp.SigningIdentity&#123;adminIdentity&#125;&#125;</span><br><span class="line">    <span class="comment">// save channel response with transaction ID</span></span><br><span class="line">     _, err = resMgmtClient.SaveChannel(channelReq, resmgmt.WithRetry(retry.DefaultResMgmtOpts), resmgmt.WithOrdererEndpoint(info.OrdererOrgName))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"创建应用通道失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"通道已成功创建，"</span>)</span><br><span class="line"></span><br><span class="line">    info.OrgResMgmt = resMgmtClient</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allows for peers to join existing channel with optional custom options (specific peers, filtered peers). If peer(s) are not specified in options it will default to all peers that belong to client's MSP.</span></span><br><span class="line">    err = info.OrgResMgmt.JoinChannel(info.ChannelID, resmgmt.WithRetry(retry.DefaultResMgmtOpts), resmgmt.WithOrdererEndpoint(info.OrdererOrgName))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Peers加入通道失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"peers 已成功加入通道."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编写测试代码"><a href="#4-编写测试代码" class="headerlink" title="4 编写测试代码"></a>4 编写测试代码</h3><p>为了确保客户端能够初始化所有组件，将在启动网络的情况下进行简单的测试。 为了做到这一点，我们需要编写 Go 代码，在项目根目录下新创建一个 <code>main.go</code> 的主文件并编辑内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p><code>main.go</code> 文件完整源代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/sdkInit"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    configFile = <span class="string">"config.yaml"</span></span><br><span class="line">    initialized = <span class="literal">false</span></span><br><span class="line">    SimpleCC = <span class="string">"simplecc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    initInfo := &amp;sdkInit.InitInfo&#123;</span><br><span class="line"></span><br><span class="line">        ChannelID: <span class="string">"kevinkongyixueyuan"</span>,</span><br><span class="line">        ChannelConfig: os.Getenv(<span class="string">"GOPATH"</span>) + <span class="string">"/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/artifacts/channel.tx"</span>,</span><br><span class="line"></span><br><span class="line">        OrgAdmin:<span class="string">"Admin"</span>,</span><br><span class="line">        OrgName:<span class="string">"Org1"</span>,</span><br><span class="line">        OrdererOrgName: <span class="string">"orderer.kevin.kongyixueyuan.com"</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdk, err := sdkInit.SetupSDK(configFile, initialized)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> sdk.Close()</span><br><span class="line"></span><br><span class="line">    err = sdkInit.CreateChannel(sdk, initInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、满足依赖"><a href="#二、满足依赖" class="headerlink" title="二、满足依赖"></a>二、满足依赖</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>根据项目要求满足所需依赖</li><li>使用Makefiel简化项目测试</li></ol><h3 id="1-安装dep工具"><a href="#1-安装dep工具" class="headerlink" title="1 安装dep工具"></a>1 安装dep工具</h3><p>在运行应用程序之前，需要将 Go 源代码时行编译，但在开始编译之前，我们需要使用一个 <code>vendor</code> 目录来包含应用中所需的所有的依赖关系。 在我们的GOPATH中，我们有Fabric SDK Go和其他项目。 在尝试编译应用程序时，Golang 会在 GOPATH 中搜索依赖项，但首先会检查项目中是否存在<code>vendor</code> 文件夹。 如果项目中包含一个叫vendor的目录，Golang 将会从这个目录搜索依赖的包，就不会去检查 GOPATH 或 GOROOT。</p><p>Golang官方最初只提供了包管理的 <code>go get</code> 工具，它将下载的第三方包放到GOPATH的src目录下。但是项目一般由许多来源不同的第三包构成，所以在Golang1.5版本增加了一个新的发现包的方法，通过使用像<a href="https://translate.googleusercontent.com/translate_c?depth=1&hl=zh-CN&rurl=translate.google.com&sl=en&sp=nmt4&tl=zh-CN&u=https://github.com/golang/dep&xid=25657,15700002,15700019,15700124,15700149,15700168,15700186,15700201&usg=ALkJrhgelyRl7D3pIJRpuA8cynagkWYHXg" target="_blank" rel="noopener"><code>dep</code></a>这样的工具在<code>vendor</code>目录中来处理这些依赖关系。</p><p>将如下环境变量设置到用户的环境文件中(.bashrc)中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>在Golang的新版本中没有自动加入 <code>dep</code> 工具，所以需要开发人员自行安装该工具。</p><p>安装 dep 工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/dep</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/dep/cmd/dep //下载不下来</span></span><br></pre></td></tr></table></figure><h3 id="2-下载所需依赖"><a href="#2-下载所需依赖" class="headerlink" title="2 下载所需依赖"></a>2 下载所需依赖</h3><p><code>dep</code> 工具安装好之后我们来安装应用所需要的依赖</p><p>使用 <code>dep</code> 命令需要一个名为 <code>Gopkg.toml</code> 的配置文件指定依赖信息</p><p>创建一个名为<code>Gopkg.toml</code>的文件并编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim Gopkg.toml</span></span><br></pre></td></tr></table></figure><p><code>Gopkg.toml</code>文件中添加如下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ignored</span> = [<span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/chaincode"</span>]</span><br><span class="line"></span><br><span class="line">[[constraint]]  //这里我还成了[[override]]</span><br><span class="line">  <span class="comment"># Release v1.0.0-alpha4</span></span><br><span class="line">  name = "github.com/hyperledger/fabric-sdk-go"</span><br><span class="line">  revision = "a906355f73d060d7bf95874a9e90dc17589edbb3"</span><br></pre></td></tr></table></figure><p>使用<code>dep</code>限制在 vendor 中指定希望SDK的特定版本。</p><p>保存该文件，然后执行 <code>dep ensure</code> 命令，该命令会自动将项目所需的依赖下载至当前的 <code>vendor</code> 目录中（下载依赖可能需要一段时间）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dep ensure</span></span><br></pre></td></tr></table></figure><blockquote><p>提醒：<code>dep ensure</code> 命令执行由于时间比较长，所以执行一次后即可，在后面的Makefile中可注释<code>@dep ensure</code>命令。</p></blockquote><h3 id="3-测试Fabric-SDK"><a href="#3-测试Fabric-SDK" class="headerlink" title="3 测试Fabric-SDK"></a>3 测试Fabric-SDK</h3><p>所在依赖下载安装完成后，我们就可以进行测试</p><p>首先启动网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fixtures</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></span><br></pre></td></tr></table></figure><p>然后编译并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./kongyixueyuan</span></span><br></pre></td></tr></table></figure><p>命令执行后输出结果如下图所示：</p><p><img src="http://image.chaindesk.cn/11.1_5.png/mark" alt="创建通道并加入指定的Peers"></p><p>如果出现上图的输出结果，则说明执行成功，否则需要根据出现的错误提示进行相应的处理。</p><h3 id="4-关闭网络并清理环境"><a href="#4-关闭网络并清理环境" class="headerlink" title="4 关闭网络并清理环境"></a>4 关闭网络并清理环境</h3><p>测试成功之后即可以关闭Hypledger Fabric网络，但是我们在Fabric-SDK的配置文件config.yaml中指定了生成的密钥、证书的存储路径，关闭网络之后需要将其进行清理。</p><p>1）首先关闭处于启动状态的网络环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose down</span></span><br></pre></td></tr></table></figure><p>2）然后删除证书存储（由config.yaml配置文件中的client.credentialStore定义）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /tmp/kongyixueyuan-*</span></span><br></pre></td></tr></table></figure><p>3）最后删除一些不是由docker-compose命令生成的docker容器和docker镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker rm -f -v `docker ps -a --no-trunc | grep <span class="string">"kongyixueyuan"</span> | cut -d <span class="string">' '</span> -f 1` 2&gt;/dev/null</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi `docker images --no-trunc | grep <span class="string">"kongyixueyuan"</span> | cut -d <span class="string">' '</span> -f 1` 2&gt;/dev/null</span></span><br></pre></td></tr></table></figure><h3 id="5-利用Makefile简化步骤"><a href="#5-利用Makefile简化步骤" class="headerlink" title="5 利用Makefile简化步骤"></a>5 利用Makefile简化步骤</h3><p>由上面的步骤大家可以看出，启动网络及关闭并清理环境需要执行很多的命令（如进入目录、启动网络、构建、关闭网络、清理环境等等），为了方便测试，用一种方式来简化每次操作时的步骤，我们可以使用一个名为make的工具来实现，该工具的命令可以在一个步骤中自动完成所有的操作执行任务。具体实现方式如下：</p><p>创建一个Makefile 文件。 首先，确保你的系统中已经安装了 make 工具。使用如下命令检测是否已安装make工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make --version</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有 <code>make</code> 工具（Ubuntu），则需要先安装 <code>make</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install make</span></span><br></pre></td></tr></table></figure></blockquote><p>然后进入到项目的根目录下并创建一个名为 <code>Makefile</code> 的文件进行编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/kongyixueyuan</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim Makefile</span></span><br></pre></td></tr></table></figure><p>在创建的 <code>Makefile</code> 文件中添加如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all dev clean build env-up env-down run</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: clean build env-up run</span></span><br><span class="line"></span><br><span class="line"><span class="section">dev: build run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### BUILD</span></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">    @echo <span class="string">"Build ..."</span></span><br><span class="line">    @dep ensure</span><br><span class="line">    @go build</span><br><span class="line">    @echo <span class="string">"Build done"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### ENV</span></span><br><span class="line"><span class="section">env-up:</span></span><br><span class="line">    @echo <span class="string">"Start environment ..."</span></span><br><span class="line">    @cd fixtures &amp;&amp; docker-compose up --force-recreate -d</span><br><span class="line">    @echo <span class="string">"Environment up"</span></span><br><span class="line"></span><br><span class="line"><span class="section">env-down:</span></span><br><span class="line">    @echo <span class="string">"Stop environment ..."</span></span><br><span class="line">    @cd fixtures &amp;&amp; docker-compose down</span><br><span class="line">    @echo <span class="string">"Environment down"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### RUN</span></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    @echo <span class="string">"Start app ..."</span></span><br><span class="line">    @./kongyixueyuan</span><br><span class="line"></span><br><span class="line"><span class="comment">##### CLEAN</span></span><br><span class="line"><span class="section">clean: env-down</span></span><br><span class="line">    @echo <span class="string">"Clean up ..."</span></span><br><span class="line">    @rm -rf /tmp/kongyixueyuan-* kongyixueyuan</span><br><span class="line">    @docker rm -f -v `docker ps -a --no-trunc | grep <span class="string">"kongyixueyuan"</span> | cut -d ' ' -f 1` 2&gt;/dev/null || true</span><br><span class="line">    @docker rmi `docker images --no-trunc | grep <span class="string">"kongyixueyuan"</span> | cut -d ' ' -f 1` 2&gt;/dev/null || true</span><br><span class="line">    @echo <span class="string">"Clean up done"</span></span><br></pre></td></tr></table></figure><p>定义的Makefile文件可以执行完成如下步骤的任务：</p><p>1）使用make clean命令将关闭并清理Hyperledger Fabric整个网络环境；</p><p>2）使用make build命令将编译Golang应用程序；</p><p>3）使用make env-up命令将启动 Hyperledger Fabric网络环境；</p><p>4）使用make clean命令将启动应用程序并运行。</p><p>如果想直接启动项目，则可以使用 make 命令。该 make 命令执行顺序如上面的步骤所示。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>Gopkg.toml 到底是一个什么文件？</p><p>Gopkg.toml 文件是 dep 工具的文件，它包含了dep 的几种类型限制规则，详情请参见：</p><p><a href="https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md" target="_blank" rel="noopener">https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md</a></p></li><li><p>Makefile文件起什么作用？</p><p>有的项目/系统在编写好源代码之后，编译、启动之前需要做大量的前期工作，而这些工作如果使用手动方式来实现，效率非常低下，这时就可以考虑使用 Linux 操作系统中的 make 命令来实现，只需要将其内容写在一个名为Mackfile的文件中，就可以实现自动化操作，提高开发及测试效率。Makefile可以看作是一个 Shell 脚本，主要用于指定整个项目的编译、启动规则（顺序），在编译之前先做什么事情，编译之后启动之前做什么。</p></li></ol><h2 id="三、链码实现"><a href="#三、链码实现" class="headerlink" title="三、链码实现"></a>三、链码实现</h2><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>实现链代码</li></ol><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><p>为了便于测试及简化代码，我们实现一个简单的链码功能，能够实现对分类账本中的数据进行设置（PutState（k，v））及相应的查询（GetState（k））功能即可。</p><h3 id="1-编写链码"><a href="#1-编写链码" class="headerlink" title="1 编写链码"></a>1 编写链码</h3><p>在当前项目根目录中创建一个存放链码文件的 <code>chaincode</code> 目录，然后在该目录下创建一个 <code>main.go</code> 的文件并对其进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim chaincode/main.go</span></span><br></pre></td></tr></table></figure><p>编写链码必须遵守链码开发的相关规定（详见第五章链码开发的相关内容），为此我们在链码文件中声明5个函数，如下：</p><ul><li><strong>Init(stub shim.ChaincodeStubInterface) ：</strong>初始化链码或升级链码时被调用的函数</li><li><strong>Invoke(stub shim.ChaincodeStubInterface)：</strong>查询或更新操作分类账本状态时被调用的函数</li><li><strong>set(stub shim.ChaincodeStubInterface, args []string)：</strong>根据用户指定的Key与Value更新分类账本中的状态</li><li><strong>get(stub shim.ChaincodeStubInterface, args []string)：</strong>根据用户指定的Key从分类账本中查询状态</li><li><strong>main()：</strong>启动链码的主函数</li></ul><p><code>main.go</code> 文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">    fun, args := stub.GetFunctionAndParameters()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> fun == <span class="string">"set"</span>&#123;</span><br><span class="line">        result, err = set(stub, args)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result, err = get(stub, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">3</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"给定的参数错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = stub.SetEvent(args[<span class="number">2</span>], []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(args[<span class="number">0</span>]), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"给定的参数错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"获取数据发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"根据 %s 没有获取到相应的数据"</span>, args[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(SimpleChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"启动SimpleChaincode时发生错误: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链码编写好以后，我们需要使用 Fabric-SDK-Go 提供的相关 API 来实现对链码的安装及实例化操作，而无需在命令提示符中输入烦锁的相关操作命令。</p><h2 id="四、使用Fabric－SDK实现链码的自动部署"><a href="#四、使用Fabric－SDK实现链码的自动部署" class="headerlink" title="四、使用Fabric－SDK实现链码的自动部署"></a>四、使用Fabric－SDK实现链码的自动部署</h2><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><ol><li>使用SDK相关的API实现对链码的安装及实例化</li><li>通过测试</li></ol><h2 id="1-链码安装及实例化"><a href="#1-链码安装及实例化" class="headerlink" title="1 链码安装及实例化"></a>1 链码安装及实例化</h2><h3 id="1-编辑结构体"><a href="#1-编辑结构体" class="headerlink" title="1 编辑结构体"></a>1 编辑结构体</h3><p>新建一个结构体，声明在 <code>sdkInit/fabricInitInfo.go</code> 文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim sdkInit/fabricInitInfo.go</span></span><br></pre></td></tr></table></figure><p><code>fabricInitInfo.go</code> 文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> sdkInit</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/resmgmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InitInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ChannelID     <span class="keyword">string</span></span><br><span class="line">    ChannelConfig <span class="keyword">string</span></span><br><span class="line">    OrgAdmin      <span class="keyword">string</span></span><br><span class="line">    OrgName       <span class="keyword">string</span></span><br><span class="line">    OrdererOrgName    <span class="keyword">string</span></span><br><span class="line">    OrgResMgmt *resmgmt.Client</span><br><span class="line"></span><br><span class="line">    ChaincodeID    <span class="keyword">string</span></span><br><span class="line">    ChaincodeGoPath    <span class="keyword">string</span></span><br><span class="line">    ChaincodePath    <span class="keyword">string</span></span><br><span class="line">    UserName    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从上面的源代码中看到，在这个结构体中，我们新增加了与链码相关的如下成员：</p><ul><li><strong>ChaincodeID：</strong>链码ID（即链码名称）</li><li><strong>ChaincodeGoPath：</strong>系统GOPATH路径</li><li><strong>ChaincodePath：</strong>链 码源代码所在路径</li><li><strong>UserName：</strong>组织用户名称</li></ul><h3 id="2-使用Fabric-SDK安装及实例化链码"><a href="#2-使用Fabric-SDK安装及实例化链码" class="headerlink" title="2 使用Fabric-SDK安装及实例化链码"></a>2 使用Fabric-SDK安装及实例化链码</h3><p>编辑 <code>sdkInit/start.go</code> 文件，利用Fabric-SDK提供的接口，对链码进行安装及实例化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim sdkInit/start.go</span></span><br></pre></td></tr></table></figure><p>在 <code>start.go</code> 文件中声明一个 <code>InstallAndInstantiateCC</code> 函数，该函数的主要功能有三项：</p><ol><li><strong>安装链码</strong></li><li><strong>实例化链码</strong></li><li><strong>创建客户端实例</strong></li></ol><p>在 <code>start.go</code> 文件中添加如下<code>InstallAndInstantiateCC</code> 函数内容并导入相应的package：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    [......]</span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/fab/ccpackager/gopackager"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/third_party/github.com/hyperledger/fabric/common/cauthdsl"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InstallAndInstantiateCC</span><span class="params">(sdk *fabsdk.FabricSDK, info *InitInfo)</span> <span class="params">(*channel.Client, error)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"开始安装链码......"</span>)</span><br><span class="line">    <span class="comment">// creates new go lang chaincode package</span></span><br><span class="line">    ccPkg, err := gopackager.NewCCPackage(info.ChaincodePath, info.ChaincodeGoPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"创建链码包失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// contains install chaincode request parameters</span></span><br><span class="line">    installCCReq := resmgmt.InstallCCRequest&#123;Name: info.ChaincodeID, Path: info.ChaincodePath, Version: ChaincodeVersion, Package: ccPkg&#125;</span><br><span class="line">    <span class="comment">// allows administrators to install chaincode onto the filesystem of a peer</span></span><br><span class="line">    _, err = info.OrgResMgmt.InstallCC(installCCReq, resmgmt.WithRetry(retry.DefaultResMgmtOpts))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"安装链码失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"指定的链码安装成功"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"开始实例化链码......"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  returns a policy that requires one valid</span></span><br><span class="line">    ccPolicy := cauthdsl.SignedByAnyMember([]<span class="keyword">string</span>&#123;<span class="string">"org1.kevin.kongyixueyuan.com"</span>&#125;)</span><br><span class="line"></span><br><span class="line">    instantiateCCReq := resmgmt.InstantiateCCRequest&#123;Name: info.ChaincodeID, Path: info.ChaincodePath, Version: ChaincodeVersion, Args: [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(<span class="string">"init"</span>)&#125;, Policy: ccPolicy&#125;</span><br><span class="line">    <span class="comment">// instantiates chaincode with optional custom options (specific peers, filtered peers, timeout). If peer(s) are not specified</span></span><br><span class="line">    _, err = info.OrgResMgmt.InstantiateCC(info.ChannelID, instantiateCCReq, resmgmt.WithRetry(retry.DefaultResMgmtOpts))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"实例化链码失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"链码实例化成功"</span>)</span><br><span class="line"></span><br><span class="line">    clientChannelContext := sdk.ChannelContext(info.ChannelID, fabsdk.WithUser(info.UserName), fabsdk.WithOrg(info.OrgName))</span><br><span class="line">    <span class="comment">// returns a Client instance. Channel client can query chaincode, execute chaincode and register/unregister for chaincode events on specific channel.</span></span><br><span class="line">    channelClient, err := channel.New(clientChannelContext)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"创建应用通道客户端失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"通道客户端创建成功，可以利用此客户端调用链码进行查询或执行事务."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> channelClient, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在main中调用"><a href="#3-在main中调用" class="headerlink" title="3 在main中调用"></a>3 在main中调用</h3><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p><code>main.go</code> 完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/sdkInit"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    configFile = <span class="string">"config.yaml"</span></span><br><span class="line">    initialized = <span class="literal">false</span></span><br><span class="line">    SimpleCC = <span class="string">"simplecc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    initInfo := &amp;sdkInit.InitInfo&#123;</span><br><span class="line"></span><br><span class="line">        ChannelID: <span class="string">"kevinkongyixueyuan"</span>,</span><br><span class="line">        ChannelConfig: os.Getenv(<span class="string">"GOPATH"</span>) + <span class="string">"/src/github.com/kongyixueyuan.com/kongyixueyuan/fixtures/artifacts/channel.tx"</span>,</span><br><span class="line"></span><br><span class="line">        OrgAdmin:<span class="string">"Admin"</span>,</span><br><span class="line">        OrgName:<span class="string">"Org1"</span>,</span><br><span class="line">        OrdererOrgName: <span class="string">"orderer.kevin.kongyixueyuan.com"</span>,</span><br><span class="line"></span><br><span class="line">        ChaincodeID: SimpleCC,</span><br><span class="line">        ChaincodeGoPath: os.Getenv(<span class="string">"GOPATH"</span>),</span><br><span class="line">        ChaincodePath: <span class="string">"github.com/kongyixueyuan.com/kongyixueyuan/chaincode/"</span>,</span><br><span class="line">        UserName:<span class="string">"User1"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sdk, err := sdkInit.SetupSDK(configFile, initialized)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> sdk.Close()</span><br><span class="line"></span><br><span class="line">    err = sdkInit.CreateChannel(sdk, initInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channelClient, err := sdkInit.InstallAndInstantiateCC(sdk, initInfo)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(channelClient)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p>执行 <code>make</code> 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><p><img src="http://image.chaindesk.cn/11.1_6.png/mark" alt="cc实例化成功"></p><p>在此，我们已经成功搭建了 Hyperledger Fabric 的网络环境，并通过 <code>fabric-sdk-go</code> 创建了应用通道，将peers加入通道，并在peer上安装、实例化了链码。那么如何在真正的应用程序中实现链码的调用，对分类账本中的状态进行操作，具体实现请参见下一章的内容。</p><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>创建应用通道客户端有什么作用？</p><p>应用通道客户端其实就是一个客户端实例。通过该实例，可以使用 fabric-sdk-go 相应的 API 查询链码，执行链码，对特定通道上的链码事件进行注册/注销。</p></li></ol><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/216" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/216</a></p><p><a href="http://zzi.ycyues.top/?mod=m_contribute&amp;id=4157&amp;tid=5" target="_blank" rel="noopener">http://zzi.ycyues.top/?mod=m_contribute&amp;id=4157&amp;tid=5</a></p><p><a href="http://www.sicris.cn/CN/column/column42.shtml" target="_blank" rel="noopener">http://www.sicris.cn/CN/column/column42.shtml</a></p><p><a href="http://aqjs.chinajournal.net.cn/WKE/WebPublication/wkTextContent.aspx?navigationContentID=0a96be87-490b-49ff-90aa-bee7b5d1b2cc&amp;mid=aqjs" target="_blank" rel="noopener">http://aqjs.chinajournal.net.cn/WKE/WebPublication/wkTextContent.aspx?navigationContentID=0a96be87-490b-49ff-90aa-bee7b5d1b2cc&amp;mid=aqjs</a></p><p><a href="http://zgxxaq.goooc.net/" target="_blank" rel="noopener">http://zgxxaq.goooc.net/</a></p><p><a href="http://netinfo-security.org/CN/column/column52.shtml" target="_blank" rel="noopener">http://netinfo-security.org/CN/column/column52.shtml</a></p><p><a href="http://wlaqhxxh.goooc.net/buy/" target="_blank" rel="noopener">http://wlaqhxxh.goooc.net/buy/</a></p><p><a href="http://www.wlaq-qikan.com/list-2.html" target="_blank" rel="noopener">http://www.wlaq-qikan.com/list-2.html</a></p><h2 id="寻找一种可以理解的共识算法Raft"><a href="#寻找一种可以理解的共识算法Raft" class="headerlink" title="寻找一种可以理解的共识算法Raft"></a>寻找一种可以理解的共识算法Raft</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Raft是用于管理复制日志的共识算法。 它产生的结果与（多个）Paxos等效，并且效率与Paxos相同，但是其结构与Paxos不同； 这使得Raft比Paxos更易于理解，并且为构建实用系统提供了更好的基础。 为了增强可理解性，Raft分离了共识的关键要素，例如领导者选举，日志复制和安全性，并强制实施了更高程度的一致性以减少必须考虑的状态数。 一项用户研究的结果表明，与Paxos相比，筏更易于学生学习。 Raft还包括用于更改集群成员资格的新机制，该机制使用重叠的多数来保证安全。</p><h4 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h4><p>​        共识算法允许一组计算机作为一个连贯的组工作，这些组可以在某些成员的故障中幸存下来。因此，它们在构建可靠的大规模软件系统中起着关键作用。在过去的十年中，Paxos [15，16]主导了共识算法的讨论：共识的大多数实现都基于Paxos或受其影响，并且Paxos已成为用于教导学生有关共识的主要工具。<br>​         不幸的是，尽管有很多尝试使Paxos变得更容易上手，但它仍然很难理解。此外，其体系结构需要复杂的更改以支持实际系统。结果，系统构建者和学生都与Paxos斗争。<br>​        在与Paxos自己奋斗之后，我们着手寻找一种新的共识算法，该算法可以为系统构建和教育提供更好的基础。我们的方法与众不同，因为我们的主要目标是可理解性：我们可以为实际系统定义共识算法，并以比Paxos容易得多的方式对其进行描述吗？此外，我们希望该算法能够促进对系统构建者必不可少的直觉的发展。重要的不仅是算法能起作用，而且很明显它为什么起作用。<br>​          这项工作的结果是一个称为Raft的共识算法。在设计Raft时，我们应用了特定的技术来提高可理解性，包括分解（Raft分离了领导者的选举，日志复制和安全性）。此技术报告是[32]的扩展版本；其他材料在页边距中用灰色条表示。 2014年5月20日发布。声明了减少空间的功能（相对于Paxos，Raft减少了不确定性的程度以及服务器之间可能不一致的方式）。一项对两所大学的43名学生进行的用户研究表明，Raft比Paxos更容易理解：学习了两种算法后，其中33位学生比Rax更好地回答了有关Raft的问题。</p><p>​       Raft在许多方面与现有的共识算法相似（最著名的是Oki和Liskov的Viewstamped复制[29，22]），但是它具有几个新颖的功能：<br>​       •强大的领导者：与其他共识算法相比，筏使用了更强大的领导形式。例如，日志条目仅从领导者流向其他服务器。这简化了复制日志的管理，并使Raft更易于理解。<br>​        •领导人选举：筏使用随机计时器选举领导人。这为任何共识算法已经要求的心跳仅增加了少量机制，同时简单，快速地解决了冲突。<br>​        •成员资格更改：Raft用于更改集群中服务器集的机制使用了一种新的联合共识方法，其中两种不同配置的大多数在转换过程中会重叠。这允许群集在配置更改期间继续正常运行。</p><p>​        我们认为Raft在教育目的和实施基础上均优于Paxos和其他共识算法。它比其他算法更简单易懂。它的描述足够完整，可以满足实际系统的需求；它具有几种开源实现，并被多家公司使用；其安全性能已得到正式规定和证明；而且其效率可与其他算法媲美。<br>​        本文的其余部分介绍了复制状态机问题（第2节），讨论了Paxos的优缺点（第3节），描述了我们对易懂性的一般方法（第4节），介绍了Raft共识算法（第5-8节） ，评估Raft（第9节），并讨论相关工作（第10节）。</p><h4 id="2个复制状态机"><a href="#2个复制状态机" class="headerlink" title="2个复制状态机"></a>2个复制状态机</h4><p>共识算法通常出现在复制状态机的环境中[37]。通过这种方法，服务器集合上的状态机将计算相同状态的相同副本，并且即使某些服务器已关闭也可以继续运行。复制状态机是</p><p><img src="C:%5CUsers%5Chuanggang%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200405163727492.png" alt="image-20200405163727492"></p><p>图1：复制状态机架构。共识算法管理包含来自客户端的状态机命令的复制日志。状态机处理来自日志的相同命令序列，因此它们产生相同的输出。<br>       用于解决分布式系统中的各种容错问题。例如，具有单个集群领导者的大型系统，例如GFS [8]，HDFS [38]和RAMCloud [33]，通常使用单独的复制状态机来管理领导者选举并存储必须保留的配置信息领导者崩溃。复制状态机的示例包括Chubby [2]和ZooKeeper [11]。<br>        复制状态机通常使用复制日志来实现，如图1所示。每个服务器都存储一个包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志以相同的顺序包含相同的命令，因此每个状态机处理相同的命令序列。由于状态机是确定性的，因此每个状态机都会计算相同的状态和相同的输出顺序。<br>        保持复制日志的一致性是共识算法的工作。服务器上的共识模块接收来自客户端的命令并将其添加到其日志中，并与其他服务器上的共识模块进行通信以确保每个日志最终都以相同顺序包含相同的请求，即使某些服务器发生故障也是如此。正确复制后，每个服务器的状态机将以日志顺序对其进行处理，然后将输出返回给客户端。结果，服务器似乎形成了单个高度可靠的状态机。<br>        实际系统的共识算法通常具有以下属性：<br>•它们可确保在所有非拜占庭条件下的安全性（绝不会返回错误的结果），包括网络延迟，分区，数据包丢失，重复和重新排序。<br>•只要任何大多数服务器都在运行，并且它们彼此之间以及与客户端进行通信，它们就可以正常运行（可用）。因此，由五个服务器组成的典型集群可以容忍任何两个服务器的故障。假定服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入群集。<br>•它们不依赖于时间来确保日志的一致性：错误的时钟和极端的消息延迟在最坏的情况下可能导致可用性问题。<br>•在通常情况下，大多数集群对单轮远程过程调用作出响应后，命令即可完成；少数慢速服务器不必影响整体系统性能</p><p>3</p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章Fabric分布式账本数据存储</title>
      <link href="/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC9%E7%AB%A0Fabric%E5%88%86%E5%B8%83%E5%BC%8F%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC9%E7%AB%A0Fabric%E5%88%86%E5%B8%83%E5%BC%8F%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、交易数据的存储"><a href="#一、交易数据的存储" class="headerlink" title="一、交易数据的存储"></a>一、交易数据的存储</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><p>了解账本数据组成结构</p></li><li><p>了解区块本身及事务数据的组成结构</p></li><li><p>理解账本数据的存储过程</p><a id="more"></a></li></ol><h3 id="1-区块链账本数据"><a href="#1-区块链账本数据" class="headerlink" title="1 区块链账本数据"></a>1 区块链账本数据</h3><p>分类账本中保存着所有交易变化的记录，具有<strong>有序和防篡改</strong>的特点。每一次交易链码需要将数据变化记录在分布式账本中，需要记录的<strong>数据</strong>称为<strong>状态</strong>, 以键值对（ K-V ）的形式进行存储。</p><p>Hyperledger Fabric 账本由两个不同但相关部分组成：</p><ul><li><strong>世界状态（World State）</strong></li><li><strong>区块链（Blockchain）</strong></li></ul><p><img src="http://image.chaindesk.cn/9.1_1.png/mark" alt="账本组成"></p><p><strong>世界状态</strong>：保存<strong>世界状态</strong>的实际上是一个<strong>NoSQL数据库</strong>，<strong>以方便对状态的存储及检索</strong>；以键值对的方式保存一组分类帐状态的最新值。可以使应用程序无须遍历整个事务日志而快速获取当前账本的最新值。其 value 可以是一个简单的值，也可以由一组键值对组成的复杂数据组成。如下图所示：</p><p><img src="http://image.chaindesk.cn/9.1_2.png/mark" alt="账本的世界状态"></p><p>从上图中可以看到，对于每一个世界状态都具有一个版本号，起始版本号的值为0。每次对状态进行更改时，状态的版本号都会递增。对状态进行更新时也会检查，确保它与创建事务时的版本匹配。</p><p><strong>区块链</strong>：是一个<strong>记录交易日志的文件系统</strong>，它是由哈希值链接的 N 个区块构造而成；每个区块包含一系列的多个有序的交易。区块头中包含了本区块所记录交易的哈希值，以及前一个区块头的哈希值。通过这种方式，分类账本中的所有交易都被有序的并以加密的形式链接一起。换言之，在分布式网络中，如果不破坏哈希链的话，根本无法篡改账本数据。</p><p><img src="http://image.chaindesk.cn/9.1_3.png/mark" alt="账本的区块链"></p><p>在上图中，我们可以看到区块 B2 具有 区块数据 D2，其包含其所有事务：T5，T6，T7。最重要的是，区块 B2 的区块头（H2）中其<strong>包含</strong> D2 中所有事务的加密散列（D2当前区块哈希）和来自前一区块（B1）的等效散列（前一区块哈希）。通过这种链接方式，使得区块之间彼此有着不可分割的联系。</p><p>下面我们详细分析区块及交易所包含的详细结构。</p><p><strong>区块</strong>：每一个区块都由三部分组成</p><p><img src="http://image.chaindesk.cn/9.1_4.png/mark" alt="区块结构"></p><p>如上图所示，区块 B2 的区块头（H2）由区块编号号（2），当前块数据（D2）的哈希（CH2）和来自上一个区块（块号1）的哈希（PH1）的副本组成。</p><ul><li><p><strong>区块头（Block Header）</strong>：区块头包含三个字段，在创建区块时写入。</p><ul><li><strong>区块编号</strong>（<strong>Block number</strong>）：从0开始的整数，对于追加到区块链的每个新的区块都会在前一个值的基础之上递增1。</li><li><strong>当前区块哈希值（Current Block Hash）</strong>：当前块中包含的所有事务的哈希值。</li><li><strong>上一个区块哈希（Previous Block Hash）</strong>：区块链中上一个区块的哈希副本。</li></ul></li><li><p><strong>区块数据（Block Data）</strong></p><p>在创建块时写入，包含按顺序排列的一系列交易。</p></li><li><p><strong>区块元数据（Block Metadata）</strong></p><p>此部分<strong>包含写入区块的时间，以及相应的证书，公钥和签名</strong>。随后，Block Committer 还为每个交易添加了一个<strong>有效/无效的指示符</strong>（也称之为位掩码）。</p></li></ul><p>现在我们了解了区块中的结构，那么，区块数据中的交易结构又是什么样的，下面我们进一步来了解交易/事务的详细结构。</p><p><strong>交易</strong>：区块中的区块数据（Block Data）包含了一系列的交易的详细结构，该交易记录了<strong>世界状态的变化</strong>。</p><p><img src="http://image.chaindesk.cn/9.1_5.png/mark" alt="交易数据"></p><p>如上图所示：区块 B1 的区块数据（D1）中的事务（T4）包括事务头（H4），事务签名（S4），事务提案（P4），事务响应（R4）和背书列表（E4）。</p><ul><li><p><strong>事务头（Header）</strong></p><p>获取有关事务的一些基本元数据如：链码相关的名称及其版本。</p></li><li><p><strong>事务签名（Signature）</strong></p><p>该部分包含使用客户端应用程序私钥而创建的加密签名。用于检查事务内容是否被篡改。</p></li><li><p><strong>事务提案（Proposal）</strong></p><p>包含要调用的链码的函数名称、调用函数所需的输入参数，链码根据提交的事务提案对分类帐进行更新。</p></li><li><p><strong>事务响应（Response）</strong></p><p>调用链码模拟执行后获取到世界状态的前后值，作为读写集（RW-set）返回给客户端。</p></li><li><p><strong>背书列表（Endorsements）</strong></p><p>交易中只包含一个交易响应，但有多个来自所需组织的背书签名，以满足所需的背书策略。</p></li></ul><h3 id="2-数据存储"><a href="#2-数据存储" class="headerlink" title="2 数据存储"></a>2 数据存储</h3><p>区块链是以文件的形式进行存储的，各区块文件默认以 blockfile_ 为文件前缀，后面以六位数字命名，起始数字默认为 000000，如有新文件则每次递增1。区块链文件默认存储目录： /var/hyperledger/production/ledgersData/chains 中，该目录中包括两个子目录： 保存区块链文件的chains 目录（以通道文件目录区分各 Ledger，各个 Peer 节点对于它所属的每个通道，都会保存一份该通道的账本副本）与使用 levelDB 实现保存索引信息的 index 目录。目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@a37b2b8a2858:/var/hyperledger/production/ledgersData/chains# ll</span><br><span class="line">chains</span><br><span class="line">  |----mychannel</span><br><span class="line">  |----|----blockfile_000000</span><br><span class="line">index</span><br><span class="line">  |----000001.log</span><br><span class="line">  |----CURRENT</span><br><span class="line">  |----LOCK</span><br><span class="line">  |----LOG</span><br><span class="line">  |----MANIFEST-000000</span><br></pre></td></tr></table></figure><p>Orderer 节点本身保存一份账本，但不包括状态数据库及历史索引数据，这些都是由 Peer 节点进行维护：</p><ul><li>状态数据库（State Database）：存储了交易日志中所有 key 的最新值（World State），默认数据库使用 LevelDB。链码调用基于当前的状态数据执行交易。</li><li>历史数据库（History Database）：以 LevelDB 数据库作为数据存储载体，<strong>存储区块中有效交易相关的 key，而不存储 value</strong>（数据库不允许 value 为空，所以实际上 value 都为 []byte{}）。</li></ul><p><img src="http://image.chaindesk.cn/9.1_6.png/mark" alt="分布式账本存储"></p><blockquote><p>idStore：存储 Peer 加入的所有的 ledgerId（或称之为 chainid/channelId）。且保证账本编号在全局中的唯一性。默认存储目录为： /var/hyperledger/production/ledgersData/ledgerProvider</p></blockquote><p><strong>读写集</strong></p><p><strong>模拟交易和读写集</strong></p><p>在模拟执行交易后，背书节点（Endorser）会生成读写集（Read-Write Set），<strong>读集（Read Set）中包含了交易在模拟执行期间读取的唯一 key 与对应已提交的值及其提交 version 的列表</strong>，<strong>写集（Write Set）中包含一个唯一键列表以及交易写入的新值</strong>。如果交易执行的是删除操作，则在写集（Write Set）中为该 key 设置一个删除标记。如果在一个交易中对同一个 key 多次进行更改，则仅保留最后更改的值（即最新值）。另外，如果交易读取指定 key 的值，只会返回已提交的状态值，而不能读取到同一交易中修改但未提交的值。</p><p>如上所述，key 的 version 只被包含在读集（Read Set）中；写集（Write Set）只包含 key 列表及其最新值。</p><p>version 为指定 key 生成一个非重复标识符，可以有各种方案来实现，如使用单调递增的数字来表示。在当前实现中，使用的是基于区块链高度的方式来表示，就是用交易的 height 作为该交易所修改的 key 的 version，交易的 height 由一个 Version 结构体表示（见下面Version struct），其中 TxNum 表示这个 tx 在区块中的编号。该方案相较于递增序号有很多优点，主要是可以很好地利用到诸如 statedb、模拟交易和交易验证这些模块中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxReadWriteSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    DataModel TxReadWriteSet_DataModel </span><br><span class="line">    NsRwset   []*NsReadWriteSet        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NsReadWriteSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    Namespace             <span class="keyword">string</span>                          </span><br><span class="line">    Rwset                 []<span class="keyword">byte</span>                          </span><br><span class="line">    CollectionHashedRwset []*CollectionHashedReadWriteSet </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RangeQueryInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    StartKey     <span class="keyword">string</span> </span><br><span class="line">    EndKey       <span class="keyword">string</span> </span><br><span class="line">    ItrExhausted <span class="keyword">bool</span>   </span><br><span class="line">    ReadsInfo isRangeQueryInfo_ReadsInfo </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KVRead <span class="keyword">struct</span> &#123;  <span class="comment">//读集</span></span><br><span class="line">    Key     <span class="keyword">string</span>   </span><br><span class="line">    Version *Version  <span class="comment">//区块高度  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KVWrite <span class="keyword">struct</span> &#123;  <span class="comment">//写集</span></span><br><span class="line">    Key      <span class="keyword">string</span> </span><br><span class="line">    IsDelete <span class="keyword">bool</span>  </span><br><span class="line">    Value    []<span class="keyword">byte</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Version <span class="keyword">struct</span> &#123;</span><br><span class="line">    BlockNum <span class="keyword">uint64</span> </span><br><span class="line">    TxNum    <span class="keyword">uint64</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个通过模拟假设事务准备的示例读写集的示例。为了方便，我们使用递增数字序号来表示版本号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;TxReadWriteSet&gt;</span><br><span class="line">  &lt;NsReadWriteSet name=<span class="string">"chaincode1"</span>&gt;</span><br><span class="line">    &lt;read-set&gt;</span><br><span class="line">      &lt;read key=<span class="string">"K1"</span>, version=<span class="string">"1"</span> /&gt;</span><br><span class="line">      &lt;read key=<span class="string">"K2"</span>, version=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;/read-set&gt;</span><br><span class="line">    &lt;write-set&gt;</span><br><span class="line">      &lt;write key=<span class="string">"K1"</span>, value=<span class="string">"V1"</span> /&gt;</span><br><span class="line">      &lt;write key=<span class="string">"K3"</span>, value=<span class="string">"V2"</span> /&gt;</span><br><span class="line">      &lt;write key=<span class="string">"K4"</span>, isDelete=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;/write-set&gt;</span><br><span class="line">  &lt;/NsReadWriteSet&gt;</span><br><span class="line">&lt;TxReadWriteSet&gt;</span><br></pre></td></tr></table></figure><p>另外，如果事务在模拟期间执行的是范围查询，则范围查询及其结果将添加到读写集中，使用<code>query-info</code> 来表示。</p><p><strong>交易验证和更新世界状态</strong></p><p>commiter 节点使用读写集的读集部分来进行交易的有效性的检查，写集部分更新受影响的 key 的版本号和值。</p><p><strong>在验证阶段，使用读集中的每个 key 的版本号与状态数据库中的世界状态（world state）进行比较，如果匹配，则认为此交易有效</strong>。如果读写集还包含一个或多个查询信息（query-info），则执行额外的验证。该验证确保在此批量查询的结果范围内没有 key 被新增、删除或更改。换句话说，如果在进行验证期间重新执行任何的范围查询(事务在模拟过程中执行)，应该产生与交易在模拟执行时得到的结果相同。此验证确保交易在提交时如果出现幻读则会被认为无效。注意，幻读保护只实现了Chaincode调用的 <code>GetStateByRange</code> 方法，其他批量查询方法（如：<code>GetQueryResult</code>）则会有幻读风险，因此应该只在不需要提交给排序的只读事务中使用，除非应用程序能够保证模拟阶段和验证阶段结果集的稳定性。</p><p>如果交易通过了有效性检查，则 commiter 节点使用写集来更新世界状态。在更新阶段，对于写集中存在的每个 key，世界状态中对应的的 value 与版本号都会被更新。</p><p><strong>模拟和验证示例</strong></p><p>为了帮助理解读写集，我们来看一个模拟示例。假设在 worldState 中由元组<code>(k,ver,val)</code>表示，其中 key 为 k，var是 k 的新最 version， val是 k 的 value。</p><p>有五个交易，分别是 <code>T1、T2、T3、T4、T5</code>，这五个交易的模拟过程是针对相同的 worldSate 快照，下面的代码片段显示了每个交易执行读写的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">World state: (k1,<span class="number">1</span>,v1), (k2,<span class="number">1</span>,v2), (k3,<span class="number">1</span>,v3), (k4,<span class="number">1</span>,v4), (k5,<span class="number">1</span>,v5)</span><br><span class="line">T1 -&gt; Write(k1, v1<span class="string">'), Write(k2, v2'</span>)</span><br><span class="line">T2 -&gt; Read(k1), Write(k3, v3<span class="string">')</span></span><br><span class="line"><span class="string">T3 -&gt; Write(k2, v2'</span><span class="string">')</span></span><br><span class="line"><span class="string">T4 -&gt; Write(k2, v2'</span><span class="string">''</span>), read(k2)</span><br><span class="line">T5 -&gt; Write(k6, v6<span class="string">'), read(k5)</span></span><br></pre></td></tr></table></figure><p>现在假设交易的顺序为 T1~T5：</p><ol><li><code>T1</code> 验证成功，因为它没有 read 操作。之后在 worldState 中的 <code>k1</code> 和 <code>k2</code> 会被更新成<code>(k1,2,v1&#39;), (k2,2,v2&#39;)</code></li><li><code>T2</code> 验证失败，因为它读取的 <code>k1</code> 在之前的交易 <code>T1</code> 中被修改了</li><li><code>T3</code> 验证成功，因为它没有 read 操作。之后在 worldState 中的 <code>k2</code> 会被更新成 <code>(k2,3,v2&#39;&#39;)</code></li><li><code>T4</code> 验证失败，因为它读取的 <code>k2</code> 在之前的交易 <code>T1</code> 中被修改了</li><li><code>T5</code> 验证成功，因为它读取的 <code>k5</code> 没有在之前的任何交易中修改</li></ol><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>我听说分类账本中有一个 blockdb，这个 blockdb 是什么？</p><p>从字面上来理解，可以解释为区块数据库，也就是存放区块的数据库，但实际是区块是一个文件系统，保存在 /var/hyperledger/production/ledgersData/chains 目录中。</p></li></ol><h2 id="二、Fabric状态数据库"><a href="#二、Fabric状态数据库" class="headerlink" title="二、Fabric状态数据库"></a>二、Fabric状态数据库</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>了解 Hyperledger Fabric 中所支持的数据库</li><li>掌握 CouchDB 数据库的实现</li></ol><h3 id="1-CouchDB数据库介绍"><a href="#1-CouchDB数据库介绍" class="headerlink" title="1 CouchDB数据库介绍"></a>1 CouchDB数据库介绍</h3><p>在 Hyperledger Fabric 项目中，目前可以支持的状态数据库有两种：</p><ol><li><strong>LevelDB：</strong>LevelDB 是嵌入在 Peer 中的默认键值对（key-value）状态数据库。</li><li><strong>CouchDB：</strong>CouchDB 是一种可选的替代 levelDB 的状态数据库。与 LevelDB 键值存储一样，CouchDB 不仅可以根据 key 进行相应的查询，还可以根据不同的应用场景需求实现复杂查询。</li></ol><p>CouchDB 是前 IBM 的 Lotus Notes 开发者 Damien Katz 创建于2005年的一个项目，定义为“面向大规模可扩展对象数据库的存储系统”，在2008年成为了 Apache 的项目。2010年7月发布第一个稳定版，目前<a href="http://couchdb.apache.org/" target="_blank" rel="noopener">官网</a>的最新版本为 2.2.0。</p><p><img src="http://image.chaindesk.cn/9.2_1_couchdb.png" alt="couchdb_logo"></p><p>Apache CouchDB 是一种新一代数据库管理系统之一，具有核心概念简单（但功能强大）且易于理解的特征，使用 JSON 并支持二进制数据以满足所有数据存储需求。具有高可用性和容错存储引擎，将数据的安全性放在第一位；适用于现代网络和移动应用程序，可以高效地实现数据分发。</p><blockquote><p>后期 Hyperledger Fabric 正式版本中可能会支持更多的数据库管理系统。</p></blockquote><h3 id="2-CouchDB在Hyperledter-Fabric中的具体实现"><a href="#2-CouchDB在Hyperledter-Fabric中的具体实现" class="headerlink" title="2 CouchDB在Hyperledter Fabric中的具体实现"></a>2 CouchDB在Hyperledter Fabric中的具体实现</h3><p>下面我们使用 CouchDB 容器来实现对 CouchDB 的使用。</p><p>以一个票据查询功能实现为例，链码中提供两个查询方法，根据持票人的证件号码查询所有票据与根据持票人的证件号码查询待签收票据。链码部署后调用自定义的 <code>billInit</code> 方法进行数据的初始化，然后分别调用两个查询方法进行测试。实现步骤如下：</p><p>首先定义一个票据的结构体文件：domain.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BillStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    ObjectType    <span class="keyword">string</span>    <span class="string">`json:"docType"`</span></span><br><span class="line">    BillInfoID    <span class="keyword">string</span>    <span class="string">`json:"BillInfoID"`</span></span><br><span class="line">    BillInfoAmt    <span class="keyword">string</span>    <span class="string">`json:"BillInfoAmt"`</span></span><br><span class="line">    BillInfoType <span class="keyword">string</span>    <span class="string">`json:"BillInfoType"`</span></span><br><span class="line"></span><br><span class="line">    BillIsseDate    <span class="keyword">string</span>    <span class="string">`json:"BillIsseDate"`</span></span><br><span class="line">    BillDueDate    <span class="keyword">string</span>    <span class="string">`json:"BillDueDate"`</span></span><br><span class="line"></span><br><span class="line">    HolderAcct    <span class="keyword">string</span>    <span class="string">`json:"HolderAcct"`</span></span><br><span class="line">    HolderCmID    <span class="keyword">string</span>    <span class="string">`json:"HolderCmID"`</span></span><br><span class="line"></span><br><span class="line">    WaitEndorseAcct    <span class="keyword">string</span>    <span class="string">`json:"WaitEndorseAcct"`</span></span><br><span class="line">    WaitEndorseCmID    <span class="keyword">string</span>    <span class="string">`json:"WaitEndorseCmID"`</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写链码文件： main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CouchDBChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *CouchDBChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *CouchDBChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">    fun, args := stub.GetFunctionAndParameters()</span><br><span class="line">    <span class="keyword">if</span> fun == <span class="string">"billInit"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> billInit(stub, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"queryBills"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryBills(stub, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"queryWaitBills"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queryWaitBills(stub, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"非法操作, 指定的函数名无效"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化票据数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">billInit</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">    bill := BillStruct&#123;</span><br><span class="line">        ObjectType:<span class="string">"billObj"</span>,</span><br><span class="line">        BillInfoID:<span class="string">"POC101"</span>,</span><br><span class="line">        BillInfoAmt:<span class="string">"1000"</span>,</span><br><span class="line">        BillInfoType:<span class="string">"111"</span>,</span><br><span class="line">        BillIsseDate:<span class="string">"20100101"</span>,</span><br><span class="line">        BillDueDate:<span class="string">"20100110"</span>,</span><br><span class="line"></span><br><span class="line">        HolderAcct:<span class="string">"AAA"</span>,</span><br><span class="line">        HolderCmID:<span class="string">"AAAID"</span>,</span><br><span class="line"></span><br><span class="line">        WaitEndorseAcct:<span class="string">""</span>,</span><br><span class="line">        WaitEndorseCmID:<span class="string">""</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    billByte, _ := json.Marshal(bill)</span><br><span class="line">    err := stub.PutState(bill.BillInfoID, billByte)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"初始化第一个票据失败: "</span>+ err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bill2 := BillStruct&#123;</span><br><span class="line">        ObjectType:<span class="string">"billObj"</span>,</span><br><span class="line">        BillInfoID:<span class="string">"POC102"</span>,</span><br><span class="line">        BillInfoAmt:<span class="string">"2000"</span>,</span><br><span class="line">        BillInfoType:<span class="string">"111"</span>,</span><br><span class="line">        BillIsseDate:<span class="string">"20100201"</span>,</span><br><span class="line">        BillDueDate:<span class="string">"20100210"</span>,</span><br><span class="line"></span><br><span class="line">        HolderAcct:<span class="string">"AAA"</span>,</span><br><span class="line">        HolderCmID:<span class="string">"AAAID"</span>,</span><br><span class="line"></span><br><span class="line">        WaitEndorseAcct:<span class="string">"BBB"</span>,</span><br><span class="line">        WaitEndorseCmID:<span class="string">"BBBID"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    billByte2, _ := json.Marshal(bill2)</span><br><span class="line">    err = stub.PutState(bill2.BillInfoID, billByte2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"初始化第二个票据失败: "</span>+ err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bill3 := BillStruct&#123;</span><br><span class="line">        ObjectType:<span class="string">"billObj"</span>,</span><br><span class="line">        BillInfoID:<span class="string">"POC103"</span>,</span><br><span class="line">        BillInfoAmt:<span class="string">"3000"</span>,</span><br><span class="line">        BillInfoType:<span class="string">"111"</span>,</span><br><span class="line">        BillIsseDate:<span class="string">"20100301"</span>,</span><br><span class="line">        BillDueDate:<span class="string">"20100310"</span>,</span><br><span class="line"></span><br><span class="line">        HolderAcct:<span class="string">"BBB"</span>,</span><br><span class="line">        HolderCmID:<span class="string">"BBBID"</span>,</span><br><span class="line"></span><br><span class="line">        WaitEndorseAcct:<span class="string">"CCC"</span>,</span><br><span class="line">        WaitEndorseCmID:<span class="string">"CCCID"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    billByte3, _ := json.Marshal(bill3)</span><br><span class="line">    err = stub.PutState(bill3.BillInfoID, billByte3)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"初始化第三个票据失败: "</span>+ err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bill4 := BillStruct&#123;</span><br><span class="line">        ObjectType:<span class="string">"billObj"</span>,</span><br><span class="line">        BillInfoID:<span class="string">"POC104"</span>,</span><br><span class="line">        BillInfoAmt:<span class="string">"4000"</span>,</span><br><span class="line">        BillInfoType:<span class="string">"111"</span>,</span><br><span class="line">        BillIsseDate:<span class="string">"20100401"</span>,</span><br><span class="line">        BillDueDate:<span class="string">"20100410"</span>,</span><br><span class="line"></span><br><span class="line">        HolderAcct:<span class="string">"CCC"</span>,</span><br><span class="line">        HolderCmID:<span class="string">"CCCID"</span>,</span><br><span class="line"></span><br><span class="line">        WaitEndorseAcct:<span class="string">"BBB"</span>,</span><br><span class="line">        WaitEndorseCmID:<span class="string">"BBBID"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    billByte4, _ := json.Marshal(bill4)</span><br><span class="line">    err = stub.PutState(bill4.BillInfoID, billByte4)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"初始化第四个票据失败: "</span>+ err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"初始化票据成功"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据持票人的证件号码批量查询持票人的持有票据列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryBills</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定持票人的证件号码"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    holderCmID := args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼装CouchDB所需要的查询字符串(是标准的一个JSON串)</span></span><br><span class="line">    <span class="comment">// "&#123;\"key\":&#123;\"k\":\"v\", \"k\":\"v\"[,...]&#125;&#125;"</span></span><br><span class="line">    queryString := fmt.Sprintf(<span class="string">"&#123;\"selector\":&#123;\"docType\":\"billObj\", \"HoldrCmID\":\"%s\"&#125;&#125;"</span>, holderCmID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line">    result, err := getBillsByQueryString(stub, queryString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据持票人的证件号码批量查询持票人的持有票据列表时发生错误: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据待背书人的证件号码批量查询待背书的票据列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryWaitBills</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定待背书人的证件号码"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waitEndorseCmID := args[<span class="number">0</span>]</span><br><span class="line">    queryString := fmt.Sprintf(<span class="string">"&#123;\"selector\":&#123;\"docType\":\"billObj\", \"WaitEndorseCmID\":\"%s\"&#125;&#125;"</span>, waitEndorseCmID)</span><br><span class="line"></span><br><span class="line">    result, err := getBillsByQueryString(stub, queryString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据待背书人的证件号码批量查询待背书的票据列表时发生错误: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的查询字符串查询批量数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBillsByQueryString</span><span class="params">(stub shim.ChaincodeStubInterface, queryString <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    iterator, err := stub.GetQueryResult(queryString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span>  iterator.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">    <span class="keyword">var</span> isSplit <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">for</span> iterator.HasNext() &#123;</span><br><span class="line">        result, err := iterator.Next()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isSplit &#123;</span><br><span class="line">            buffer.WriteString(<span class="string">"; "</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.WriteString(<span class="string">"key:"</span>)</span><br><span class="line">        buffer.WriteString(result.Key)</span><br><span class="line">        buffer.WriteString(<span class="string">", Value: "</span>)</span><br><span class="line">        buffer.WriteString(<span class="keyword">string</span>(result.Value))</span><br><span class="line"></span><br><span class="line">        isSplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer.Bytes(), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(CouchDBChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Errorf(<span class="string">"启动链码失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 CouchDB 需要声明相应的 couchdb 容器， 在 docker-compose-simple.yaml 配置文件中添加 couchdb 的容器信息：</p><blockquote><p>可以参考 first-network 目录中的 docker-compose-couch.yaml 配置文件，该文件中声明了 couchdb 的示例配置信息。</p></blockquote><p>需要在 chaincode-docker-devmode 目录下编辑 docker-compose-simple.yaml 文件. 添加couchDB相关内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">couchdb:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">couchdb</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-couchdb</span></span><br><span class="line">  <span class="comment"># Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password</span></span><br><span class="line">  <span class="comment"># for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COUCHDB_USER=</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COUCHDB_PASSWORD=</span></span><br><span class="line">  <span class="comment"># Comment/Uncomment the port mapping if you want to hide/expose the CouchDB service,</span></span><br><span class="line">  <span class="comment"># for example map it to utilize Fauxton User Interface in dev environments.</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"5984:5984"</span></span><br></pre></td></tr></table></figure><blockquote><p>peer容器中声明的配置信息参考 first-network 目录中的 docker-compose-couch.yaml 配置文件</p></blockquote><p>需要在 chaincode-docker-devmode 目录下编辑 docker-compose-simple.yaml 文件. 添加couchDB相关内容，在声明 peer 容器中的 environment 中添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_STATEDATABASE=CouchDB</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=</span></span><br><span class="line"><span class="attr">depends_on:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">couchdb</span></span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>进入 <code>chaincode</code> 目录中，创建并进入 <code>testcdb</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hyfa/fabric-samples/chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir testcdb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> testcdb</span></span><br></pre></td></tr></table></figure><p>将编写的两个 <code>domain.go、main.go</code> 文件上传至 <code>testcdb</code> 目录中，然后跳转至<code>fabric-samples</code>的<code>chaincode-docker-devmode</code>目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode-docker-devmode/</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>终端1 启动网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-simple.yaml up -d</span></span><br></pre></td></tr></table></figure><blockquote><p>在执行启动网络的命令之前确保无Fabric网络处于运行状态，如果有网络在运行，请先关闭。</p></blockquote></li><li><p><strong>终端2 建立并启动链码</strong></p><p><strong>2.1 打开一个新终端2，进入 chaincode 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br></pre></td></tr></table></figure><p><strong>2.2 编译</strong></p><p>进入 testcdb 目录编译 chaincode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> testcdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go build</span></span><br></pre></td></tr></table></figure><p><strong>2.3 运行chaincode</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=cdb:0 ./testcdb</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode log level not provided; defaulting to: INFO</span><br><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 002 Chaincode (build level: ) starting up ...</span><br></pre></td></tr></table></figure></li><li><p><strong>终端3 测试</strong></p><p><strong>3.1 打开一个新的终端3，进入 cli 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p><strong>3.2 安装链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -p chaincodedev/chaincode/testcdb -n cdb -v 0</span></span><br></pre></td></tr></table></figure><p><strong>3.3 实例化链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -n cdb -v 0 -C myc -c <span class="string">'&#123;"Args":["init"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>3.4 初始化数据</strong></p><p>指定调用 billInit 函数进行数据的初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -n cdb -C myc -c <span class="string">'&#123;"Args":["billInit"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功，输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 0a8 Chaincode invoke successful. result: status:200 payload:"\345\210\235\345\247\213\345\214\226\347\245\250\346\215\256\346\210\220\345\212\237"</span><br></pre></td></tr></table></figure><p><strong>3.5 根据持票人证件号码查询所有票据列表</strong></p><p>指定调用 queryBills 函数，查询指定持票人的票据列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n cdb -C myc -c <span class="string">'&#123;"Args":["queryBills", "AAAID"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功，输出查询到的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[msp/identity] Sign -&gt; DEBU 045 Sign: digest: 200A43B1310FF70847EB518A10EBFE1231F448CDBD61239AF11E82BA40D9456F </span><br><span class="line">key:POC101, Value: &#123;"BillDueDate":"20100110","BillInfoAmt":"1000","BillInfoID":"POC101","BillInfoType":"111","BillIsseDate":"20100101","HolderAcct":"AAA","HolderCmID":"AAAID","WaitEndorseAcct":"","WaitEndorseCmID":"","docType":"billObj"&#125;; key:POC102, Value: &#123;"BillDueDate":"20100210","BillInfoAmt":"2000","BillInfoID":"POC102","BillInfoType":"111","BillIsseDate":"20100201","HolderAcct":"AAA","HolderCmID":"AAAID","WaitEndorseAcct":"BBB","WaitEndorseCmID":"BBBID","docType":"billObj"&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>3.6 根据持票人证件号码查询待签收票据列表</strong></p><p>指定调用 queryWaitBills 函数，查询指定人员的待签收票据列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n cdb -C myc -c <span class="string">'&#123;"Args":["queryWaitBills", "CCCID"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功，输出查询到的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[msp/identity] Sign -&gt; DEBU 045 Sign: digest: 94F32E3D440F409720433DDFA3A2F2FA48BF98835916927923ED1D1A75344B8A </span><br><span class="line">key:POC103, Value: &#123;"BillDueDate":"20100310","BillInfoAmt":"3000","BillInfoID":"POC103","BillInfoType":"111","BillIsseDate":"20100301","HolderAcct":"BBB","HolderCmID":"BBBID","WaitEndorseAcct":"CCC","WaitEndorseCmID":"CCCID","docType":"billObj"&#125;</span><br></pre></td></tr></table></figure><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>在 Hyperledger Fabric 中，状态数据库使用 LevelDB 与 CouchDB 有什么区别？</p><p>如果状态数据库使用 CouchDB 的话，具有最大的一个特点：可以使用富查询实现对状态的检索，但是需要自定义富查询字符串，该字符串必须符合 CouchDB 查询语法结构。</p></li><li><p>如何使用 CouchDB？</p><p>在 Hyperledger Fabric 环境中，如果需要使用 CouchDB，那么必须在 docker-compose.yml/docker-compose.yaml或自定义的配置文件中声明 CouchDB 容器，然后在各个 peer 容器中 environment 属性中声明相关环境内容，且在 depends_on 属性中指定声明的 CouchDB 容器的名称。</p></li></ol><p>未经授权禁止转载、改编，转载请注明出处！</p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/198" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/198</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章基于区块链技术实现学历信息认证</title>
      <link href="/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC13%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%A6%E5%8E%86%E4%BF%A1%E6%81%AF%E5%BE%81%E4%BF%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/27/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC13%E7%AB%A0%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AD%A6%E5%8E%86%E4%BF%A1%E6%81%AF%E5%BE%81%E4%BF%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><a id="more"></a><h3 id="13-1-1-需求分析"><a href="#13-1-1-需求分析" class="headerlink" title="13.1.1 需求分析"></a>13.1.1 需求分析</h3><p>现在是一个信息化的高科技时代，许许多多的企业必须紧跟时代步伐，不断创新，才能发展壮大；而企业的发展必然离不开人才队伍的建设，也可以说创新是企业发展的动力，而人才却是企业发展的根本，所以现在各企业对于人才队伍建设十分看重，而对于人才的素质及受教育情况的要求更是重中之重。</p><p>对学历信息的查询，要么成本较高，要么比较麻烦，甚至还有一些假冒网站让人防不胜防；传统应用是将数据保存在数据库中来实现，但是现在出现的数据库由于故障或者被删、被黑造成的数据丢失的情况更是屡见不鲜，所以传统数据库并不能真正意义上确保数据的完整性及安全性。</p><p>基于这些情况，我们设计并开发了一个 <code>基于区块链技术的实现的学历信息征信系统</code>，实现了在线对学历信息的查询功能，由于区块链技术本身的特点，无须考虑数据被破坏的问题，而且杜绝了对于信息造假的情况，保证了学历信息的真实性。由于篇幅原因，我们对学历信息征信系统的应用场景进行修改及简化，实现的业务逻辑包括添加信息、修改信息、查询信息、查询详情信息等操作，实际情况下的的业务逻辑需要根据实际需求场景做出相应的调整。</p><p>由于系统需要保证人才受教育情况真实性，所以对于系统的用户而言，不可能由用户自己添加相应的学历信息，而是由具有一定权限的用户来完成添加或修改的功能。但普通用户可以通过系统溯源功能来确定信息的真伪。所以我们将系统用户的使用角色分为两种：</p><ol><li>普通用户</li><li>管理员用户</li></ol><p>普通用户具有对数据的查询功能 ，但实现查询之前必须经过登录认证：</p><ul><li>用户登录：系统只针对合法用户进行授权使用，所以用户必须先进行登录才能完成相应的功能。</li><li>查询实现：查询分为两种方式实现<ul><li>根据证书编号与姓名查询：根据用户输入的证书编号与姓名进行查询。</li><li>根据身份证号码查询：根据用户输入指定的身份证号码进行查询，此功能可以实现溯源。</li></ul></li></ul><p>管理员用户除具有普通用户的功能之外，额外添加了两个功能：</p><ul><li>添加信息：可以向系统中添加新的学历信息。</li><li>修改信息：针对已存在的学历信息进行修改。</li></ul><h3 id="13-1-2-架构设计"><a href="#13-1-2-架构设计" class="headerlink" title="13.1.2 架构设计"></a>13.1.2 架构设计</h3><p>我们在本书的第十、十一、十二章中已经完成了一个完整的基于 <code>fabric-sdk-go</code> 的应用示例，所以我们现在使用之前的应用架构，不同的是在此应用中需要编写实现完整的链码并通过业务层调用链码中的各个函数，以实现对数据状态的操作。界面为了方便用户操作使用，仍然使用Web浏览器的方式实现。而且在此应用中我们将 <code>Hyperledger Fabric</code> 默认的状态数据库由 <code>LevelDB</code> 替换为 <code>CouchDB</code> 来实现</p><p><img src="http://image.chaindesk.cn/projectArch.png/mark" alt="架构"></p><p>对于 <code>Fabric Network</code>结构如下图所示：</p><p><img src="http://image.chaindesk.cn/networkArch.png/mark" alt="networkArch"></p><h3 id="13-1-3-数据模型设计"><a href="#13-1-3-数据模型设计" class="headerlink" title="13.1.3 数据模型设计"></a>13.1.3 数据模型设计</h3><p>由于需要向分类账本中保存数据，所以必须设计相关的结构体用于声明要保存的数据结构，用于方便的在应用中处理数据。</p><p><code>Education</code> 结构体设计如下表所示：</p><table><thead><tr><th align="left">名称</th><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ObjectType</td><td align="left">string</td><td align="left"></td></tr><tr><td align="left">Name</td><td align="left">string</td><td align="left">姓名</td></tr><tr><td align="left">Gender</td><td align="left">string</td><td align="left">性别</td></tr><tr><td align="left">Nation</td><td align="left">string</td><td align="left">民族</td></tr><tr><td align="left">EntityID</td><td align="left">string</td><td align="left">身份证号（记录的Key）</td></tr><tr><td align="left">Place</td><td align="left">string</td><td align="left">籍贯</td></tr><tr><td align="left">BirthDay</td><td align="left">string</td><td align="left">出生日期</td></tr><tr><td align="left">Photo</td><td align="left">string</td><td align="left">照片</td></tr><tr><td align="left">EnrollDate</td><td align="left">string</td><td align="left">入学日期</td></tr><tr><td align="left">GraduationDate</td><td align="left">string</td><td align="left">毕（结）业日期</td></tr><tr><td align="left">SchoolName</td><td align="left">string</td><td align="left">所读学校名称</td></tr><tr><td align="left">Major</td><td align="left">string</td><td align="left">所读专业</td></tr><tr><td align="left">QuaType</td><td align="left">string</td><td align="left">学历类别（普通、成考等）</td></tr><tr><td align="left">Length</td><td align="left">string</td><td align="left">学制（两年、三年、四年、五年）</td></tr><tr><td align="left">Mode</td><td align="left">string</td><td align="left">学习形式（普通全日制）</td></tr><tr><td align="left">Level</td><td align="left">string</td><td align="left">层次（专科、本科、研究生、博士）</td></tr><tr><td align="left">Graduation</td><td align="left">string</td><td align="left">毕（结）业（毕业、结业）</td></tr><tr><td align="left">CertNo</td><td align="left">string</td><td align="left">证书编号</td></tr><tr><td align="left">Historys</td><td align="left">[]HistoryItem</td><td align="left">当前edu的详细历史记录</td></tr></tbody></table><p>为了能够从当前的分类状态中查询出详细的历史操作记录，我们在 <code>Education</code> 中设计了一个类型为<code>HistoryItem</code> 数组的 <code>Historys</code> 成员，表示当前状态的历史记录集。</p><p><code>HistoryItem</code> 结构体设计如下表所示：</p><table><thead><tr><th align="left">名称</th><th align="left">数据类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">TxId</td><td align="left">string</td><td align="left">交易编号</td></tr><tr><td align="left">Education</td><td align="left">Education</td><td align="left">本次历史记录的详细信息</td></tr></tbody></table><h3 id="13-1-4-网络环境"><a href="#13-1-4-网络环境" class="headerlink" title="13.1.4 网络环境"></a>13.1.4 网络环境</h3><h4 id="13-1-4-1-设置环境"><a href="#13-1-4-1-设置环境" class="headerlink" title="13.1.4.1 设置环境"></a>13.1.4.1 设置环境</h4><p>我们在第十章中说明了如何构建fabric网络环境，现在我们要重新完成一个新的应用，所以网络环境可以使用之前的内容，但是因为<strong>状态数据库使用 <code>CouchDB</code> 来实现</strong>，所以需要做出部分修改，新增与 <code>CouchDB</code> 相关的内容。为了方便读者起见，我们重新搭建一个应用所需的网络环境。</p><p>在<code>GOPATH</code>的<code>src</code>文件夹中新建一个目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education</span></span><br></pre></td></tr></table></figure><p>使用 <code>git</code> 命令克隆 hf-fixtures 目录当前路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/kevin-hf/hf-fixtures.git</span></span><br></pre></td></tr></table></figure><p>将 hf-fixtures 文件夹重命名为 fixtures</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv hf-fixtures/fixtures</span></span><br></pre></td></tr></table></figure><p>修改<code>fixtures</code> 文件夹的所属关系为当前用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R kevin:kevin ./fixtures</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： kevin 为安装 Ubuntu 16.04 系统时创建的用户</p></blockquote><p>进入 <code>fixtures</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fixtures</span></span><br></pre></td></tr></table></figure><p>为了构建区块链网络，使用 <code>docker</code> 构建处理不同角色的虚拟计算机。 在这里我们将尽可能保持简单。如果确定您的系统中已经存在相关的所需容器，或可以使用其它方式获取，则无需执行如下命令。否则请将 <code>fixtures</code> 目录下的 <code>pull_images.sh</code> 文件添加可执行权限后直接执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 777 ./pull_images.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./pull_images.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：<code>pull_images.sh</code> 文件是下载 Fabric 环境所需容器的一个可执行脚本，下载过程需要一段时间（视网速情况而定），请耐心等待。另：请确定您的系统支持虚拟技术。</p></blockquote><h4 id="13-1-4-2-配置docker-compose-yml文件"><a href="#13-1-4-2-配置docker-compose-yml文件" class="headerlink" title="13.1.4.2 配置docker-compose.yml文件"></a>13.1.4.2 配置docker-compose.yml文件</h4><p>在 <code>fixtures</code> 目录下创建一个 <code>docker-compose.yml</code> 文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim docker-compose.yml</span></span><br></pre></td></tr></table></figure><ol><li><p>将 <code>network下的basic</code> 修改为 <code>default</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br></pre></td></tr></table></figure></li><li><p>编辑 orderer 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">orderer.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=debug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENPORT=7050</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISPROFILE=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./artifacts/genesis.block:/var/hyperledger/orderer/genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/orderers/orderer.kevin.kongyixueyuan.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/orderers/orderer.kevin.kongyixueyuan.com/tls:/var/hyperledger/orderer/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7050</span><span class="string">:7050</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>编辑 ca 部分</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ca.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-ca</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_NAME=ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_CA_KEYFILE=/etc/hyperledger/fabric-ca-server-config/727e69ed4a01a204cd53bf4a97c2c1cb947419504f82851f6ae563c3c96dea3a_sk</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_TLS_KEYFILE=/etc/hyperledger/fabric-ca-server-config/727e69ed4a01a204cd53bf4a97c2c1cb947419504f82851f6ae563c3c96dea3a_sk</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7054</span><span class="string">:7054</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'fabric-ca-server start -b admin:adminpw -d'</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/ca/:/etc/hyperledger/fabric-ca-server-config</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>声明 CouchDB 部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">couchdb:</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">couchdb</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-couchdb</span></span><br><span class="line">  <span class="comment"># Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password</span></span><br><span class="line">  <span class="comment"># for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COUCHDB_USER=</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">COUCHDB_PASSWORD=</span></span><br><span class="line">  <span class="comment"># Comment/Uncomment the port mapping if you want to hide/expose the CouchDB service,</span></span><br><span class="line">  <span class="comment"># for example map it to utilize Fauxton User Interface in dev environments.</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"5984:5984"</span></span><br></pre></td></tr></table></figure></li><li><p>编辑Peer部分</p><ol><li><p><code>peer0.org1.example.com</code> 内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-peer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_DOCKER_ATTACHSTDOUT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_NETWORKID=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_PROFILE_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/var/hyperledger/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/var/hyperledger/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESSAUTODETECT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_SKIPHANDSHAKE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_SERVERHOSTOVERRIDE=peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_STATEDATABASE=CouchDB</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">peer</span> <span class="string">node</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer0.org1.kevin.kongyixueyuan.com/msp:/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer0.org1.kevin.kongyixueyuan.com/tls:/var/hyperledger/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">couchdb</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li><li><p>peer1.org1.example.com 内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-peer</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_VM_DOCKER_ATTACHSTDOUT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_NETWORKID=kongyixueyuan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_PROFILE_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/var/hyperledger/tls/server.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/var/hyperledger/tls/server.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/var/hyperledger/tls/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESSAUTODETECT=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.kevin.kongyixueyuan.com:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_SKIPHANDSHAKE=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_SERVERHOSTOVERRIDE=peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_STATEDATABASE=CouchDB</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:5984</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=</span></span><br><span class="line">  <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">peer</span> <span class="string">node</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer1.org1.kevin.kongyixueyuan.com/msp:/var/hyperledger/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/peers/peer1.org1.kevin.kongyixueyuan.com/tls:/var/hyperledger/tls</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7151</span><span class="string">:7051</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7153</span><span class="string">:7053</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">couchdb</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="13-1-5-测试网络环境"><a href="#13-1-5-测试网络环境" class="headerlink" title="13.1.5 测试网络环境"></a>13.1.5 测试网络环境</h3><p>为了检查网络是否正常工作，使用<code>docker-compose</code>同时启动或停止所有容器。 进入<code>fixtures</code>文件夹，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education/fixtures</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br></pre></td></tr></table></figure><p>如果在您的系统中没有相关的容器，那么会自动下载docker镜像。下载完毕后自动启动，控制台会输出很多不同颜色的日志（红色不等于错误）</p><p><img src="http://image.chaindesk.cn/dockercompose_up.png/mark" alt="启动网络"></p><p>打开一个新终端并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/docker_ps.png/mark" alt="查看容器"></p><p>将看到：两个peer，一个orderer和一个CA容器，还有一个 CouchDB 容器。 代表已成功创建了一个新的网络，可以随SDK一起使用。 要停止网络，请返回到上一个终端，按<code>Ctrl+C</code>并等待所有容器都停止。</p><blockquote><p><strong>提示</strong> ：当网络成功启动后，所有处于活动中的容器都可以访问。 也可以查看指定容器的详细日志内容。 如果想删除这些容器，需要使用<code>docker rm $(docker ps -aq)</code>将其删除 ，但在删除容器之前需要确定其在网络环境中已不再使用。</p><p>如果在网络环境启动过程中不想看到大量的日志信息，请在该启动命令中添加参数 <code>-d</code> ，如下所示： <code>docker-compose up -d</code> 。 如果要停止网络，请务必在 <code>docker-compose.yaml</code> 所在的文件夹中运行命令： <code>docker-compose stop</code> （或 使用<code>docker-compose down</code> 进行清理停止所有容器）。</p></blockquote><p>最后在终端2中执行如下命令关闭网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education/fixtures</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose down</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/dockercompose_down.png/mark" alt="关闭网络"></p><p>终端1窗口中输出如下：</p><p><img src="http://image.chaindesk.cn/dockercompose_down2.png/mark" alt="关闭网络过程"></p><h3 id="SDK与链码的实现"><a href="#SDK与链码的实现" class="headerlink" title="SDK与链码的实现"></a>SDK与链码的实现</h3><h3 id="13-2-1-创建-config-yaml-文件"><a href="#13-2-1-创建-config-yaml-文件" class="headerlink" title="13.2.1 创建 config.yaml 文件"></a>13.2.1 创建 <code>config.yaml</code> 文件</h3><p>确认 Hyperledger Fabric 基础网络环境运行没有问题后，现在我们通过创建一个新的 config.yaml 配置文件给应用程序所使用的 Fabric-SDK-Go 配置相关参数及 Fabric 组件的通信地址</p><p>进入项目的根目录中创建一个 <code>config.yaml</code> 文件并编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim config.yaml</span></span><br></pre></td></tr></table></figure><p>config.yaml 配置文件完整内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">"kongyixueyuan-network"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Schema version of the content. Used by the SDK to apply the corresponding parsing rules.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The client section used by GO SDK.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Which organization does this application instance belong to? The value must be the name of an org</span></span><br><span class="line">  <span class="comment"># defined under "organizations"</span></span><br><span class="line">  <span class="attr">organization:</span> <span class="string">Org1</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">logging:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global configuration for peer, event service and orderer timeouts</span></span><br><span class="line">  <span class="comment"># if this this section is omitted, then default values will be used (same values as below)</span></span><br><span class="line"><span class="comment">#  peer:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 10s</span></span><br><span class="line"><span class="comment">#      response: 180s</span></span><br><span class="line"><span class="comment">#      discovery:</span></span><br><span class="line"><span class="comment">#        # Expiry period for discovery service greylist filter</span></span><br><span class="line"><span class="comment">#        # The channel client will greylist peers that are found to be offline</span></span><br><span class="line"><span class="comment">#        # to prevent re-selecting them in subsequent retries.</span></span><br><span class="line"><span class="comment">#        # This interval will define how long a peer is greylisted</span></span><br><span class="line"><span class="comment">#        greylistExpiry: 10s</span></span><br><span class="line"><span class="comment">#  eventService:</span></span><br><span class="line"><span class="comment">#    # Event service type (optional). If not specified then the type is automatically</span></span><br><span class="line"><span class="comment">#    # determined from channel capabilities.</span></span><br><span class="line"><span class="comment">#    type: (deliver|eventhub)</span></span><br><span class="line">    <span class="comment"># the below timeouts are commented out to use the default values that are found in</span></span><br><span class="line">    <span class="comment"># "pkg/fab/endpointconfig.go"</span></span><br><span class="line">    <span class="comment"># the client is free to override the default values by uncommenting and resetting</span></span><br><span class="line">    <span class="comment"># the values as they see fit in their config file</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 15s</span></span><br><span class="line"><span class="comment">#      registrationResponse: 15s</span></span><br><span class="line"><span class="comment">#  orderer:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      connection: 15s</span></span><br><span class="line"><span class="comment">#      response: 15s</span></span><br><span class="line"><span class="comment">#  global:</span></span><br><span class="line"><span class="comment">#    timeout:</span></span><br><span class="line"><span class="comment">#      query: 180s</span></span><br><span class="line"><span class="comment">#      execute: 180s</span></span><br><span class="line"><span class="comment">#      resmgmt: 180s</span></span><br><span class="line"><span class="comment">#    cache:</span></span><br><span class="line"><span class="comment">#      connectionIdle: 30s</span></span><br><span class="line"><span class="comment">#      eventServiceIdle: 2m</span></span><br><span class="line"><span class="comment">#      channelConfig: 30m</span></span><br><span class="line"><span class="comment">#      channelMembership: 30s</span></span><br><span class="line"><span class="comment">#      discovery: 10s</span></span><br><span class="line"><span class="comment">#      selection: 10m</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Root of the MSP directories with keys and certs.</span></span><br><span class="line">  <span class="attr">cryptoconfig:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/education/fixtures/crypto-config</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Some SDKs support pluggable KV stores, the properties under "credentialStore"</span></span><br><span class="line">  <span class="comment"># are implementation specific</span></span><br><span class="line">  <span class="attr">credentialStore:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/tmp/kongyixueyuan-store</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Specific to the CryptoSuite implementation used by GO SDK. Software-based implementations</span></span><br><span class="line">    <span class="comment"># requiring a key store. PKCS#11 based implementations does not.</span></span><br><span class="line">    <span class="attr">cryptoStore:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/kongyixueyuan-msp</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># BCCSP config for the client. Used by GO SDK.</span></span><br><span class="line">  <span class="attr">BCCSP:</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">     <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">     <span class="attr">default:</span></span><br><span class="line">      <span class="attr">provider:</span> <span class="string">"SW"</span></span><br><span class="line">     <span class="attr">hashAlgorithm:</span> <span class="string">"SHA2"</span></span><br><span class="line">     <span class="attr">softVerify:</span> <span class="literal">true</span></span><br><span class="line">     <span class="attr">level:</span> <span class="number">256</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tlsCerts:</span></span><br><span class="line">    <span class="comment"># [Optional]. Use system certificate pool when connecting to peers, orderers (for negotiating TLS) Default: false</span></span><br><span class="line">    <span class="attr">systemCertPool:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Client key and cert for TLS handshake with peers and orderers</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">key:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">      <span class="attr">cert:</span></span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [Optional]. But most apps would have this section so that channel objects can be constructed</span></span><br><span class="line"><span class="comment"># based on the content below. If an app is creating channels, then it likely will not need this</span></span><br><span class="line"><span class="comment"># section.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="comment"># name of the channel</span></span><br><span class="line">  <span class="attr">kevinkongyixueyuan:</span></span><br><span class="line">    <span class="comment"># Required. list of orderers designated by the application to use for transactions on this</span></span><br><span class="line">    <span class="comment"># channel. This list can be a result of access control ("org1" can only access "ordererA"), or</span></span><br><span class="line">    <span class="comment"># operational decisions to share loads from applications among the orderers.  The values must</span></span><br><span class="line">    <span class="comment"># be "names" of orgs defined under "organizations/peers"</span></span><br><span class="line">    <span class="comment"># deprecated: not recommended, to override any orderer configuration items, entity matchers should be used.</span></span><br><span class="line">    <span class="comment"># orderers:</span></span><br><span class="line">    <span class="comment">#  - orderer.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required. list of peers from participating orgs</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent transaction proposals for endorsement? The peer must</span></span><br><span class="line">        <span class="comment"># have the chaincode installed. The app can also use this property to decide which peers</span></span><br><span class="line">        <span class="comment"># to send the chaincode install request. Default: true</span></span><br><span class="line">        <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent query proposals? The peer must have the chaincode</span></span><br><span class="line">        <span class="comment"># installed. The app can also use this property to decide which peers to send the</span></span><br><span class="line">        <span class="comment"># chaincode install request. Default: true</span></span><br><span class="line">        <span class="attr">chaincodeQuery:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be sent query proposals that do not require chaincodes, like</span></span><br><span class="line">        <span class="comment"># queryBlock(), queryTransaction(), etc. Default: true</span></span><br><span class="line">        <span class="attr">ledgerQuery:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [Optional]. will this peer be the target of the SDK's listener registration? All peers can</span></span><br><span class="line">        <span class="comment"># produce events but the app typically only needs to connect to one to listen to events.</span></span><br><span class="line">        <span class="comment"># Default: true</span></span><br><span class="line">        <span class="attr">eventSource:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">        <span class="attr">endorsingPeer:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">chaincodeQuery:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ledgerQuery:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">eventSource:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="comment">#[Optional] options for retrieving channel configuration blocks</span></span><br><span class="line">      <span class="attr">queryChannelConfig:</span></span><br><span class="line">        <span class="comment">#[Optional] min number of success responses (from targets/peers)</span></span><br><span class="line">        <span class="attr">minResponses:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#[Optional] channel config will be retrieved for these number of random targets</span></span><br><span class="line">        <span class="attr">maxTargets:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#[Optional] retry options for query config block</span></span><br><span class="line">        <span class="attr">retryOpts:</span></span><br><span class="line">          <span class="comment">#[Optional] number of retry attempts</span></span><br><span class="line">          <span class="attr">attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment">#[Optional] the back off interval for the first retry attempt</span></span><br><span class="line">          <span class="attr">initialBackoff:</span> <span class="string">500ms</span></span><br><span class="line">          <span class="comment">#[Optional] the maximum back off interval for any retry attempt</span></span><br><span class="line">          <span class="attr">maxBackoff:</span> <span class="string">5s</span></span><br><span class="line">          <span class="comment">#[Optional] he factor by which the initial back off period is exponentially incremented</span></span><br><span class="line">          <span class="attr">backoffFactor:</span> <span class="number">2.0</span></span><br><span class="line">      <span class="comment">#[Optional] options for retrieving discovery info</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#[Optional] discovery info will be retrieved for these number of random targets</span></span><br><span class="line">        <span class="attr">maxTargets:</span> <span class="number">2</span></span><br><span class="line">        <span class="comment">#[Optional] retry options for retrieving discovery info</span></span><br><span class="line">        <span class="attr">retryOpts:</span></span><br><span class="line">          <span class="comment">#[Optional] number of retry attempts</span></span><br><span class="line">          <span class="attr">attempts:</span> <span class="number">4</span></span><br><span class="line">          <span class="comment">#[Optional] the back off interval for the first retry attempt</span></span><br><span class="line">          <span class="attr">initialBackoff:</span> <span class="string">500ms</span></span><br><span class="line">          <span class="comment">#[Optional] the maximum back off interval for any retry attempt</span></span><br><span class="line">          <span class="attr">maxBackoff:</span> <span class="string">5s</span></span><br><span class="line">          <span class="comment">#[Optional] he factor by which the initial back off period is exponentially incremented</span></span><br><span class="line">          <span class="attr">backoffFactor:</span> <span class="number">2.0</span></span><br><span class="line">      <span class="comment">#[Optional] options for the event service</span></span><br><span class="line">      <span class="attr">eventService:</span></span><br><span class="line">        <span class="comment"># [Optional] resolverStrategy specifies the peer resolver strategy to use when connecting to a peer</span></span><br><span class="line">        <span class="comment"># Possible values: [PreferOrg (default), MinBlockHeight, Balanced]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># PreferOrg:</span></span><br><span class="line">        <span class="comment">#   Determines which peers are suitable based on block height lag threshold, although will prefer the peers in the</span></span><br><span class="line">        <span class="comment">#   current org (as long as their block height is above a configured threshold). If none of the peers from the current org</span></span><br><span class="line">        <span class="comment">#   are suitable then a peer from another org is chosen.</span></span><br><span class="line">        <span class="comment"># MinBlockHeight:</span></span><br><span class="line">        <span class="comment">#   Chooses the best peer according to a block height lag threshold. The maximum block height of all peers is</span></span><br><span class="line">        <span class="comment">#   determined and the peers whose block heights are under the maximum height but above a provided "lag" threshold are load</span></span><br><span class="line">        <span class="comment">#   balanced. The other peers are not considered.</span></span><br><span class="line">        <span class="comment"># Balanced:</span></span><br><span class="line">        <span class="comment">#   Chooses peers using the configured balancer.</span></span><br><span class="line">        <span class="attr">resolverStrategy:</span> <span class="string">PreferOrg</span></span><br><span class="line">        <span class="comment"># [Optional] balancer is the balancer to use when choosing a peer to connect to</span></span><br><span class="line">        <span class="comment"># Possible values: [Random (default), RoundRobin]</span></span><br><span class="line">        <span class="attr">balancer:</span> <span class="string">Random</span></span><br><span class="line">        <span class="comment"># [Optional] blockHeightLagThreshold sets the block height lag threshold. This value is used for choosing a peer</span></span><br><span class="line">        <span class="comment"># to connect to. If a peer is lagging behind the most up-to-date peer by more than the given number of</span></span><br><span class="line">        <span class="comment"># blocks then it will be excluded from selection.</span></span><br><span class="line">        <span class="comment"># If set to 0 then only the most up-to-date peers are considered.</span></span><br><span class="line">        <span class="comment"># If set to -1 then all peers (regardless of block height) are considered for selection.</span></span><br><span class="line">        <span class="comment"># Default: 5</span></span><br><span class="line">        <span class="attr">blockHeightLagThreshold:</span> <span class="number">5</span></span><br><span class="line">        <span class="comment"># [Optional] reconnectBlockHeightLagThreshold - if &gt;0 then the event client will disconnect from the peer if the peer's</span></span><br><span class="line">        <span class="comment"># block height falls behind the specified number of blocks and will reconnect to a better performing peer.</span></span><br><span class="line">        <span class="comment"># If set to 0 then this feature is disabled.</span></span><br><span class="line">        <span class="comment"># Default: 10</span></span><br><span class="line">        <span class="comment"># NOTES:</span></span><br><span class="line">        <span class="comment">#   - peerMonitorPeriod must be &gt;0 to enable this feature</span></span><br><span class="line">        <span class="comment">#   - Setting this value too low may cause the event client to disconnect/reconnect too frequently, thereby</span></span><br><span class="line">        <span class="comment">#     affecting performance.</span></span><br><span class="line">        <span class="attr">reconnectBlockHeightLagThreshold:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># [Optional] peerMonitorPeriod is the period in which the connected peer is monitored to see if</span></span><br><span class="line">        <span class="comment"># the event client should disconnect from it and reconnect to another peer.</span></span><br><span class="line">        <span class="comment"># Default: 0 (disabled)</span></span><br><span class="line">        <span class="attr">peerMonitorPeriod:</span> <span class="string">5s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># list of participating organizations in this network</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="attr">Org1:</span></span><br><span class="line">    <span class="attr">mspid:</span> <span class="string">org1.kevin.kongyixueyuan.com</span></span><br><span class="line">    <span class="attr">cryptoPath:</span> <span class="string">peerOrganizations/org1.kevin.kongyixueyuan.com/users/&#123;userName&#125;@org1.kevin.kongyixueyuan.com/msp</span></span><br><span class="line">    <span class="attr">peers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># [Optional]. Certificate Authorities issue certificates for identification purposes in a Fabric based</span></span><br><span class="line">    <span class="comment"># network. Typically certificates provisioning is done in a separate process outside of the</span></span><br><span class="line">    <span class="comment"># runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for</span></span><br><span class="line">    <span class="comment"># dynamic certificate management (enroll, revoke, re-enroll). The following section is only for</span></span><br><span class="line">    <span class="comment"># Fabric-CA servers.</span></span><br><span class="line">    <span class="attr">certificateAuthorities:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># List of orderers to send transaction and channel create/update requests to. For the time</span></span><br><span class="line"><span class="comment"># being only one orderer is needed. If more than one is defined, which one get used by the</span></span><br><span class="line"><span class="comment"># SDK is implementation specific. Consult each SDK's documentation for its handling of orderers.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">orderers:</span></span><br><span class="line">  <span class="attr">orderer.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7050</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># these are standard properties defined by the gRPC library</span></span><br><span class="line">    <span class="comment"># they will be passed in as-is to gRPC client constructor</span></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/education/fixtures/crypto-config/ordererOrganizations/kevin.kongyixueyuan.com/tlsca/tlsca.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># List of peers to send various requests to, including endorsement, query</span></span><br><span class="line"><span class="comment"># and event listener registration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">peers:</span></span><br><span class="line">  <span class="attr">peer0.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="comment"># this URL is used to send endorsement and query requests</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7051</span></span><br><span class="line">    <span class="comment"># eventUrl is only needed when using eventhub (default is delivery service)</span></span><br><span class="line">    <span class="attr">eventUrl:</span> <span class="string">localhost:7053</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/education/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/tlsca/tlsca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="comment"># this URL is used to send endorsement and query requests</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">localhost:7151</span></span><br><span class="line">    <span class="comment"># eventUrl is only needed when using eventhub (default is delivery service)</span></span><br><span class="line">    <span class="attr">eventUrl:</span> <span class="string">localhost:7153</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">grpcOptions:</span></span><br><span class="line">      <span class="attr">ssl-target-name-override:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="comment"># These parameters should be set in coordination with the keepalive policy on the server,</span></span><br><span class="line">      <span class="comment"># as incompatible settings can result in closing of connection.</span></span><br><span class="line">      <span class="comment"># When duration of the 'keep-alive-time' is set to 0 or less the keep alive client parameters are disabled</span></span><br><span class="line">      <span class="attr">keep-alive-time:</span> <span class="string">0s</span></span><br><span class="line">      <span class="attr">keep-alive-timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">keep-alive-permit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># allow-insecure will be taken into consideration if address has no protocol defined, if true then grpc or else grpcs</span></span><br><span class="line">      <span class="attr">allow-insecure:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/education/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/tlsca/tlsca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fabric-CA is a special kind of Certificate Authority provided by Hyperledger Fabric which allows</span></span><br><span class="line"><span class="comment"># certificate management to be done via REST APIs. Application may choose to use a standard</span></span><br><span class="line"><span class="comment"># Certificate Authority instead of Fabric-CA, in which case this section would not be specified.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">certificateAuthorities:</span></span><br><span class="line">  <span class="attr">ca.org1.kevin.kongyixueyuan.com:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">    <span class="attr">tlsCACerts:</span></span><br><span class="line">      <span class="comment"># Certificate location absolute path</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">$&#123;GOPATH&#125;/src/github.com/kongyixueyuan.com/education/fixtures/crypto-config/peerOrganizations/org1.kevin.kongyixueyuan.com/ca/ca.org1.kevin.kongyixueyuan.com-cert.pem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fabric-CA supports dynamic user enrollment via REST APIs. A "root" user, a.k.a registrar, is</span></span><br><span class="line">    <span class="comment"># needed to enroll and invoke new users.</span></span><br><span class="line">    <span class="attr">registrar:</span></span><br><span class="line">      <span class="attr">enrollId:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">enrollSecret:</span> <span class="string">adminpw</span></span><br><span class="line">    <span class="comment"># [Optional] The optional name of the CA.</span></span><br><span class="line">    <span class="attr">caName:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entityMatchers:</span></span><br><span class="line">  <span class="attr">peer:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)peer0.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7051</span></span><br><span class="line">      <span class="attr">eventUrlSubstitutionExp:</span> <span class="string">localhost:7053</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">peer0.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)peer1.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7151</span></span><br><span class="line">      <span class="attr">eventUrlSubstitutionExp:</span> <span class="string">localhost:7153</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">peer1.org1.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)orderer.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">localhost:7050</span></span><br><span class="line">      <span class="attr">sslTargetOverrideUrlSubstitutionExp:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">orderer.kevin.kongyixueyuan.com</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">certificateAuthorities:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">(\w*)ca.org1.kevin.kongyixueyuan.com(\w*)</span></span><br><span class="line">      <span class="attr">urlSubstitutionExp:</span> <span class="string">http://localhost:7054</span></span><br><span class="line">      <span class="attr">mappedHost:</span> <span class="string">ca.org1.kevin.kongyixueyuan.com</span></span><br></pre></td></tr></table></figure><h3 id="13-2-2-声明结构体"><a href="#13-2-2-声明结构体" class="headerlink" title="13.2.2 声明结构体"></a>13.2.2 声明结构体</h3><p>在当前项目根目录中创建一个存放链码文件的 <code>chaincode</code> 目录，然后在该目录下创建一个 <code>eduStruct.go</code> 的文件并对其进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim chaincode/eduStruct.go</span></span><br></pre></td></tr></table></figure><p><code>eduStruct.go</code> 文件主要声明一个结构体，用于将多个数据包装成为一个对象，然后进行进一步的处理。该文件完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Education <span class="keyword">struct</span> &#123;</span><br><span class="line">    ObjectType    <span class="keyword">string</span>    <span class="string">`json:"docType"`</span></span><br><span class="line">    Name    <span class="keyword">string</span>    <span class="string">`json:"Name"`</span>        <span class="comment">// 姓名</span></span><br><span class="line">    Gender    <span class="keyword">string</span>    <span class="string">`json:"Gender"`</span>        <span class="comment">// 性别</span></span><br><span class="line">    Nation    <span class="keyword">string</span>    <span class="string">`json:"Nation"`</span>        <span class="comment">// 民族</span></span><br><span class="line">    EntityID    <span class="keyword">string</span>    <span class="string">`json:"EntityID"`</span>        <span class="comment">// 身份证号</span></span><br><span class="line">    Place    <span class="keyword">string</span>    <span class="string">`json:"Place"`</span>        <span class="comment">// 籍贯</span></span><br><span class="line">    BirthDay    <span class="keyword">string</span>    <span class="string">`json:"BirthDay"`</span>        <span class="comment">// 出生日期</span></span><br><span class="line"></span><br><span class="line">    EnrollDate    <span class="keyword">string</span>    <span class="string">`json:"EnrollDate"`</span>        <span class="comment">// 入学日期</span></span><br><span class="line">    GraduationDate    <span class="keyword">string</span>    <span class="string">`json:"GraduationDate"`</span>    <span class="comment">// 毕（结）业日期</span></span><br><span class="line">    SchoolName    <span class="keyword">string</span>    <span class="string">`json:"SchoolName"`</span>    <span class="comment">// 学校名称</span></span><br><span class="line">    Major    <span class="keyword">string</span>    <span class="string">`json:"Major"`</span>    <span class="comment">// 专业</span></span><br><span class="line">    QuaType    <span class="keyword">string</span>    <span class="string">`json:"QuaType"`</span>    <span class="comment">// 学历类别</span></span><br><span class="line">    Length    <span class="keyword">string</span>    <span class="string">`json:"Length"`</span>    <span class="comment">// 学制</span></span><br><span class="line">    Mode    <span class="keyword">string</span>    <span class="string">`json:"Mode"`</span>    <span class="comment">// 学习形式</span></span><br><span class="line">    Level    <span class="keyword">string</span>    <span class="string">`json:"Level"`</span>    <span class="comment">// 层次</span></span><br><span class="line">    Graduation    <span class="keyword">string</span>    <span class="string">`json:"Graduation"`</span>    <span class="comment">// 毕（结）业</span></span><br><span class="line">    CertNo    <span class="keyword">string</span>    <span class="string">`json:"CertNo"`</span>    <span class="comment">// 证书编号</span></span><br><span class="line"></span><br><span class="line">    Photo    <span class="keyword">string</span>    <span class="string">`json:"Photo"`</span>    <span class="comment">// 照片</span></span><br><span class="line"></span><br><span class="line">    Historys    []HistoryItem    <span class="comment">// 当前edu的历史记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HistoryItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    TxId    <span class="keyword">string</span></span><br><span class="line">    Education    Education</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-3-编写链码"><a href="#13-2-3-编写链码" class="headerlink" title="13.2.3 编写链码"></a>13.2.3 编写链码</h3><p>在 <code>chaincode</code> 目录下创建一个 <code>main.go</code> 的文件并对其进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim chaincode/main.go</span></span><br></pre></td></tr></table></figure><p><code>main.go</code> 文件作为链码的主文件，主要声明 <code>Init(stub shim.ChaincodeStubInterface)、Invoke(stub shim.ChaincodeStubInterface)</code> 函数，完成对链码初始化及调用的相关实现，完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EducationChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户意图</span></span><br><span class="line">    fun, args := stub.GetFunctionAndParameters()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fun == <span class="string">"addEdu"</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.addEdu(stub, args)        <span class="comment">// 添加信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"queryEduByCertNoAndName"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.queryEduByCertNoAndName(stub, args)        <span class="comment">// 根据证书编号及姓名查询信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"queryEduInfoByEntityID"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.queryEduInfoByEntityID(stub, args)    <span class="comment">// 根据身份证号码及姓名查询详情</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"updateEdu"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.updateEdu(stub, args)        <span class="comment">// 根据证书编号更新信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"delEdu"</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.delEdu(stub, args)    <span class="comment">// 根据证书编号删除信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Error(<span class="string">"指定的函数名称错误"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(EducationChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"启动EducationChaincode时发生错误: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>eduCC.go</code> 文件，该文件实现了使用链码相关的API对分类账本状态进行具体操作的各个函数：</p><ul><li><strong>PutEdu：</strong>实现将指定的对象序列化后保存至分类账本中</li><li><strong>GetEduInfo：</strong>根据指定的Key（身份证号码）查询对应的状态，反序列后将对象返回</li><li><strong>getEduByQueryString：</strong>根据指定的查询字符串从 <code>CouchDB</code> 中查询状态</li><li><strong>addEdu：</strong>接收对象并调用 <code>PutEdu</code> 函数实现保存状态的功能</li><li><strong>queryEduByCertNoAndName：</strong>根据指定的证书编号与姓名查询状态</li><li><strong>queryEduInfoByEntityID：</strong>根据指定的身份证号码（Key）查询状态</li><li><strong>updateEdu：</strong>实现对状态进行编辑功能</li><li><strong>delEdu：</strong>从分类账本中删除状态，此功能暂不提供</li></ul><p><code>eduCC.go</code> 文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DOC_TYPE = <span class="string">"eduObj"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存edu</span></span><br><span class="line"><span class="comment">// args: education</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutEdu</span><span class="params">(stub shim.ChaincodeStubInterface, edu Education)</span> <span class="params">([]<span class="keyword">byte</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    edu.ObjectType = DOC_TYPE</span><br><span class="line"></span><br><span class="line">    b, err := json.Marshal(edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存edu状态</span></span><br><span class="line">    err = stub.PutState(edu.EntityID, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据身份证号码查询信息状态</span></span><br><span class="line"><span class="comment">// args: entityID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEduInfo</span><span class="params">(stub shim.ChaincodeStubInterface, entityID <span class="keyword">string</span>)</span> <span class="params">(Education, <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> edu Education</span><br><span class="line">    <span class="comment">// 根据身份证号码查询信息状态</span></span><br><span class="line">    b, err := stub.GetState(entityID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edu, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edu, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对查询到的状态进行反序列化</span></span><br><span class="line">    err = json.Unmarshal(b, &amp;edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> edu, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> edu, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的查询字符串实现富查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getEduByQueryString</span><span class="params">(stub shim.ChaincodeStubInterface, queryString <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    resultsIterator, err := stub.GetQueryResult(queryString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span>  resultsIterator.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer is a JSON array containing QueryRecords</span></span><br><span class="line">    <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"></span><br><span class="line">    bArrayMemberAlreadyWritten := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> resultsIterator.HasNext() &#123;</span><br><span class="line">        queryResponse, err := resultsIterator.Next()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Add a comma before array members, suppress it for the first array member</span></span><br><span class="line">        <span class="keyword">if</span> bArrayMemberAlreadyWritten == <span class="literal">true</span> &#123;</span><br><span class="line">            buffer.WriteString(<span class="string">","</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Record is a JSON object, so we write as-is</span></span><br><span class="line">        buffer.WriteString(<span class="keyword">string</span>(queryResponse.Value))</span><br><span class="line">        bArrayMemberAlreadyWritten = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"- getQueryResultForQueryString queryResult:\n%s\n"</span>, buffer.String())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer.Bytes(), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加信息</span></span><br><span class="line"><span class="comment">// args: educationObject</span></span><br><span class="line"><span class="comment">// 身份证号为 key, Education 为 value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">addEdu</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> edu Education</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(args[<span class="number">0</span>]), &amp;edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"反序列化信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查重: 身份证号码必须唯一</span></span><br><span class="line">    _, exist := GetEduInfo(stub, edu.EntityID)</span><br><span class="line">    <span class="keyword">if</span> exist &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"要添加的身份证号码已存在"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, bl := PutEdu(stub, edu)</span><br><span class="line">    <span class="keyword">if</span> !bl &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"保存信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = stub.SetEvent(args[<span class="number">1</span>], []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"信息添加成功"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据证书编号及姓名查询信息</span></span><br><span class="line"><span class="comment">// args: CertNo, name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">queryEduByCertNoAndName</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    CertNo := args[<span class="number">0</span>]</span><br><span class="line">    name := args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼装CouchDB所需要的查询字符串(是标准的一个JSON串)</span></span><br><span class="line">    <span class="comment">// queryString := fmt.Sprintf("&#123;\"selector\":&#123;\"docType\":\"eduObj\", \"CertNo\":\"%s\"&#125;&#125;", CertNo)</span></span><br><span class="line">    queryString := fmt.Sprintf(<span class="string">"&#123;\"selector\":&#123;\"docType\":\"%s\", \"CertNo\":\"%s\", \"Name\":\"%s\"&#125;&#125;"</span>, DOC_TYPE, CertNo, name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line">    result, err := getEduByQueryString(stub, queryString)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据证书编号及姓名查询信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据指定的证书编号及姓名没有查询到相关的信息"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据身份证号码查询详情（溯源）</span></span><br><span class="line"><span class="comment">// args: entityID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">queryEduInfoByEntityID</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据身份证号码查询edu状态</span></span><br><span class="line">    b, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据身份证号码查询信息失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据身份证号码没有查询到相关的信息"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对查询到的状态进行反序列化</span></span><br><span class="line">    <span class="keyword">var</span> edu Education</span><br><span class="line">    err = json.Unmarshal(b, &amp;edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  shim.Error(<span class="string">"反序列化edu信息失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取历史变更数据</span></span><br><span class="line">    iterator, err := stub.GetHistoryForKey(edu.EntityID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据指定的身份证号码查询对应的历史变更数据失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> iterator.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代处理</span></span><br><span class="line">    <span class="keyword">var</span> historys []HistoryItem</span><br><span class="line">    <span class="keyword">var</span> hisEdu Education</span><br><span class="line">    <span class="keyword">for</span> iterator.HasNext() &#123;</span><br><span class="line">        hisData, err := iterator.Next()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shim.Error(<span class="string">"获取edu的历史变更数据失败"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> historyItem HistoryItem</span><br><span class="line">        historyItem.TxId = hisData.TxId</span><br><span class="line">        json.Unmarshal(hisData.Value, &amp;hisEdu)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hisData.Value == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> empty Education</span><br><span class="line">            historyItem.Education = empty</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            historyItem.Education = hisEdu</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        historys = <span class="built_in">append</span>(historys, historyItem)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edu.Historys = historys</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    result, err := json.Marshal(edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"序列化edu信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据身份证号更新信息</span></span><br><span class="line"><span class="comment">// args: educationObject</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">updateEdu</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info Education</span><br><span class="line">    err := json.Unmarshal([]<span class="keyword">byte</span>(args[<span class="number">0</span>]), &amp;info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  shim.Error(<span class="string">"反序列化edu信息失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据身份证号码查询信息</span></span><br><span class="line">    result, bl := GetEduInfo(stub, info.EntityID)</span><br><span class="line">    <span class="keyword">if</span> !bl&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据身份证号码查询信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.EnrollDate = info.EnrollDate</span><br><span class="line">    result.GraduationDate = info.GraduationDate</span><br><span class="line">    result.SchoolName = info.SchoolName</span><br><span class="line">    result.Major = info.Major</span><br><span class="line">    result.QuaType = info.QuaType</span><br><span class="line">    result.Length = info.Length</span><br><span class="line">    result.Mode = info.Mode</span><br><span class="line">    result.Level = info.Level</span><br><span class="line">    result.Graduation = info.Graduation</span><br><span class="line">    result.CertNo = info.CertNo;</span><br><span class="line"></span><br><span class="line">    _, bl = PutEdu(stub, result)</span><br><span class="line">    <span class="keyword">if</span> !bl &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"保存信息信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = stub.SetEvent(args[<span class="number">1</span>], []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"信息更新成功"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据身份证号删除信息（暂不对外提供）</span></span><br><span class="line"><span class="comment">// args: entityID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *EducationChaincode)</span> <span class="title">delEdu</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*var edu Education</span></span><br><span class="line"><span class="comment">    result, bl := GetEduInfo(stub, info.EntityID)</span></span><br><span class="line"><span class="comment">    err := json.Unmarshal(result, &amp;edu)</span></span><br><span class="line"><span class="comment">    if err != nil &#123;</span></span><br><span class="line"><span class="comment">        return shim.Error("反序列化信息时发生错误")</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    err := stub.DelState(args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"删除信息时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = stub.SetEvent(args[<span class="number">1</span>], []<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"信息删除成功"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链码编写好以后，我们需要使用 Fabric-SDK-Go 提供的相关 API 来实现对链码的安装及实例化操作，而无需在命令提示符中输入烦锁的相关操作命令。接下来依次完成如下步骤：</p><ul><li>安装依赖：相关内容及代码请参见第十一章第二节中的内容。</li><li>链码自动布署：相关内容代码请参见第十一章第四节中的内容</li></ul><h3 id="业务层实现"><a href="#业务层实现" class="headerlink" title="业务层实现"></a>业务层实现</h3><h3 id="13-3-1-事件处理"><a href="#13-3-1-事件处理" class="headerlink" title="13.3.1 事件处理"></a>13.3.1 事件处理</h3><p>在项目根目录下创建一个 <code>service</code> 目录作为业务层，在业务层中，我们使用 <code>Fabric-SDK-Go</code> 提供的接口对象调用相应的 API 以实现对链码的访问，最终实现对分类账本中的状态进行操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir service</span></span><br></pre></td></tr></table></figure><p>在 <code>service</code> 目录下创建 <code>domain.go</code> 文件并进行编辑， 声明一个结构体及对事件相关而封装的源代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/domain.go</span></span><br></pre></td></tr></table></figure><p><code>domain.go</code> 文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/fab"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Education <span class="keyword">struct</span> &#123;</span><br><span class="line">    ObjectType    <span class="keyword">string</span>    <span class="string">`json:"docType"`</span></span><br><span class="line">    Name    <span class="keyword">string</span>    <span class="string">`json:"Name"`</span>        <span class="comment">// 姓名</span></span><br><span class="line">    Gender    <span class="keyword">string</span>    <span class="string">`json:"Gender"`</span>        <span class="comment">// 性别</span></span><br><span class="line">    Nation    <span class="keyword">string</span>    <span class="string">`json:"Nation"`</span>        <span class="comment">// 民族</span></span><br><span class="line">    EntityID    <span class="keyword">string</span>    <span class="string">`json:"EntityID"`</span>        <span class="comment">// 身份证号</span></span><br><span class="line">    Place    <span class="keyword">string</span>    <span class="string">`json:"Place"`</span>        <span class="comment">// 籍贯</span></span><br><span class="line">    BirthDay    <span class="keyword">string</span>    <span class="string">`json:"BirthDay"`</span>        <span class="comment">// 出生日期</span></span><br><span class="line">    EnrollDate    <span class="keyword">string</span>    <span class="string">`json:"EnrollDate"`</span>        <span class="comment">// 入学日期</span></span><br><span class="line">    GraduationDate    <span class="keyword">string</span>    <span class="string">`json:"GraduationDate"`</span>    <span class="comment">// 毕（结）业日期</span></span><br><span class="line">    SchoolName    <span class="keyword">string</span>    <span class="string">`json:"SchoolName"`</span>    <span class="comment">// 学校名称</span></span><br><span class="line">    Major    <span class="keyword">string</span>    <span class="string">`json:"Major"`</span>    <span class="comment">// 专业</span></span><br><span class="line">    QuaType    <span class="keyword">string</span>    <span class="string">`json:"QuaType"`</span>    <span class="comment">// 学历类别</span></span><br><span class="line">    Length    <span class="keyword">string</span>    <span class="string">`json:"Length"`</span>    <span class="comment">// 学制</span></span><br><span class="line">    Mode    <span class="keyword">string</span>    <span class="string">`json:"Mode"`</span>    <span class="comment">// 学习形式</span></span><br><span class="line">    Level    <span class="keyword">string</span>    <span class="string">`json:"Level"`</span>    <span class="comment">// 层次</span></span><br><span class="line">    Graduation    <span class="keyword">string</span>    <span class="string">`json:"Graduation"`</span>    <span class="comment">// 毕（结）业</span></span><br><span class="line">    CertNo    <span class="keyword">string</span>    <span class="string">`json:"CertNo"`</span>    <span class="comment">// 证书编号</span></span><br><span class="line"></span><br><span class="line">    Photo    <span class="keyword">string</span>    <span class="string">`json:"Photo"`</span>    <span class="comment">// 照片</span></span><br><span class="line"></span><br><span class="line">    Historys    []HistoryItem    <span class="comment">// 当前edu的历史记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HistoryItem <span class="keyword">struct</span> &#123;</span><br><span class="line">    TxId    <span class="keyword">string</span></span><br><span class="line">    Education    Education</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceSetup <span class="keyword">struct</span> &#123;</span><br><span class="line">    ChaincodeID    <span class="keyword">string</span></span><br><span class="line">    Client    *channel.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">regitserEvent</span><span class="params">(client *channel.Client, chaincodeID, eventID <span class="keyword">string</span>)</span> <span class="params">(fab.Registration, &lt;-<span class="keyword">chan</span> *fab.CCEvent)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    reg, notifier, err := client.RegisterChaincodeEvent(chaincodeID, eventID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"注册链码事件失败: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reg, notifier</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eventResult</span><span class="params">(notifier &lt;-<span class="keyword">chan</span> *fab.CCEvent, eventID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ccEvent := &lt;-notifier:</span><br><span class="line">        fmt.Printf(<span class="string">"接收到链码事件: %v\n"</span>, ccEvent)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">20</span>):</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"不能根据指定的事件ID接收到相应的链码事件(%s)"</span>, eventID)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-3-2-业务层调用链码实现添加状态"><a href="#13-3-2-业务层调用链码实现添加状态" class="headerlink" title="13.3.2 业务层调用链码实现添加状态"></a>13.3.2 业务层调用链码实现添加状态</h3><p>在 <code>service</code> 目录下创建 <code>eduService.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/eduService.go</span></span><br></pre></td></tr></table></figure><p>在 <code>eduService.go</code> 文件中编写内容如下，通过一个 <code>SaveEdu</code> 函数实现链码的调用，向分类账本中添加状态的功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment">  QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">SaveEdu</span><span class="params">(edu Education)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    eventID := <span class="string">"eventAddEdu"</span></span><br><span class="line">    reg, notifier := regitserEvent(t.Client, t.ChaincodeID, eventID)</span><br><span class="line">    <span class="keyword">defer</span> t.Client.UnregisterChaincodeEvent(reg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将edu对象序列化成为字节数组</span></span><br><span class="line">    b, err := json.Marshal(edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"指定的edu对象序列化时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"addEdu"</span>, Args: [][]<span class="keyword">byte</span>&#123;b, []<span class="keyword">byte</span>(eventID)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Execute(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = eventResult(notifier, eventID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(respone.TransactionID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试添加状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p><code>main.go</code> 中创建两个 <code>edu</code> 个对象，并调用 <code>SaveEdu</code> 函数，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  author: hanxiaodong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    [......]</span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/education/service"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[......]</span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">    serviceSetup := service.ServiceSetup&#123;</span><br><span class="line">        ChaincodeID:EduCC,</span><br><span class="line">        Client:channelClient,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edu := service.Education&#123;</span><br><span class="line">        Name: <span class="string">"张三"</span>,</span><br><span class="line">        Gender: <span class="string">"男"</span>,</span><br><span class="line">        Nation: <span class="string">"汉"</span>,</span><br><span class="line">        EntityID: <span class="string">"101"</span>,</span><br><span class="line">        Place: <span class="string">"北京"</span>,</span><br><span class="line">        BirthDay: <span class="string">"1991年01月01日"</span>,</span><br><span class="line">        EnrollDate: <span class="string">"2009年9月"</span>,</span><br><span class="line">        GraduationDate: <span class="string">"2013年7月"</span>,</span><br><span class="line">        SchoolName: <span class="string">"中国政法大学"</span>,</span><br><span class="line">        Major: <span class="string">"社会学"</span>,</span><br><span class="line">        QuaType: <span class="string">"普通"</span>,</span><br><span class="line">        Length: <span class="string">"四年"</span>,</span><br><span class="line">        Mode: <span class="string">"普通全日制"</span>,</span><br><span class="line">        Level: <span class="string">"本科"</span>,</span><br><span class="line">        Graduation: <span class="string">"毕业"</span>,</span><br><span class="line">        CertNo: <span class="string">"111"</span>,</span><br><span class="line">        Photo: <span class="string">"/static/phone/11.png"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edu2 := service.Education&#123;</span><br><span class="line">        Name: <span class="string">"李四"</span>,</span><br><span class="line">        Gender: <span class="string">"男"</span>,</span><br><span class="line">        Nation: <span class="string">"汉"</span>,</span><br><span class="line">        EntityID: <span class="string">"102"</span>,</span><br><span class="line">        Place: <span class="string">"上海"</span>,</span><br><span class="line">        BirthDay: <span class="string">"1992年02月01日"</span>,</span><br><span class="line">        EnrollDate: <span class="string">"2010年9月"</span>,</span><br><span class="line">        GraduationDate: <span class="string">"2014年7月"</span>,</span><br><span class="line">        SchoolName: <span class="string">"中国人民大学"</span>,</span><br><span class="line">        Major: <span class="string">"行政管理"</span>,</span><br><span class="line">        QuaType: <span class="string">"普通"</span>,</span><br><span class="line">        Length: <span class="string">"四年"</span>,</span><br><span class="line">        Mode: <span class="string">"普通全日制"</span>,</span><br><span class="line">        Level: <span class="string">"本科"</span>,</span><br><span class="line">        Graduation: <span class="string">"毕业"</span>,</span><br><span class="line">        CertNo: <span class="string">"222"</span>,</span><br><span class="line">        Photo: <span class="string">"/static/phone/22.png"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg, err := serviceSetup.SaveEdu(edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"信息发布成功, 交易编号为: "</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg, err = serviceSetup.SaveEdu(edu2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"信息发布成功, 交易编号为: "</span> + msg)</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/saveedu.png/mark" alt="测试添加状态"></p><h3 id="13-3-3-调用链码实现根据证书编号与名称查询状态"><a href="#13-3-3-调用链码实现根据证书编号与名称查询状态" class="headerlink" title="13.3.3 调用链码实现根据证书编号与名称查询状态"></a>13.3.3 调用链码实现根据证书编号与名称查询状态</h3><p>通过上面的 <code>SaveEdu(edu Education)</code> 函数，实现了向分类账本中添加状态，那么我们还需要实现从该分类账本中根据指定的条件查询出相应的状态，编辑 <code>service/eduService.go</code> 文件，向该文件中添加实现根据证书编号与姓名查询状态的相应代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/eduService.go</span></span><br></pre></td></tr></table></figure><p>定义一个 <code>FindEduByCertNoAndName</code> 函数，接收两个字符串类型的参数，分别代表证书编号与姓名，该函数实现通过调用链码而实现查询状态的功能，该函数完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">FindEduByCertNoAndName</span><span class="params">(certNo, name <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"queryEduByCertNoAndName"</span>, Args: [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(certNo), []<span class="keyword">byte</span>(name)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Query(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;<span class="number">0x00</span>&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> respone.Payload, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试根据证书编号与名称查询状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据证书编号与名称查询信息</span></span><br><span class="line">    result, err := serviceSetup.FindEduByCertNoAndName(<span class="string">"222"</span>,<span class="string">"李四"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> edu service.Education</span><br><span class="line">        json.Unmarshal(result, &amp;edu)</span><br><span class="line">        fmt.Println(<span class="string">"根据证书编号与姓名查询信息成功："</span>)</span><br><span class="line">        fmt.Println(edu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/findEduByCertNoAndName.png/mark" alt="证书编号查询测试"></p><h3 id="13-3-4-调用链码实现根据身份证号码查询状态"><a href="#13-3-4-调用链码实现根据身份证号码查询状态" class="headerlink" title="13.3.4 调用链码实现根据身份证号码查询状态"></a>13.3.4 调用链码实现根据身份证号码查询状态</h3><p>通过上面的 <code>FindEduByCertNoAndName(certNo, name string)</code> 函数，实现从该分类账本中根据指定的证书编号与姓名查询出相应的状态，下面我们来实现根据身份证号码查询状态的功能，编辑 <code>service/eduService.go</code> 文件，向该文件中添加实现根据 key 查询状态的相应代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/eduService.go</span></span><br></pre></td></tr></table></figure><p>定义一个 <code>FindEduInfoByEntityID</code> 函数，接收一个字符串类型的参数，代表身份证号码（key），该函数实现通过调用链码而实现查询状态的功能，该函数完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">FindEduInfoByEntityID</span><span class="params">(entityID <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"queryEduInfoByEntityID"</span>, Args: [][]<span class="keyword">byte</span>&#123;[]<span class="keyword">byte</span>(entityID)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Query(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;<span class="number">0x00</span>&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> respone.Payload, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试根据身份证号码查询状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据身份证号码查询信息</span></span><br><span class="line">    result, err = serviceSetup.FindEduInfoByEntityID(<span class="string">"101"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> edu service.Education</span><br><span class="line">        json.Unmarshal(result, &amp;edu)</span><br><span class="line">        fmt.Println(<span class="string">"根据身份证号码查询信息成功："</span>)</span><br><span class="line">        fmt.Println(edu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/findEduInfoByEntityID.png/mark" alt="身份证号码查询测试"></p><h3 id="13-3-5-调用链码实现修改-添加信息状态"><a href="#13-3-5-调用链码实现修改-添加信息状态" class="headerlink" title="13.3.5 调用链码实现修改/添加信息状态"></a>13.3.5 调用链码实现修改/添加信息状态</h3><p>在一些情况下，有些人才会利用工作的业余时间进修，从而提升学历层次，我们必须要考虑到这种情况，所以需要应用程序实现对已有人员的信息进行编辑的功能；但是编辑并不能将之前的学历信息删除，而是在保留之前状态的基础之上添加新的状态，区块链技术很好的帮我们解决了这个问题。编辑 <code>service/eduService.go</code> 文件，向该文件中添加修改已有状态的相关代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim service/eduService.go</span></span><br></pre></td></tr></table></figure><p>定义一个 <code>ModifyEdu</code> 函数，接收一个 <code>Education</code> 类型的对象，该函数实现通过调用链码而实现对已存在的状态进行修改（添加新信息）的功能，该函数完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ServiceSetup)</span> <span class="title">ModifyEdu</span><span class="params">(edu Education)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    eventID := <span class="string">"eventModifyEdu"</span></span><br><span class="line">    reg, notifier := regitserEvent(t.Client, t.ChaincodeID, eventID)</span><br><span class="line">    <span class="keyword">defer</span> t.Client.UnregisterChaincodeEvent(reg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将edu对象序列化成为字节数组</span></span><br><span class="line">    b, err := json.Marshal(edu)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"指定的edu对象序列化时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req := channel.Request&#123;ChaincodeID: t.ChaincodeID, Fcn: <span class="string">"updateEdu"</span>, Args: [][]<span class="keyword">byte</span>&#123;b, []<span class="keyword">byte</span>(eventID)&#125;&#125;</span><br><span class="line">    respone, err := t.Client.Execute(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = eventResult(notifier, eventID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(respone.TransactionID), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试修改状态</strong></p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改/添加信息</span></span><br><span class="line">    info := service.Education&#123;</span><br><span class="line">        Name: <span class="string">"张三"</span>,</span><br><span class="line">        Gender: <span class="string">"男"</span>,</span><br><span class="line">        Nation: <span class="string">"汉"</span>,</span><br><span class="line">        EntityID: <span class="string">"101"</span>,</span><br><span class="line">        Place: <span class="string">"北京"</span>,</span><br><span class="line">        BirthDay: <span class="string">"1991年01月01日"</span>,</span><br><span class="line">        EnrollDate: <span class="string">"2013年9月"</span>,</span><br><span class="line">        GraduationDate: <span class="string">"2015年7月"</span>,</span><br><span class="line">        SchoolName: <span class="string">"中国政法大学"</span>,</span><br><span class="line">        Major: <span class="string">"社会学"</span>,</span><br><span class="line">        QuaType: <span class="string">"普通"</span>,</span><br><span class="line">        Length: <span class="string">"两年"</span>,</span><br><span class="line">        Mode: <span class="string">"普通全日制"</span>,</span><br><span class="line">        Level: <span class="string">"研究生"</span>,</span><br><span class="line">        Graduation: <span class="string">"毕业"</span>,</span><br><span class="line">        CertNo: <span class="string">"333"</span>,</span><br><span class="line">        Photo: <span class="string">"/static/phone/11.png"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    msg, err = serviceSetup.ModifyEdu(info)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"信息操作成功, 交易编号为: "</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/modifyEdu.png/mark" alt="修改信息测试"></p><p><strong>查看修改之后的状态（根据身份证号码）</strong></p><p>状态被修改之后，我们为了确认是否真正修改成功，所以需要调用已经编写好的 <code>FindEduInfoByEntityID(entityID string)</code> 函数实现查询详情的功能。</p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据身份证号码查询信息</span></span><br><span class="line">    result, err = serviceSetup.FindEduInfoByEntityID(<span class="string">"101"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> edu service.Education</span><br><span class="line">        json.Unmarshal(result, &amp;edu)</span><br><span class="line">        fmt.Println(<span class="string">"根据身份证号码查询信息成功："</span>)</span><br><span class="line">        fmt.Println(edu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/update_findEduInfoByEntityID.png/mark" alt="修改信息测试"></p><p>从终端的输出结果中可以看到详情信息已从分类账本中被成功查询，接下来我们使用根据证书编号与姓名查询修改之后的信息，看看是否正确</p><p><strong>查看修改之后的最新状态（根据证书编号与姓名）</strong></p><p>状态被修改之后，我们为了确认是否真正修改成功，所以需要调用已经编写好的 <code>FindEduInfoByEntityID(entityID string)</code> 函数实现查询详情的功能。</p><p>编辑 <code>main.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>在 <code>main.go</code> 文件中添加调用代码如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[......]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据证书编号与名称查询信息</span></span><br><span class="line">    result, err = serviceSetup.FindEduByCertNoAndName(<span class="string">"333"</span>,<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> edu service.Education</span><br><span class="line">        json.Unmarshal(result, &amp;edu)</span><br><span class="line">        fmt.Println(<span class="string">"根据证书编号与姓名查询信息成功："</span>)</span><br><span class="line">        fmt.Println(edu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//===========================================//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>make</code> 命令运行应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>执行后如下图所示：</p><p><img src="http://image.chaindesk.cn/update_findEduByCertNoAndName.png/mark" alt="修改信息测试"></p><h3 id="控制层实现"><a href="#控制层实现" class="headerlink" title="控制层实现"></a>控制层实现</h3><h3 id="13-4-1-设置系统用户"><a href="#13-4-1-设置系统用户" class="headerlink" title="13.4.1 设置系统用户"></a>13.4.1 设置系统用户</h3><p>通过业务层已经实现了利用 <code>fabric-sdk-go</code> 调用链码查询或操作分类账本状态，接下来，我们开始实现Web应用层，应用层将其分为两个部分，</p><ul><li><strong>控制层</strong></li><li><strong>视图层</strong></li></ul><p>在项目根目录下新创建一个名为 <code>web</code> 的目录，用来存放Web应用层的所有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/controller</span></span><br></pre></td></tr></table></figure><p>在 <code>web</code> 目录下创建 <code>controller</code> 子目录，在该目录下创建 <code>userInfo.go</code> 、 <code>controllerResponse.go</code> 与 <code>controllerHandler.go</code> 三个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/userInfo.go</span></span><br></pre></td></tr></table></figure><p><code>userInfo.go</code> 用来模拟RDB，保存系统用户信息，作为用户登录时核对用户信息，当然，这部分大家可以使用 <code>MySQL</code> 或其它数据库来实现。</p><p><code>userInfo.go</code> 完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/kongyixueyuan.com/education/service"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Application <span class="keyword">struct</span> &#123;</span><br><span class="line">    Setup *service.ServiceSetup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    LoginName    <span class="keyword">string</span></span><br><span class="line">    Password    <span class="keyword">string</span></span><br><span class="line">    IsAdmin    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    admin := User&#123;LoginName:<span class="string">"Hanxiaodong"</span>, Password:<span class="string">"123456"</span>, IsAdmin:<span class="string">"T"</span>&#125;</span><br><span class="line">    alice := User&#123;LoginName:<span class="string">"ChainDesk"</span>, Password:<span class="string">"123456"</span>, IsAdmin:<span class="string">"T"</span>&#125;</span><br><span class="line">    bob := User&#123;LoginName:<span class="string">"alice"</span>, Password:<span class="string">"123456"</span>, IsAdmin:<span class="string">"F"</span>&#125;</span><br><span class="line">    jack := User&#123;LoginName:<span class="string">"bob"</span>, Password:<span class="string">"123456"</span>, IsAdmin:<span class="string">"F"</span>&#125;</span><br><span class="line"></span><br><span class="line">    users = <span class="built_in">append</span>(users, admin)</span><br><span class="line">    users = <span class="built_in">append</span>(users, alice)</span><br><span class="line">    users = <span class="built_in">append</span>(users, bob)</span><br><span class="line">    users = <span class="built_in">append</span>(users, jack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAdmin</span><span class="params">(cuser User)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cuser.IsAdmin == <span class="string">"T"</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-2-处理响应"><a href="#13-4-2-处理响应" class="headerlink" title="13.4.2 处理响应"></a>13.4.2 处理响应</h3><p>创建 <code>controllerResponse.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/controllerResponse.go</span></span><br></pre></td></tr></table></figure><p><code>controllerResponse.go</code> 主要实现对用户请求的响应，将响应结果返回给客户端浏览器。文件完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowView</span><span class="params">(w http.ResponseWriter, r *http.Request, templateName <span class="keyword">string</span>, data <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定视图所在路径</span></span><br><span class="line">    pagePath := filepath.Join(<span class="string">"web"</span>, <span class="string">"tpl"</span>, templateName)</span><br><span class="line"></span><br><span class="line">    resultTemplate, err := template.ParseFiles(pagePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"创建模板实例错误: %v"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = resultTemplate.Execute(w, data)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"在模板中融合数据时发生错误: %v"</span>, err)</span><br><span class="line">        <span class="comment">//fmt.Fprintf(w, "显示在客户端浏览器中的错误信息")</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-3-处理请求"><a href="#13-4-3-处理请求" class="headerlink" title="13.4.3 处理请求"></a>13.4.3 处理请求</h3><p>创建 <code>controllerHandler.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/controllerHandler.go</span></span><br></pre></td></tr></table></figure><p><code>controllerHandler.go</code> 文件主要实现接收用户请求，并根据不同的用户请求调用业务层不同的函数，实现对分类账本的访问。其中需要声明并实现的函数：</p><p>文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/education/service"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cuser User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">LoginView</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    ShowView(w, r, <span class="string">"login.html"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">Index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    ShowView(w, r, <span class="string">"index.html"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">Help</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        CurrentUser User</span><br><span class="line">    &#125;&#123;</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">    &#125;</span><br><span class="line">    ShowView(w, r, <span class="string">"help.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">Login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    loginName := r.FormValue(<span class="string">"loginName"</span>)</span><br><span class="line">    password := r.FormValue(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> user.LoginName == loginName &amp;&amp; user.Password == password &#123;</span><br><span class="line">            cuser = user</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag &#123;</span><br><span class="line">        <span class="comment">// 登录成功</span></span><br><span class="line">        ShowView(w, r, <span class="string">"index.html"</span>, data)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 登录失败</span></span><br><span class="line">        data.Flag = <span class="literal">true</span></span><br><span class="line">        data.CurrentUser.LoginName = loginName</span><br><span class="line">        ShowView(w, r, <span class="string">"login.html"</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">LoginOut</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    cuser = User&#123;&#125;</span><br><span class="line">    ShowView(w, r, <span class="string">"login.html"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示添加信息页面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">AddEduShow</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ShowView(w, r, <span class="string">"addEdu.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">AddEdu</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    edu := service.Education&#123;</span><br><span class="line">        Name:r.FormValue(<span class="string">"name"</span>),</span><br><span class="line">        Gender:r.FormValue(<span class="string">"gender"</span>),</span><br><span class="line">        Nation:r.FormValue(<span class="string">"nation"</span>),</span><br><span class="line">        EntityID:r.FormValue(<span class="string">"entityID"</span>),</span><br><span class="line">        Place:r.FormValue(<span class="string">"place"</span>),</span><br><span class="line">        BirthDay:r.FormValue(<span class="string">"birthDay"</span>),</span><br><span class="line">        EnrollDate:r.FormValue(<span class="string">"enrollDate"</span>),</span><br><span class="line">        GraduationDate:r.FormValue(<span class="string">"graduationDate"</span>),</span><br><span class="line">        SchoolName:r.FormValue(<span class="string">"schoolName"</span>),</span><br><span class="line">        Major:r.FormValue(<span class="string">"major"</span>),</span><br><span class="line">        QuaType:r.FormValue(<span class="string">"quaType"</span>),</span><br><span class="line">        Length:r.FormValue(<span class="string">"length"</span>),</span><br><span class="line">        Mode:r.FormValue(<span class="string">"mode"</span>),</span><br><span class="line">        Level:r.FormValue(<span class="string">"level"</span>),</span><br><span class="line">        Graduation:r.FormValue(<span class="string">"graduation"</span>),</span><br><span class="line">        CertNo:r.FormValue(<span class="string">"certNo"</span>),</span><br><span class="line">        Photo:r.FormValue(<span class="string">"photo"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Setup.SaveEdu(edu)</span><br><span class="line"></span><br><span class="line">    r.Form.Set(<span class="string">"certNo"</span>, edu.CertNo)</span><br><span class="line">    r.Form.Set(<span class="string">"name"</span>, edu.Name)</span><br><span class="line">    app.FindCertByNoAndName(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">QueryPage</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ShowView(w, r, <span class="string">"query.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据证书编号与姓名查询信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">FindCertByNoAndName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    certNo := r.FormValue(<span class="string">"certNo"</span>)</span><br><span class="line">    name := r.FormValue(<span class="string">"name"</span>)</span><br><span class="line">    result, err := app.Setup.FindEduByCertNoAndName(certNo, name)</span><br><span class="line">    <span class="keyword">var</span> edu = service.Education&#123;&#125;</span><br><span class="line">    json.Unmarshal(result, &amp;edu)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"根据证书编号与姓名查询信息成功："</span>)</span><br><span class="line">    fmt.Println(edu)</span><br><span class="line"></span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        Edu service.Education</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">        History <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        Edu:edu,</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">        History:<span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        data.Msg = err.Error()</span><br><span class="line">        data.Flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowView(w, r, <span class="string">"queryResult.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">QueryPage2</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ShowView(w, r, <span class="string">"query2.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据身份证号码查询信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">FindByID</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    entityID := r.FormValue(<span class="string">"entityID"</span>)</span><br><span class="line">    result, err := app.Setup.FindEduInfoByEntityID(entityID)</span><br><span class="line">    <span class="keyword">var</span> edu = service.Education&#123;&#125;</span><br><span class="line">    json.Unmarshal(result, &amp;edu)</span><br><span class="line"></span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        Edu service.Education</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">        History <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        Edu:edu,</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">        Flag:<span class="literal">false</span>,</span><br><span class="line">        History:<span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        data.Msg = err.Error()</span><br><span class="line">        data.Flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowView(w, r, <span class="string">"queryResult.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改/添加新信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">ModifyShow</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 根据证书编号与姓名查询信息</span></span><br><span class="line">    certNo := r.FormValue(<span class="string">"certNo"</span>)</span><br><span class="line">    name := r.FormValue(<span class="string">"name"</span>)</span><br><span class="line">    result, err := app.Setup.FindEduByCertNoAndName(certNo, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> edu = service.Education&#123;&#125;</span><br><span class="line">    json.Unmarshal(result, &amp;edu)</span><br><span class="line"></span><br><span class="line">    data := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        Edu service.Education</span><br><span class="line">        CurrentUser User</span><br><span class="line">        Msg <span class="keyword">string</span></span><br><span class="line">        Flag <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        Edu:edu,</span><br><span class="line">        CurrentUser:cuser,</span><br><span class="line">        Flag:<span class="literal">true</span>,</span><br><span class="line">        Msg:<span class="string">""</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        data.Msg = err.Error()</span><br><span class="line">        data.Flag = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowView(w, r, <span class="string">"modify.html"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改/添加新信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">Modify</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    edu := service.Education&#123;</span><br><span class="line">        Name:r.FormValue(<span class="string">"name"</span>),</span><br><span class="line">        Gender:r.FormValue(<span class="string">"gender"</span>),</span><br><span class="line">        Nation:r.FormValue(<span class="string">"nation"</span>),</span><br><span class="line">        EntityID:r.FormValue(<span class="string">"entityID"</span>),</span><br><span class="line">        Place:r.FormValue(<span class="string">"place"</span>),</span><br><span class="line">        BirthDay:r.FormValue(<span class="string">"birthDay"</span>),</span><br><span class="line">        EnrollDate:r.FormValue(<span class="string">"enrollDate"</span>),</span><br><span class="line">        GraduationDate:r.FormValue(<span class="string">"graduationDate"</span>),</span><br><span class="line">        SchoolName:r.FormValue(<span class="string">"schoolName"</span>),</span><br><span class="line">        Major:r.FormValue(<span class="string">"major"</span>),</span><br><span class="line">        QuaType:r.FormValue(<span class="string">"quaType"</span>),</span><br><span class="line">        Length:r.FormValue(<span class="string">"length"</span>),</span><br><span class="line">        Mode:r.FormValue(<span class="string">"mode"</span>),</span><br><span class="line">        Level:r.FormValue(<span class="string">"level"</span>),</span><br><span class="line">        Graduation:r.FormValue(<span class="string">"graduation"</span>),</span><br><span class="line">        CertNo:r.FormValue(<span class="string">"certNo"</span>),</span><br><span class="line">        Photo:r.FormValue(<span class="string">"photo"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Setup.ModifyEdu(edu)</span><br><span class="line"></span><br><span class="line">    r.Form.Set(<span class="string">"entityID"</span>, edu.EntityID)</span><br><span class="line">    app.FindByID(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示：用户在做一些管理操作时需要验证其它是否有相应的操作权限，需要另外进行设计。</p></blockquote><h3 id="13-4-4-指定路由"><a href="#13-4-4-指定路由" class="headerlink" title="13.4.4 指定路由"></a>13.4.4 指定路由</h3><p>在 <code>web</code> 目录下创建一个 <code>webServer.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/webServer.go</span></span><br></pre></td></tr></table></figure><p>该文件主要声明用户请求的路由信息，并且指定 Web 服务的启动信息。文件完整内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/education/web/controller"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Web服务并指定路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WebStart</span><span class="params">(app controller.Application)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    fs:= http.FileServer(http.Dir(<span class="string">"web/static"</span>))</span><br><span class="line">    http.Handle(<span class="string">"/static/"</span>, http.StripPrefix(<span class="string">"/static/"</span>, fs))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定路由信息(匹配请求)</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, app.LoginView)</span><br><span class="line">    http.HandleFunc(<span class="string">"/login"</span>, app.Login)</span><br><span class="line">    http.HandleFunc(<span class="string">"/loginout"</span>, app.LoginOut)</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/index"</span>, app.Index)</span><br><span class="line">    http.HandleFunc(<span class="string">"/help"</span>, app.Help)</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/addEduInfo"</span>, app.AddEduShow)    <span class="comment">// 显示添加信息页面</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/addEdu"</span>, app.AddEdu)    <span class="comment">// 提交信息请求</span></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/queryPage"</span>, app.QueryPage)    <span class="comment">// 转至根据证书编号与姓名查询信息页面</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/query"</span>, app.FindCertByNoAndName)    <span class="comment">// 根据证书编号与姓名查询信息</span></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/queryPage2"</span>, app.QueryPage2)    <span class="comment">// 转至根据身份证号码查询信息页面</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/query2"</span>, app.FindByID)    <span class="comment">// 根据身份证号码查询信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/modifyPage"</span>, app.ModifyShow)    <span class="comment">// 修改信息页面</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/modify"</span>, app.Modify)    <span class="comment">//  修改信息</span></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/upload"</span>, app.UploadFile)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"启动Web服务, 监听端口号为: 9000"</span>)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9000"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Web服务启动失败: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视图层实现"><a href="#视图层实现" class="headerlink" title="视图层实现"></a>视图层实现</h3><h3 id="13-5-1-目录结构"><a href="#13-5-1-目录结构" class="headerlink" title="13.5.1 目录结构"></a>13.5.1 目录结构</h3><p>在项目的web目录下新创建一个名为 <code>static</code> 的目录，用来存放Web应用视图层的所有静态内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/kongyixueyuan.com/education</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir web/static</span></span><br></pre></td></tr></table></figure><p><strong><code>web/static</code>目录下包括四个子目录，分别为：</strong></p><ul><li><code>web/static/css</code> ：用于存放控制页面布局及显示样式所需的 <code>CSS</code> 文件</li><li><code>web/static/js</code> ：用于存放编写的与用户交互的 <code>JavaScript</code> 源代码文件</li><li><code>web/static/images</code>：用户存放页面显示所需的所有图片文件</li><li><code>web/static/photo</code>：用于存储添加信息时上传的图片文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/css</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/images</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/js</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p web/static/photo</span></span><br></pre></td></tr></table></figure><p>在项目的web目录下新创建一个名为 <code>tpl</code> 的目录，用来存放Web应用响应客户端的模板页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir web/tpl</span></span><br></pre></td></tr></table></figure><p>在 <code>web/tpl</code> 目录下主要有如下页面：</p><ul><li><code>login.html</code>：用户登录页面</li><li><code>index.html</code>：用户登录成功之后进入的首页面</li><li><code>help.html</code>： 显示帮助信息及相关操作的链接页面</li><li><code>query.html</code>：根据证书编号与姓名查询的页面</li><li><code>query2.html</code>：根据身份证号码查询的页面</li><li><code>queryResult.html</code>：根据不同的查询请求显示查询结果的页面</li><li><code>addEdu.html</code>：添加信息的页面</li><li><code>modify.html</code>：修改信息的页面</li></ul><h3 id="13-5-2-相关源码实现"><a href="#13-5-2-相关源码实现" class="headerlink" title="13.5.2 相关源码实现"></a>13.5.2 相关源码实现</h3><p>相关源代码请参考：</p><p>CSS 部分：</p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/addEdu.css" target="_blank" rel="noopener">web/static/css/addEdu.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/bootstrap.min.css" target="_blank" rel="noopener">web/static/css/bootstrap.min.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/help.css" target="_blank" rel="noopener">web/static/css/help.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/index.css" target="_blank" rel="noopener">web/static/css/index.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/login.css" target="_blank" rel="noopener">web/static/css/login.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/query.css" target="_blank" rel="noopener">web/static/css/query.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/queryResult.css" target="_blank" rel="noopener">web/static/css/queryResult.css</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/css/reset.css" target="_blank" rel="noopener">web/static/css/reset.css</a></p><p>JavaScript 部分</p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/js/bootstrap.min.js" target="_blank" rel="noopener">web/static/js/bootstrap.min.js</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/static/js/jquery.min.js" target="_blank" rel="noopener">web/static/js/jquery.min.js</a></p><p>HTML 页面模板部分：</p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/addEdu.html" target="_blank" rel="noopener">web/tpl/addEdu.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/help.html" target="_blank" rel="noopener">web/tpl/help.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/index.html" target="_blank" rel="noopener">web/tpl/index.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/login.html" target="_blank" rel="noopener">web/tpl/login.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/modify.html" target="_blank" rel="noopener">web/tpl/modify.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/query.html" target="_blank" rel="noopener">web/tpl/query.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/query2.html" target="_blank" rel="noopener">web/tpl/query2.html</a></p><p><a href="https://github.com/kevin-hf/education/blob/master/web/tpl/queryResult.html" target="_blank" rel="noopener">web/tpl/queryResult.html</a></p><h3 id="13-5-3-照片上传"><a href="#13-5-3-照片上传" class="headerlink" title="13.5.3 照片上传"></a>13.5.3 照片上传</h3><p>在添加信息时需要额外实现一个功能－添加照片</p><p>使用jQuery Ajax功能实现</p><p>HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"headImg"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"uploadImg"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"上传照片"</span> <span class="attr">id</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">          +</span><br><span class="line">          <span class="comment">&lt;!-- &lt;img src="./images/head.jpg" alt=""&gt; --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>请上传照片(120*160px)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 上传图片</span></span><br><span class="line">$(<span class="string">'#file'</span>).unbind(<span class="string">'change'</span>).bind(<span class="string">'change'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    uploadFile(<span class="string">'img'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 头像图片</span></span><br><span class="line"><span class="keyword">var</span> artImg;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="keyword">if</span>( type == <span class="string">"img"</span>)&#123;</span><br><span class="line">        formData.append(<span class="string">'file'</span>, $(<span class="string">'#file'</span>)[<span class="number">0</span>].files[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/upload'</span>,</span><br><span class="line">        type: <span class="string">'POST'</span>,</span><br><span class="line">        cache: <span class="literal">false</span>,</span><br><span class="line">        data: formData,</span><br><span class="line">        processData: <span class="literal">false</span>,</span><br><span class="line">        dataType: <span class="string">"json"</span>,</span><br><span class="line">        contentType: <span class="literal">false</span></span><br><span class="line">    &#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.error == <span class="string">"0"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( type == <span class="string">"img"</span>)&#123;</span><br><span class="line">                $(<span class="string">'.uploadImg img'</span>).attr(<span class="string">'src'</span>,res.result.path);</span><br><span class="line">                $(<span class="string">'#photo'</span>).val(res.result.path)</span><br><span class="line">                <span class="keyword">return</span> artImg = res.result.path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"上传失败！"</span> + res.result.msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>web/controller</code> 目录下创建一个 <code>upload.go</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim web/controller/upload.go</span></span><br></pre></td></tr></table></figure><p><code>upload.go</code> 文件主要利用 Ajax完成 照片传功能的，完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @Author : hanxiaodong</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controller</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"mime"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *Application)</span> <span class="title">UploadFile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    start := <span class="string">"&#123;"</span></span><br><span class="line">    content := <span class="string">""</span></span><br><span class="line">    end := <span class="string">"&#125;"</span></span><br><span class="line"></span><br><span class="line">    file, _, err := r.FormFile(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        content = <span class="string">"\"error\":1,\"result\":&#123;\"msg\":\"指定了无效的文件\",\"path\":\"\"&#125;"</span></span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    fileBytes, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        content = <span class="string">"\"error\":1,\"result\":&#123;\"msg\":\"无法读取文件内容\",\"path\":\"\"&#125;"</span></span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filetype := http.DetectContentType(fileBytes)</span><br><span class="line">    <span class="comment">//log.Println("filetype = " + filetype)</span></span><br><span class="line">    <span class="keyword">switch</span> filetype &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"image/jpeg"</span>, <span class="string">"image/jpg"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"image/gif"</span>, <span class="string">"image/png"</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"application/pdf"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        content = <span class="string">"\"error\":1,\"result\":&#123;\"msg\":\"文件类型错误\",\"path\":\"\"&#125;"</span></span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileName := randToken(<span class="number">12</span>)    <span class="comment">// 指定文件名</span></span><br><span class="line">    fileEndings, err := mime.ExtensionsByType(filetype)    <span class="comment">// 获取文件扩展名</span></span><br><span class="line">    <span class="comment">//log.Println("fileEndings = " + fileEndings[0])</span></span><br><span class="line">    <span class="comment">// 指定文件存储路径</span></span><br><span class="line">    newPath := filepath.Join(<span class="string">"web"</span>, <span class="string">"static"</span>, <span class="string">"photo"</span>, fileName + fileEndings[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//fmt.Printf("FileType: %s, File: %s\n", filetype, newPath)</span></span><br><span class="line"></span><br><span class="line">    newFile, err := os.Create(newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"创建文件失败："</span> + err.Error())</span><br><span class="line">        content = <span class="string">"\"error\":1,\"result\":&#123;\"msg\":\"创建文件失败\",\"path\":\"\"&#125;"</span></span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, err := newFile.Write(fileBytes); err != <span class="literal">nil</span> || newFile.Close() != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"写入文件失败："</span> + err.Error())</span><br><span class="line">        content = <span class="string">"\"error\":1,\"result\":&#123;\"msg\":\"保存文件内容失败\",\"path\":\"\"&#125;"</span></span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path := <span class="string">"/static/photo/"</span> + fileName + fileEndings[<span class="number">0</span>]</span><br><span class="line">    content = <span class="string">"\"error\":0,\"result\":&#123;\"fileType\":\"image/png\",\"path\":\""</span> + path + <span class="string">"\",\"fileName\":\"ce73ac68d0d93de80d925b5a.png\"&#125;"</span></span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(start + content + end))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randToken</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>)</span><br><span class="line">    rand.Read(b)</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%x"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目交互演示"><a href="#项目交互演示" class="headerlink" title="项目交互演示"></a>项目交互演示</h3><h3 id="13-6-1-启动Web服务"><a href="#13-6-1-启动Web服务" class="headerlink" title="13.6.1 启动Web服务"></a>13.6.1 启动Web服务</h3><p>最后编辑 <code>main.go</code> ，以便启动Web界面实现Web应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim main.go</span></span><br></pre></td></tr></table></figure><p>添加如下内容:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    [......]</span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/education/web/controller"</span></span><br><span class="line">    <span class="string">"github.com/kongyixueyuan.com/education/web"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    [......]</span><br><span class="line"></span><br><span class="line">    app := controller.Application&#123;</span><br><span class="line">        Setup: &amp;serviceSetup,</span><br><span class="line">    &#125;</span><br><span class="line">    web.WebStart(app)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用项目开发完成后，可以直接启动用来查看效果。在命令提示符中输入 <code>make</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><h3 id="13-6-2-访问页面"><a href="#13-6-2-访问页面" class="headerlink" title="13.6.2 访问页面"></a>13.6.2 访问页面</h3><p>项目启动成功之后，打开浏览器访问: <a href="http://localhost:9000/" target="_blank" rel="noopener">htt://localhost:9000/</a></p><p>根据访问的URL地址系统自动响应登录页面</p><p><img src="http://image.chaindesk.cn/html_login.png/mark" alt="login"></p><p>输入管理员账号及密码登录验证成功，则进入系统首页面</p><p><img src="http://image.chaindesk.cn/html_index.png/mark" alt="login"></p><p>在首页面中点击 <code>查询范围</code>链接，进入 <code>help</code>页面，</p><p><img src="http://image.chaindesk.cn/html_help.png/mark" alt="login"></p><p>点击添加学历信息链接进入，添加学历信息页面</p><p><img src="http://image.chaindesk.cn/html_addEdu.png/mark" alt="login"></p><p>根据学历证书编号与姓名查询页面</p><p><img src="http://image.chaindesk.cn/html_queryResultbycert.png/mark" alt="login"></p><p>根据学历证书编号与姓名查询结果页面</p><p><img src="http://image.chaindesk.cn/html_query.png/mark" alt="certNoAndName"></p><p>根据身份证号码查询页面</p><p><img src="http://image.chaindesk.cn/html_query2.png/mark" alt="login"></p><p>根据身份证号码查询页面查询结果页面</p><p><img src="http://image.chaindesk.cn/html_queryResultbyentityid.png/mark" alt="login"></p><p>编辑页面</p><p><img src="http://image.chaindesk.cn/html_modify.png/mark" alt="login"></p><p>编辑成功自动跳转到根据身份证号码查询结果页面</p><p><img src="http://image.chaindesk.cn/html_modifyResult.png/mark" alt="login"></p><p>项目完整源代码，请 <a href="https://github.com/kevin-hf/education" target="_blank" rel="noopener">点击此处</a></p><p>未经授权禁止转载、改编，转载请注明出处！</p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/223" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/223</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章Fabric共识机制</title>
      <link href="/2020/03/26/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC7%E7%AB%A0Fabric%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/26/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC7%E7%AB%A0Fabric%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Fabric中的共识实现"><a href="#一、Fabric中的共识实现" class="headerlink" title="一、Fabric中的共识实现"></a>一、Fabric中的共识实现</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li><p>共识算法的实现目的</p></li><li><p>共识算法的分类</p></li><li><p>Hyperledger Fabric所使用的共识算法</p><a id="more"></a></li></ol><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>在区块链网络中，不同的参与者发起的交易必须按照产生的顺序被依次写入到账本中。交易如何在分布式场景下， 所有节点对同一个提案或值达成一致性，是区块链技术中必须考虑并加以解决的一个问题。要实现这一目标，交易顺序必须被正确的建立，并且必须包含对交易被篡改或者恶意提交交易的处理方法。</p><p>通常，共识算法就是保证分布式系统一致性实现的解决方式，共识算法是计算机科学中用于在分布式过程或系统之间实现对单个数据值的一致性的过程。<strong>共识算法旨在实现涉及在网络中多个不可靠节点的可靠性</strong>。解决该问题（称为共识问题）在分布式计算和多代理系统中非常重要。</p><h3 id="2-共识算法类型"><a href="#2-共识算法类型" class="headerlink" title="2 共识算法类型"></a>2 共识算法类型</h3><h4 id="2-1-共识属性"><a href="#2-1-共识属性" class="headerlink" title="2.1 共识属性"></a>2.1 共识属性</h4><p>共识算法必须满足两个属性，以保证节点之间的一致性， 这两个属性分别是：<strong>安全性</strong>和<strong>活跃性。</strong></p><ul><li><strong>安全性：</strong>表示每个节点保证相同的输入序列，并在每个节点上产生相同的输出结果。当节点收到相同的一系列交易时，每个节点上将发生相同的状态更改。该算法必须与单个节点系统的执行结果相同。</li><li><strong>活跃性：</strong>在通信正常的情况下，每个非故障节点最终都能接收每个提交的交易。</li></ul><h4 id="2-2-共识算法类型"><a href="#2-2-共识算法类型" class="headerlink" title="2.2 共识算法类型"></a>2.2 共识算法类型</h4><p>共识算法可以以不同的方式实现，一般有如下两种类型：</p><ol><li><strong>基于彩票的算法（Lottery-based Algorithms），</strong>包括消耗时间证明（Proof of Elapsed Time，PoET）和工作量证明（Proof of Work，PoW）算法。基于彩票的算法的优势在于它们可以扩展到一个大的数字，由网络中任意一个节点生成一个区块，并将其传递给网络中的其它节点加以验证。另一方面，这些算法可能导致分叉，当两个“赢家”同时各广播一个新产生的区块时，<strong>会产生分支</strong>，每一个分支都必须被解析，这导致使用很长时间来确认终结。</li><li><strong>基于投票的方法（Voting-based Methods），</strong>包括冗余的拜占庭容错（Redundant Byzantine Fault Tolerance，RBFT）和 Paxos（基于消息传递的一致性算法）。每一种方法都针对不同的网络需求容错模型。基于投票的算法的优势在于它们提供了<strong>低延迟</strong>的终结性。当大多数节点验证事务或块时，就存在共识和终结性发生。因为基于投票的算法通常需要节点来对网络上的每个节点传输消息，所以网络上存在的节点越多，达成共识的时间越长。这导致了可伸缩性之间的权衡和速度， <strong>不能满足高并发、快速交易（低延迟）的需求场景。</strong></li></ol><p>下表介绍了两种共识算法类型的比较：</p><table><thead><tr><th align="left"></th><th align="center">基于彩票的算法</th><th align="center">基于投票的方法</th></tr></thead><tbody><tr><td align="left">速度</td><td align="center">较好</td><td align="center">较好</td></tr><tr><td align="left">可扩展性</td><td align="center">较好</td><td align="center">中等</td></tr><tr><td align="left">确定性</td><td align="center">中等</td><td align="center">较好</td></tr></tbody></table><p>因为区块链中的业务需求会有所不同，所以 Hyperledger 社区研究几种不同的一致性共识机制并进行实施以确保模块化实现。Hyperledger 团队开发人员为了提高资源使用及时间效率， 在 Hyperledger 项目开发前做出评估，将区块链业务指定在部分信任的网络环境中运行。所以，Hyperledger 网络环境中不支持匿名访问者的标准工作共识证明方法（Pow共识算法）。</p><p>目前，Hyperledger 中各框架项目所使用的共识算法如下：</p><ul><li>Hyperledger Fabric 中使用了基于 Zookeeper（分布式服务框架）的 Apache Kafka（分布式消息系统）。</li><li>Hyperledger Indy 中使用了基于投票的方法 RBFT（Redundant Byzantine Fault Tolerance，冗余拜占庭容错算法）。</li><li>Hyperledger Iroha 中使用了一种基于投票的方法（Sumeragi）来达成共识故障容错。</li><li>Hyperledger Sawtooth 中使用了基于彩票的 PoET 算法以拖延为代价实现共识。</li></ul><h3 id="3-Hyperledger-Fabric中的共识实现"><a href="#3-Hyperledger-Fabric中的共识实现" class="headerlink" title="3 Hyperledger Fabric中的共识实现"></a>3 Hyperledger Fabric中的共识实现</h3><p>不同的 Hyperledger 框架可以选择不同的方式实现共识。Hyperledger 区块链框架业务通过执行两个框架达成单独的共识过程：</p><ul><li>Ordering of transactions （交易排序）</li><li>Validating Transactions（交易验证）</li></ul><p>为了确保任何 Hyperledger 框架可以应用于任何的 Hyperledger 共识模块，通过逻辑分离这两个共识实现过程。Hyperledger Fabric 网络中的共识被分解为<strong>三个阶段：背书阶段、排序阶段和验证阶段</strong>。</p><ul><li><p><strong>背书阶段：签名必须由参与者的背书策略确定。</strong></p><p>客户端应用程序将交易请求打包成为交易提案（Proposal）后，根据背书策略（Endorse Policy）发达给指定的背书节点（Endorse Peer）。背书节点接收到交易提案后调用链码（Chaincode）执行，但此执行过程是模拟执行，并不会将数据记录到账本中。执行完成后调用交易背书系统链码（Endorsement System Chaincode，ESCC）对执行结果进行签名，然后响应给客户端应用程序。Ordering Service 可以以不同的方式实现：开发和测试阶段可以使用集中式排序服务（中心化），针对不同网络的分布式协议节点故障模型。为了保证交易的机密性，Ordering Service 不能看到交易中的具体内容（不参与对交易内容的任何处理），也就是说，交易内容可以使用哈希散列或加密方式去处理。</p></li><li><p><strong>排序阶段：接受提交的被认可的交易并进行排序，确保交易顺序的一致性。</strong></p><p>排序阶段通过 Ordering 服务提供的接口接收到已经背书的交易，Ordering Service 根据共识算法配置策略（根据指定的配置信息中定义时间限制或指定允许的交易数量），确定交易的顺序和交易数量。然后将交易打包到区块中进行广播。大多数时候，由于为了提高系统效率的原因，Ordering 服务将多个交易分组到一个区块中，而不是将单个交易输出成为一个区块。</p></li><li><p><strong>验证阶段：获取有序事务块并验证其结果的正确性，包括检查背书策略和重复提交攻击。</strong></p><p>Peer 节点接收到广播的区块后，进行保存之前的最终检查验证，验证通过后将该区块保存在区块链中。为了校验交易的正确性，共识的建立依赖于智能合约层（Hyperledger Fabric 中的 Chaincode），智能合约层定义了商业逻辑来如何验证交易的有效性。智能合约层根据特定的策略与约定来确认每一笔交易都是有效的。无效的交易会被拒绝，并在块中剔除。潜在的校验失败主要分为以下两种：</p><ol><li>语法错误：包含以下几种类型，比如无效输入、未验证的签名、重复的交易等，这类交易应该被丢弃。</li><li>逻辑错误：此类错误更为复杂，应该需要定义策略决定是继续处理还是终止执行。如，导致重复交易或版本控制的交易。如果策略需要，我们可能需要日志记录这些交易以进行审计。</li></ol></li></ul><p>Hyperledger Fabric 应用程序可以根据不同的交易背书、排序和验证模型要求，实现支持对3个阶段的可拔插共识服务，特别是 Ordering 服务 API 允许插入基于 BFT 的协议算法。Orderer 节点通过gRPC服务提供两个 API 接口：广播（broadcase）和交付（deliver）。</p><ul><li><p><strong>broadcast（blob）：</strong>客户端调用此函数在通道中广播任意的消息blob（客户端向排序服务发送交易请求）。在BFT中，给服务发送一个请求时，又称为 request(blob)。</p></li><li><p><strong>deliver（seqno，prevhash，blob）：</strong>Ordering 服务调用此函数给 Peer 节点发送blob消息，包含非负整数的序列号 seqno 和最近一次消息的哈希 prevhash 。换句话说，它是共识服务的输出接口。deliver（）在发布/订阅系统中称为notify（），在BFT系统中称为commit（）。</p><blockquote><p>注意共识服务客户端（即 Peer 节点）只通过broadcast（）和deliver（）事件和服务进行交互。</p></blockquote></li></ul><p>在 Hyperledger Fabric 框架项目的正式版本中支持两种共识算法类型：</p><ul><li><strong>Solo：</strong>单节点共识，整个Fabric网络只有一个 Orderer 节点（Fabric网络默认）。主要用于测试模式。</li><li><strong>Kafka：</strong>分布式消息队列，整个Fabric网络的共识由 Kafka 集群实现（实际上Kafka实现了对于Hyperledger Fabric网络中所有的交易请求进行排序服务）。具体实现方式请参见下一节内容。</li></ul><blockquote><p>目前，Hyperledger 项目团队正在开发其它 Ordering 共识插件，包括BFT Smart，简化拜占庭容错算法（Simplified Byzantine Fault Tolerance，SBFT），蜜獾拜占庭容错算法（Honey Badger of BFT）等。</p></blockquote><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>已经启动了 Orderer 服务，然后想使用其它一致性算法，如何实现？</p><p>在 Hyperledger Fabric 中不支持此种操作方式。</p></li><li><p>现在可以在 Hyperledger Fabric 中使用拜占庭容错算法 吗？</p><p>不可以，目前在 Fabric 发布的标准版本中只能使用 Solo 与 Kafka 实现共识，其它共识插件处于开发状态中，在哪个正式版本中发布官方并没有确定。</p></li></ol><h2 id="二、基于Kafka排序服务的实现"><a href="#二、基于Kafka排序服务的实现" class="headerlink" title="二、基于Kafka排序服务的实现"></a>二、基于Kafka排序服务的实现</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>实现现基于 Kafka 集群的排序服务</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>在上一节中，我们知道了 Hyperledger Fabric 的共识实现，现在我们使用容器实现一个基于 Kafka 提供排序服务的集群环境。在该网络环境中，我们使用2个 Org 组织，每个 Org 组织下各有2个 peer 节点，4个 orderer节点，后端使用 Kafka 集群实现排序服务，由4个 kafka 节点，3个 zookeeper 节点组成。</p></blockquote><h3 id="1-指定-Kafka-实现排序服务"><a href="#1-指定-Kafka-实现排序服务" class="headerlink" title="1 指定 Kafka 实现排序服务"></a>1 指定 Kafka 实现排序服务</h3><h4 id="1-1-配置-crypto-config-yaml"><a href="#1-1-配置-crypto-config-yaml" class="headerlink" title="1.1 配置 crypto-config.yaml"></a>1.1 配置 crypto-config.yaml</h4><p>进入 <code>fabric-samples/first-network</code> 目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hyfa/fabric-samples/first-network/</span></span><br></pre></td></tr></table></figure><p>将 <code>crypto-config.yaml</code> 配置文件备份为 <code>crypto-config_backup.yaml</code> ，然后编辑 <code>crypto-config.yaml</code> 文件，在 <code>OrdererOrgs.Specs</code> 中添加三个 orderer 节点，共计四个 orderer 节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp crypto-config.yaml crypto-config_backup.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim crypto-config.yaml</span></span><br></pre></td></tr></table></figure><p>编辑后 <code>OrdererOrgs</code> 的具体内容如下（PeerOrgs 中的内容不变）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># "OrdererOrgs" - Definition of organizations managing orderer nodes</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">OrdererOrgs:</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Orderer</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Orderer</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Specs" - See PeerOrgs below for complete description</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Specs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer3</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># "PeerOrgs" - Definition of organizations managing peer nodes</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">PeerOrgs:</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Org1</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org1</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org1.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Specs"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Uncomment this section to enable the explicit definition of hosts in your</span></span><br><span class="line">    <span class="comment"># configuration.  Most users will want to use Template, below</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Specs is an array of Spec entries.  Each Spec entry consists of two fields:</span></span><br><span class="line">    <span class="comment">#   - Hostname:   (Required) The desired hostname, sans the domain.</span></span><br><span class="line">    <span class="comment">#   - CommonName: (Optional) Specifies the template or explicit override for</span></span><br><span class="line">    <span class="comment">#                 the CN.  By default, this is the template:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                              "&#123;&#123;.Hostname&#125;&#125;.&#123;&#123;.Domain&#125;&#125;"</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#                 which obtains its values from the Spec.Hostname and</span></span><br><span class="line">    <span class="comment">#                 Org.Domain, respectively.</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Specs:</span></span><br><span class="line">    <span class="comment">#   - Hostname: foo # implicitly "foo.org1.example.com"</span></span><br><span class="line">    <span class="comment">#     CommonName: foo27.org5.example.com # overrides Hostname-based FQDN set above</span></span><br><span class="line">    <span class="comment">#   - Hostname: bar</span></span><br><span class="line">    <span class="comment">#   - Hostname: baz</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Template"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Allows for the definition of 1 or more hosts that are created sequentially</span></span><br><span class="line">    <span class="comment"># from a template. By default, this looks like "peer%d" from 0 to Count-1.</span></span><br><span class="line">    <span class="comment"># You may override the number of nodes (Count), the starting index (Start)</span></span><br><span class="line">    <span class="comment"># or the template used to construct the name (Hostname).</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># <span class="doctag">Note:</span> Template and Specs are not mutually exclusive.  You may define both</span></span><br><span class="line">    <span class="comment"># sections and the aggregate nodes will be created for you.  Take care with</span></span><br><span class="line">    <span class="comment"># name collisions</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">2</span></span><br><span class="line">      <span class="comment"># Start: 5</span></span><br><span class="line">      <span class="comment"># Hostname: &#123;&#123;.Prefix&#125;&#125;&#123;&#123;.Index&#125;&#125; # default</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># "Users"</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># Count: The number of user accounts _in addition_ to Admin</span></span><br><span class="line">    <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Org2: See "Org1" for full specification</span></span><br><span class="line">  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org2</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org2.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1-2-配置-configtx-yaml"><a href="#1-2-配置-configtx-yaml" class="headerlink" title="1.2 配置 configtx.yaml"></a>1.2 配置 configtx.yaml</h4><p>将 <code>configtx.yaml</code> 配置文件备份为 <code>configtx_backup.yaml</code> ，然后编辑 <code>configtx.yaml</code> 文件，在 <code>Orderer.Addresses</code> 中声明四个 orderer 节点信息， 将 <code>Orderer.OrdererType</code> 的值由默认的 <code>solo</code> 修改为 <code>kafka</code>，在 <code>Orderer.Addresses</code> 下添加另外的三个 <code>orderer</code> 节点信息，在 <code>Orderer.Kafka.Brokers</code> 中添加 kafka 集群服务器的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp configtx.yaml configtx_backup.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim configtx.yaml</span></span><br></pre></td></tr></table></figure><p>编辑后 <code>Orderer</code> 下的具体内容如下（其它部分不变）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Section: Organizations</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the different organizational identities which will</span></span><br><span class="line"><span class="comment">#   be referenced later in the configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># SampleOrg defines an MSP using the sampleconfig.  It should never be used</span></span><br><span class="line">    <span class="comment"># in production but may be used as a template for other definitions</span></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;OrdererOrg</span></span><br><span class="line">        <span class="comment"># DefaultOrg defines the organization which is used in the sampleconfig</span></span><br><span class="line">        <span class="comment"># of the fabric.git development environment</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">OrdererOrg</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ID to load the MSP definition as</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">OrdererMSP</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># MSPDir is the filesystem path which contains the MSP configuration</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/ordererOrganizations/example.com/msp</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;Org1</span></span><br><span class="line">        <span class="comment"># DefaultOrg defines the organization which is used in the sampleconfig</span></span><br><span class="line">        <span class="comment"># of the fabric.git development environment</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">Org1MSP</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ID to load the MSP definition as</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">Org1MSP</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/peerOrganizations/org1.example.com/msp</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">AnchorPeers:</span></span><br><span class="line">            <span class="comment"># AnchorPeers defines the location of peers which can be used</span></span><br><span class="line">            <span class="comment"># for cross org gossip communication.  Note, this value is only</span></span><br><span class="line">            <span class="comment"># encoded in the genesis block in the Application section context</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">              <span class="attr">Port:</span> <span class="number">7051</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;Org2</span></span><br><span class="line">        <span class="comment"># DefaultOrg defines the organization which is used in the sampleconfig</span></span><br><span class="line">        <span class="comment"># of the fabric.git development environment</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">Org2MSP</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ID to load the MSP definition as</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">Org2MSP</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/peerOrganizations/org2.example.com/msp</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">AnchorPeers:</span></span><br><span class="line">            <span class="comment"># AnchorPeers defines the location of peers which can be used</span></span><br><span class="line">            <span class="comment"># for cross org gossip communication.  Note, this value is only</span></span><br><span class="line">            <span class="comment"># encoded in the genesis block in the Application section context</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">              <span class="attr">Port:</span> <span class="number">7051</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Capabilities</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the capabilities of fabric network. This is a new</span></span><br><span class="line"><span class="comment">#   concept as of v1.1.0 and should not be utilized in mixed networks with</span></span><br><span class="line"><span class="comment">#   v1.0.x peers and orderers.  Capabilities define features which must be</span></span><br><span class="line"><span class="comment">#   present in a fabric binary for that binary to safely participate in the</span></span><br><span class="line"><span class="comment">#   fabric network.  For instance, if a new MSP type is added, newer binaries</span></span><br><span class="line"><span class="comment">#   might recognize and validate the signatures from this type, while older</span></span><br><span class="line"><span class="comment">#   binaries without this support would be unable to validate those</span></span><br><span class="line"><span class="comment">#   transactions.  This could lead to different versions of the fabric binaries</span></span><br><span class="line"><span class="comment">#   having different world states.  Instead, defining a capability for a channel</span></span><br><span class="line"><span class="comment">#   informs those binaries without this capability that they must cease</span></span><br><span class="line"><span class="comment">#   processing transactions until they have been upgraded.  For v1.0.x if any</span></span><br><span class="line"><span class="comment">#   capabilities are defined (including a map with all capabilities turned off)</span></span><br><span class="line"><span class="comment">#   then the v1.0.x peer will deliberately crash.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Capabilities:</span></span><br><span class="line">    <span class="comment"># Channel capabilities apply to both the orderers and the peers and must be</span></span><br><span class="line">    <span class="comment"># supported by both.  Set the value of the capability to true to require it.</span></span><br><span class="line">    <span class="attr">Global:</span> <span class="meta">&amp;ChannelCapabilities</span></span><br><span class="line">        <span class="comment"># V1.1 for Global is a catchall flag for behavior which has been</span></span><br><span class="line">        <span class="comment"># determined to be desired for all orderers and peers running v1.0.x,</span></span><br><span class="line">        <span class="comment"># but the modification of which would cause incompatibilities.  Users</span></span><br><span class="line">        <span class="comment"># should leave this flag set to true.</span></span><br><span class="line">        <span class="attr">V1_1:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Orderer capabilities apply only to the orderers, and may be safely</span></span><br><span class="line">    <span class="comment"># manipulated without concern for upgrading peers.  Set the value of the</span></span><br><span class="line">    <span class="comment"># capability to true to require it.</span></span><br><span class="line">    <span class="attr">Orderer:</span> <span class="meta">&amp;OrdererCapabilities</span></span><br><span class="line">        <span class="comment"># V1.1 for Order is a catchall flag for behavior which has been</span></span><br><span class="line">        <span class="comment"># determined to be desired for all orderers running v1.0.x, but the</span></span><br><span class="line">        <span class="comment"># modification of which  would cause incompatibilities.  Users should</span></span><br><span class="line">        <span class="comment"># leave this flag set to true.</span></span><br><span class="line">        <span class="attr">V1_1:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Application capabilities apply only to the peer network, and may be safely</span></span><br><span class="line">    <span class="comment"># manipulated without concern for upgrading orderers.  Set the value of the</span></span><br><span class="line">    <span class="comment"># capability to true to require it.</span></span><br><span class="line">    <span class="attr">Application:</span> <span class="meta">&amp;ApplicationCapabilities</span></span><br><span class="line">        <span class="comment"># V1.2 for Application is a catchall flag for behavior which has been</span></span><br><span class="line">        <span class="comment"># determined to be desired for all peers running v1.0.x, but the</span></span><br><span class="line">        <span class="comment"># modification of which would cause incompatibilities.  Users should</span></span><br><span class="line">        <span class="comment"># leave this flag set to true.</span></span><br><span class="line">        <span class="attr">V1_2:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Application</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the values to encode into a config transaction or</span></span><br><span class="line"><span class="comment">#   genesis block for application related parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Application:</span> <span class="meta">&amp;ApplicationDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Organizations is the list of orgs which are defined as participants on</span></span><br><span class="line">    <span class="comment"># the application side of the network</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   SECTION: Orderer</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - This section defines the values to encode into a config transaction or</span></span><br><span class="line"><span class="comment">#   genesis block for orderer related parameters</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Orderer:</span> <span class="meta">&amp;OrdererDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Orderer Type: The orderer implementation to start</span></span><br><span class="line">    <span class="comment"># Available types are "solo" and "kafka"</span></span><br><span class="line">    <span class="attr">OrdererType:</span> <span class="string">kafka</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer.example.com:7050</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer1.example.com:7050</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer2.example.com:7050</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer3.example.com:7050</span></span><br><span class="line">    <span class="comment"># Batch Timeout: The amount of time to wait before creating a batch</span></span><br><span class="line">    <span class="attr">BatchTimeout:</span> <span class="string">2s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Batch Size: Controls the number of messages batched into a block</span></span><br><span class="line">    <span class="attr">BatchSize:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Max Message Count: The maximum number of messages to permit in a batch</span></span><br><span class="line">        <span class="attr">MaxMessageCount:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Absolute Max Bytes: The absolute maximum number of bytes allowed for</span></span><br><span class="line">        <span class="comment"># the serialized messages in a batch.</span></span><br><span class="line">        <span class="attr">AbsoluteMaxBytes:</span> <span class="number">99</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Preferred Max Bytes: The preferred maximum number of bytes allowed for</span></span><br><span class="line">        <span class="comment"># the serialized messages in a batch. A message larger than the preferred</span></span><br><span class="line">        <span class="comment"># max bytes will result in a batch larger than preferred max bytes.</span></span><br><span class="line">        <span class="attr">PreferredMaxBytes:</span> <span class="number">512</span> <span class="string">KB</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Kafka:</span></span><br><span class="line">        <span class="comment"># Brokers: A list of Kafka brokers to which the orderer connects</span></span><br><span class="line">        <span class="comment"># <span class="doctag">NOTE:</span> Use IP:port notation</span></span><br><span class="line">        <span class="attr">Brokers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">kafka0:9092</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">kafka1:9092</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">kafka2:9092</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">kafka3:9092</span></span><br><span class="line">    <span class="comment"># Organizations is the list of orgs which are defined as participants on</span></span><br><span class="line">    <span class="comment"># the orderer side of the network</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Profile</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   - Different configuration profiles may be encoded here to be specified</span></span><br><span class="line"><span class="comment">#   as parameters to the configtxgen tool</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="attr">Profiles:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">TwoOrgsOrdererGenesis:</span></span><br><span class="line">        <span class="attr">Capabilities:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*ChannelCapabilities</span></span><br><span class="line">        <span class="attr">Orderer:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*OrdererDefaults</span></span><br><span class="line">            <span class="attr">Organizations:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*OrdererOrg</span></span><br><span class="line">            <span class="attr">Capabilities:</span></span><br><span class="line">                <span class="string">&lt;&lt;:</span> <span class="meta">*OrdererCapabilities</span></span><br><span class="line">        <span class="attr">Consortiums:</span></span><br><span class="line">            <span class="attr">SampleConsortium:</span></span><br><span class="line">                <span class="attr">Organizations:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="meta">*Org1</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="meta">*Org2</span></span><br><span class="line">    <span class="attr">TwoOrgsChannel:</span></span><br><span class="line">        <span class="attr">Consortium:</span> <span class="string">SampleConsortium</span></span><br><span class="line">        <span class="attr">Application:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationDefaults</span></span><br><span class="line">            <span class="attr">Organizations:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*Org1</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*Org2</span></span><br><span class="line">            <span class="attr">Capabilities:</span></span><br><span class="line">                <span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationCapabilities</span></span><br></pre></td></tr></table></figure><h3 id="2-配置网络环境"><a href="#2-配置网络环境" class="headerlink" title="2 配置网络环境"></a>2 配置网络环境</h3><h4 id="2-1-配置-docker-compose-base-yaml"><a href="#2-1-配置-docker-compose-base-yaml" class="headerlink" title="2.1 配置 docker-compose-base.yaml"></a>2.1 配置 docker-compose-base.yaml</h4><p>将 <code>base/docker-compose-base.yaml</code> 配置文件备份为 <code>base/docker-compose-base_backup.yaml</code> ，然后编辑 <code>base/docker-compose-base.yaml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp base/docker-compose-base.yaml base/docker-compose-base_backup.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim base/docker-compose-base.yaml</span></span><br></pre></td></tr></table></figure><p>在文件中添加 zookeeper 节点信息、kafka 节点信息及修改 orderer 节点的信息，peer 节点信息不变，详细配置信息如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">zookeeper:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZOO_SERVERS=server.1=zookeeper1:2888:3888</span> <span class="string">server.2=zookeeper2:2888:3888</span> <span class="string">server.3=zookeeper3:2888:3888</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'2181'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'2888'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'3888'</span></span><br><span class="line">  <span class="attr">kafka:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-kafka</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_LOG_RETENTION_MS=-1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_MESSAGE_MAX_BYTES=103809024</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_REPLICA_FETCH_MAX_BYTES=103809024</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_UNCLEAN_LEADER_ELECTION_ENABLE=false</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_MIN_INSYNC_REPLICAS=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_DEFAULT_REPLICATION_FACTOR=3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_ZOOKEEPER_CONNECT=zookeeper1:2181,zookeeper2:2181,zookeeper3:2181</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'9092'</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer.example.com:</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer:$IMAGE_TAG</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=INFO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line"><span class="comment"># kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_ORDERERTYPE=kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_KAFKA_BROKERS=[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092]</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTTOTAL=30s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_VERBOSE=true</span></span><br><span class="line">      <span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">   <span class="comment"># - orderer.example.com:/var/hyperledger/production/orderer</span></span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7050'</span></span><br><span class="line">  <span class="attr">orderer1.example.com:</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer1.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=debug</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line"><span class="comment"># kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_ORDERERTYPE=kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_KAFKA_BROKERS=[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092]</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTTOTAL=30s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_VERBOSE=true</span></span><br><span class="line"><span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7050'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">orderer2.example.com:</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer2.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=debug</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line"><span class="comment"># kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_ORDERERTYPE=kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_KAFKA_BROKERS=[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092]</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTTOTAL=30s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_VERBOSE=true</span></span><br><span class="line"><span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7050'</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer3.example.com:</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer3.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=debug</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line"><span class="comment"># kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_ORDERERTYPE=kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CONFIGTX_ORDERER_KAFKA_BROKERS=[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092]</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_RETRY_SHORTTOTAL=30s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_KAFKA_VERBOSE=true</span></span><br><span class="line"><span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer3.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer3.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">'7050'</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org1.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.example.com:/var/hyperledger/production</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org2MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org2.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org2MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org2.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10053</span><span class="string">:7053</span></span><br></pre></td></tr></table></figure><h4 id="2-2-配置-docker-compose-cli-yaml"><a href="#2-2-配置-docker-compose-cli-yaml" class="headerlink" title="2.2 配置 docker-compose-cli.yaml"></a>2.2 配置 docker-compose-cli.yaml</h4><p>将 <code>docker-compose-cli.yaml</code> 配置文件备份为 <code>docker-compose-cli_backup.yaml</code>，然后编辑 <code>docker-compose-cli.yaml</code> 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp docker-compose-cli.yaml docker-compose-cli_backup.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim docker-compose-cli.yaml</span></span><br></pre></td></tr></table></figure><p>在文件中添加三个 zookeeper 节点、四个 kafka 节点及相应的 orderer 节点的信息，具体配置内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">  <span class="attr">orderer1.example.com:</span></span><br><span class="line">  <span class="attr">orderer2.example.com:</span></span><br><span class="line">  <span class="attr">orderer3.example.com:</span></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">byfn:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper1:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper1</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZOO_MY_ID=1</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">zookeeper2:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper2</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZOO_MY_ID=2</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">zookeeper3:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ZOO_MY_ID=3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">kafka0:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka0</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_BROKER_ID=0</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka1:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka1</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_BROKER_ID=1</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka2:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka2</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_BROKER_ID=2</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka3:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KAFKA_BROKER_ID=3</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">orderer1.example.com:</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">orderer1.example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer1.example.com</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer2.example.com:</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">orderer2.example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer2.example.com</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer3.example.com:</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">orderer3.example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer3.example.com</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools:$IMAGE_TAG</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">      <span class="comment">#- CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=INFO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/bash</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./../chaincode/:/opt/gopath/src/github.com/chaincode</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderer.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderer1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderer2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderer3.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br></pre></td></tr></table></figure><h3 id="3-启动网络"><a href="#3-启动网络" class="headerlink" title="3 启动网络"></a>3 启动网络</h3><p><strong>关闭并清理网络环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./byfn.sh down</span></span><br></pre></td></tr></table></figure><p><strong>使用 <code>byfn.sh</code> 生成组织结构及身份证书及所需的各项配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./byfn.sh generate</span></span><br></pre></td></tr></table></figure><p><strong>启动网络</strong>  （出错在这里docker-compose-cli.yaml,修改了cli 参数为cli2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml up -d</span></span><br></pre></td></tr></table></figure><p>查看活动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps</span></span><br></pre></td></tr></table></figure><p>可发现发三个 zookeeper 节点、四个 kafka 节点、四个 orderer 节点、四个 peer 节点都已经处于活动状态，如下图所示：</p><p><img src="http://image.chaindesk.cn/7.2_12.png/mark" alt="集群容器"></p><p><strong>打开一个新的终端2窗口：</strong></p><p>进入 <code>zookeeper1</code> 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it zookeeper1 bash</span></span><br></pre></td></tr></table></figure><p>使用 <code>ifconfig</code> 命令查看容器的 IP 地址之后退出</p><p><img src="http://image.chaindesk.cn/7.2_13.png/mark" alt="集群容器"></p><p>进入 kafka0 容器并进入 kafka HOME目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it kafka0 bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> opt/kafka/</span></span><br></pre></td></tr></table></figure><p>查看 kafka 自动创建的 topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bin/kafka-topics.sh --list --zookeeper 172.20.0.2:2181</span></span><br><span class="line">----输出结果</span><br><span class="line">testchainid</span><br></pre></td></tr></table></figure><p><strong>创建通道</strong></p><p>返回终端 <code>１</code> 窗口，进入 <code>cli</code> 容器<strong>cli换成cli2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br><span class="line">//我的sudo docker exec -it cli2 bash</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel</span></span><br></pre></td></tr></table></figure><p>创建通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel create -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><p>终端输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 002 Got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 004 Got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 005 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 006 Got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 007 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 008 Got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 009 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 00a Got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 00b Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 00c Received block: 0</span><br></pre></td></tr></table></figure><p>创建通道之后在终端 <code>2</code> 窗口的 kafka 容器中再次查看 topic 信息， 发现 kafka 又自动创建了一个新的名为 <code>mychannel</code> 的 topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bin/kafka-topics.sh --list --zookeeper 172.20.0.2:2181</span></span><br><span class="line"></span><br><span class="line">mychannel</span><br><span class="line">testchainid</span><br></pre></td></tr></table></figure><p>返回终端 <code>１</code> 窗口的 <code>cli</code> 容器中，将当前代表的 <code>peer0.org1.example.com</code> 节点加入到应用通道中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel join -b mychannel.block</span></span><br></pre></td></tr></table></figure><p>终端输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">[channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h3><p><strong>安装链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/</span></span><br></pre></td></tr></table></figure><p>安装成功显示内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">[chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:"OK" &gt;</span><br></pre></td></tr></table></figure><p><strong>实例化链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a", "100", "b","200"]&#125;'</span> -P <span class="string">"OR ('Org1MSP.peer','Org2MSP.peer')"</span></span></span><br></pre></td></tr></table></figure><p>实例化成功显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br></pre></td></tr></table></figure><p><strong>查询链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>返回查询结果：<code>100</code></p><p><strong>调用链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>返回调用结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p><strong>查询转账之后的结果</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>返回查询结果：<code>90</code></p><p>orderer 节点以集群的方式运行，在集群环境下，客户端将交易发送到任何一个 orderer 排序节点都可以，如下所示，指定Orderer2节点。</p><p><strong>调用链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -o orderer2.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer2.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>返回调用结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><p><strong>再次查询链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>返回查询结果：<code>80</code></p><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>之前从未使用过 Kafka / Zookeeper 集群，我想使用基于 Kafka 的 Ordering 服务。我该怎么办？</p><p>如果之前从未使用过 Kafka，那么应该先从官方网站学习一下 <a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">Kafka快速入门指南</a></p></li><li><p>docker-compose-cli.yaml 配置文件有官方的配置示例吗？</p><p>官方的配置示例请参阅 <a href="https://github.com/hyperledger/fabric/blob/master/examples/e2e_cli/docker-compose-e2e.yaml" target="_blank" rel="noopener">端到端CLI 示例</a></p></li><li><p>为什么使用基于 Kafka 的集群服务中必须使用 ZooKeeper？</p><p>Zookeeper 是一个开源的为分布式应用提供一致性服务的软件，Kafka 在内部使用 Zookeeper 来进行 broker 之间的协调。更多的内容，请查看官方提供的相关说明文档。</p></li></ol><h2 id="三、多链及多通道实现"><a href="#三、多链及多通道实现" class="headerlink" title="三、多链及多通道实现"></a>三、多链及多通道实现</h2><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>Hyperledger Fabric 多链&amp;多通道</li><li>多链&amp;&amp;多通道的实现</li></ol><h3 id="1-多链及多通道"><a href="#1-多链及多通道" class="headerlink" title="1 多链及多通道"></a>1 多链及多通道</h3><p>在 Hyperledger Fabric 0.6 版本中，所有节点都属于同一个链中，由此产生了数据处理、存储及访问安全的问题。在后期的 Hyperledger Fabric 1.0 版本中，新增加了对多链实现。</p><p><strong>链</strong>是由一个通道 + 一个共享账本 + N个 peer 节点组成；不同的链将参与者和数据（包含chaincode）进行隔离；在由多个 Peer 节点组成的网络中，不同的 Peer 节点加入到不同的应用通道中，便产生了多个不同的链。真正实现了对数据的隔离。</p><p>加入到同一个应用通道中的 Peer 节点共同维护相同的区块数据，与加入其它应用通道的 Peer 节点相互隔离，也就意味着不能访问其它应用通道中 Peer 节点的数据，有效保护了隐私数据，并且提高了对数据的并行处理效率及对数据存储空间的利用。</p><h4 id="1-1-多链环境"><a href="#1-1-多链环境" class="headerlink" title="1.1 多链环境"></a>1.1 多链环境</h4><p>现在假设我们有一个 Hyperledger Fabric 网络环境，该网络中包含由4个 Orderer 节点组成的一个 Ordering Service 集群，三个 Org 组织；其中 Org1 Peers中包含6个 Peer 节点；Org2 组织中包含4个 Peer 节点；Org3 组织中包含3个 Peer 节点。</p><p><img src="http://image.chaindesk.cn/7.3_1.png/mark" alt="多链"></p><p>如上面的多链示意图所示：</p><p>Chain1：由 Org1、Org2 两个组织中的 1.1，1.2，2.1，2.2 四个 Peer 节点组成。</p><p>Chain2：同 Org1、Org2 、Org3三个组织中的 1.1，1.3，2.1，2.3，3.1，3.2，3.3 七个 Peer 节点组成。</p><p>Anchors：由 1.3，2.3，3.1 三个不同组织的 Peer 节点代表。</p><p>Leaders：由 1.1，2.1，3.1 三个不同组织的 Peer 节点代表 。</p><h4 id="1-2-多通道环境"><a href="#1-2-多通道环境" class="headerlink" title="1.2 多通道环境"></a>1.2 多通道环境</h4><p><img src="http://image.chaindesk.cn/7.3_2.png/mark" alt="多通道"></p><p>如上图所示：网络中有三个通道，分别由红色、蓝色、黑色三种颜色代表；多个 Peer 节点加入不同的应用通道中形成多个账本。</p><ul><li>Peer 1，Peer 2 和 Peer N 加入到红色通道，并共同维护红色账本;</li><li>Peer 1 和 Peer N加入到蓝色通道，并共同维护蓝色账本;</li><li>Peer 2 和 Peer N加入到黑色通道上并共同维护黑色账本。</li></ul><h3 id="2-应用多通道"><a href="#2-应用多通道" class="headerlink" title="2 应用多通道"></a>2 应用多通道</h3><p>如果当前网络开发测试模式，请先关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode-docker-devmode</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-simple.yaml down</span></span><br></pre></td></tr></table></figure><p>然后进入 <code>fabric-samples/first-network</code> 目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../first-network</span></span><br></pre></td></tr></table></figure><h4 id="2-1-创建一个应用通道的配置交易"><a href="#2-1-创建一个应用通道的配置交易" class="headerlink" title="2.1 创建一个应用通道的配置交易"></a>2.1 创建一个应用通道的配置交易</h4><p>由在要对一个网络进行分割，所以为了区分不同的“子网”，我们需要给不同的“子网”指定一个标识名称，所以请务必设置$CHANNEL_NAME环境变量为一个与之前通道名称完全不相同的值（代表新创建的另外一个应用通道名称）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel2</span></span><br></pre></td></tr></table></figure><p>指定使用 <code>configtx.yaml</code> 配置文件中的 <code>TwoOrgsChannel</code> 模板, 来生成新建通道的配置交易文件,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel2.tx -channelID <span class="variable">$CHANNEL_NAME</span></span></span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">[common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx</span><br><span class="line">[common/tools/configtxgen/encoder] NewApplicationGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the application group in configtx.yaml</span><br><span class="line">[msp] getMspConfig -&gt; INFO 004 Loading NodeOUs</span><br><span class="line">[common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the application org group Org1MSP in configtx.yaml</span><br><span class="line">[msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">[common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the application org group Org2MSP in configtx.yaml</span><br><span class="line">[common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 008 Writing new channel tx</span><br></pre></td></tr></table></figure><h4 id="2-2-生成锚节点配置更新文件"><a href="#2-2-生成锚节点配置更新文件" class="headerlink" title="2.2 生成锚节点配置更新文件"></a>2.2 生成锚节点配置更新文件</h4><p>锚节点配置更新文件用来对组织的锚节点进行配置</p><p>同样基于 <code>configtx.yaml</code> 配置文件生成新建通道文件, 每个组织都需要分别生成且注意指定对应的组织名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors2.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org1MSP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors2.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org2MSP</span></span><br></pre></td></tr></table></figure><p>执行完毕后查看 <code>channel-artifacts</code> 目录内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 root root  4096 8月  28 16:29 ./</span><br><span class="line">drwxr-xr-x 7 root root  4096 8月  28 10:41 ../</span><br><span class="line">-rw-r--r-- 1 root root   348 8月  28 16:27 channel2.tx</span><br><span class="line">-rw-r--r-- 1 root root   346 8月  28 10:41 channel.tx</span><br><span class="line">-rw-r--r-- 1 root root 12639 8月  28 10:41 genesis.block</span><br><span class="line">-rw-r--r-- 1 root root     0 8月   7 10:12 .gitkeep</span><br><span class="line">-rw-r--r-- 1 root root   286 8月  28 16:28 Org1MSPanchors2.tx</span><br><span class="line">-rw-r--r-- 1 root root   284 8月  28 10:41 Org1MSPanchors.tx</span><br><span class="line">-rw-r--r-- 1 root root   286 8月  28 16:29 Org2MSPanchors2.tx</span><br><span class="line">-rw-r--r-- 1 root root   284 8月  28 10:41 Org2MSPanchors.tx</span><br></pre></td></tr></table></figure><p>如上输出内容所示，在 <code>channel-artifacts</code> 目录中新增了 <code>channel2.tx、Org1MSPanchors2.tx、Org2MSPanchors2.tx</code> 三个配置文件。</p><h4 id="2-3-启动网络"><a href="#2-3-启动网络" class="headerlink" title="2.3 启动网络"></a>2.3 启动网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml up -d</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Creating network "net_byfn" with the default driver</span><br><span class="line">Creating orderer.example.com</span><br><span class="line">Creating peer1.org2.example.com</span><br><span class="line">Creating peer0.org2.example.com</span><br><span class="line">Creating peer1.org1.example.com</span><br><span class="line">Creating peer0.org1.example.com</span><br><span class="line">Creating cli</span><br></pre></td></tr></table></figure><h4 id="2-4-创建通道"><a href="#2-4-创建通道" class="headerlink" title="2.4 创建通道"></a>2.4 创建通道</h4><p><strong>进入Docker容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p>检查环境变量是否正确设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CHANNEL_NAME</span></span></span><br></pre></td></tr></table></figure><p><strong>设置环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel2</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：此处设置的应用通道名称环境变量必须与创建应用通道时指定的环境变量名称一致。</p></blockquote><p><strong>创建通道</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel create -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/channel2.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 002 Received block: 0</span><br></pre></td></tr></table></figure><h4 id="2-5-加入通道"><a href="#2-5-加入通道" class="headerlink" title="2.5 加入通道"></a>2.5 加入通道</h4><p>应用通道所包含组织的成员节点可以加入通道中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel join -b mychannel2.block -o orderer:7050</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">[channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br></pre></td></tr></table></figure><h4 id="2-6-更新锚点"><a href="#2-6-更新锚点" class="headerlink" title="2.6 更新锚点"></a>2.6 更新锚点</h4><p>使用Org1的管理员身份更新锚节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel update -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/Org1MSPanchors2.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><p>使用Org2的管理员身份更新锚节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer0.org2.example.com:7051 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_LOCALMSPID=<span class="string">"Org2MSP"</span> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> peer channel update -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/Org2MSPanchors2.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><h4 id="2-7-列出所加入的通道"><a href="#2-7-列出所加入的通道" class="headerlink" title="2.7 列出所加入的通道"></a>2.7 列出所加入的通道</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel list</span></span><br></pre></td></tr></table></figure><p>list命令会列出指定的Peer节点已经加入的所有应用通道的列表.</p><p>输出当前节点已加入的应用通道信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">Channels peers has joined: </span><br><span class="line">mychannel</span><br><span class="line">mychannel2</span><br></pre></td></tr></table></figure><p>从如上终端输出中可以看到，当前 peer 节点加入了两个不同的应用通道，分别为 <code>mychannel、mychannel2</code>。从而实现当前 peer 节点会维护两个账本。</p><h4 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>是一个通道对应一个账本吗？</p><p>对，一个通道中所包含的所有 Peer 节点共同维护同一个账本。</p></li><li><p>多个不同的链码会对应一个账本吗？</p><p>简单的说，一个链码也同样对应一个账本。</p></li><li><p>多通道一般应用在什么场景之下？</p><p>考虑多个不同行业、不同组织、数据隐私的不同访问策略等等的情况下应用多通道及多链。</p></li><li><p>一个 Peer 节点对应一个账本吗？</p><p>不一定，这需要考虑此 Peer 节点加入了几个应用通道，部署了几个链码等等这些情况。</p></li></ol><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/147" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/147</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章Fabric数据分发机制的实现</title>
      <link href="/2020/03/26/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC8%E7%AB%A0Fabric%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/03/26/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC8%E7%AB%A0Fabric%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、认识Gossip"><a href="#一、认识Gossip" class="headerlink" title="一、认识Gossip"></a>一、认识Gossip</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>Gossip 协议的概念</li><li>Gossip 协议的数据传输方式</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>在分布式网络中，网络节点是否具有高扩展性，节点的可用性，数据如何进行传播，且在一个不稳定的分布式网络环境中，如何保证数据的实时同步，是所有开发人员都需要关注并解决的问题。</p></blockquote><a id="more"></a><h3 id="1-认识-Gossip协议-Gossip-Protocol"><a href="#1-认识-Gossip协议-Gossip-Protocol" class="headerlink" title="1 认识 Gossip协议(Gossip Protocol)"></a>1 认识 Gossip协议(Gossip Protocol)</h3><p><strong>Gossip由来</strong></p><p>Gossip 协议取自人类的”八卦”概念，两个人只要愿意，可以随时互相交换信息。Gossip 协议最初是在 1987 年由 Alan Demers 发明的，他当时是 Xerox 的 Palo Alto 研究中心的研究员，专门研究在不可信网络环境中路由信息的方式。</p><p><strong>Gossip作用</strong></p><p>Gossip是一种去中心化的分布式协议，<strong>用于实现节点或者进程之间的信息交换</strong>，通常被用在大型的无中心化网络环境中，并且假设网络环境不太稳定，是分布式系统中被广泛使用的一种<strong>最终一致性协议</strong>。</p><p>Gossip协议是在网络中的某个节点将指定的数据发送到网络内的一组其他节点。数据通过节点像病毒一样逐个传播。最终，数据传播到系统中的每个节点。从而实现在大型分布式系统中可靠地进行数据的传播。</p><blockquote><p>简单的理解，Gossip是一种网络通信协议， 这种协议类似于人类中的谣言传播。一个人A第一次听到谣言，然后打电话给某人B以分享谣言。一旦他们挂了电话，B打电话给第三个人C，A与B分享谣言的同时，也在联系D分享谣言。这个过程一直持续到每个人都知道这个谣言。这种方式可方便地在一个网络中的所有节点之间快速传播数据。</p></blockquote><p><strong>Gossip协议所具备的特征如下：</strong></p><ul><li>Gossip 协议本质上是概率性的，节点选择其网络内随机通信的目标节点。</li><li>扩展性高：发送方节点向固定数量的接收方节点发送消息，与网络中的总节点数量无关。</li><li>低延迟：如果确认信息未到达接收节点，发送节点不会等待确认。</li><li>不需要故障检测或特定恢复操作，因为节点没有特定的角色，接收信息失败的节点不会阻止其他节点继续发送消息。</li><li>实现容错：因为节点从其它不同的节点接收消息的副本。</li></ul><p><strong>Gossip协议类型：</strong></p><ul><li><p><strong>传播协议/谣言协议（Dissemination Protocols / Rumor-Mongering Protocols）</strong>：</p><p>通过网络中的泛洪代理来工作，节点收到广播的数据后直接转发给所有的邻居节点；此方式可以提高网络的健壮性，但是容易造成广播风暴。</p></li><li><p><strong>反熵协议（Anti-Entropy Protocols）</strong>：用于修复复制数据，通过比较复制和协调差异进行操作；Hyperledger Fabric中的数据同步就是使用此方式实现。</p></li><li><p><strong>计算聚合的协议（Protocols that Compute Aggregates）</strong>：通过对网络中节点的信息进行采样，并将这些值组合起来得到系统范围内的值，从而计算出网络范围内的集合 ；之后将建立一种全面的信息流模式。</p></li></ul><h3 id="2-Gossip数据传输-Gossip-Messaging"><a href="#2-Gossip数据传输-Gossip-Messaging" class="headerlink" title="2 Gossip数据传输(Gossip Messaging)"></a>2 Gossip数据传输(Gossip Messaging)</h3><p>Gossip 协议最终的目的是将数据分发到网络中的每一个节点，那么在不同的具体应用场景中如何保证网络中的每一个节点都能够接收到对应的数据且在不稳定的网络环境中保持数据的实时同步，Gossip数据分发协议实现了两种数据传输方式：</p><ol><li><p><strong>推送方式（Push-based）：</strong></p><p>1.1 网络中的某个节点随机选择N个节点作为数据接收对象</p><p>1.2 该节点向其选中的N个节点传输相应的信息</p><p>1.3 接收到信息的节点处理它接收到的数据</p><p>1.4 接收到数据的节点再从第一步开始重复执行</p></li></ol><p><img src="http://image.chaindesk.cn/8.1_1.png/mark" alt="Gossip Push-based方式"></p><ol><li><p><strong>拉取方式（Pull-based）：</strong></p><p>2.1 某个节点周期性地选择随机N个节点询问有没有最新的信息</p><p>2.2 收到请求的节点回复请求节点其最近未收到的信息</p></li></ol><p><img src="http://image.chaindesk.cn/8.1_2.png/mark" alt="Gossip Pull-based方式"></p><h2 id="二、Fabric中数据同步的实现"><a href="#二、Fabric中数据同步的实现" class="headerlink" title="二、Fabric中数据同步的实现"></a>二、Fabric中数据同步的实现</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>Hyperledger Fabric 中数据传输的实现</li></ol><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>Hyperledger Fabric 是一个由N个节点组成的分布式网络，且 HyperLedger Fabric 通过把网络内的节点分解为执行交易（背书和提交）节点和交易排序节点，利用这些分解后的节点来优化区块链网络性能及安全性和可扩展性。但是分解之后网络需要一个安全、可靠、可扩展的数据分发协议来保证数据的完整性和一致性。为了满足这些要求，Hyperledger Fabric 中使用了 <strong>Gossip 数据分发协议</strong>。</p></blockquote><h3 id="1-Hyperledger-Fabric中的Gossip"><a href="#1-Hyperledger-Fabric中的Gossip" class="headerlink" title="1 Hyperledger Fabric中的Gossip"></a>1 Hyperledger Fabric中的Gossip</h3><p>Fabric 中 的各个 Peer 节点之间利用 Gossip 协议来完成区块广播以及状态同步的过程。Gossip 消息是连续的，通道上的每个 Peer 节点都不断地接收来自多个节点已完成一致性的区块数据。每条传输的 Gossip 消息都有相应的签名，从而由拜占庭参与者发送的伪造消息很容易地识别来，并且可以防止将消息分发给不在同一通道中的其它节点。受到延迟、网络分区或其他导致区块丢失的原因影响的节点，最终将通过联系已经拥有这些缺失区块的节点，与当前账本状态进行同步。</p><p>在 Hyperledger Fabric 网络中基于 Gossip 的数据传播协议在 Fabric 网络上执行三个主要功能：</p><ol><li><strong>通过不断识别可用的成员节点并最终监测节点离线状态的方式，对节点的发现和通道中的成员进行管理。</strong></li><li><strong>将分类帐本数据传播到通道上的所有节点。任何节点中如有缺失区块都可以通过从通道中其它节点复制正确的数据来标识缺失的区块并同步自身。</strong></li><li><strong>在通道上的所有节点上同步分类帐状态。通过允许点对点状态传输更新账本数据，保证新连接的节点以最快的速度实现数据同步。</strong></li></ol><p>基于 gossip 的广播由节点接收来自通道内其他节点的消息，然后将这些消息转发给随机选择的且在同一通道内的若干个邻居节点，这种循环不断重复，使通道中所有的成员节点的账本和状态信息不断保持与当前的最新状态同步。对于新区块的传播，通道上的 Leader Peer 节点从 Ordering 服务中提取数据，并向随机选择的邻居节点发起 Gossip 传播。</p><blockquote><p>随机选择的邻居节点数量可以通过配置文件进行配置声明。节点也可以使用拉取机制，而不是等待消息的传递。</p></blockquote><p><img src="http://image.chaindesk.cn/8.2_1.png/mark" alt="Gossip Fabric"></p><p>正如上图所示，客户端应用程序将交易提案请求提交给背书节点（Endorse Peer），背书节点处理并背书签名后返回响应，然后提交给 Ordering 服务进行排序，排序服务达成共识后生成区块，通过 deliver（）广播给各个组织中通过选举方式选择的作为代表能够连接到排序服务的 Leader Peer 节点，Leader Peer 节点随机选择N个节点将接收到的区块进行分发。另外，为了保持数据同步，每个节点会在后台周期性地与其它随机的N个节点的数据进行比较，以保持区块数据状态的同步。</p><h3 id="2-Leader节点选举"><a href="#2-Leader节点选举" class="headerlink" title="2 Leader节点选举"></a>2 Leader节点选举</h3><p>在 Hyperledger Fabric 网络中，每一个组织都会通过领导选举机制选择一个节点（Leader Peer），该节点将保持与 Ordering 服务的连接，并在其所在组织的节点之间分发从 Ordering 服务节点接收到的新区块。利用领导人选举为系统提供了有效利用 Ordering 服务带宽的能力。在 Hyperledger Fabric 中实现领导人选举有两种方式：</p><ol><li><strong>静态选举：</strong>由系统管理员手动配置实现，指定组织中的一个 peer 节点作为领导节点代表组织与 Ordering 服务建立连接。</li><li><strong>动态选举：</strong>通过执行领导人选举程序，动态从组织中选择一个 peer 节点成为领导者节点，从Ordering 服务中拉出区块，并将块分发给组织中的其他 peer 节点。</li></ol><h4 id="静态选举"><a href="#静态选举" class="headerlink" title="静态选举"></a>静态选举</h4><p>使用静态领导选举可以通过在配置文件中指定相关的参数来实现。可以定义一个节点为 Leader Peer，也可定义多个节点或组织内所有节点都为 Leader Peer。</p><p>实现静态选举机制，需要在 <code>core.yaml</code> 中配置以下参数:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line">    <span class="attr">gossip:</span></span><br><span class="line">        <span class="attr">useLeaderElection:</span> <span class="literal">false</span>    <span class="comment"># 是否指定使用选举方式产式Leader</span></span><br><span class="line">        <span class="attr">orgLeader:</span> <span class="literal">true</span>    <span class="comment"># 是否指定当前节点为Leader</span></span><br></pre></td></tr></table></figure><p>或者可以使用环境变量来配置和覆盖相应的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_GOSSIP_USELEADERELECTION=false</span><br><span class="line">export CORE_PEER_GOSSIP_ORGLEADER=true</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果两个值全部都指定为 false， 那么代表 peer 节点不会成为领导者。</p></blockquote><h4 id="动态选举"><a href="#动态选举" class="headerlink" title="动态选举"></a>动态选举</h4><p>动态领导选举可以在各个组织内各自动态选举一个 Leader 节点，它将代表各个连接到 Ordering 服务并拉出新的区块。</p><p>当选的 Leader 节点必须向组织内的其他节点定期发送心跳信息，作为处于活跃的证据。如果一名或多名节点在指定的一段时间内得不到最新消息，网络将启动新一轮领导人选举程序，最终选出新的 Leader 节点。</p><p>启用动态选举机制，需要在 <code>core.yaml</code> 中配置以下参数: </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line">    <span class="attr">gossip:</span></span><br><span class="line">        <span class="attr">useLeaderElection:</span> <span class="literal">true</span>     <span class="comment"># 是否指定使用选举方式产式Leader</span></span><br><span class="line">        <span class="attr">orgLeader:</span> <span class="literal">false</span>    <span class="comment"># 是否指定当前节点为Leader</span></span><br></pre></td></tr></table></figure><p>或者，可以使用环境变量来配置和覆盖相应参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CORE_PEER_GOSSIP_USELEADERELECTION=true</span><br><span class="line">export CORE_PEER_GOSSIP_ORGLEADER=false</span><br></pre></td></tr></table></figure><p><code>core.yaml</code> 以下配置内容指定了动态选举 Leader 的相关信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line">    <span class="attr">gossip:</span></span><br><span class="line">         <span class="attr">election:</span>   <span class="comment"># 选举Leader配置     </span></span><br><span class="line">            <span class="attr">startupGracePeriod:</span> <span class="string">15s</span>       <span class="comment"># 最长等待时间 </span></span><br><span class="line">            <span class="attr">membershipSampleInterval:</span> <span class="string">1s</span>  <span class="comment"># 检查稳定性的间隔时间     </span></span><br><span class="line">            <span class="attr">leaderAliveThreshold:</span> <span class="string">10s</span>     <span class="comment"># 进行选举的间隔时间</span></span><br><span class="line">            <span class="attr">leaderElectionDuration:</span> <span class="string">5s</span>    <span class="comment"># 声明自己为Leader的等待时间</span></span><br></pre></td></tr></table></figure><h3 id="锚节点（Anchor-Peer）"><a href="#锚节点（Anchor-Peer）" class="headerlink" title="锚节点（Anchor Peer）"></a>锚节点（Anchor Peer）</h3><p>锚节点<strong>主要用于启动来自不同组织的节点之间的 Gossip 通信</strong>。锚节点作为同一通道上的另一组织的节点的入口点，可以与目标锚节点所在组织中的每个节点通信。跨组织的 Gossip 通信必须包含在通道的范围内。</p><p>由于跨组织的通信依赖于 Gossip，某一个组织的节点需要知道来自其它组织的节点的至少一个地址(从这个节点，可以找到该组织中的所有节点的信息)。所以添加到通道的每个组织应将其节点中的至少一个节点标识为锚节点（也可以有多个锚节点，以防止单点故障）。网络启动后锚节点地址存储在通道的配置块中。</p><p>可以通过在 <code>configtx.yaml</code> 配置文件指定锚节点：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Organizations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;OrdererOrg</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">OrdererOrg</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">OrdererMSP</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/ordererOrganizations/example.com/msp</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;Org1</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">Org1MSP</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">Org1MSP</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/peerOrganizations/org1.example.com/msp</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">AnchorPeers:</span>    <span class="comment"># 指定当前组织的锚节点</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">              <span class="attr">Port:</span> <span class="number">7051</span></span><br><span class="line">    <span class="string">......</span></span><br></pre></td></tr></table></figure><h3 id="2-Fabric的数据同步实现"><a href="#2-Fabric的数据同步实现" class="headerlink" title="2 Fabric的数据同步实现"></a>2 Fabric的数据同步实现</h3><p>Hyperledger Fabric 是一个分布式区块链网络，所有的 peer 节点都会保存共享分类帐的副本（即所有事务的确切历史记录）。当新区块产生后必须通过分布式网络，使分类帐的副本在所有节点之间保持同步。</p><p>在较高的层次上，该过程如下所示：</p><ul><li>新的交易被提交给 Ordering 服务进行排序。</li><li>Ordering 服务在排序之后创建一个新区块（包含新的交易）。</li><li>Ordering 服务将新产生的区块交给所有 Peer。</li></ul><p>但在Hyperledger Fabric 网络中实际发生的情况是，Ordering 服务只向每个组织中的单个节点（Leader Peer）提供新的区块。通过 Gossip 的过程， Peer 节点自己完成了将新区块传播到其它 Peer 节点的工作：</p><ul><li>Peer 节点接收到新的消息。</li><li>该节点将消息发送到预先指定数量（随机选择的 Fabric中 默认为3个 Peer）的其他 Peer 节点。</li><li>接收到消息的每一个 Peer 节点再将消息转发给预定数量的其他 Peer 节点。</li><li>依此类推，直到所有的 Peer 节点都收到了新的消息。</li></ul><p>上面的过程称之为广播，它是一种基于推送（Push-based）的方式，通过网络传输信息，Fabric 的 Gossip 系统使用它来向所有 Peer 节点分发消息。</p><p>Gossip 协议的关键组成部分是每个节点将消息随机选择并转发给网络中其它节点。这意味着每个节点都知道网络中的所有节点，因此可以在相应的 Peer 节点中进行选择。那么，某一个节点是如何知道组织内的所有节点呢？并且如果有 Peer 节点与网络断开连接并在后期重新连接，则它将错过广播过程。</p><p>在 Hyperledger Fabric 中，每个节点都会随机性的向预先定义数量的其它节点定期广播一条消息，指示它仍处于活动状态并连接到网络。每个节点都维护着自己的网络中所有节点的列表（处于活跃的节点和无响应的节点）。</p><ul><li>当某一个节点 A 收到来自节点 B 的<strong>“活跃”</strong>消息时，它将节点 B 标记为<strong>“有效”</strong>（Peer B是网络中的一个有效节点）</li><li>如果过了一段时间，节点 A 没有收到来自节点 B 的<strong>“活跃”</strong>消息，Peer A 节点会定期尝试连接 Peer B 节点，确认是否真的无响应。如果无响应将节点 B 标记为<strong>“死亡”</strong>（Peer B不再是网络的有效节点）。</li></ul><p>这种情况之下需要一个基于拉取（Pull-based）的实现机制来向其它 Peer 节点请求它丢失的数据。在Hyperledger Fabric中， Peer 节点之间定期相互交换成员资格数据（ Peer 节点列表，活动和死亡）和分类帐本数据（事务块）。在这种机制下， Peer 节点即使因为故障或其它原因导致错过了接收新区块的广播或因为其它原因产生了缺失区块，但仍然在加入网络之后可以与其它的 Peer 节点交换信息以保持数据同步。</p><p><img src="http://image.chaindesk.cn/8.2_2.png/mark" alt="Fabric数据同步"></p><p>正如上图所示，Hyperledger Fabric使用对等体之间的 Gossip 作为容错和可扩展机制，以保持区块链分类账的所有副本同步，它减少了Orderer 节点上的负载。由于不需要固定连接来维护基于Gossip的数据传播，因此该流程可以可靠地为共享账本保证数据的一致性和完整性，包括对节点崩溃的容错。</p><p>另外，某些节点可以加入多个不同的通道，但是通过将基于节点通道订阅的机制作为消息分发策略，由于通道之间实现了相互隔离，一个通道上的节点不能在其他通道上发送或共享信息，所以节点无法将区块传播给不在通道中的节点。</p><blockquote><p>点对点消息的安全性由节点的TLS层处理，不需要签名。节点通过其由CA分配的证书进行身份验证。节点在Gossip层的身份认证会通过TLS证书体现。账本中的区块由排序服务进行签名，然后传递给通道中的领导者节点。</p><p>身份验证过程由节点的成员管理服务的提供者（MSP）进行管理。当节点第一次连接到通道中的时候，TLS会话将与成员身份绑定。这本质上是通过网络和通道中的成员身份对连接的每个节点进行身份验证。</p></blockquote><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>如何将多个 Peer 节点定义为 Leader 节点？</p><p>静态指定方式可以将多个 Peer 节点定义为 Leader 节点，将配置文件中需要指定为 Leader 节点的所属 Peer 配置的 environment 中的两项参数值设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span></span><br></pre></td></tr></table></figure><p>但在实际的生产环境中，使用太多的 Leader 节点连接到 Ordering 服务可能会降低网络带宽利用率， 所以不推荐同一个组织中设置多个 Leader 节点。</p></li><li><p>组织内的其它 Peer 节点可以与 Ordering 服务直接通信吗？</p><p>组织内的节点除了 Leader 节点， 其它所有的 Peer 节点都不能够与 Ordering 服务直接通信。</p></li></ol><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/170" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/170</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章MSP成员管理和CA服务实现</title>
      <link href="/2020/03/25/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC6%E7%AB%A0MSP%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E5%92%8CCA%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/03/25/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC6%E7%AB%A0MSP%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E5%92%8CCA%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="走进MSP"><a href="#走进MSP" class="headerlink" title="走进MSP"></a>走进MSP</h3><h2 id="一、走进MSP"><a href="#一、走进MSP" class="headerlink" title="一、走进MSP"></a>一、走进MSP</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>MSP 概念及作用</li><li>MSP 的组成结构</li><li>MSP 在 Hyperledger Fabric 中的应用</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>数据隐私及安全是区块链技术中的的重要组成部分，联盟链中由多个不同的组织组成，且每一个组织又可以由多个节点组成，那么在 Hyperledger Fabric 中使用了什么且如何确保数据隐私及安全，在这一章中我们来认识一下相关的重要内容。</p></blockquote><a id="more"></a><h3 id="1-MSP定义及作用"><a href="#1-MSP定义及作用" class="headerlink" title="1 MSP定义及作用"></a>1 MSP定义及作用</h3><p>在 Hyperledger Fabric 中，各个网络参与者之间的通信安全依赖于 <strong>PKI</strong> 标准来实现，并确保在区块链上发布的消息得到相应的认证。</p><p><strong>PKI（Public Key Infrastructure）</strong>：<strong>公钥基础结构</strong>。由向各方（如服务的用户，服务提供商）发布数字证书的证书颁发机构组成，然后他们使用它们在与其环境交换的消息中对自己进行身份验证。</p><p><strong>PKI</strong> 有四个关键要素：</p><ul><li><strong>数字证书：</strong>包含与证书持有者相关的一组属性的文档。最常见的证书类型是符合X.509标准的证书，允许在其结构中编码一方的识别细节。</li><li><strong>公钥和私钥：</strong>身份验证和消息完整性是安全通信中的重要概念。身份验证要求确保交换消息的各方创建特定消息的身份。对于具有“完整性”的消息意味着在其传输期间不能被修改。</li><li><strong>证书颁发机构：</strong>证书颁发机构向不同的参与者分发证书，这些证书由CA进行数字签名。CA是为组织的参与者提供可验证的数字身份的基础。</li><li><strong>证书撤销列表：</strong>某种原因而被撤销的证书的引用列表。</li></ul><blockquote><p>PKI 只是一个体系结构，负责生成及颁发；在 Hyperledger Fabric 中的默认 MSP 实际上是使用符合 X.509 标准的证书作为身份，采用传统的公钥基础结构（PKI）分层模型来实现。</p></blockquote><p><strong>MSP（Membership Service Provider）：</strong>成员服务提供商，是 Hyperledger Fabric 1.0版本开始抽象出来的一个模块化组件。<strong>用于定义身份验证，进行身份验证和允许访问网络的规则</strong>。更确切地说，<strong>MSP</strong> 是 Hyperledger Fabric <strong>对网络中的组成成员进行身份管理与验证的模块组件。</strong></p><p>具体作用如下：</p><ul><li>MSP 管理用户 ID。</li><li>验证想要加入网络的节点：每一个想加入网络中的节点必须提供其有效且合法的 MSP 信息。</li><li>为客户发起的交易提供凭证：在各节点（Client、Peer、Orderer）之间进行数据传输时，需要验证各节点的签名。 </li></ul><p><strong>MSP 在 Hyperledger Fabric 中的分类：</strong></p><ul><li><strong>网络MSP：</strong>对整个 Hyperledger Fabric 网络中的成员进行管理；定义参与组织的 MSP ，以及组织成员中的哪些成员被授权执行管理任务（如创建通道）</li><li><strong>通道MSP：</strong>对一个通道中的组织成员进行管理。通道在特定的一组组织之间提供私有通信。在该通道的 MSP 环境中通道策略定义了谁有权限参与通道上的某些行为（如添加组织或实例化链码）。</li><li><strong>Peer MSP：</strong>本地 MSP 在每个 Peer 的文件系统上定义，并且每个 Peer 都有一个单独的 MSP 实例。执行与通道 MSP 完全相同的功能，其限制是它仅适用于定义它的 Peer。</li><li><strong>Orderer MSP：</strong>与 Peer MSP 相同，Orderer 本地 MSP 也在其节点的文件系统上定义，仅适用于该节点。</li><li><strong>User MSP：</strong> 每一个组织都可以拥有多个不同的用户，都在其 Organizations 节点的文件系统上定义，仅适用该组织（包括该组织下的所有 Peer 节点）。</li></ul><h3 id="2-MSP-的组成结构"><a href="#2-MSP-的组成结构" class="headerlink" title="2 MSP 的组成结构"></a>2 MSP 的组成结构</h3><p>MSP的逻辑结构如下所示（与实际的物理结构会有所不同）：</p><p><img src="http://image.chaindesk.cn/6.1.1%20MSP%E6%88%90%E5%91%98.png/mark" alt="MSP成员"></p><p>如上图所示，MSP有九个元素。其中MSP名称是根文件夹名称，每个子文件夹代表MSP配置的不同元素：</p><ul><li><p><strong>根CA（Root CAs）：</strong>文件夹中包含根CA（CA：Certificate Authorities）的自签名 X.509 证书列表。用于自签名及给中间 CA 证书签名。</p></li><li><p><strong>中间CA（ICA）：</strong>包含由根据 CA 颁发的证书列表。</p></li><li><p><strong>组织单位（OUs）：</strong>这些单位列在 $FABRIC_CFG_PATH/msp/config.yaml 文件中，包含一个组织单位列表，其成员被视为该MSP所代表的组织的一部分。</p></li><li><p><strong>管理员（B）：</strong>此文件夹包含一个标识列表，用于定义具有此组织管理员角色的角色。对于标准MSP 类型，此列表中应该有一个或多个 X.509 证书。</p><p>需要注意，仅仅一个具有管理员的角色，并不意味着他们可以管理特定的资源，给定标识在管理系统方面的实际功能由管理系统资源的策略决定。</p></li><li><p><strong>撤销证书（ReCA）：</strong>保存已被撤销参与者身份的信息。</p></li><li><p><strong>签名证书（SCA）：</strong>背书节点在交易提案响应中的签名证书。此文件夹对于本地 MSP 是必需的，并且该节点必须只有一个 X.509 证书。</p></li><li><p><strong>私钥（KeyStore）：</strong>此文件夹是为 Peer 或 Orderer 节点（或客户端的本地MSP）的本地MSP定义的，并包含节点的<strong>签名密钥</strong>。此密钥以加密方式匹配 SCA 文件夹中包含的签名证书，并用于签署数据（如签署交易提议响应，作为认可阶段的一部分）。此文件夹对于本地MSP是必需的，并且必须只包含一个私钥。</p></li><li><p><strong>TLS根CA（TLS RCA）：</strong>包含组织信任的用于 TLS 通信的根 CA 的自签名 X.509 证书列表。此文件夹中必须至少有一个 TLS 根 CA X.509 证书。</p></li><li><p><strong>TLS中间CA（TLS ICA）：</strong>保存由 TLS 根 CA 颁发的中间证书列表。</p></li></ul><h3 id="3-MSP应用"><a href="#3-MSP应用" class="headerlink" title="3 MSP应用"></a>3 MSP应用</h3><p>要想初始化一个MSP实例，每一个peer节点和orderer节点都需要在本地指定其配置并启动。</p><p>首先， 为了方便地在网络中引用MSP，每个MSP都需要一个特定的名字（如 OrdererMSP、Org1MSP 或 Org2MSP.domain.com）。此名字被称之为 MSP 标识符或 MSP ID。对于每个 MSP 实例来说，MSP 标识符都必须独一无二。</p><p>在系统起始阶段，需要指定在网络中出现的所有 MSP 的验证参数，且这些参数需要在系统通道的创世区块中指定。<strong>MSP的验证参数</strong>包括<strong>MSP标识符、信任源证书、中间 CA 和管理员的证书，以及 OU 说明和 CLR</strong>。系统的创世区块会在 orderer 节点设置阶段被提供给它们，且允许它们批准创建通道的请求。如果创世区块包含两个有相同标识符的 MSP，那么 orderer 节点将拒绝系统创世区块，导致网络引导程序执行失败。</p><p>要想生成 X.509 证书以满足 MSP 配置，应用程序可以有多种方式实现：</p><ul><li>使用Openssl。在此需要注意：在 Hyperledger Fabric 中，不支持包括RSA密钥在内的证书。</li><li>使用 cryptogen 工具，其操作方法参见第三章 3.1 生成组织结构与身份证书 一节 。</li><li><strong>Hyperledger Fabric CA</strong> 也可用于生成配置 MSP 所需的密钥及证书。详见下节内容。</li></ul><p>在节点的配置文件中（对 peer 节点而言配置文件是 core.yaml 文件，对 orderer 节点而言则是orderer.yaml文件。在实际开发中可自定义配置文件名称），我们需要指定到 mspconfig 文件夹的路径，以及节点的 MSP 的 MSP 标识符。节点的 MSP 的 MSP 标识符则会作为参数 localMspId 和 LocalMSPID 的值分别提供给 peer 节点和 orderer 节点。</p><p>运行环境可以通过为 peer 使用 CORE 前缀（如 CORE_PEER_LOCALMSPID）及为 orderer 使用 ORDERER 前缀（例如 ORDERER_GENERAL_LOCALMSPID）对以上变量进行重写。如在 fabric-samples 中提供的示例配置文件 docker-compose-base.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer:$IMAGE_TAG</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=INFO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">      <span class="comment"># 指定本地 MSP ID</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line">      <span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="comment"># MSP 映射信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="comment"># TLS 映射信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.example.com:/var/hyperledger/production/orderer</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7050</span><span class="string">:7050</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="comment"># 指定本地 MSP ID</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="comment"># MSP 映射信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">         <span class="comment"># TLS 映射信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org1.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="comment"># 指定本地 MSP ID</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">         <span class="comment"># MSP 映射信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">         <span class="comment"># TLS 映射信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure><blockquote><p>对本地的 MSP 进行重新配置只能通过手动的方式实现，且该过程需要重启 peer 节点和 orderer 节点。在后期的版本中计划提供在线/动态的重新配置的功能（通过使用一个由节点管理的系统 chaincode，而不必停止node）。</p></blockquote><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><h5 id="MSP-是如何实现对身份的验证？"><a href="#MSP-是如何实现对身份的验证？" class="headerlink" title="MSP 是如何实现对身份的验证？"></a>MSP 是如何实现对身份的验证？</h5><p>身份验证过程：</p><p>首先，使用证书颁发机构对用户身份进行验证。证书颁发机构标识应用程序、Peer 和 Orderer 标识，并验证这些凭据。通过使用签名算法和签名验证算法生成签名。具体地，生成签名以签名算法开始，签名算法利用与其各自身份相关联的实体的凭证，并输出认可。生成签名，该签名是绑定到特定标识的字节数组。</p><p>接下来，签名验证算法将身份，认可和签名作为输入，如果签名字节数组与输入的认可的有效签名相对应，则输出 ‘accept’，否则输出 ‘reject’。如果输出是 ‘accept’，则用户可以看到网络中的事务并与网络中的其他参与者执行事务。如果输出为 ‘reject’，则表示用户未经过身份验证，并且无法向网络提交事务或查看任何的事务。</p></li></ol><h2 id="二、认识Fabric-CA"><a href="#二、认识Fabric-CA" class="headerlink" title="二、认识Fabric CA"></a>二、认识Fabric CA</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>了解 Fabric CA 结构及在 Hyperledger Fabric 中的作用</li><li>安装 Fabric CA</li></ol><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><h3 id="1-Fabric-CA简介"><a href="#1-Fabric-CA简介" class="headerlink" title="1 Fabric CA简介"></a>1 Fabric CA简介</h3><p>Hyperledger Fabric CA 是 Hyperledger Fabric 的证书颁发机构（CA），是超级账本 Hyperledger Fabric 内一个可选的 MemberService 组件，对网络内各个实体的身份证书进行管理，主要实现：</p><ul><li><strong>负责 Fabric 网络内所有实体（Identity）身份的注册。</strong></li><li><strong>负责对数字证书的签发，包括 ECerts（身份证书）、TCerts（交易证书）。</strong></li><li><strong>证书的续签或吊销。</strong></li></ul><p>Fabric CA 在 Hyperledger Fabric 网络中的作用如下图所示：</p><p><img src="http://image.chaindesk.cn/6.2.1%20fabric-ca_arch.png/mark" alt="fabric-ca架构图"></p><p>访问 Fabric CA 服务器可以通过 Hyperledger Fabric CA 客户端或通过其中一个 Fabric SDK 来实现，与 Hyperledger Fabric CA 服务器的所有通信都是通过 REST API 进行。</p><p>Hyperledger Fabric CA 客户端或 SDK 可以连接到 Hyperledger Fabric CA 服务器集群，集群由 HA Proxy 等实现负载均衡。服务器可能包含多个CA，每个CA都是根CA或中间CA，每个中间CA都有一个父CA。</p><p>Hyperledger Fabric CA 的身份信息保存在数据库或LDAP中。目前 Fabric CA 支持的数据库有 MySQL、PostgreSQL、SQLite；默认使用 SQLite 数据库。如果配置了 LDAP，则身份信息将保留在 LDAP 而不是数据库中。</p><p>关于 Hyperledger Fabric CA 的更多详细信息，请 <a href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/" target="_blank" rel="noopener">点击此处</a></p><h3 id="2-Fabric-CA-安装"><a href="#2-Fabric-CA-安装" class="headerlink" title="2 Fabric CA 安装"></a>2 Fabric CA 安装</h3><h4 id="2-1-环境要求"><a href="#2-1-环境要求" class="headerlink" title="2.1 环境要求"></a>2.1 环境要求</h4><ol><li><p>安装 Go1.9 或以上版本并设置 GOPATH 环境变量</p></li><li><p>安装 libtool 与 libltdl-dev 依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install libtool libltdl-dev</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有安装 libtool libltdl-dev 依赖，会在安装 Fabric CA 时产生错误</p></blockquote></li></ol><h4 id="2-2-安装服务端与客户端"><a href="#2-2-安装服务端与客户端" class="headerlink" title="2.2 安装服务端与客户端"></a>2.2 安装服务端与客户端</h4><p><strong>方式一：</strong></p><p>安装服务端与客户端二进制命令到 <strong>$GOPATH/bin</strong> 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/hyperledger/fabric-ca/cmd/...</span></span><br></pre></td></tr></table></figure><p>命令执行完成后，会自动在 <strong>$GOPATH/bin</strong> 目录下产生两个可执行文件：</p><ul><li><strong>fabric-ca-client</strong></li><li><strong>fabric-ca-server</strong></li></ul><p>设置环境变量，以便于在任何路径下都可以直接使用两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><p>除了如上方式外，还可以在 fabric-ca 目录下生成 fabric-ca-client、fabric-ca-server 两个可执行文件，方法如下：</p><p>切换至源码目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca/</span></span><br></pre></td></tr></table></figure><p>使用make命令编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make fabric-ca-server</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make fabric-ca-client</span></span><br></pre></td></tr></table></figure><p>自动在当前的 fabric-ca 目录下生成 <code>bin</code> 目录, 目录中包含 <code>fabric-ca-client</code> 与 <code>fabric-ca-server</code> 两个可执行文件。</p><p>设置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><h3 id="三、如何启动Fabric-CA"><a href="#三、如何启动Fabric-CA" class="headerlink" title="三、如何启动Fabric CA"></a>三、如何启动Fabric CA</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>认识 Fabric CA 服务器端主目录路径</li><li>启动 Fabric CA 的方式</li></ol><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h3><p>Fabric CA 服务器的主目录确定如下：</p><ul><li>如果设置了 <code>-home</code> 命令行选项，则使用其值</li><li>否则，如果 <code>FABRIC_CA_SERVER_HOME</code> 设置了环境变量，则使用其值</li><li>否则，如果 <code>FABRIC_CA_HOME</code> 设置了环境变量，则使用其值</li><li>否则，如果 <code>CA_CFG_PATH</code> 设置了环境变量，则使用其值</li><li>否则，使用当前工作目录作为服务器端的主目录.</li></ul><p>现在我们使用一个当前所在的目录作为服务器端的主目录。返回至用户的HOME目录下，创建一个 fabric-ca 目录并进入该目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir fabric-ca</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-ca</span></span><br></pre></td></tr></table></figure><blockquote><p>创建该目录的目的是作为 Fabric CA 服务器的主目录。默认服务器主目录为 “./” 。</p></blockquote><p>初始化 Fabric CA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-server init -b admin:pass</span></span><br></pre></td></tr></table></figure><p>在初始化时 <code>-b</code> 选项是必需的，用于指定注册用户的用户名与密码。</p><p>命令执行后会自动生成配置文件到至当前目录：</p><ul><li><strong>fabric-ca-server-config.yaml：</strong> 默认配置文件</li><li><strong>ca-cert.pem：</strong> PEM 格式的 CA 证书文件, 自签名</li><li><strong>fabric-ca-server.db：</strong> 存放数据的 sqlite3 数据库</li><li><strong>msp/keystore/：</strong> 路径下存放个人身份的私钥文件(_sk文件)，对应签名证书</li></ul><h3 id="2-快速启动"><a href="#2-快速启动" class="headerlink" title="2 快速启动"></a>2 快速启动</h3><p>快速启动并初始化一个 fabric-ca-server 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-server start -b admin:pass</span></span><br></pre></td></tr></table></figure><p><strong>-b：</strong> 提供注册用户的名称与密码, 如果没有使用 LDAP，这个选项为必需。默认的配置文件的名称为 <code>fabric-ca-server-config.yaml</code></p><blockquote><p>如果之前没有执行初始化命令, 则启动过程中会自动进行初始化操作. 即从主配置目录搜索相关证书和配置文件, 如果不存在则会自动生成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hg@ubuntu:~/fabric-ca$ fabric-ca-server start -b admin:pass</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Configuration file location: /home/hg/fabric-ca/fabric-ca-server-config.yaml</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Starting server in home directory: /home/hg/fabric-ca</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Server Version: <span class="number">2.0</span><span class="number">.0</span>-snapshot<span class="number">-3495963</span></span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Server Levels: &amp;&#123;Identity:<span class="number">2</span> Affiliation:<span class="number">1</span> Certificate:<span class="number">1</span> Credential:<span class="number">1</span> RAInfo:<span class="number">1</span> Nonce:<span class="number">1</span>&#125;</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] The CA key and certificate already exist</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] The key is stored by BCCSP provider <span class="string">'SW'</span></span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] The certificate is at: /home/hg/fabric-ca/ca-cert.pem</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Initialized sqlite3 database at /home/hg/fabric-ca/fabric-ca-server.db</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] The Idemix issuer public and secret key files already exist</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO]    secret key file location: /home/hg/fabric-ca/msp/keystore/IssuerSecretKey</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO]    public key file location: /home/hg/fabric-ca/IssuerPublicKey</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] The Idemix issuer revocation public and secret key files already exist</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO]    private key file location: /home/hg/fabric-ca/msp/keystore/IssuerRevocationPrivateKey</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO]    public key file location: /home/hg/fabric-ca/IssuerRevocationPublicKey</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Home directory <span class="keyword">for</span> <span class="keyword">default</span> CA: /home/hg/fabric-ca</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Operation Server Listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9443</span></span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">26</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">30</span> [INFO] Listening on http:<span class="comment">//0.0.0.0:7054</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-配置数据库-我跳过了，使用默认SQLite"><a href="#3-配置数据库-我跳过了，使用默认SQLite" class="headerlink" title="3 配置数据库(我跳过了，使用默认SQLite)"></a>3 配置数据库(我跳过了，使用默认SQLite)</h3><p>Fabric CA 默认数据库为 <strong>SQLite</strong>，默认数据库文件 <code>fabric-ca-server.db</code> 位于 Fabric CA 服务器的主目录中。SQLite 是一个嵌入式的小型的数据系统，但在一些特定的情况下，我们需要集群来支持，所以Fabric CA 也设计了支持其它的数据库系统（目前只支持 MySQL、PostgreSQL 两种）。Fabric CA 在集群设置中支持以下数据库版本：</p><ul><li><strong>PostgreSQL：</strong>9.5.5 或更高版本</li><li><strong>MySQL：</strong>5.7 或更高版本</li></ul><p>下面我们来看如何配置来实现对不同数据库的支持。</p><h4 id="3-1-配置-PostgreSQL"><a href="#3-1-配置-PostgreSQL" class="headerlink" title="3.1 配置 PostgreSQL"></a>3.1 配置 PostgreSQL</h4><p>如果使用 PostgreSQL 数据库，则需要在 Fabric CA 服务器端的配置文件进行如下设置：fabric-ca-server-config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">postgres</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="string">host=localhost</span> <span class="string">port=5432</span> <span class="string">user=Username</span> <span class="string">password=Password</span> <span class="string">dbname=fabric_ca</span> <span class="string">sslmode=verify-full</span></span><br></pre></td></tr></table></figure><p>如果要使用 TLS，则必须指定 Fabric CA 服务器配置文件中的 <code>db.tls</code> 部分。如果在 PostgreSQL 服务器上启用了 SSL 客户端身份验证，则还必须在 <code>db.tls.client</code> 部分中指定客户端证书和密钥文件。如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">certfiles:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">db-server-cert.pem</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">            <span class="attr">certfile:</span> <span class="string">db-client-cert.pem</span></span><br><span class="line">            <span class="attr">keyfile:</span> <span class="string">db-client-key.pem</span></span><br></pre></td></tr></table></figure><p><strong>certfiles</strong>：PEM 编码的受信任根证书文件列表。</p><p><strong>certfile</strong>和<strong>keyfile</strong>：Fabric CA 服务器用于与 PostgreSQL 服务器安全通信的 PEM 编码证书和密钥文件。用于服务器与数据库之间的 TLS 连接。</p><p>关于生成自签名证书可参考官方说明：<a href="https://www.postgresql.org/docs/9.5/static/ssl-tcp.html，需要注意的是，自签名证书仅用于测试目的，不应在生产环境中使用。" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.5/static/ssl-tcp.html，需要注意的是，自签名证书仅用于测试目的，不应在生产环境中使用。</a></p><p>有关在PostgreSQL服务器上配置SSL的更多详细信息，请参阅以下PostgreSQL文档：<a href="https://www.postgresql.org/docs/9.4/static/libpq-ssl.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.4/static/libpq-ssl.html</a></p><h4 id="3-2-配置-MySQL"><a href="#3-2-配置-MySQL" class="headerlink" title="3.2 配置 MySQL"></a>3.2 配置 MySQL</h4><p>如果使用 MySQL 数据库，则需要在 Fabric CA 服务器端的配置文件进行如下设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="string">root:rootpw@tcp(localhost:3306)/fabric_ca?parseTime=true&amp;tls=custom</span></span><br></pre></td></tr></table></figure><p>如果通过 TLS 连接到 MySQL 服务器，则还需要配置 <code>db.tls.client</code> 部分。如 PostgreSQL 的部分所述。</p><p>mySQL 数据库名称中允许使用字符限制。请参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/identifiers.html</a></p><p>关于 MySQL 可用的不同模式，请参阅：<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html，为正在使用的特定MySQL版本选择适当的设置。" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html，为正在使用的特定MySQL版本选择适当的设置。</a></p><h3 id="4-配置LDAP"><a href="#4-配置LDAP" class="headerlink" title="4 配置LDAP"></a>4 配置LDAP</h3><p><strong>LDAP</strong>（Lightweight Directory Access Protocol）：<strong>轻量目录访问协议</strong>。</p><p>Fabric CA服务器可以通过服务器端的配置连接到指定LDAP服务器。之后可以执行以下操作：</p><ul><li>在注册之前读取信息进行验证</li><li>对用于授权的标识属性值进行验证</li></ul><p>修改 Fabric CA 服务器的配置文件中的LDAP部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldap:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">   <span class="attr">url:</span> <span class="string">&lt;scheme&gt;://&lt;adminDN&gt;:&lt;adminPassword&gt;@&lt;host&gt;:&lt;port&gt;/&lt;base&gt;</span></span><br><span class="line">   <span class="attr">userfilter:</span> <span class="string">&lt;filter&gt;</span></span><br><span class="line">   <span class="attr">attribute:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">&lt;LDAPAttrs&gt;</span></span><br><span class="line">      <span class="attr">converters:</span><span class="comment">#将LDAP属性转换为结构CA属性</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;fcaAttrName&gt;</span> <span class="comment">#fcaAttrName是结构CA属性的名称</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&lt;fcaExpr&gt;</span><span class="comment">#`fcaExpr` 是一个表达式</span></span><br><span class="line">      <span class="attr">maps:</span></span><br><span class="line">        <span class="string">&lt;mapName&gt;:</span><span class="comment">#用于映射LDAP响应值</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;from&gt;</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&lt;to&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置信息中各部分解释如下：</strong></p><ul><li><strong>scheme：</strong>为 ldap 或 ldaps；</li><li><strong>adminDN：</strong>是admin用户的唯一名称；</li><li><strong>adminPassword：</strong>是admin用户的密码；</li><li><strong>host：</strong>是LDAP服务器的主机名或IP地址；</li><li><strong>port：</strong>是可选的端口号，默认 LDAP 为 389 ； LDAPS 为 636 ；</li><li><strong>base：</strong>用于搜索的LDAP树的可选根路径；</li><li><strong>filter：</strong>将登录用户名转换为可分辨名称时使用的过滤器；</li><li><strong>LDAPAttrs：</strong>是一个LDAP属性名称数组，代表用户从LDAP服务器请求；</li><li><strong>attribute.converters：</strong>部分用于将LDAP属性转换为结构CA属性，其中 <code>fcaAttrName</code> 是结构CA属性的名称; <code>fcaExpr</code> 是一个表达式。例如，假设是[“uid”]，是’hf.Revoker’，而是’attr（“uid”）=〜“revoker *”’。这意味着代表用户从LDAP服务器请求名为“uid”的属性。如果用户的’uid’LDAP属性的值以 revoker 开头，则为 hf.Revoker 属性赋予用户 true 的值；否则，为 hf.Revoker 属性赋予用户 false 的值。</li><li><strong>attribute.maps：</strong>部分用于映射LDAP响应值。典型的用例是将与LDAP组关联的可分辨名称映射到标识类型。</li></ul><p>配置好 LDAP 后，用户注册的过程如下：</p><ol><li>Fabric CA 客户端或客户端 SDK 使用基本授权标头发送注册请求。</li><li>Fabric CA 服务器接收注册请求，解码授权头中的身份名称和密码，使用配置文件中的 “userfilter” 查找与身份名称关联的 DN（专有名称），然后尝试 LDAP 绑定用户身份的密码。如果 LDAP 绑定成功，则注册被通过。</li></ol><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>在实际中 Fabric CA 的身份信息保存在什么地方？</p><p>可根据具体需求选择 Fabric CA 支持的数据库，一般应用选择 SQLite 即可。中、大型应用选择 MySQL 或 PostgreSQL 或 LDAP</p></li></ol><h3 id="四、Fabric-CA的具体使用：应用Fabric-CA的客户端命令"><a href="#四、Fabric-CA的具体使用：应用Fabric-CA的客户端命令" class="headerlink" title="四、Fabric CA的具体使用：应用Fabric CA的客户端命令"></a>四、Fabric CA的具体使用：应用Fabric CA的客户端命令</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><ol><li>Fabric CA 客户端主目录路径</li><li>Fabric CA客户端的相关命令</li><li>实现 Fabric CA 对身份的登记及注册</li></ol><h4 id="任务实现-2"><a href="#任务实现-2" class="headerlink" title="任务实现"></a>任务实现</h4><p>Fabric CA 可以采用客户端命令行或 RESTful API 在内的两种方式与 Fabric-CA 服务端进行交互。其中最方便的方式是通过客户端工具 <strong>fabric-ca-client</strong>。</p><p>Fabric CA 客户端的主目录路径设置如下：</p><ul><li>如果设置了 <code>--home</code> 命令行选项，以此值为首选；</li><li>如果没有设置 <code>--home</code> ，则查找 <code>FABRIC_CA_CLIENT_HOME</code> 值；</li><li>否则，查找 <code>FABRIC_CA_HOME</code> 值；</li><li>否则，查找 <code>CA_CFG_PATH</code> 值；</li><li>如果都未设置，则使用 <code>$HOME/.fabric-ca-client</code> 作为客户端的主目录。</li></ul><h3 id="1-Fabric-CA-客户端命令"><a href="#1-Fabric-CA-客户端命令" class="headerlink" title="1 Fabric CA 客户端命令"></a>1 Fabric CA 客户端命令</h3><p>fabric-ca-client 命令可以与服务端进行交互, 包括五个子命令:</p><ul><li><strong>enroll：</strong>注册获取ECert</li><li><strong>register：</strong>登记用户</li><li><strong>getcainfo</strong>：获取CA服务的证书链</li><li><strong>reenroll：</strong>重新注册</li><li><strong>revoke：</strong>撤销签发的证书身份</li><li><strong>version：</strong>Fabric CA 客户端版本信息</li></ul><p>这些命令在执行时都是通过服务端的 RESTful 接口来进行操作的。</p><h4 id="1-1-注册用户"><a href="#1-1-注册用户" class="headerlink" title="1.1 注册用户"></a>1.1 注册用户</h4><p>打开一个新的终端，首先，设置 fabric-ca-client 所在路径，然后设置 Fabric CA 客户端主目录。通过调用在 7054 端口运行的 Fabric CA 服务器来注册 ID 为 <strong>admin</strong> 且密码为 <strong>pass</strong> 的标识。得保持服务开启<code>fabric-ca-server start -b admin:pass</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client enroll -u http://admin:pass@localhost:7054  </span></span><br><span class="line">ID：admin  密码：pass</span><br></pre></td></tr></table></figure><blockquote><p>如果名称与密码不匹配， 则运行注册命令可能会产生如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Error: Response from server: Error Code: 20 - Authorization failure</span><br><span class="line">解决方式: </span><br><span class="line">删除生成的目录，之后使用启动服务时的用户名与密码注册</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">返回至目录下重新启动服务， 然后在新终端中使用 admin:pass 注册</span><br><span class="line">    $ cd ~</span><br><span class="line">    $ fabric-ca-server start -b admin:pass</span><br><span class="line">    打开新终端</span><br><span class="line">    $ export PATH=$PATH:$GOPATH/bin</span><br><span class="line">    $ export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/admin</span><br><span class="line">    $ fabric-ca-client enroll -u http://admin:pass@localhost:7054</span><br><span class="line"></span><br><span class="line">第二个问题再另一个端口打开</span><br><span class="line"><span class="meta">$</span><span class="bash">执行fabric-ca-client enroll -u http://admin:pass@localhost:7054  出现fabric-ca-client commod not found 原因不明，我在home/hg/fabric-ca目录下重新新初始化，启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash">fabric-ca-server init -b admin:pass</span></span><br><span class="line"><span class="meta">$</span><span class="bash">fabric-ca-server start -b admin:pass   //这个是开启服务，不能关  端口1</span></span><br><span class="line">再在另一个终端执行</span><br><span class="line"><span class="meta">$</span><span class="bash">fabric-ca-client enroll -u http://admin:pass@localhost:7054  //端口2</span></span><br><span class="line"></span><br><span class="line">端口1显示，表示成功</span><br><span class="line">2020/03/26 19:24:01 [INFO] signed certificate with serial number 48910820134200213190918311267575370317025657035</span><br><span class="line">2020/03/26 19:24:01 [INFO] 127.0.0.1:58542 POST /enroll 201 0 "OK"</span><br></pre></td></tr></table></figure></blockquote><p><strong>参数解释：</strong></p><ul><li><strong>-u：</strong>进行连接的 fabric-ca-server 服务地址。</li></ul><p><strong>enroll</strong> 命令访问指定的 Fabric CA 服务，采用 <strong>admin</strong> 用户进行注册。 在 Fabric CA 客户端主目录下创建配置文件 <code>fabric-ca-clien-config.yaml</code> 和 <code>msp</code> 子目录，存储注册证书（ECert），相应的私钥和 CA 证书链 PEM 文件。我们可以在终端输出中看到指示 PEM 文件存储位置的相关信息。</p><p>生成的文件结构如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree fabric-ca/clients/</span></span><br><span class="line">fabric-ca/clients/</span><br><span class="line">└── admin</span><br><span class="line">    ├── fabric-ca-client-config.yaml</span><br><span class="line">    └── msp</span><br><span class="line">        ├── cacerts</span><br><span class="line">        │   └── localhost-7054.pem</span><br><span class="line">        ├── keystore</span><br><span class="line">        │   └── 7441dddf832b4495cac12c05cc20b242f2ce545c5720010a83c11437157ac69d_sk</span><br><span class="line">        ├── signcerts</span><br><span class="line">        │   └── cert.pem</span><br><span class="line">        └── user</span><br></pre></td></tr></table></figure><blockquote><p>提示：可以使用 <code>$ tree fabric-ca/clients/</code> 命令查看目录结构</p></blockquote><h4 id="1-2-登记用户"><a href="#1-2-登记用户" class="headerlink" title="1.2 登记用户"></a>1.2 登记用户</h4><p>注册成功后的用户可以使用 register 命令来发起登记请求：</p><p><strong>Fabric CA 服务器在注册期间进行了三次授权检查：</strong></p><ol><li><strong>注册者（即调用者）必须具有 “hf.Registrar.Roles” 属性</strong>，其中包含逗号分隔的值列表，其中一个值等于要注册的身份类型； 如，如果注册商具有值为 “<strong>peer，app，user</strong>” 的 “hf.Registrar.Roles” 属性，则注册商可以注册 peer，app 和 user 类型的身份，但不能注册 orderer。</li><li><strong>注册者的登记其范围内的用户</strong>。例如，具有 “a.b” 的从属关系的注册者可以登记具有 “a.b.c” 的从属关系的身份，但是可以不登记具有 “a.c” 的从属关系的身份。如果登记请求中未指定任何从属关系，则登记的身份将被授予注册者同样的归属范围。</li><li>如果满足以下所有条件，<strong>注册者可以指定登记用户属性</strong>：<ul><li>注册者可以登记具有前缀 “hf” 的 Fabric CA 保留属性。只有当注册商拥有该属性并且它是hf.Registrar.Attributes 属性的值的一部分时。此外，如果属性是类型列表，则登记的属性值必须等于注册者具有的值的一个子集。如果属性的类型为 boolean，则只有当注册者的属性值为 “true” 时，注册者才能登记该属性。</li><li>注册自定义属性（即名称不以 ‘hf.’ 开头的任何属性）要求注册者具有 ‘hf.Registar.Attributes’ 属性，其中包含要注册的属性或模式的值。唯一支持的模式是末尾带有 “<em>” 的字符串。例如，“a.b.\</em>” 是匹配以 “a.b” 开头的所有属性名称的模式。例如，如果注册者具有hf.Registrar.Attributes = orgAdmin，则注册者可以在身份中添加或删除唯一的 orgAdmin 属性。</li><li>如果请求的属性名称为 “hf.Registrar.Attributes”，则执行附加检查以查看此属性的请求值是否等于 “hf.Registrar.Attributes” 的注册者值的子集。如，如果注册者的 hf.Registrar.Attributes 的值是 ‘a.b.<em>，x.y.z’ 并且所请求的属性值是 ‘a.b.c，x.y.z’，那么它是有效的，因为 ‘a.b.c’ 匹配 ‘a.b</em> ‘，’x.y.z’ 匹配注册者的 ‘x.y.z’ 值。</li></ul></li></ol><p>如下命令，使用<strong>管理员</strong>标识的凭据注登记 ID 为 “admin2” 的新用户，从属关系为 “org1.department1”，名为 “hf.Revoker” 的属性值为 “true”，以及属性名为 “admin”的值为 “true”。“：ecert” 后缀表示默认情况下，“admin” 属性及其值将插入用户的注册证书中，实现访问控制决策。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client register --id.name admin2 --id.affiliation org1.department1 --id.attrs <span class="string">'hf.Revoker=true,admin=true:ecert'</span></span></span><br></pre></td></tr></table></figure><p>执行后输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020/03/26 22:37:11 [INFO] Configuration file location: /home/hg/fabric-ca/clients/admin/fabric-ca-client-config.yaml</span><br><span class="line">Password: gSArDmBauVFR</span><br></pre></td></tr></table></figure><blockquote><p><strong>命令执行成功后返回该新登记用户的密码</strong>。</p><p><strong>如果想使用指定的密码, 在命令中添加选项 –id.secret password 即可</strong></p></blockquote><p>登记时可以将多个属性指定为 <code>-id.attrs</code>标志的一部分，每个属性必须以逗号分隔。对于包含逗号的属性值，必须将该属性封装在双引号中。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client register -d --id.name admin2 --id.affiliation org1.department1 --id.attrs <span class="string">'"hf.Registrar.Roles=peer,user",hf.Revoker=true'</span>    //登记的另一种方式，多用户</span></span><br></pre></td></tr></table></figure><h4 id="1-3-登记注册节点"><a href="#1-3-登记注册节点" class="headerlink" title="1.3 登记注册节点"></a>1.3 登记注册节点</h4><p>登记Peer或Orderer节点的操作与登记用户身份类似；可以通过 -M 指定本地 MSP 的根路径来在其下存放证书文件</p><p>下面我们登记一个名为 peer1 的节点，登记时指定密码，而不是让服务器为生成。</p><h5 id="登记节点"><a href="#登记节点" class="headerlink" title="登记节点:"></a>登记节点:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client register --id.name peer1 --id.type peer --id.affiliation org1.department1 --id.secret peer1pw    //id.secret 表示指定密码</span></span><br></pre></td></tr></table></figure><h5 id="注册节点"><a href="#注册节点" class="headerlink" title="注册节点"></a>注册节点</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/peer1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client enroll -u http://peer1:peer1pw@localhost:7054 -M <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp   //上下表示在一行，</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-M：</strong> 指定生成证书存放目录 MSP 的路径, 默认为 “msp”</li></ul><blockquote><p>命令执行成功后会在 <code>$FABRIC_CA_CLIENT_HOME</code> 目录下生成指定的 msp 目录, 在此目录下生成 msp 的私钥和证书。</p></blockquote><h4 id="1-4-其它命令"><a href="#1-4-其它命令" class="headerlink" title="1.4 其它命令"></a>1.4 其它命令</h4><h5 id="getcainfo命令"><a href="#getcainfo命令" class="headerlink" title="getcainfo命令"></a>getcainfo命令</h5><p>通常，MSP 目录的 cacerts 目录必须包含其他证书颁发机构的证书颁发机构链，代表 Peer 的所有信任根。</p><p>以下内容将在 localhost上启动第二个 Fabric CA 服务器，侦听端口 7055，名称为 “CA2”。这代表完全独立的信任根，并由区块链上的其他成员管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_SERVER_HOME=<span class="variable">$HOME</span>/ca2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-server start -b admin:ca2pw -p 7055 -n CA2</span></span><br></pre></td></tr></table></figure><p>打开一个新终端，使用如下命令将CA2的证书链安装到peer1的MSP目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/peer1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client getcainfo -u http://localhost:7055 -M <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp</span></span><br></pre></td></tr></table></figure><h5 id="reenroll命令"><a href="#reenroll命令" class="headerlink" title="reenroll命令"></a>reenroll命令</h5><p>如果注册证书即将过期或已被盗用。可以使用 reenroll 命令以重新生成新的签名证书材料</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/peer1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client reenroll</span></span><br></pre></td></tr></table></figure><h5 id="revoke命令"><a href="#revoke命令" class="headerlink" title="revoke命令"></a>revoke命令</h5><p>身份或证书都可以被撤销，撤销身份会撤销其所拥有的所有证书，并且还将阻止其获取新证书。被撤销后，Fabtric CA 服务器从此身份收到的所有请求都将被拒绝。</p><p>使用 revoke 命令的客户端身份必须拥有足够的权限（hf.Revoker为true, 并且被撤销者机构不能超出撤销者机构的范围）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fabric-ca-client revoke -e peer1 -r <span class="string">"affiliationchange"</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-e：</strong>指定被撤销的身份</li><li><strong>-r：</strong>指定被撤销的原因</li></ul><p>命令执行后输出内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configuration file location: /home/kevin/fabric-ca/clients/admin/fabric-ca-client-config.yaml</span><br><span class="line">Sucessfully revoked certificates: [&#123;Serial:21ed80434dd59cb1f80f89b85ebf55b3f677a54e AKI:1a99482cc8fe46349f0bd7ad7095985177708207&#125; &#123;Serial:4cf57dc2a8a70609e6eaaf3094e1ab3ff6aabe91 AKI:1a99482cc8fe46349f0bd7ad7095985177708207&#125;]</span><br></pre></td></tr></table></figure><p>另一种撤销身份的方式是可以指定其AKI（授权密钥标识符）和序列号来操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fabric-ca-client revoke -a xxx -s yyy -r &lt;reason&gt;</span><br></pre></td></tr></table></figure><p>可以使用 openssl 命令获取 AKI 和证书的序列号，并将它们传递给 <code>revoke</code> 命令以撤销所述证书，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serial=$(openssl x509 -in userecert.pem -serial -noout | cut -d "=" -f 2)</span><br><span class="line">aki=$(openssl x509 -in userecert.pem -text | awk '/keyid/ &#123;gsub(/ *keyid:|:/,"",$1);print tolower($0)&#125;')</span><br><span class="line">fabric-ca-client revoke -s $serial -a $aki -r affiliationchange</span><br></pre></td></tr></table></figure><h3 id="2-查看AKI和序列号"><a href="#2-查看AKI和序列号" class="headerlink" title="2 查看AKI和序列号"></a>2 查看AKI和序列号</h3><p>AKI: <strong>公钥标识号, 代表了对该证书进行签发机构的身份</strong></p><p><strong>查看根证书的AKI与序列号信息:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl x509 -<span class="keyword">in</span> <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp/signcerts/cert.pem -text -noout</span></span><br></pre></td></tr></table></figure><p>输出内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:    # 序列号</span><br><span class="line">            74:48:88:33:70:1a:01:a0:ad:32:29:6e:c5:ab:5a:fa:3b:91:25:a4</span><br><span class="line">   ......</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">           ......</span><br><span class="line">            X509v3 Authority Key Identifier:     # keyid后面的内容就是 AKI</span><br><span class="line">                keyid:45:B1:50:B6:CD:8A:8D:C5:9B:9E:5F:75:15:47:D6:C0:AD:75:FE:71</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:  # 序列号</span><br><span class="line">            73:18:52:67:25:94:8a:e1:fe:00:8a:21:be:a2:9f:ca:bb:14:62:fe</span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA256</span><br><span class="line">        Issuer: C=US, ST=North Carolina, O=Hyperledger, OU=Fabric, CN=fabric-ca-server</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Mar 26 15:07:00 2020 GMT</span><br><span class="line">            Not After : Mar 26 15:12:00 2021 GMT</span><br><span class="line">        Subject: C=US, ST=North Carolina, O=Hyperledger, OU=peer, OU=org1, OU=department1, CN=peer1</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: id-ecPublicKey</span><br><span class="line">                Public-Key: (256 bit)</span><br><span class="line">                pub: </span><br><span class="line">                    04:3d:d3:e0:86:d7:83:68:28:13:c2:0b:44:9b:e8:</span><br><span class="line">                    7f:fa:27:d3:7a:2d:4a:82:45:78:bf:b7:90:c2:93:</span><br><span class="line">                    db:a4:d9:aa:9c:0e:6c:03:e3:6e:3c:2a:a6:7e:6b:</span><br><span class="line">                    73:cd:3c:27:c1:c6:a2:26:6a:50:d9:7b:10:8f:fb:</span><br><span class="line">                    08:03:73:bb:db</span><br><span class="line">                ASN1 OID: prime256v1</span><br><span class="line">                NIST CURVE: P-256</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:FALSE</span><br><span class="line">            X509v3 Subject Key Identifier:  </span><br><span class="line">                E3:4E:BD:52:94:C9:92:24:F0:03:65:E5:22:CE:F8:F6:4B:A7:48:49</span><br><span class="line">            X509v3 Authority Key Identifier:       # keyid后面的内容就是 AKI</span><br><span class="line">                keyid:F2:60:57:91:72:BE:BB:2C:D0:31:F4:28:1F:E3:49:EE:7A:F9:92:43</span><br><span class="line"></span><br><span class="line">            X509v3 Subject Alternative Name: </span><br><span class="line">                DNS:ubuntu</span><br><span class="line">            1.2.3.4.5.6.7.8.1: </span><br><span class="line">                &#123;"attrs":&#123;"hf.Affiliation":"org1.department1","hf.EnrollmentID":"peer1","hf.Type":"peer"&#125;&#125;</span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA256</span><br><span class="line">         30:44:02:20:05:9e:65:6a:af:12:42:35:1d:e6:d0:1e:e4:a6:</span><br><span class="line">         7d:79:94:b8:ed:56:d9:1f:ad:b9:7b:d9:2b:1e:08:83:4f:bf:</span><br><span class="line">         02:20:6a:7f:e3:c2:aa:8e:6e:8c:f9:3c:9a:84:7d:4b:e6:7e:</span><br><span class="line">         da:8d:be:87:95:74:4b:1e:98:65:00:f4:e7:f3:01:f0</span><br></pre></td></tr></table></figure><h4 id="2-1-单独获取AKI"><a href="#2-1-单独获取AKI" class="headerlink" title="2.1 单独获取AKI"></a>2.1 单独获取AKI</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl x509 -<span class="keyword">in</span> <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp/signcerts/cert.pem -text -noout | awk <span class="string">'/keyid/ &#123;gsub (/ *keyid:|:/,"",$1);print tolower($0)&#125;'</span></span></span><br></pre></td></tr></table></figure><p>输出内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f260579172bebb2cd031f4281fe349ee7af99243</span><br></pre></td></tr></table></figure><h4 id="2-2-单独获取序列号"><a href="#2-2-单独获取序列号" class="headerlink" title="2.2 单独获取序列号"></a>2.2 单独获取序列号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl x509 -<span class="keyword">in</span> <span class="variable">$FABRIC_CA_CLIENT_HOME</span>/msp/signcerts/cert.pem -serial -noout | cut -d <span class="string">"="</span> -f 2</span></span><br></pre></td></tr></table></figure><p>输出内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7318526725948AE1FE008A21BEA29FCABB1462FE</span><br></pre></td></tr></table></figure><h4 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>在实际的生产环境中 Fabric CA 需要考虑哪些问题？</p><p>采用PKI推荐的分层结构，即根 CA、中间 CA 甚至根据实际需求场景更深层的 CA 来实现对身份的管理；</p><p>为了实现高可用的负载均衡，正如官方推荐的使用 HA Proxy 软件或 Nginx等来部署集群环境。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章链码的开发与实战</title>
      <link href="/2020/03/24/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC5%E7%AB%A0%E9%93%BE%E7%A0%81%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2020/03/24/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC5%E7%AB%A0%E9%93%BE%E7%A0%81%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、如何利用Fabric提供的接口编写链码"><a href="#一、如何利用Fabric提供的接口编写链码" class="headerlink" title="一、如何利用Fabric提供的接口编写链码"></a>一、如何利用Fabric提供的接口编写链码</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>牢记编写链码所需要的两个重要包</li><li>开发链码所必须实现的接口及方法</li><li>开发链码文件的基本结构</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><p>开发链码，离不开 Hyperledger Fabric 提供的 SDK ，为了方便诸多不同的应用场景且使用不同语言的开发人员，Hyperledger Fabric 提供了许多不同的 SDK 来支持各种编程语言。如：</p><ul><li>Hyperledger Fabric Node SDK：<a href="https://github.com/hyperledger/fabric-sdk-node" target="_blank" rel="noopener">https://github.com/hyperledger/fabric-sdk-node</a></li><li>Hyperledger Fabric Java SDK：<a href="https://github.com/hyperledger/fabric-sdk-java" target="_blank" rel="noopener">https://github.com/hyperledger/fabric-sdk-java</a></li><li>Hyperledger Fabric Python SDK：<a href="https://github.com/hyperledger/fabric-sdk-py" target="_blank" rel="noopener">https://github.com/hyperledger/fabric-sdk-py</a></li><li>Hyperledger Fabric Go SDK：<a href="https://github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">https://github.com/hyperledger/fabric-sdk-go</a></li></ul><p>在本课程中我们将使用 Golang 进行链码的开发，所以我们应该确定在本系统中有 Hyperledger Fabric 提供的相关API，其它语言的 SDK 我们不在本课程中进行讨论。</p><a id="more"></a><p>如果本地系统中没有相关的API，请执行如下下载命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/hyperledger/fabric/core/chaincode/shim   //2.0版本没有shim包</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">wget https://github.com/hyperledger/fabric/archive/v1.2.0.tar.gz </span></span><br><span class="line">hg@ubuntu:/home/fabric-1.2.0/core/chaincode/shim$ sudo cp -Rf /home/fabric-1.2.0/core/chaincode/shim/* /home/hg/go/src/github.com/hyperledger/fabric/core/chaincode/shim/</span><br><span class="line">//将shim包拷贝过去</span><br></pre></td></tr></table></figure><h3 id="1-链码接口"><a href="#1-链码接口" class="headerlink" title="1 链码接口"></a>1 链码接口</h3><p>链码启动必须通过调用 shim 包中的 Start 函数，而 Start 函数被调用时需要传递一个类型为 Chaincode 的参数，这个参数 Chaincode 是一个接口类型，该接口中有两个重要的函数 Init 与 Invoke 。</p><p>Chaincode 接口定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Chaincode <span class="keyword">interface</span>&#123;</span><br><span class="line">    Init(stub ChaincodeStubInterface) peer.Response</span><br><span class="line">    Invoke(stub ChaincodeStubInterface) peer.Response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Init 与 Invoke 方法</strong></p><p>编写链码，关键是实现 Init 与 Invoke 两个方法，必须由所有链码实现。Fabric 通过调用指定的函数来运行事务。</p><ul><li><strong>Init：</strong>在<strong>链码实例化或升级时被调用</strong>, 完成初始化数据的工作。</li><li><strong>invoke：</strong>更<strong>新或查询提案事务中的分类帐本数据状态时</strong>，Invoke 方法被调用， 因此响应调用或查询的业务实现逻辑都需要在此方法中编写实现。</li></ul><p>在实际开发中，开发人员可以自行定义一个结构体，然后重写 Chaincode 接口的两个方法，并将两个方法指定为自定义结构体的成员方法；具体可参考下一节的内容。</p><h3 id="2-必要结构"><a href="#2-必要结构" class="headerlink" title="2 必要结构"></a>2 必要结构</h3><p><strong>依赖包</strong></p><p>shim 包为链码提供了 API 用来访问/操作数据状态、事务上下文和调用其他链代码；peer 包提供了链码执行后的响应信息。所以开发链码需要引入如下依赖包：</p><ul><li>“github.com/hyperledger/fabric/core/chaincode/shim”<ul><li>shim 包提供了链码与账本交互的中间层。</li><li>链码通过 shim.ChaincodeStub 提供的方法来读取和修改账本的状态。</li></ul></li><li>“github.com/hyperledger/fabric/protos/peer”<ul><li>peer.Response：封装的响应信息。</li></ul></li></ul><p>一个开发的链码源文件的必要结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入必要的包</span></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">    <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个结构体</span></span><br><span class="line"><span class="keyword">type</span> SimpleChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构体添加Init方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在该方法中实现链码初始化或升级时的处理逻辑</span></span><br><span class="line">  <span class="comment">// 编写时可灵活使用stub中的API</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结构体添加Invoke方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在该方法中实现链码运行中被调用或查询时的处理逻辑</span></span><br><span class="line">  <span class="comment">// 编写时可灵活使用stub中的API</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，需要调用shim.Start（ ）方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := shim.Start(<span class="built_in">new</span>(SimpleChaincode))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     fmt.Printf(<span class="string">"Error starting Simple chaincode: %s"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为链码是一个可独立运行的应用，所以必须声明在一个 main 包中，并且提供相应的 main 函数做为应用入口。</p></blockquote><h2 id="二、如何操作账本数据：熟悉链码相关API"><a href="#二、如何操作账本数据：熟悉链码相关API" class="headerlink" title="二、如何操作账本数据：熟悉链码相关API"></a>二、如何操作账本数据：熟悉链码相关API</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>掌握与账本进行交互的相关 API 种类</li><li>熟知与参数、账本状态操作相关的 API</li></ol><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>现在我们知道了编写链码的基本接口及所需要的结构，那么实际中对账本数据该如何在什么情况下调用什么 API 进行操作？</p></blockquote><p>shim 包提供给链码的相应接口有如下几种类型：</p><ul><li><strong>参数解析 API：</strong>调用链码时需要给被调用的目标函数/方法传递参数，与参数解析相关的 API 提供了获取这些参数（包含被调用的目标函数/方法名称）的方法。</li><li><strong>账本状态数据操作 API：</strong>该类型的 API 提供了对账本数据状态进行操作的方法，包括对状态数据的查询及事务处理等。</li><li><strong>交易信息获取 API：</strong>获取提交的交易信息的相关 API。</li><li><strong>事件处理 API：</strong>与事件处理相关的 API。</li><li><strong>对 PrivateData 操作的 API：</strong> Hyperledger Fabric 在 1.2.0 版本中新增的对私有数据操作的相关 API。</li></ul><p>下面我们介绍每一种类型相对应的 API 的定义及调用时所需参数。</p><h3 id="1-参数解析相关API"><a href="#1-参数解析相关API" class="headerlink" title="1 参数解析相关API"></a>1 参数解析相关API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GetArgs() [][]<span class="keyword">byte</span>：返回调用链码时在交易提案中指定提供的被调用函数及参数列表</span><br><span class="line"></span><br><span class="line">GetArgsSlice() ([]<span class="keyword">byte</span>, error)：返回调用链码时在交易提案中指定提供的参数列表</span><br><span class="line"></span><br><span class="line">GetFunctionAndParameters() (function <span class="keyword">string</span>, params []<span class="keyword">string</span>)：返回调用链码时在交易提案中指定提供的被调用的函数名称及其参数列表</span><br><span class="line"></span><br><span class="line">GetStringArgs() []<span class="keyword">string</span>：返回调用链码时指定提供的参数列表</span><br></pre></td></tr></table></figure><blockquote><p>在实际开发中，常用的获取被调用函数及参数列表的API一般为： GetFunctionAndParameters() 及 GetStringArgs() 两个。</p></blockquote><h3 id="2-账本数据状态操作API"><a href="#2-账本数据状态操作API" class="headerlink" title="2 账本数据状态操作API"></a>2 账本数据状态操作API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GetState(key <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, error) ：根据指定的 Key 查询相应的数据状态。</span><br><span class="line"></span><br><span class="line">PutState(key <span class="keyword">string</span>, value []<span class="keyword">byte</span>) error：根据指定的 key，将对应的 value 保存在分类账本中。</span><br><span class="line"></span><br><span class="line">DelState(key <span class="keyword">string</span>) error：根据指定的 key 将对应的数据状态删除</span><br><span class="line"></span><br><span class="line">GetStateByRange(startKey, endKey <span class="keyword">string</span>) (StateQueryIteratorInterface, error)：根据指定的开始及结束 key，查询范围内的所有数据状态。注意：结束 key 对应的数据状态不包含在返回的结果集中。</span><br><span class="line"></span><br><span class="line">GetHistoryForKey(key <span class="keyword">string</span>) (HistoryQueryIteratorInterface, error)：根据指定的 key 查询所有的历史记录信息。</span><br><span class="line"></span><br><span class="line">CreateCompositeKey(objectType <span class="keyword">string</span>, attributes []<span class="keyword">string</span>) (<span class="keyword">string</span>, error)：创建一个复合键。</span><br><span class="line"></span><br><span class="line">SplitCompositeKey(compositeKey <span class="keyword">string</span>) (<span class="keyword">string</span>, []<span class="keyword">string</span>, error)：将指定的复合键进行分割。</span><br><span class="line"></span><br><span class="line">GetQueryResult(query <span class="keyword">string</span>) (StateQueryIteratorInterface, error)：对(支持富查询功能的)状态数据库进行富查询，目前支持富查询的只有 CouchDB。</span><br></pre></td></tr></table></figure><h3 id="3-交易信息相关API"><a href="#3-交易信息相关API" class="headerlink" title="3 交易信息相关API"></a>3 交易信息相关API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GetTxID() <span class="keyword">string</span>：**返回交易提案中指定的交易 ID。</span><br><span class="line"></span><br><span class="line">GetChannelID() <span class="keyword">string</span>：**返回交易提案中指定的 Channel ID。</span><br><span class="line"></span><br><span class="line">GetTxTimestamp() (\*timestamp.Timestamp, error)：**返回交易创建的时间戳，这个时间戳是peer 接收到交易的具体时间。</span><br><span class="line"></span><br><span class="line">GetBinding() ([]<span class="keyword">byte</span>, error)：**返回交易的绑定信息。如果一些临时信息，以避免重复性攻击。</span><br><span class="line"></span><br><span class="line">GetSignedProposal() (\*pb.SignedProposal, error)：**返回与交易提案相关的签名身份信息。</span><br><span class="line"></span><br><span class="line">GetCreator() ([]<span class="keyword">byte</span>, error)：**返回该交易提交者的身份信息。</span><br><span class="line"></span><br><span class="line">GetTransient() (<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, error)：**返回交易中不会被写至账本中的一些临时信息。</span><br></pre></td></tr></table></figure><h3 id="4-事件处理API"><a href="#4-事件处理API" class="headerlink" title="4 事件处理API"></a>4 事件处理API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetEvent(name <span class="keyword">string</span>, payload []<span class="keyword">byte</span>) error：**设置事件，包括事件名称及内容。</span><br></pre></td></tr></table></figure><h3 id="5-对-PrivateData-操作的-API"><a href="#5-对-PrivateData-操作的-API" class="headerlink" title="5 对 PrivateData 操作的 API"></a>5 对 PrivateData 操作的 API</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GetPrivateData(collection, key <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, error)：**根据指定的 key，从指定的私有数据集中查询对应的私有数据。</span><br><span class="line"></span><br><span class="line">PutPrivateData(collection <span class="keyword">string</span>, key <span class="keyword">string</span>, value []<span class="keyword">byte</span>) error：**将指定的 key 与 value 保存到私有数据集中。</span><br><span class="line"></span><br><span class="line">DelPrivateData(collection, key <span class="keyword">string</span>) error：**根据指定的 key 从私有数据集中删除相应的数据。</span><br><span class="line"></span><br><span class="line">GetPrivateDataByRange(collection, startKey, endKey <span class="keyword">string</span>) (StateQueryIteratorInterface, error)：**根据指定的开始与结束 key 查询范围（不包含结束key）内的私有数据。</span><br><span class="line"></span><br><span class="line">GetPrivateDataByPartialCompositeKey(collection, objectType <span class="keyword">string</span>, keys []<span class="keyword">string</span>) (StateQueryIteratorInterface, error)：**根据给定的部分组合键的集合，查询给定的私有状态。</span><br><span class="line"></span><br><span class="line">GetPrivateDataQueryResult(collection, query <span class="keyword">string</span>) (StateQueryIteratorInterface, error)：**根据指定的查询字符串执行富查询 （只支持支持富查询的 CouchDB）。</span><br></pre></td></tr></table></figure><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>通过 put 写入的数据状态能立刻 get 到吗？</p><p>不能立刻 get 到，因为 put 只是链码执行的模拟交易（防止重复提交攻击），并不会真正将状态保存到账本中，必须经过Orderer达成共识之后，将数据状态保存在区块中，然后保存在各 peer 节点的账本中。</p></li></ol><h2 id="三、链码实现的Hello-World"><a href="#三、链码实现的Hello-World" class="headerlink" title="三、链码实现的Hello World"></a>三、链码实现的Hello World</h2><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>使用链码相关的API实现一个简单的 Hello World 入门应用</li><li>使用开发测试模式测试 Hello World 应用</li></ol><h4 id="任务实现-2"><a href="#任务实现-2" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>前面我们已经接触了与链码相关的内容，下面我们根据已掌握的链码知识实现一个简单的链码应用。该应用需求较为简单：链码在实例化时向账本保存一个初始数据，key 为 Hello， value 为 World，然后用户发出查询请求，可以根据 key 查询到相应的 value。</p></blockquote><h3 id="1-链码开发"><a href="#1-链码开发" class="headerlink" title="1 链码开发"></a>1 链码开发</h3><ol><li><p><strong>创建文件夹</strong></p><p>进入 <code>fabric-samples/chaincode/</code> 目录下并创建一个名为 <code>hello</code> 的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hyfa/fabric-samples/chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hello</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建并编辑链码文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim hello.go</span></span><br></pre></td></tr></table></figure></li><li><p><strong>导入链码依赖包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>编写主函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   err := shim.Start(<span class="built_in">new</span>(HelloChaincode))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"链码启动失败: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义结构体</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type HelloChaincode struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现 Chaincode 接口</strong></p><p>实现 <code>Chaincode</code> 接口必须重写 <strong>Init</strong> 与 <strong>Invoke</strong> 两个方法。</p><p><strong>Init</strong> 函数：初始化数据状态</p><ul><li>获取参数并判断参数长度是否为2<ul><li>参数: Key, Value</li></ul></li><li>调用 PutState 函数将状态写入账本中</li><li>如果有错误, 则返回</li><li>打印输出提示信息</li><li>返回成功</li></ul><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化/升级链码时被自动调用</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["Hello","World"]'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *HelloChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"开始实例化链码...."</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取参数</span></span><br><span class="line">   <span class="comment">//args := stub.GetStringArgs()</span></span><br><span class="line">   _, args := stub.GetFunctionAndParameters()</span><br><span class="line">   <span class="comment">// 判断参数长度是否为2个</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"指定了错误的参数个数"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"保存数据......"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过调用PutState方法将数据保存在账本中</span></span><br><span class="line">   err := stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"保存数据时发生错误..."</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"实例化链码成功"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>Invoke</strong> 函数</p><ul><li><p>获取参数并判断长度是否为1</p></li><li><p>利用第1个参数获取对应状态 GetState(key)</p></li><li><p>如果有错误则返回</p></li><li><p>如果返回值为空则返回错误</p></li><li><p>返回成功状态</p><p>具体实现代码如下：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对账本数据进行操作时被自动调用(query, invoke)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *HelloChaincode)</span>  <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 获取调用链码时传递的参数内容(包括要调用的函数名及参数)</span></span><br><span class="line">    fun, args := stub.GetFunctionAndParameters()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户意图</span></span><br><span class="line">    <span class="keyword">if</span> fun == <span class="string">"query"</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(stub, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> shim.Error(<span class="string">"非法操作, 指定功能不能实现"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>实现查询函数</strong></p><p>函数名称为 query，具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">   <span class="comment">// 检查传递的参数个数是否为1</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"指定的参数错误，必须且只能指定相应的Key"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据指定的Key调用GetState方法查询数据</span></span><br><span class="line">   result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"根据指定的 "</span> + args[<span class="number">0</span>] + <span class="string">" 查询数据时发生错误"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"根据指定的 "</span> + args[<span class="number">0</span>] + <span class="string">" 没有查询到相应的数据"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回查询结果</span></span><br><span class="line">   <span class="keyword">return</span> shim.Success(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-链码测试"><a href="#2-链码测试" class="headerlink" title="2 链码测试"></a>2 链码测试</h3><ol><li><p><strong>启动网络</strong></p><p>进入 <code>fabric-samples/chaincode-docker-devmode/</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../chaincode-docker-devmode/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构建并启动链码</strong></p><p><strong>2.1 打开一个新的终端2，进入 chaincode 容器：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br></pre></td></tr></table></figure><p><strong>2.2 编译链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> hello</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go build</span></span><br></pre></td></tr></table></figure><p><strong>2.3 启动链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=hellocc:0 ./hello</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">hg@ubuntu:~/hyfa/fabric-samples/chaincode-docker-devmode$ sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br><span class="line">[sudo] password for hg: </span><br><span class="line">root@d36c558ae252:/opt/gopath/src/chaincode# cd hello/</span><br><span class="line">root@d36c558ae252:/opt/gopath/src/chaincode/hello# go build</span><br><span class="line">root@d36c558ae252:/opt/gopath/src/chaincode/hello# ls</span><br><span class="line">hello  hello.go</span><br><span class="line">root@d36c558ae252:/opt/gopath/src/chaincode/hello# CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=hellocc:0 ./hello</span><br><span class="line">2020-03-25 07:30:42.224 UTC [shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode log level not provided; defaulting to: INFO</span><br><span class="line">2020-03-25 07:30:42.224 UTC [shim] SetupChaincodeLogging -&gt; INFO 002 Chaincode (build level: ) starting up ...</span><br></pre></td></tr></table></figure></li><li><p><strong>测试：</strong></p><p><strong>3.1 打开一个新的终端3，进入 cli 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hg</span>@ubuntu:~/hyfa/fabric-samples/chaincode-docker-devmode$ sudo docker <span class="built_in">exec</span> -it cli bash</span><br><span class="line">   [sudo] password <span class="keyword">for</span> hg: </span><br><span class="line">   root@4e025ea243b3:/opt/gopath/src/chaincodedev<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>3.2 安装链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -p chaincodedev/chaincode/hello -n hellocc -v 0</span></span><br></pre></td></tr></table></figure><p><strong>3.3 实例化链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">peer chaincode instantiate -n hellocc -v 0 -c <span class="string">'&#123;"Args":["init", "Hello","World"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p><strong>3.4 调用链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据指定的 key （"Hello"）查询对应的状态数据</span><br><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n hellocc  -c <span class="string">'&#123;"Args":["query","Hello"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>返回查询结果： <code>World</code></p></li></ol><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>在调用链码时将 query 换为 invoke 可以吗？</p><p>可以将 query 替换为 invoke 操作，但是两个命令的执行流程也不同，而且执行后可以从终端的输出中看出，返回的查询结果显示的内容是一串数字，无法确定其正确性。</p></li></ol><h2 id="四、动手编码一：链码实现资产管理"><a href="#四、动手编码一：链码实现资产管理" class="headerlink" title="四、动手编码一：链码实现资产管理"></a>四、动手编码一：链码实现资产管理</h2><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><ol><li>简单的分析链码的设计与开发</li><li>使用链码相关的API实现一个简单的资产管理应用</li><li>使用开发测试模式测试简单的资产链码应用</li></ol><h4 id="任务实现-3"><a href="#任务实现-3" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>下面我们来实现一个简单的资产链码应用，该链码能够让用户在分类账上创建资产，并通过指定的函数实现对资产的修改与查询功能。</p></blockquote><h3 id="1-资产链码开发"><a href="#1-资产链码开发" class="headerlink" title="1 资产链码开发"></a>1 资产链码开发</h3><ol><li><p><strong>创建目录</strong></p><p>为 chaincode 应用创建一个名为 test 的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir <span class="built_in">test</span> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>新建并编辑链码文件</strong></p><p>新建一个文件 test.go ，用于编写Go代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim test.go</span></span><br></pre></td></tr></table></figure></li><li><p><strong>导入链码依赖包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>定义结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SimpleChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写主函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(SimpleChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"启动 SimpleChaincode 时发生错误: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现 Chaincode 接口</strong></p><p><strong>Init</strong> 函数：初始化数据状态</p><ul><li>获取参数, 使用 <code>GetStringArgs</code> 函数传递给调用链码的所需参数</li><li>检查合法性, 检查参数数量是否为2个, 如果不是, 则返回错误信息</li><li>利用两个参数, 调用 PutState 方法向账本中写入状态, 如果有错误则返回 shim.Error()， 否则返回 nil（shim.Success）</li></ul><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SimpleChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">    args := stub.GetStringArgs()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"初始化的参数只能为2个， 分别代表名称与状态数据"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    err := stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"在保存状态时出现错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>Invok</strong>函数：验证函数名称为 set 或 get，并调用那些链式代码应用程序函数，通过 shim.Success 或 shim.Error 函数返回响应。</p><ul><li><p>获取函数名与参数</p></li><li><p>对获取到的参数名称进行判断, 如果为 set, 则调用 set 方法, 反之调用 get</p><ul><li>set/get 函数返回两个值（result, err）</li></ul></li><li><p>如果 err 不为空则返回错误</p></li><li><p>err 为空则返回 []byte（result）</p><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t * SimpleChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span>&#123;</span><br><span class="line">fun, args := stub.GetFunctionAndParameters()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> fun == <span class="string">"set"</span>&#123;</span><br><span class="line">   result, err = set(stub, args)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   result, err = get(stub, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><strong>实现具体业务功能的函数</strong></p><p>应用程序实现了两个可以通过 <code>Invoke</code> 函数调用的函数 （set/get）</p><p>为了访问分类账的状态，利用 chaincode shim API 的 <code>ChaincodeStubInterface.PutState</code> 和<code>ChaincodeStubInterface.GetState</code> 函数</p><p><strong>7.1 实现set函数：修改资产</strong></p><ul><li>检查参数个数是否为2</li><li>利用 PutState 方法将状态写入</li><li>如果成功,则返回要写入的状态, 失败返回错误: fmt.Errorf(“…”)</li></ul><p>具体实现代码如下：</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(args[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(args[<span class="number">0</span>]), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.2 实现get函数：查询资产</strong></p><ul><li><p>接收参数并判断个数 是否为1个</p></li><li><p>调用 GetState 方法返回并接收两个返回值（value, err）判断 err 及 value 是否为空 return “”， fmt.Errorf(“……”)</p></li><li><p>返回值 return string(value)，nil</p><p>具体实现代码如下：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span><span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"给定的参数个数不符合要求"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"获取数据发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"根据 %s 没有获取到相应的数据"</span>, args[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-链码测试-1"><a href="#2-链码测试-1" class="headerlink" title="2 链码测试"></a>2 链码测试</h3><p>跳转至 <code>fabric-samples</code> 的 <code>chaincode-docker-devmode</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode-docker-devmode/</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>终端1 启动网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-simple.yaml up -d</span></span><br></pre></td></tr></table></figure><blockquote><p>在执行启动网络的命令之前确保无 Fabric 网络处于运行状态，如果有网络在运行，请先关闭。</p></blockquote></li><li><p><strong>终端2 建立并启动链码</strong></p><p><strong>2.1 打开一个新终端2，进入 chaincode 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br></pre></td></tr></table></figure><p><strong>2.2 编译</strong></p><p>进入 test 目录编译 chaincode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go build</span></span><br></pre></td></tr></table></figure><p><strong>2.3 运行chaincode</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=<span class="built_in">test</span>:0 ./<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode log level not provided; defaulting to: INFO</span><br><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 002 Chaincode (build level: ) starting up ...</span><br></pre></td></tr></table></figure></li><li><p><strong>终端3 测试</strong></p><p><strong>3.1 打开一个新的终端3，进入 cli 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p><strong>3.2 安装链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -p chaincodedev/chaincode/<span class="built_in">test</span> -n <span class="built_in">test</span> -v 0</span></span><br></pre></td></tr></table></figure><p><strong>3.3 实例化链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -n <span class="built_in">test</span> -v 0 -c <span class="string">'&#123;"Args":["a","10"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p><strong>3.4 调用链码</strong></p><p>指定调用 set 函数，将<code>a</code>的值更改为<code>20</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -n <span class="built_in">test</span> -c <span class="string">'&#123;"Args":["set", "a", "20"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功，输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 0a8 Chaincode invoke successful. result: status:200 payload:"a"</span><br></pre></td></tr></table></figure><p><strong>3.5 查询</strong></p><p>指定调用 get 函数，查询 <code>a</code> 的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n <span class="built_in">test</span> -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功, 输出: <code>20</code></p></li></ol><h2 id="五、动手编码二：链码实现转账"><a href="#五、动手编码二：链码实现转账" class="headerlink" title="五、动手编码二：链码实现转账"></a>五、动手编码二：链码实现转账</h2><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><ol><li>简单的分析链码的设计与开发</li><li>使用链码相关的API实现一个简单的资产管理应用</li><li>使用开发测试模式测试简单的资产链码应用</li></ol><h4 id="任务实现-4"><a href="#任务实现-4" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>下面我们来实现一个使用链码能够实现对账户的查询，转账，删除账户的功能，并且整合完善资产管理应用链码的功能，该链码能够让用户在分类账上创建资产，并通过指定的函数实现对资产的修改与查询。</p></blockquote><h3 id="1-转账链码开发"><a href="#1-转账链码开发" class="headerlink" title="1 转账链码开发"></a>1 转账链码开发</h3><ol><li><p><strong>创建目录</strong></p><p>为 chaincode 应用创建一个名为 payment 的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir payment </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> payment</span></span><br></pre></td></tr></table></figure></li><li><p><strong>新建并编辑链码文件</strong></p><p>新建一个文件 payment.go ，用于编写Go代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim payment.go</span></span><br></pre></td></tr></table></figure></li><li><p><strong>导入链码依赖包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hanxiaodong</span></span><br><span class="line"><span class="comment">// QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span><br><span class="line">   <span class="string">"github.com/hyperledger/fabric/protos/peer"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>定义结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PaymentChaincode <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写主函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := shim.Start(<span class="built_in">new</span>(PaymentChaincode))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"启动 PaymentChaincode 时发生错误: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现 Chaincode 接口</strong></p><p><strong>Init</strong> 函数：初始化两个账户，账户名分别为a、b，对应的金额为 100、200</p><ul><li>判断参数个数是否为4</li><li>获取 args[0] 的值赋给A</li><li>strconv.Atoi（args[1]） 转换为整数, 返回 aval, err</li><li>判断 err</li><li>获取 args[2] 的值赋给B</li><li>strconv.Atoi（args[3]） 转换为整数, 返回 bval, err</li><li>判断 err</li><li>将 A 的状态值记录到分布式账本中</li><li>判断 err</li><li>将 B 的状态值记录到分布式账本中</li><li>判断 err</li><li>return shim.Success（nil）</li></ul><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化两个账户及相应的余额</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["init", "第一个账户名称", "第一个账户初始余额", "第二个账户名称", "第二个账户初始余额"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *PaymentChaincode)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数并验证</span></span><br><span class="line">    _, args := stub.GetFunctionAndParameters()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"必须指定两个账户名称及相应的初始余额"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断账户名称是否合法</span></span><br><span class="line">    <span class="keyword">var</span> a = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> avalStr = args[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">var</span> b = args[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">var</span> bvalStr = args[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(a + <span class="string">" 账户名称不能少于2个字符长度"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(b + <span class="string">" 账户名称不能少于2个字符长度"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err := strconv.Atoi(avalStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"指定的账户初始余额错误: "</span> + avalStr)</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = strconv.Atoi(bvalStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"指定的账户初始余额错误: "</span> + bvalStr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存两个账户状态至账本中</span></span><br><span class="line">    err = stub.PutState(a, []<span class="keyword">byte</span>(avalStr))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(a + <span class="string">" 保存状态时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    err = stub.PutState(b, []<span class="keyword">byte</span>(bvalStr))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(b + <span class="string">" 保存状态时发生错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"初始化成功"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>Invoke</strong> 函数：应用程序将具有三个不同的分支功能：<code>find</code> 、<code>payment</code> 、<code>delete</code>分别实现转账、删除、查询的功能, 根据交易参数定位到不同的分支处理逻辑。</p><ul><li><p>获取函数名称与参数列表</p></li><li><p>判断函数名称并调用相应的函数</p><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer chaincode query -n pay -C myc -c '&#123;"Args":["find", "a"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *PaymentChaincode)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取用户意图</span></span><br><span class="line">  fun, args := stub.GetFunctionAndParameters()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> fun == <span class="string">"find"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> find(stub, args)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"payment"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> payment(stub, args)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"del"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> delAccount(stub, args)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"set"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> t.set(stub, args)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> fun == <span class="string">"get"</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> t.get(stub, args)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shim.Error(<span class="string">"非法操作, 指定的功能不能实现"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><strong>实现具体业务功能的函数</strong></p><p>应用程序实现了三个可以通过 <code>Invoke</code> 函数调用的函数（finde、payment、delAccount）</p><p><strong>7.1 实现 find 函数：根据给定的账户名称查询对应的状态信息</strong></p><ul><li>判断参数是否为1个</li><li>根据传入的参数调用 GetState 查询状态， aval， err 为接收返回值</li><li>如果返回 err 不为空，则返回错误</li><li>如果返回的状态为空，则返回错误</li><li>如果无错误，返回查询到的值</li></ul><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据指定的账户名称查询对应的余额信息</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["find", "账户名称"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定要查询的账户名称"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"查询 "</span> + args[<span class="number">0</span>] + <span class="string">" 账户信息失败"</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shim.Error(<span class="string">"根据指定 "</span> + args[<span class="number">0</span>] + <span class="string">" 没有查询到对应的余额"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shim.Success(result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>7.2 实现 payment 函数：根据指定的两个账户名称及金额，实现转账</strong></p><ul><li><p>判断参数是否为3</p></li><li><p>获取两个账户名称（args[0] 与 args[1]）值, 赋给两个变量</p></li><li><p>调用 GetState 获取 a 账户状态，avalsByte， err 为返回值</p><ul><li>判断有无错误（err 不为空， avalsByte 为空）</li></ul></li><li><p>类型转换: aval， _ = strconv.Atoi（string(avalsByte)）</p></li><li><p>调用 GetState 获取 b 账户状态， bvalsByte，err 为返回值</p><ul><li>判断有无错误（err 不为空，bvalsByte 为空）</li></ul></li><li><p>类型转换: bval， _ = strconv.Atoi（string(bvalsByte)）</p></li><li><p>将要转账的数额进行类型转换： x， err = strconv.Atoi（args[2]）</p></li><li><p>判断 err 是否为空</p></li><li><p>aval， bval 执行转账操作</p></li><li><p>记录状态， err = PutState(a, []byte（strconv.Itoa(aval))）</p><ul><li>Itoa： 将整数转换为十进制字符串形式</li><li>判断有无错误.</li></ul></li><li><p>记录状态， err = PutState（b, []byte(strconv.Itoa(bval))）</p><ul><li>判断有无错误.</li></ul></li><li><p>return shim.Success（nil）</p><p>具体实现代码如下：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转账</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["payment", "源账户名称", "目标账户名称", "转账金额"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">payment</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">3</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定源账户及目标账户名称与对应的转账金额"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> source, target <span class="keyword">string</span></span><br><span class="line">       <span class="keyword">var</span> x <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">       source = args[<span class="number">0</span>]</span><br><span class="line">       target = args[<span class="number">1</span>]</span><br><span class="line">       x = args[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 源账户扣除对应的转账金额</span></span><br><span class="line">       <span class="comment">// 目标账户加上对应的转账金额</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 查询源账户及目标账户的余额</span></span><br><span class="line">       sval, err := stub.GetState(source)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"查询源账户信息失败"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果源账户或目标账户不存在的情况下</span></span><br><span class="line">       <span class="comment">// 不存在的情况下直接return</span></span><br><span class="line"></span><br><span class="line">       tval, err := stub.GetState(target)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"查询目标账户信息失败"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 实现转账</span></span><br><span class="line">       s, err := strconv.Atoi(x)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"指定的转账金额错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       svi, err := strconv.Atoi(<span class="keyword">string</span>(sval))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"处理源账户余额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tvi, err := strconv.Atoi(<span class="keyword">string</span>(tval))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"处理目标账户余额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> svi &lt; s &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"指定的源账户余额不足, 无法实现转账"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       svi = svi - s</span><br><span class="line">       tvi = tvi + s</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将修改之后的源账户与目标账户的状态保存至账本中</span></span><br><span class="line">       err = stub.PutState(source, []<span class="keyword">byte</span>(strconv.Itoa(svi)))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span>  shim.Error(<span class="string">"保存转账后的源账户状态失败"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       err = stub.PutState(target, []<span class="keyword">byte</span>(strconv.Itoa(tvi)))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span>  shim.Error(<span class="string">"保存转账后的目标账户状态失败"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"转账成功"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.3 实现 delAccount 函数：根据指定的名称删除对应的实体信息</strong></p><ul><li><p>判断参数个数是否为1</p></li><li><p>调用 DelState 方法，err 接收返回值</p></li><li><p>如果 err 不为空, 返回错误</p></li><li><p>返回成功 shim.Success(nil)</p><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据指定的账户名称删除相应信息</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["del", "账户名称"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delAccount</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定要删除的账户名称"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"查询 "</span> + args[<span class="number">0</span>] + <span class="string">" 账户信息失败"</span> + err.Error())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"根据指定 "</span> + args[<span class="number">0</span>] + <span class="string">" 没有查询到对应的余额"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = stub.DelState(args[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> shim.Error(<span class="string">"删除指定的账户失败: "</span> + args[<span class="number">0</span>] + <span class="string">", "</span> + err.Error())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"删除指定的账户成功"</span> + args[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>7.4 实现 set 函数，设置指定账户的值</strong></p><p>在简单资产管理链码的的 set 函数的功能并不完善，因为我们没有考虑用户存入资产之后需要对该账户的资产进行修改，现在我们来添加这一功能。</p><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向指定的账户存入对应的金额</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["set", "账户名称", "要存入的金额"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *PaymentChaincode)</span> <span class="title">set</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定账户名称及要存入的金额"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"根据指定的账户查询信息失败"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"指定的账户不存在"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 存入账户</span></span><br><span class="line">       val, err := strconv.Atoi(<span class="keyword">string</span>(result))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"处理指定的账户金额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       x, err := strconv.Atoi(args[<span class="number">1</span>])</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"指定要存入的金额错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       val = val + x</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 保存信息</span></span><br><span class="line">       err = stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(strconv.Itoa(val)))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"存入账户金额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"存入操作成功"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.5 实现 get 函数，从指定的账户中提取指定的金额</strong></p><p>同理，用户从账户中提取从指定金额的资产之后，也需要对该账户的资产进行修改。</p><p>具体实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从账户中提取指定的金额</span></span><br><span class="line"><span class="comment">// -c '&#123;"Args":["get", "账户名称", "要提取的金额"]&#125;'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *PaymentChaincode)</span> <span class="title">get</span><span class="params">(stub shim.ChaincodeStubInterface, args []<span class="keyword">string</span>)</span> <span class="title">peer</span>.<span class="title">Response</span></span>  &#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">2</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"必须且只能指定要提取的账户名称及金额"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       x, err := strconv.Atoi(args[<span class="number">1</span>])</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"指定要提取的金额错误, 请重新输入"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从指定的账户中查询出现有金额</span></span><br><span class="line">       result, err := stub.GetState(args[<span class="number">0</span>])</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"查询指定账户金额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> result == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"要查询的账户不存在或已被注销"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       val, err := strconv.Atoi(<span class="keyword">string</span>(result))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"处理账户金额时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> val &lt; x &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"要提取的金额不足"</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       val = val - x</span><br><span class="line">       err = stub.PutState(args[<span class="number">0</span>], []<span class="keyword">byte</span>(strconv.Itoa(val)))</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> shim.Error(<span class="string">"提取失败, 保存数据时发生错误"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shim.Success([]<span class="keyword">byte</span>(<span class="string">"提取成功"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-链码测试-2"><a href="#2-链码测试-2" class="headerlink" title="2 链码测试"></a>2 链码测试</h3><p>跳转至 <code>fabric-samples</code> 的 <code>chaincode-docker-devmode</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode-docker-devmode/</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>终端1 启动网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-simple.yaml up -d</span></span><br></pre></td></tr></table></figure><blockquote><p>在执行启动网络的命令之前确保无Fabric网络处于运行状态，如果有网络在运行，请先关闭。</p></blockquote></li><li><p><strong>终端2 建立并启动链码</strong></p><p><strong>2.1 打开一个新终端2，进入 chaincode 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br></pre></td></tr></table></figure><p><strong>2.2 编译</strong></p><p>进入 test 目录编译 chaincode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> payment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> go build</span></span><br></pre></td></tr></table></figure><p><strong>2.3 运行chaincode</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=paycc:0 ./payment</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode log level not provided; defaulting to: INFO</span><br><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 002 Chaincode (build level: ) starting up ...</span><br></pre></td></tr></table></figure></li><li><p><strong>终端3 测试</strong></p><p><strong>3.1 打开一个新的终端3，进入 cli 容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p><strong>3.2 安装链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -p chaincodedev/chaincode/payment -n paycc -v 0</span></span><br></pre></td></tr></table></figure><p><strong>3.3 实例化链码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -n paycc -v 0 -c <span class="string">'&#123;"Args":["init","aaa", "100", "bbb","200"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p><strong>3.4 调用链码</strong></p><p>指定调用 payment 函数，从 <code>aaa</code> 账户向 <code>bbb</code> 账户转账 <code>20</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -n paycc -c <span class="string">'&#123;"Args":["payment", "aaa","bbb","20"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功，输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 0a8 Chaincode invoke successful. result: status:200 payload:"\350\275\254\350\264\246\346\210\220\345\212\237"</span><br></pre></td></tr></table></figure><p><strong>3.5 查询</strong></p><p>指定调用 find 函数，查询 <code>a</code> 账户的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n paycc -c <span class="string">'&#123;"Args":["find","aaa"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功, 输出: <code>80</code></p></li></ol><p>未经授权禁止转载、改编，转载请注明出处！</p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/125" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/125</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联盟链/Untitled</title>
      <link href="/2020/03/22/%E8%81%94%E7%9B%9F%E9%93%BE/Untitled/"/>
      <url>/2020/03/22/%E8%81%94%E7%9B%9F%E9%93%BE/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第4章认识链码：链码作用及对链码进行管理与测试</title>
      <link href="/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC4%E7%AB%A0%E8%AE%A4%E8%AF%86%E9%93%BE%E7%A0%81%EF%BC%9A%E9%93%BE%E7%A0%81%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AF%B9%E9%93%BE%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC4%E7%AB%A0%E8%AE%A4%E8%AF%86%E9%93%BE%E7%A0%81%EF%BC%9A%E9%93%BE%E7%A0%81%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AF%B9%E9%93%BE%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="初识链码：链码概念与原理"><a href="#初识链码：链码概念与原理" class="headerlink" title="初识链码：链码概念与原理"></a>初识链码：链码概念与原理</h3><h3 id="一、初识链码：链码概念与原理"><a href="#一、初识链码：链码概念与原理" class="headerlink" title="一、初识链码：链码概念与原理"></a>一、初识链码：链码概念与原理</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>认识 Hyperledger Fabric 中的链码（智能合约）</li><li>明确系统链码的种类及作用</li><li>熟知链码的生命周期管理</li></ol><h3 id="1-链码概念"><a href="#1-链码概念" class="headerlink" title="1 链码概念"></a>1 链码概念</h3><blockquote><p>网络运行环境我们已经启动完成，现在我们从开发者的角度来认识一下完成交易所必须的智能合约（在 Hyperledger Fabric 中被称之为 Chaincode，也就是链上代码）的相关知识，以便于理解账本中的数据到底是通过什么方式进行操作。</p></blockquote><p>Chaincode：链上代码，简称链码，一般是指由开发人员使用Go语言（也支持Java等语言）编写的应用程序代码，<strong>提供分布式账本的状态处理逻辑</strong>。链码被部署在Fabric的网络节点中，能够独立运行在具有安全特性的受保护的 Docker 容器中，<strong>以 gRPC 协议与相应的 peer 节点进行通信</strong>，以操作（初始化或管理）分布式账本中的数据。可以根据不同的需求开发出不同的复杂的应用。</p><a id="more"></a><p><strong>链码分类</strong></p><p>在 Hyperledger Fabric 中，链码一般分为：</p><ul><li><strong>系统链码</strong></li><li><strong>用户链码</strong></li></ul><h3 id="2-Fabric提供了什么－系统链码"><a href="#2-Fabric提供了什么－系统链码" class="headerlink" title="2 Fabric提供了什么－系统链码"></a>2 Fabric提供了什么－系统链码</h3><p>负责 Fabric 节点自身的处理逻辑, 包括系统配置、背书、校验等工作</p><p>系统链码仅支持 Go 语言, 在 Peer 节点启动时会自动完成注册和部署</p><p><strong>系统链码共有五种类型：</strong></p><ol><li><p><strong>配置系统链码(CSCC)</strong></p><p>CSCC：Configuration System Chaincode，负责处理 Peer 端的 Channel 配置。</p></li><li><p><strong>生命周期系统链码(LSCC)</strong></p><p>LSCC：Lifecycle System Chaincode，负责对用户链码的生命周期进行管理。</p></li><li><p><strong>查询系统链码(QSCC)</strong></p><p>QSCC：Query System Chaincode，提供账本查询 API。如获取区块和交易等信息。</p></li><li><p><strong>背书管理系统链码(ESCC)</strong></p><p>ESCC：Endorsement System Chaincode，负责背书(签名)过程, 并可以支持对背书策略进行管理</p><p>对提交的交易提案的模拟运行结果进行签名,，之后创建响应消息返回给客户端</p></li><li><p><strong>验证系统链码(VSCC)</strong></p><p>VSCC：Validation System Chaincode，处理交易的验证，包括检查背书策略以及多版本并发控制</p></li></ol><h3 id="3-什么是用户链码"><a href="#3-什么是用户链码" class="headerlink" title="3 什么是用户链码"></a>3 什么是用户链码</h3><p>由应用程序开发人员根据不同场景需求及成员制定的相关规则，使用 Golang（或Java等）语言编写的基于操作区块链分布式账本的状态的业务处理逻辑代码，<strong>运行在链码容器中</strong>，通过 Fabric 提供的接口与账本状态进行交互。</p><p>用户链码在整个应用程序中处于重要地位。因为它下可对账本数据进行操作，上可以给企业级应用程序提供调用接口。所以一个没有链码的企业级应用程序，不能称之为是基于区块链的企业级应用程序。</p><h3 id="4-链码的生命周期管理"><a href="#4-链码的生命周期管理" class="headerlink" title="4 链码的生命周期管理"></a>4 链码的生命周期管理</h3><p>链码开发编写完成后，并不能立刻使用，而是必须经过一系列的操作之后才能应用在 Hyperledger Fabric 网络中进而处理客户端提交的交易。这一系列的操作是由链码的生命周期来负责管理。</p><p><strong>管理 Chaincode 的生命周期共有五个命令：</strong></p><ul><li><strong>install：</strong>将已编写完成的链码安装在网络节点中。</li><li><strong>instantiate：</strong>对已安装的链码进行实例化。</li><li><strong>upgrade：</strong>对已有链码进行升级。链代码可以在安装后根据具体需求的变化进行升级。</li><li><strong>package：</strong>对指定的链码进行打包的操作。</li><li><strong>singnpackage：</strong>签名。</li></ul><blockquote><p>安装、实例化、升级这三项操作不适用于系统链码</p></blockquote><p>链码的生命周期管理命令现阶段只有这五个，但未来还会支持 <code>stop</code> 和 <code>start</code> 命令, 用来停止和启动链码。</p><p>链代码成功安装和实例化后，则处于活动状态（正在运行），时刻准备执行处理提交的交易提案。</p><p>下一节开始我们会使用这些生命周期管理命令来实现对链码的相关操作。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>文中所说的状态与账本数据是什么关系？</p><p>状态其实指的就是账本中的数据。没有其它另外的含义。</p></li><li><p>链码可以访问所有账本中的状态吗？</p><p>一个链码对应一个账本，所以一般情况下链码是不可以访问其它账本中的数据的。</p></li></ol><h3 id="二、链码如何使用：实现对链码的安装、实例化及调用"><a href="#二、链码如何使用：实现对链码的安装、实例化及调用" class="headerlink" title="二、链码如何使用：实现对链码的安装、实例化及调用"></a>二、链码如何使用：实现对链码的安装、实例化及调用</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>链码的安装及实例化</li><li>调用链码实现交易处理</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>我们对链码已经有了一个基础的认识，下面我们利用 fabric-samples 提供的示例链码来进行实践；如何安装、实例化及调用链码处理交易。</p></blockquote><p>首先确认网络是否处于开启状态，利用 docker ps 命令查看容器是否处于活动状态，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps</span></span><br></pre></td></tr></table></figure><p>如果没有活动的容器，则先使用 docker-compose 命令启动网络然后进入CLI 容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml up -d</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><blockquote><p>如果当前已进入至 CLI 容器中，则上面的命令无需执行。如果之前使用 <strong>exit</strong> 命令退出了 cli 容器，请使用 <strong>sudo docker exec -it cli bash</strong> 命令重新进入 cli 容器。</p></blockquote><p>检查当前节点（默认为peer0.example.com）已加入到哪些通道中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel list</span></span><br></pre></td></tr></table></figure><p>执行成功后会在终端中输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Channels peers has joined: </span><br><span class="line">mychannel</span><br><span class="line">-----</span><br><span class="line">2020-03-23 09:10:25.812 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">Channels peers has joined:</span><br></pre></td></tr></table></figure><p>根据如下的输出内容，说明当前节点已成功加入到一个名为 mychannel 的应用通道中。Peer加入应用通道后，可以执行链码调用的相关操作，进行测试。如果没有，则先将当前节点加入到已创建的应用通道中。</p><p>检查环境变量是否正确设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CHANNEL_NAME</span></span></span><br></pre></td></tr></table></figure><p>设置环境变量，指定应用通道名称为 mychannel ，因为我们创建的应用通道及当前的 peer 节点加入的应用通道名称为 mychannel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel</span></span><br></pre></td></tr></table></figure><p>链码调用处理交易之前必须将其部署到 Peer 节点上，实现步骤如下：</p><ol><li>将其安装在指定的网络节点上</li><li>安装完成后要对其进行实例化</li></ol><p>然后才可以调用链码处理交易(查询或执行事务)</p><h3 id="1-安装链码"><a href="#1-安装链码" class="headerlink" title="1 安装链码"></a>1 安装链码</h3><p>安装链码使用 install 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-n：</strong> 指定要安装的链码的名称</li><li><strong>-v：</strong> 指定链码的版本</li><li><strong>-p：</strong> 指定要安装的链码的所在路径</li></ul><p>命令执行完成看到如下输出说明指定的链码被成功安装至 peer 节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">[chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:"OK" &gt;</span><br></pre></td></tr></table></figure><h3 id="2-实例化链码"><a href="#2-实例化链码" class="headerlink" title="2 实例化链码"></a>2 实例化链码</h3><p>实例化链码使用 instantiate 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 1.0 -c <span class="string">'&#123;"Args":["init","a", "100", "b","200"]&#125;'</span> -P <span class="string">"OR ('Org1MSP.peer','Org2MSP.peer')"</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><strong>-o：</strong> 指定Oderer服务节点地址</li><li><strong>–tls：</strong> 开启 TLS 验证</li><li><strong>–cafile：</strong> 指定 TLS_CA 证书的所在路径</li><li><strong>-n：</strong> 指定要实例化的链码名称，必须与安装时指定的链码名称相同</li><li><strong>-v：</strong> 指定要实例化的链码的版本号，必须与安装时指定的链码版本号相同</li><li><strong>-C：</strong> 指定通道名称</li><li><strong>-c：</strong> 实例化链码时指定的参数</li><li><strong>-P：</strong> 指定背书策略</li></ul><p>实例化完成后，用户即可向网络中发起交易。</p><h3 id="3-查询链码"><a href="#3-查询链码" class="headerlink" title="3 查询链码"></a>3 查询链码</h3><p>查询链码使用 query 命令实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-n：</strong> 指定要调用的链码名称</li><li><strong>-C：</strong> 指定通道名称</li><li><strong>-c</strong> 指定调用链码时所需要的参数</li></ul><p>执行成功输出结果：<code>100</code></p><h3 id="4-调用链码"><a href="#4-调用链码" class="headerlink" title="4 调用链码"></a>4 调用链码</h3><h4 id="4-1-调用"><a href="#4-1-调用" class="headerlink" title="4.1 调用"></a>4.1 调用</h4><p>调用链码使用 invoke 命令实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-o：</strong> 指定orderer节点地址</li><li><strong>–tls：</strong> 开启TLS验证</li><li><strong>–cafile：</strong> 指定TLS_CA证书路径</li><li><strong>-n:</strong> 指定链码名称</li><li><strong>-C：</strong> 指定通道名称</li><li><strong>-c：</strong> 指定调用链码的所需参数</li></ul><p>有如下输出则说明链码被调用成功且交易请求被成功处理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure><h4 id="4-2-查询a账户的金额"><a href="#4-2-查询a账户的金额" class="headerlink" title="4.2 查询a账户的金额"></a>4.2 查询a账户的金额</h4><p>执行查询a账户的命令，并查看输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出结果: <code>90</code></p><h2 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>链码是安装在一个节点中还是安装在多个节点中？有什么区别？</p><p>在实际生产环境中，必须在应用通道上每一个要运行 chaincode 的背书节点上安装 chaincode。其它未安装 chaincode 的节点不能执行 chaincode。但仍可以验证交易并提交到账本中。</p><p>背书节点需要由联盟的成员共同指定，然后在实例化链码时指定背书策略，但安装一定要在所有预先指定的背书 peer 中安装。</p></li><li><p>链码的执行查询与执行事务方式的流程相同吗？</p><p>不相同，如果执行的查询操作，则客户端接收到背书的交易提案响应后不会再将交易请求提交给 Orderer 服务节点。如果是执行事务操作，则会执行完整的交易流程。</p></li><li><p>背书策略具体指的是什么？</p><p>背书策略是在实例化链码时指定的由当前通道中的哪些节点成员进行背书签名的一种策略。</p></li><li><p>如果在实例化链码时没有指定背书策略会有节点进行背书吗？</p><p>如果在实例化链码时没有明确指定背书策略，那么默认的背书策略是 MSP 标识 DEFAULT 成员的签名</p></li></ol><h3 id="三、链码的其它操作：实现对链码的打包升级"><a href="#三、链码的其它操作：实现对链码的打包升级" class="headerlink" title="三、链码的其它操作：实现对链码的打包升级"></a>三、链码的其它操作：实现对链码的打包升级</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>实现如何对链码打包签名</li><li>链码升级的实现</li></ol><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>链码部署除了正常的安装、实例化操作步骤之外，还有一种部署方式，即先将链码进行打包，然后对已打包的文件进行签名，最后再进行安装与实例的操作。</p></blockquote><h3 id="1-链码打包及签名"><a href="#1-链码打包及签名" class="headerlink" title="1 链码打包及签名"></a>1 链码打包及签名</h3><h4 id="1-1打包"><a href="#1-1打包" class="headerlink" title="1.1打包"></a>1.1打包</h4><p>通过将链码相关数据（如链码名称、版本、实例化策略等信息）进行封装，可以实现对其进行打包和签名的操作。</p><p>chaincode 包具体包含以下三个部分：</p><ul><li>chaincode 本身，由 ChaincodeDeploymentSpec（CDS）定义。CDS 根据代码及一些其他属性（名称，版本等）来定义 chaincode。</li><li>一个可选的实例化策略，该策略可被 <strong>背书策略</strong> 描述。</li><li>一组表示 chaincode 所有权的签名。</li></ul><p>对于一个已经编写完成的链码可以使用 <strong>package</strong> 命令进行打包操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode package -n exacc -v 1.0 -p github.com/chaincode/chaincode_example02/go/  -s -S -i <span class="string">"AND('Org1MSP.admin')"</span> ccpack.out</span></span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>-s：</strong> 创建一个可以被多个所有者签名的包。</li><li><strong>-S：</strong> 可选参数，使用 core.yaml 文件中被 localMspId 相关属性值定义的 MSP 对包进行签名。</li><li><strong>-i：</strong> 指定链码的实例化策略（指定谁可以实例化链码）。</li></ul><blockquote><p>打包后的文件，可以直接用于 install 操作，如： <code>peer chaincode install ccpack.out</code>，但我们一般会在将打包的文件进行签名之后再做进一步的处理。</p></blockquote><h4 id="1-2-签名"><a href="#1-2-签名" class="headerlink" title="1.2 签名"></a>1.2 签名</h4><p>对一个打包文件进行签名操作（添加当前 MSP 签名到签名列表中）</p><p>使用 <strong>signpackage</strong> 命令实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode signpackage ccpack.out signedccpack.out</span></span><br></pre></td></tr></table></figure><blockquote><p>signedccpack.out 包含一个用本地 MSP 对包进行的附加签名。</p></blockquote><p>添加了签名的链码包可以进行进行一步的处理，如先将链码进行安装，然后对已安装的链码进行实例化或升级的操作。</p><p>安装已添加签名的链码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install signedccpack.out</span></span><br></pre></td></tr></table></figure><p>命令执行成功输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-03-24 06:52:55.139 UTC [chaincodeCmd] install -&gt; INFO 001 Installed remotely response:&lt;status:200 payload:"OK" &gt;</span><br></pre></td></tr></table></figure><p>安装成功之后进行链码的实例化操作，同时指定其背书策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C <span class="variable">$CHANNEL_NAME</span> -n exacc -v 1.0 -c <span class="string">'&#123;"Args":["init","a", "100", "b","200"]&#125;'</span> -P <span class="string">"OR ('Org1MSP.peer','Org2MSP.peer')"</span></span></span><br></pre></td></tr></table></figure><p>​    -P:指定背书策略</p><p><strong>测试：</strong></p><ol><li><p><strong>查询链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n exacc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>100</code></p></li><li><p><strong>调用链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C <span class="variable">$CHANNEL_NAME</span> -n exacc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure></li><li><p><strong>查询链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n exacc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>90</code></p></li></ol><h3 id="2-链码的升级"><a href="#2-链码的升级" class="headerlink" title="2 链码的升级"></a>2 链码的升级</h3><p>在实际场景中，由于需求场景的变化，链码也需求实时做出修改，以适应不同的场景需求。所以我们必须能够对于已成功部署并运行状态中的链码进行升级操作。</p><p>首先，先将修改之后的链码进行安装，然后使用 upgrade 命令对已安装的链码进行升级，具体实现如下：</p><p><strong>安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -n mycc -v 2.0 -p github.com/chaincode/chaincode_example02/go/</span></span><br></pre></td></tr></table></figure><p><strong>升级：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode upgrade -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C <span class="variable">$CHANNEL_NAME</span> -n mycc -v 2.0 -c <span class="string">'&#123;"Args":["init","a", "100", "b","200"]&#125;'</span> -P <span class="string">"OR ('Org1MSP.peer','Org2MSP.peer')"</span></span></span><br></pre></td></tr></table></figure><p>为了验证链码升级是否成功，我们可以使用如下步骤进行测试：</p><p><strong>测试：</strong></p><ol><li><p><strong>查询链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>100</code></p></li><li><p><strong>调用链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure></li><li><p><strong>查询链码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -C <span class="variable">$CHANNEL_NAME</span> -n mycc -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span></span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>90</code></p></li></ol><blockquote><p>注意：升级过程中，chaincode 的 Init 函数会被调用以执行数据相关的操作，或者重新初始化数据；所以需要多加小心，以避免在升级 chaincode 时重设状态信息。</p></blockquote><h4 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>链码升级之后， 之前旧版本的链码还能使用吗？</p><p>升级是一个类似于实例化操作的交易，它会将新版本的链码与通道绑定。<strong>其他与旧版本绑定的通道则仍旧运行旧版本的链码</strong>。换句话说，升级只会一次影响一个提交它的通道。</p></li></ol><h3 id="四、开发模式下的测试：简化我们对链码的测试过程"><a href="#四、开发模式下的测试：简化我们对链码的测试过程" class="headerlink" title="四、开发模式下的测试：简化我们对链码的测试过程"></a>四、开发模式下的测试：简化我们对链码的测试过程</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><ol><li>熟练掌握链码的 dev 开发测试模式</li></ol><h4 id="任务实现-2"><a href="#任务实现-2" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>从之前对链码操作来看，我们需要在相关操作（安装、实例化、升级、调用、查询）命令中加入大量的参数，尤其是开启 TLS 验证之后指定 TLS 证书时的那一长串路径会让人不厌其烦。如果每次都需要输入那么内容，我想大部分人都会崩溃掉的。那么我们现在就来掌握一种能够快速对链码进行测试而不需要输入那些烦琐的内容，从而简化我们对链码的测试。</p></blockquote><p>正常情况下 chaincode 由 peer 启动和维护。然而，在 dev “开发模式”下，链码由用户构建并启动。</p><ul><li><p>如果没有下载安装 Hyperledger Fabric Samples 请先下载安装；</p></li><li><p>如果没有下载 Docker images 请先下载。</p></li></ul><p><strong>在 dev 开发模式下我们可以使用三个终端来实现具体的测试过程</strong></p><h3 id="1-启动网络"><a href="#1-启动网络" class="headerlink" title="1 启动网络"></a>1 启动网络</h3><p><strong>终端1（当前终端）</strong></p><p>为了确保我们的系统中的 Docker 镜像文件是完整的，首先使用 <code>docker images</code> 命令查看 Docker 镜像信息(显示本地 Docker Registry)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker images</span></span><br></pre></td></tr></table></figure><p>终端中会看到如下类似输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                     TAG             IMAGE ID        CREATED        SIZE</span><br><span class="line">hyperledger/fabric-ca          1.2.0           66cc132bd09c    4 weeks ago    252 MB</span><br><span class="line">hyperledger/fabric-ca          latest          66cc132bd09c    4 weeks ago    252 MB</span><br><span class="line">hyperledger/fabric-tools       1.2.0           379602873003    4 weeks ago    1.51 GB</span><br><span class="line">hyperledger/fabric-tools       latest          379602873003    4 weeks ago    1.51 GB</span><br><span class="line">hyperledger/fabric-ccenv       1.2.0           6acf31e2d9a4    4 weeks ago    1.43 GB</span><br><span class="line">hyperledger/fabric-ccenv       latest          6acf31e2d9a4    4 weeks ago    1.43 GB</span><br><span class="line">hyperledger/fabric-orderer     1.2.0           4baf7789a8ec    4 weeks ago    152 MB</span><br><span class="line">hyperledger/fabric-orderer     latest          4baf7789a8ec    4 weeks ago    152 MB</span><br><span class="line">hyperledger/fabric-peer        1.2.0           82c262e65984    4 weeks ago    159 MB</span><br><span class="line">hyperledger/fabric-peer        latest          82c262e65984    4 weeks ago    159 MB</span><br><span class="line">hyperledger/fabric-zookeeper   0.4.10          2b51158f3898    5 weeks ago    1.44 GB</span><br><span class="line">hyperledger/fabric-zookeeper   latest          2b51158f3898    5 weeks ago    1.44 GB</span><br><span class="line">hyperledger/fabric-kafka       0.4.10          936aef6db0e6    5 weeks ago    1.45 GB</span><br><span class="line">hyperledger/fabric-kafka       latest          936aef6db0e6    5 weeks ago    1.45 GB</span><br><span class="line">hyperledger/fabric-couchdb     0.4.10          3092eca241fc    5 weeks ago    1.61 GB</span><br><span class="line">hyperledger/fabric-couchdb     latest          3092eca241fc    5 weeks ago    1.61 GB</span><br><span class="line">hyperledger/fabric-baseos      amd64-0.4.10    52190e831002    6 weeks ago    132 MB</span><br></pre></td></tr></table></figure><p>在 dev 模式中所需的必要镜像文件为：</p><ul><li>hyperledger/fabric-tools</li><li>hyperledger/fabric-orderer</li><li>hyperledger/fabric-peer</li><li>hyperledger/fabric-ccenv</li></ul><p>关闭之前已启动的网络环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml down</span></span><br></pre></td></tr></table></figure><p>进入 chaincode-docker-devmode 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/hyfa/fabric-samples/chaincode-docker-devmode/</span></span><br></pre></td></tr></table></figure><p>进入 chaincode-docker-devmode 目录下我们会发现与网络、通道、初始区块相关的所有内容。如：</p><ul><li><p><strong>docker-compose-simple.yaml：</strong>网络启动依赖的配置文件</p><p>该配置文件中指定了四个容器，分别为：orderer、peer、cli、chaincode， 各项的配置内容大家可以通过 cat 命令查看，在此不再赘述。</p></li><li><p><strong>msp：</strong>网络环境的 MSP，包含一系列的证书及私钥。</p></li><li><p><strong>myc.block：</strong>代表通道配置块文件。</p></li><li><p><strong>myc.tx：</strong>应用通道交易配置文件。</p></li><li><p><strong>orderer.block：</strong>初始区块配置文件。</p></li></ul><p>下面，我们使用 docker-compose-simple.yaml 配置文件来启动网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-simple.yaml up -d</span></span><br></pre></td></tr></table></figure><p>上面的命令以 docker-compose-simple.yaml 启动了网络，并以开发模式启动 peer。另外还启动了两个容器：</p><ul><li>一个 chaincode 容器，用于链码环境</li><li>一个 CLI 容器，用于与链码进行交互。</li></ul><p>命令执行后，终端中输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creating orderer</span><br><span class="line">Creating peer</span><br><span class="line">Creating chaincode</span><br><span class="line">Creating cli</span><br></pre></td></tr></table></figure><p>创建和连接通道的命令嵌入到 CLI 容器中，因此我们可以立即跳转到链码调用。</p><h3 id="2-构建并启动链码"><a href="#2-构建并启动链码" class="headerlink" title="2 构建并启动链码"></a>2 构建并启动链码</h3><blockquote><p>网络启动成功后，下一步需要开发者自行对已经编写好的链码进行构建及启动。</p></blockquote><p><strong>终端2（开启一个新的终端2）</strong></p><h4 id="2-1-进入chaincode容器"><a href="#2-1-进入chaincode容器" class="headerlink" title="2.1 进入chaincode容器"></a>2.1 进入chaincode容器</h4><p>chaincode 容器的作用是为了以简化的方式建立并启动链码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it chaincode bash</span></span><br></pre></td></tr></table></figure><blockquote><p>命令提示符变为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@858726aed16e</span><span class="symbol">:/opt/gopath/src/chaincode</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>进入 chaincode 容器之后就可以构建与启动链码。</p></blockquote><h4 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h4><p>现在我们对 fabric-samples 提供的 chaincode_example02 进行测试，当然，在实际环境中，我们可以将开发的链码添加到 chaincode 子目录中并重新构建及启动链码，然后进行测试。</p><p>进入 <code>chaincode_example02/go/</code> 目录编译 chaincode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> chaincode_example02/go/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> go build</span></span><br></pre></td></tr></table></figure><h4 id="2-3-运行chaincode"><a href="#2-3-运行chaincode" class="headerlink" title="2.3 运行chaincode"></a>2.3 运行chaincode</h4><p>使用如下命令启动并运行链码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=mycc:0 ./go</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 001 Chaincode log level not provided; defaulting to: INFO</span><br><span class="line">[shim] SetupChaincodeLogging -&gt; INFO 002 Chaincode (build level: ) starting up ...</span><br></pre></td></tr></table></figure><p><strong>命令含义：</strong></p><ul><li><p><strong>CORE_PEER_ADDRESS：</strong>用于指定peer。</p></li><li><p><strong>CORE_CHAINCODE_ID_NAME</strong>：用于注册到peer的链码。</p><ul><li><strong>mycc：</strong> 指定链码名称</li><li><strong>0：</strong> 指定链码初始版本号</li><li><strong>./go：</strong> 指定链码文件</li></ul></li></ul><blockquote><p>注意，此阶段，链码与任何通道都没有关联。我们需要在后续步骤中使用“实例化”命令来完成.</p></blockquote><h3 id="3-调用链码"><a href="#3-调用链码" class="headerlink" title="3 调用链码"></a>3 调用链码</h3><p><strong>终端3（开启一个新的终端3）</strong></p><p>首先进入 cli 容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p>进入 CLI 容器后，执行如下命令安装及实例化 chaincode</p><blockquote><p>即使我们在 dev 模式下，也需要安装链码，使链码能够正常通过生命周期系统链码的检查 。将来可能会删除此步骤。</p></blockquote><p><strong>安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode install -p chaincodedev/chaincode/chaincode_example02/go -n mycc -v 0</span></span><br></pre></td></tr></table></figure><p>注意：安装链码时指定的链码名称与版本号必须与在终端2中注册的链码名称及版本号相同。</p><p>安装命令执行后，终端中输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">[msp] setupSigningIdentity -&gt; DEBU 034 Signing identity expires at 2027-11-10 13:41:11 +0000 UTC</span><br><span class="line">[msp] Validate -&gt; DEBU 035 MSP DEFAULT validating identity</span><br><span class="line">[grpc] Printf -&gt; DEBU 036 parsed scheme: ""</span><br><span class="line">[grpc] Printf -&gt; DEBU 037 scheme "" not registered, fallback to default scheme</span><br><span class="line">[grpc] Printf -&gt; DEBU 038 ccResolverWrapper: sending new addresses to cc: [&#123;peer:7051 0  &lt;nil&gt;&#125;]</span><br><span class="line">[grpc] Printf -&gt; DEBU 039 ClientConn switching balancer to "pick_first"</span><br><span class="line">[grpc] Printf -&gt; DEBU 03a pickfirstBalancer: HandleSubConnStateChange: 0xc4204e7c40, CONNECTING</span><br><span class="line">[grpc] Printf -&gt; DEBU 03b pickfirstBalancer: HandleSubConnStateChange: 0xc4204e7c40, READY</span><br><span class="line">[grpc] Printf -&gt; DEBU 03c parsed scheme: ""</span><br><span class="line">[grpc] Printf -&gt; DEBU 03d scheme "" not registered, fallback to default scheme</span><br><span class="line">[grpc] Printf -&gt; DEBU 03e ccResolverWrapper: sending new addresses to cc: [&#123;peer:7051 0  &lt;nil&gt;&#125;]</span><br><span class="line">[grpc] Printf -&gt; DEBU 03f ClientConn switching balancer to "pick_first"</span><br><span class="line">[grpc] Printf -&gt; DEBU 040 pickfirstBalancer: HandleSubConnStateChange: 0xc420072170, CONNECTING</span><br><span class="line">[grpc] Printf -&gt; DEBU 041 pickfirstBalancer: HandleSubConnStateChange: 0xc420072170, READY</span><br><span class="line">[msp] GetDefaultSigningIdentity -&gt; DEBU 042 Obtaining default signing identity</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 043 Using default escc</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 044 Using default vscc</span><br><span class="line">[chaincodeCmd] getChaincodeSpec -&gt; DEBU 045 java chaincode disabled</span><br><span class="line">[golang-platform] getCodeFromFS -&gt; DEBU 046 getCodeFromFS chaincodedev/chaincode/chaincode_example02/go</span><br><span class="line">[golang-platform] func1 -&gt; DEBU 047 Discarding GOROOT package fmt</span><br><span class="line">[golang-platform] func1 -&gt; DEBU 048 Discarding provided package github.com/hyperledger/fabric/core/chaincode/shim</span><br><span class="line">[golang-platform] func1 -&gt; DEBU 049 Discarding provided package github.com/hyperledger/fabric/protos/peer</span><br><span class="line">[golang-platform] func1 -&gt; DEBU 04a Discarding GOROOT package strconv</span><br><span class="line">[golang-platform] GetDeploymentPayload -&gt; DEBU 04b done</span><br><span class="line">[container] WriteFileToPackage -&gt; DEBU 04c Writing file to tarball: src/chaincodedev/chaincode/chaincode_example02/go/chaincode_example02.go</span><br><span class="line">[msp/identity] Sign -&gt; DEBU 04d Sign: plaintext: 0AC4070A5C08031A0C08C3F492DC0510...21E3DF010000FFFF4C61C899001C0000 </span><br><span class="line">[msp/identity] Sign -&gt; DEBU 04e Sign: digest: 6F0F7CF70A07027506571AAC56B978353CA3C73E311C882AB57263543ECE7B76 </span><br><span class="line">[chaincodeCmd] install -&gt; INFO 04f Installed remotely response:&lt;status:200 payload:"OK" &gt;</span><br></pre></td></tr></table></figure><p><strong>实例化：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode instantiate -n mycc -v 0 -c <span class="string">'&#123;"Args":["init","a", "100", "b","200"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>实例化命令执行后，终端中输出如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 091 Adding to config map: [Policy] /Channel/Application/Readers</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 092 Adding to config map: [Policy] /Channel/Application/Writers</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 093 Adding to config map: [Policy] /Channel/Application/Admins</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 094 Adding to config map: [Value]  /Channel/BlockDataHashingStructure</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 095 Adding to config map: [Value]  /Channel/OrdererAddresses</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 096 Adding to config map: [Value]  /Channel/HashingAlgorithm</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 097 Adding to config map: [Value]  /Channel/Consortium</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 098 Adding to config map: [Policy] /Channel/Writers</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 099 Adding to config map: [Policy] /Channel/Admins</span><br><span class="line">[common/configtx] addToMap -&gt; DEBU 09a Adding to config map: [Policy] /Channel/Readers</span><br><span class="line">[chaincodeCmd] InitCmdFactory -&gt; INFO 09b Retrieved channel (myc) orderer endpoint: orderer:7050</span><br><span class="line">[grpc] Printf -&gt; DEBU 09c parsed scheme: ""</span><br><span class="line">[grpc] Printf -&gt; DEBU 09d scheme "" not registered, fallback to default scheme</span><br><span class="line">[grpc] Printf -&gt; DEBU 09e ccResolverWrapper: sending new addresses to cc: [&#123;orderer:7050 0  &lt;nil&gt;&#125;]</span><br><span class="line">[grpc] Printf -&gt; DEBU 09f ClientConn switching balancer to "pick_first"</span><br><span class="line">[grpc] Printf -&gt; DEBU 0a0 pickfirstBalancer: HandleSubConnStateChange: 0xc42043d790, CONNECTING</span><br><span class="line">[grpc] Printf -&gt; DEBU 0a1 pickfirstBalancer: HandleSubConnStateChange: 0xc42043d790, READY</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 0a2 Using default escc</span><br><span class="line">[chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 0a3 Using default vscc</span><br><span class="line">[chaincodeCmd] getChaincodeSpec -&gt; DEBU 0a4 java chaincode disabled</span><br><span class="line">[msp/identity] Sign -&gt; DEBU 0a5 Sign: plaintext: 0AC9070A6108031A0C08F2F592DC0510...30300A000A04657363630A0476736363 </span><br><span class="line">[msp/identity] Sign -&gt; DEBU 0a6 Sign: digest: B7822DC27649C2CE85206E13DC69861CDB6C4786D6D3E299032BE2A187C0A362 </span><br><span class="line">[msp/identity] Sign -&gt; DEBU 0a7 Sign: plaintext: 0AC9070A6108031A0C08F2F592DC0510...025C39086D09D5D731F33C16A2E53492 </span><br><span class="line">[msp/identity] Sign -&gt; DEBU 0a8 Sign: digest: 27E503A393AD2B63F56A02FD29E4495999D913F037FEE4BCD894C16447EDAB35</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ol><li><p><strong>查询：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n mycc  -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>100</code></p></li><li><p><strong>调用：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode invoke -n mycc -c <span class="string">'&#123;"Args":["invoke","a","b","10"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 0a8 Chaincode invoke successful. result: status:200</span><br></pre></td></tr></table></figure></li><li><p><strong>查询：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer chaincode query -n mycc  -c <span class="string">'&#123;"Args":["query","a"]&#125;'</span> -C myc</span></span><br></pre></td></tr></table></figure><p>执行成功输出查询结果： <code>90</code></p></li></ol><h2 id="FAQ-3"><a href="#FAQ-3" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p>net 模式与 dev 模式到底有什么区别？</p><p>使用 net 模式每次修改链码后想要测试，需要对链码进行升级重新实例化（或重新安装再实例化），指定一大堆参数，给开发调试带来了很大的不便。而 dev 模式就简化了这些过程。</p></li><li><p>CORE_PEER_ADDRESS=peer:7052 中的 7052 端口到底指的是什么？为什么不是 7051 ？</p><p>peer:7052 是用于指定链码的专用监听地址及端口号。而7051是peer节点监听的网络端口</p></li></ol><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/119" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/119</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章fabric架构设计</title>
      <link href="/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC2%E7%AB%A0Fabric%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC2%E7%AB%A0Fabric%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="扒开Fabric架构：抽象的逻辑架构与实际的运行时架构"><a href="#扒开Fabric架构：抽象的逻辑架构与实际的运行时架构" class="headerlink" title="扒开Fabric架构：抽象的逻辑架构与实际的运行时架构"></a>扒开Fabric架构：抽象的逻辑架构与实际的运行时架构</h2><h2 id="一、扒开Fabric架构：抽象的逻辑架构与实际的运行时架构"><a href="#一、扒开Fabric架构：抽象的逻辑架构与实际的运行时架构" class="headerlink" title="一、扒开Fabric架构：抽象的逻辑架构与实际的运行时架构"></a>一、扒开Fabric架构：抽象的逻辑架构与实际的运行时架构</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>理解Hyperledger Fabric超级账本的逻辑架构。</li><li>理解Hyperledger Fabric超级账本的实际运行时架构。</li></ol><h3 id="1-比较抽象的逻辑架构"><a href="#1-比较抽象的逻辑架构" class="headerlink" title="1 比较抽象的逻辑架构"></a>1 比较抽象的逻辑架构</h3><p>Fabric从1.X开始，在扩展性及安全性上面有了大大的提升，且新增了诸多的新特性：</p><ul><li><p>多通道：支持多通道，提高隔离安全性。</p></li><li><p>可拔插的组件：支持共识组件、权限管理组件等可拔插功能。</p></li><li><p>账本数据可被存储为多种格式。</p></li><li><p>分化了Peer节点的多种角色，可以根据具体情况实现灵活部署</p><a id="more"></a></li></ul><p>Hyperledger Fabric超级账本整体逻辑架构如下图所示：</p><p><img src="http://image.chaindesk.cn/2.1.png/mark" alt="Fabric逻辑架构"></p><p><strong>Fabric四大核心组件：</strong></p><ol><li><p><strong>Membership Services：</strong>成员管理保证了Fabric平台访问的安全性。提供了成员的注册、管理及审核功能。</p></li><li><p><strong>Blockchain Services：</strong></p><p>是区块链的核心部分，为区块链的主体功能提供了底层支撑；包括共识管理、分布式账本实现、账本的存储以及网络中各节点之间的通信实现。</p><ul><li><strong>BlockChain：</strong>区块之间以Hash连接为结构的交易日志。peer从order service接收交易区块k，并根据背书策略和并发冲突标记区块上的交易是否有效，然后将该区块追加到peer文件系统中的Hash Chain上。</li><li><strong>Transaction：</strong>交易有对链码的部署或调用两种操作类型：<ul><li>部署交易：部署是请求在peer上启动链码容器；创建新的链码并设置一个程序作为参数。当一个部署交易执行成功，表明链码已被安装到区块链上。</li><li>调用交易：调用是从账本中请求读写集。是在之前已部署链码的情况下执行一个操作。调用交易将使用链码提供的一个函数。当成功时，链码执行特定的函数对账本数据进行操作（修改状态），并返回操作结果。</li></ul></li></ul><p>3.<strong>Chaincode Services：</strong></p><p>提供了链码的部署及运行时的所需环境。</p></li></ol><ul><li><p>Chaincode：是一个可以对账本数据进行操作的可开发的组件程；链码被布署运行在一个安全的容器中；用户可以通过调用链码中的指定函数对账本数据进行修改或读取操作。</p><p>4.<strong>Event：</strong>为各组件之间提供异步通信提供了技术实现。</p></li></ul><h3 id="2-实际中的运行时架构"><a href="#2-实际中的运行时架构" class="headerlink" title="2 实际中的运行时架构"></a>2 实际中的运行时架构</h3><p>实际运行时架构如下图所示：</p><p><img src="http://image.chaindesk.cn/2.2.png/mark" alt="运行时架构"></p><p>运行时架构图中各项解释如下：</p><p><strong>APP：</strong>代表一个客户端（CLI）或SDK，作用是创建交易并<strong>获取到足够的背书</strong>之后向Orderer排序服务节点提交交易请求（Peer与Orderer节点提供了gRPC远程访问接口，供客户端调用）。</p><p><strong>CA：</strong>负责对网络中所有的证书进行管理(对Fabric网络中的成员身份进行管理), 提供标准的PKI服务。</p><p><strong>MSP（Member Service Provider）：</strong>为客户端和Peer提供证书的系统抽象组件。</p><p><strong>Channel：</strong>将一个大的网络分割成为不同的私有”子网”。</p><ul><li><p>通道的作用：通道提供一种通讯机制，将peers和orderer连接在一起，形成一个具有保密性的通讯链路（虚拟）， 进行数据隔离。</p><blockquote><p>要加入通道的每个节点都必须拥有自己的通过成员服务提供商（MSP）获得的身份标识。</p></blockquote></li></ul><p><strong>Orderer：</strong>对客户端提交的交易请求进行排序，之后生成区块广播给通道内的所有peer节点。</p><p><strong>Org1：</strong>代表联盟中的某一个组织（一个联盟中可以多个不同的组织组成）。</p><p><strong>Peer：</strong>表示组织中的节点；Peer节点以区块的形式从Orderer排序服务节点接收有序状态更新，维护状态和账本。在Fabtic网络环境中 Peer 节点可以划分为如下角色：</p><ul><li><p><strong>Endorsing peer：</strong>根据指定的策略调用智能合约，对结果进行背书， 返回提案响应到客户端。</p></li><li><p><strong>Committing peer：</strong>验证数据并保存至账本中。</p></li><li><p><strong>Anchor peer：</strong>跨组织通信。</p></li><li><p><strong>Leading peer：</strong>作为组织内所有节点的的代表连接到Orderer排序服务节点, 将从排序服务节点接收到的批量区块广播给组织内的其它节点。</p><blockquote><p>网络中只有部分节点为背书节点； 网络中所有Peer节点为账本节点。</p></blockquote></li></ul><p><strong>Chaincode：</strong>链式代码，简称链码；运行在容器中，提供相应的API与账本数据进行交互。</p><p><strong>Ledger：</strong>是由排序服务构建的一个全部有序的交易哈希链块，保存在所有的peer节点中。账本提供了在系统运行过程中发生的可验证历史，它包含所有成功的状态更改（有效交易）和不成功的状态更改（无效交易）。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>应用程序或客户端到底需要连接到哪些Peer节点？</p><p>只需要连接到背书节点即可。</p></li><li><p>背书节点怎么指定？</p><p>在实例化链码时由背书策略指定。</p></li></ol><h2 id="二、Fabric核心配置文件的理解"><a href="#二、Fabric核心配置文件的理解" class="headerlink" title="二、Fabric核心配置文件的理解"></a>二、Fabric核心配置文件的理解</h2><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li>了解Hyperledger Fabric对Peer节点的核心配置信息</li><li>了解Hyperledger Fabric对orderer节点的核心配置信息</li></ol><blockquote><p>在Hyperledger Fabric中， 有两个示例配置文件，一个为Peer节点的示例配置文件，一个为Orderer节点的示例配置文件，理解这两个配置文件的内容对于我们而言，会更进一步的理解Hyperledger Fabric运行状况。</p></blockquote><h3 id="1-core-yaml详解"><a href="#1-core-yaml详解" class="headerlink" title="1 core.yaml详解"></a>1 core.yaml详解</h3><p>core.yaml配置文件是Peer节点的示例配置文件，具体路径在 fabric-samples/config 目录下；该core.yaml示例配置文件中共指定了六大部分内容，详见解释如下。</p><blockquote><p>在Fabirc源码中的路径为：<code>$GOPATH/src/github.com/hyperledger/fabric/sampleconfig/core.yaml</code></p></blockquote><h4 id="1-1-日志部分："><a href="#1-1-日志部分：" class="headerlink" title="1.1 日志部分："></a>1.1 日志部分：</h4><p>日志记录级别有六种：<code>CRITICAL | ERROR | WARNING | NOTICE | INFO | DEBUG</code></p><p>使用 level 指定默认所有模块为 <code>info</code> 级别，然后单独指定 cauthdsl、gossip、grpc、ledger、msp、policies、peer 的 gossip 模块的日志级别，以覆盖默认的日志级别。</p><p>format属性指定了日志的输出格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">    <span class="attr">level:</span>       <span class="string">info</span>    <span class="comment"># 全局的日志级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独模块的日志级别，覆盖全局日志级别</span></span><br><span class="line">    <span class="attr">cauthdsl:</span>   <span class="string">warning</span></span><br><span class="line">    <span class="attr">gossip:</span>     <span class="string">warning</span></span><br><span class="line">    <span class="attr">grpc:</span>       <span class="string">error</span></span><br><span class="line">    <span class="attr">ledger:</span>     <span class="string">info</span></span><br><span class="line">    <span class="attr">msp:</span>        <span class="string">warning</span></span><br><span class="line">    <span class="attr">policies:</span>   <span class="string">warning</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">peer:</span></span><br><span class="line">        <span class="attr">gossip:</span> <span class="string">warning</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">format:</span> <span class="string">'<span class="template-variable">%&#123;color&#125;</span><span class="template-variable">%&#123;time:2006-01-02 15:04:05.000 MST&#125;</span> [<span class="template-variable">%&#123;module&#125;</span>] <span class="template-variable">%&#123;shortfunc&#125;</span> -&gt; <span class="template-variable">%&#123;level:.4s&#125;</span> <span class="template-variable">%&#123;id:03x&#125;</span><span class="template-variable">%&#123;color:reset&#125;</span> <span class="template-variable">%&#123;message&#125;</span>'</span></span><br></pre></td></tr></table></figure><h4 id="1-2-peer部分："><a href="#1-2-peer部分：" class="headerlink" title="1.2 peer部分："></a>1.2 peer部分：</h4><p>peer部分是 Peer 服务的核心配置内容，包括 Peer 的基础服务部分、gossip 部分、event、tls、BCCSP 等相关配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peer:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">jdoe</span>        <span class="comment"># 指定节点ID</span></span><br><span class="line">    <span class="attr">networkId:</span> <span class="string">dev</span>     <span class="comment"># 指定网络ID</span></span><br><span class="line">    <span class="attr">listenAddress:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:7051</span>        <span class="comment">#侦听本地网络接口上的地址。默认监听所有网络接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#侦听入站链码连接的端点。如果被注释，则选择侦听地址端口7052的对等点地址</span></span><br><span class="line">    <span class="comment"># chaincodeListenAddress: 0.0.0.0:7052    </span></span><br><span class="line">    <span class="comment"># 此peer的链码端点用于连接到peer。如果没有指定，则选择chaincodeListenAddress地址。</span></span><br><span class="line">    <span class="comment"># 如果没有指定chaincodeListenAddress，则从其中选择address </span></span><br><span class="line">    <span class="comment"># chaincodeAddress: 0.0.0.0:705</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:7051</span>    <span class="comment"># 节点对外的服务地址</span></span><br><span class="line">    <span class="attr">addressAutoDetect:</span> <span class="literal">false</span>    <span class="comment"># 是否自动探测对外服务地址    </span></span><br><span class="line">    <span class="attr">gomaxprocs:</span> <span class="number">-1</span>    <span class="comment"># 进程数限制，－1代表无限制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Peer服务与Client的设置</span></span><br><span class="line">    <span class="attr">keepalive:</span></span><br><span class="line">        <span class="comment"># 指定客户机ping的最小间隔，如果客户端频繁发送ping，Peer服务器会自动断开</span></span><br><span class="line">        <span class="attr">minInterval:</span> <span class="string">60s</span>    </span><br><span class="line"></span><br><span class="line">        <span class="attr">client:</span>     <span class="comment"># 客户端与Peer的通信设置 </span></span><br><span class="line">            <span class="comment"># 指定ping Peer节点的间隔时间，必须大于或等于 minInterval 的值        </span></span><br><span class="line">            <span class="attr">interval:</span> <span class="string">60s</span>           </span><br><span class="line">            <span class="attr">timeout:</span> <span class="string">20s</span>    <span class="comment"># 在断开peer节点连接之前等待的响应时间</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">deliveryClient:</span>    <span class="comment"># 客户端与Orderer节点的通信设置</span></span><br><span class="line">            <span class="comment"># 指定ping orderer节点的间隔时间，必须大于或等于 minInterval 的值</span></span><br><span class="line">            <span class="attr">interval:</span> <span class="string">60s</span>             </span><br><span class="line">            <span class="attr">timeout:</span> <span class="string">20s</span>    <span class="comment"># 在断开Orderer节点连接之前等待的响应时间</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gossip:</span>   <span class="comment"># gossip相关配置    </span></span><br><span class="line">        <span class="attr">bootstrap:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7051</span>    <span class="comment"># 启动后的初始节点</span></span><br><span class="line">        <span class="attr">useLeaderElection:</span> <span class="literal">true</span>     <span class="comment"># 是否指定使用选举方式产式Leader</span></span><br><span class="line">        <span class="attr">orgLeader:</span> <span class="literal">false</span>    <span class="comment"># 是否指定当前节点为Leader</span></span><br><span class="line">        <span class="attr">endpoint:</span>      </span><br><span class="line"></span><br><span class="line">        <span class="attr">maxBlockCountToStore:</span> <span class="number">100</span>  <span class="comment"># 保存在内存中的最大区块     </span></span><br><span class="line">        <span class="attr">maxPropagationBurstLatency:</span> <span class="string">10ms</span>    <span class="comment">#消息连续推送之间的最大时间(超过则触发，转发给其它节点)</span></span><br><span class="line">        <span class="attr">maxPropagationBurstSize:</span> <span class="number">10</span>    <span class="comment"># 消息的最大存储数量，直到推送被触发 </span></span><br><span class="line">        <span class="attr">propagateIterations:</span> <span class="number">1</span>    <span class="comment"># 将消息推送到远程Peer节点的次数   </span></span><br><span class="line">        <span class="attr">propagatePeerNum:</span> <span class="number">3</span>  <span class="comment"># 选择推送消息到Peer节点的数量     </span></span><br><span class="line">        <span class="attr">pullInterval:</span> <span class="string">4s</span>    <span class="comment"># 拉取消息的时间间隔  </span></span><br><span class="line">        <span class="attr">pullPeerNum:</span> <span class="number">3</span>      <span class="comment"># 从指定数量的Peer节点拉取 </span></span><br><span class="line">        <span class="attr">requestStateInfoInterval:</span> <span class="string">4s</span> <span class="comment"># 确定从Peer节点提取状态信息消息的频率(单位:秒)             </span></span><br><span class="line">        <span class="attr">publishStateInfoInterval:</span> <span class="string">4s</span> <span class="comment"># 确定将状态信息消息推送到Peer节点的频率     </span></span><br><span class="line">        <span class="attr">stateInfoRetentionInterval:</span>  <span class="comment"># 状态信息的最长保存时间     </span></span><br><span class="line">        <span class="attr">publishCertPeriod:</span> <span class="string">10s</span>      <span class="comment">#  启动后包括证书的等待时间</span></span><br><span class="line">        <span class="attr">skipBlockVerification:</span> <span class="literal">false</span>     <span class="comment"># 是否应该跳过区块消息的验证   </span></span><br><span class="line">        <span class="attr">dialTimeout:</span> <span class="string">3s</span>     <span class="comment"># 拨号的超时时间     </span></span><br><span class="line">        <span class="attr">connTimeout:</span> <span class="string">2s</span>     <span class="comment"># 连接超时时间    </span></span><br><span class="line">        <span class="attr">recvBuffSize:</span> <span class="number">20</span>    <span class="comment"># 接收到消息的缓存区大小    </span></span><br><span class="line">        <span class="attr">sendBuffSize:</span> <span class="number">200</span>    <span class="comment"># 发送消息的缓冲区大小</span></span><br><span class="line">        <span class="attr">digestWaitTime:</span> <span class="string">1s</span>  <span class="comment"># 处理摘要数据的等待时间     </span></span><br><span class="line">        <span class="attr">requestWaitTime:</span> <span class="string">1500ms</span>      <span class="comment"># 处理nonce之前等待的时间   </span></span><br><span class="line">        <span class="attr">responseWaitTime:</span> <span class="string">2s</span>   <span class="comment"># 终止拉取数据处理的等待时间    </span></span><br><span class="line">        <span class="attr">aliveTimeInterval:</span> <span class="string">5s</span>      <span class="comment"># 心跳检查间隔时间  </span></span><br><span class="line">        <span class="attr">aliveExpirationTimeout:</span> <span class="string">25s</span>    <span class="comment"># 心跳消息的超时时间    </span></span><br><span class="line">        <span class="attr">reconnectInterval:</span> <span class="string">25s</span>       <span class="comment"># 重新连接的间隔时间 </span></span><br><span class="line">        <span class="attr">externalEndpoint:</span>    <span class="comment"># 组织外的端点</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">election:</span>   <span class="comment"># 选举Leader配置     </span></span><br><span class="line">            <span class="attr">startupGracePeriod:</span> <span class="string">15s</span>       <span class="comment"># 最长等待时间 </span></span><br><span class="line">            <span class="attr">membershipSampleInterval:</span> <span class="string">1s</span>  <span class="comment"># 检查稳定性的间隔时间     </span></span><br><span class="line">            <span class="attr">leaderAliveThreshold:</span> <span class="string">10s</span>     <span class="comment"># 进行选举的间隔时间</span></span><br><span class="line">            <span class="attr">leaderElectionDuration:</span> <span class="string">5s</span>    <span class="comment"># 声明自己为Leader的等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">pvtData:</span>    <span class="comment"># 私有数据配置</span></span><br><span class="line">            <span class="comment"># 尝试从peer节点中提取给定块对应的私有数据的最大持续时间</span></span><br><span class="line">            <span class="attr">pullRetryThreshold:</span> <span class="string">60s</span>    </span><br><span class="line">            <span class="comment"># 当前分类帐在提交时的高度之间的最大差异</span></span><br><span class="line">            <span class="attr">transientstoreMaxBlockRetention:</span> <span class="number">1000</span>            </span><br><span class="line">            <span class="attr">pushAckTimeout:</span> <span class="string">3s</span>   <span class="comment"># 等待每个对等方确认的最大时间         </span></span><br><span class="line">            <span class="comment"># 用作缓冲器；防止peer试图获取私有数据来自即将在接下来的N个块中被清除的对等节点</span></span><br><span class="line">            <span class="attr">btlPullMargin:</span> <span class="number">10</span>    </span><br><span class="line"></span><br><span class="line">    <span class="attr">events:</span>    </span><br><span class="line">        <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:7053</span>    <span class="comment"># 指定事件服务的地址</span></span><br><span class="line">        <span class="attr">buffersize:</span> <span class="number">100</span>    <span class="comment"># 可以在不阻塞发送的情况下缓冲的事件总数</span></span><br><span class="line">        <span class="comment"># 将事件添加到一个完整的缓冲区时要阻塞多长时间</span></span><br><span class="line">        <span class="comment"># 如果小于0，直接丢弃</span></span><br><span class="line">        <span class="comment"># 如果等于0，事件被添加至缓冲区并发出</span></span><br><span class="line">        <span class="comment"># 如果大于0，超时还未发出则丢弃</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="string">10ms</span>    </span><br><span class="line">        <span class="comment"># 在注册事件中指定的时间和客户端时间之间的差异</span></span><br><span class="line">        <span class="attr">timewindow:</span> <span class="string">15m</span>    </span><br><span class="line"></span><br><span class="line">        <span class="attr">keepalive:</span> <span class="comment"># peer服务器与客户端的实时设置           </span></span><br><span class="line">            <span class="attr">minInterval:</span> <span class="string">60s</span>    <span class="comment"># 允许客户端向peer服务器发送ping的最小间隔时间</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">sendTimeout:</span> <span class="string">60s</span>    <span class="comment"># GRPC向客户端发送事件的超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">tls:</span>    <span class="comment"># TLS设置 </span></span><br><span class="line">        <span class="attr">enabled:</span>  <span class="literal">false</span>   <span class="comment"># 是否开启服务器端TLS    </span></span><br><span class="line">        <span class="comment"># 是否需要客户端证书（没有配置使用证书的客户端不能连接到对等点）</span></span><br><span class="line">        <span class="attr">clientAuthRequired:</span> <span class="literal">false</span>    </span><br><span class="line"></span><br><span class="line">        <span class="attr">cert:</span>    <span class="comment"># TLS服务器的X.509证书</span></span><br><span class="line">            <span class="attr">file:</span> <span class="string">tls/server.crt</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">key:</span>    <span class="comment"># TLS服务器(需启用clientAuthEnabled的客户端)的签名私钥</span></span><br><span class="line">            <span class="attr">file:</span> <span class="string">tls/server.key</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">rootcert:</span>    <span class="comment"># 可信任的根CA证书</span></span><br><span class="line">            <span class="attr">file:</span> <span class="string">tls/ca.crt</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">clientRootCAs:</span>    <span class="comment"># 用于验证客户端证书的根证书</span></span><br><span class="line">            <span class="attr">files:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">tls/ca.crt</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">clientKey:</span>    <span class="comment"># 建立客户端连接时用于TLS的私钥。如果没有设置将使用peer.tls.key</span></span><br><span class="line">            <span class="attr">file:</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">clientCert:</span>    <span class="comment"># 建立客户端连接时用于TLS的证书。如果没有设置将使用peer.tls.cert</span></span><br><span class="line">            <span class="attr">file:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">authentication:</span>    <span class="comment"># 与身份验证相关的配置</span></span><br><span class="line">        <span class="attr">timewindow:</span> <span class="string">15m</span>    <span class="comment"># 当前服务器时间与客户端请求消息中指定的客户端时间差异</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">fileSystemPath:</span> <span class="string">/var/hyperledger/production</span>    <span class="comment"># 文件存储路径</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">BCCSP:</span>    <span class="comment"># 区块链加密实现</span></span><br><span class="line">        <span class="attr">Default:</span> <span class="string">SW</span>        <span class="comment"># 设置SW为默认加密程序  </span></span><br><span class="line">        <span class="attr">SW:</span>      <span class="comment"># SW加密配置（如果默认为SW）       </span></span><br><span class="line">            <span class="attr">Hash:</span> <span class="string">SHA2</span>        <span class="comment"># 默认的哈希算法和安全级别</span></span><br><span class="line">            <span class="attr">Security:</span> <span class="number">256</span>    <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">            <span class="attr">FileKeyStore:</span>    <span class="comment"># 密钥存储位置</span></span><br><span class="line">                <span class="comment"># 如果为空，默认为'mspConfigPath/keystore'</span></span><br><span class="line">                <span class="attr">KeyStore:</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">PKCS11:</span>  <span class="comment"># PKCS11加密配置（如果默认为PKCS11）</span></span><br><span class="line">            <span class="attr">Library:</span>    <span class="comment"># PKCS11模块库位置           </span></span><br><span class="line">            <span class="attr">Label:</span>    <span class="comment"># 令牌Label</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">Pin:</span></span><br><span class="line">            <span class="attr">Hash:</span></span><br><span class="line">            <span class="attr">Security:</span></span><br><span class="line">            <span class="attr">FileKeyStore:</span></span><br><span class="line">                <span class="attr">KeyStore:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MSP配置路径，peer根据此路径找到MSP本地配置</span></span><br><span class="line">    <span class="attr">mspConfigPath:</span> <span class="string">msp</span></span><br><span class="line">    <span class="attr">localMspId:</span> <span class="string">SampleOrg</span>    <span class="comment">#本地MSP的标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">client:</span>    <span class="comment"># CLI客户端配置选项</span></span><br><span class="line">        <span class="attr">connTimeout:</span> <span class="string">3s</span>    <span class="comment"># 连接超时</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">deliveryclient:</span>    <span class="comment"># 订购服务相关的配置        </span></span><br><span class="line">        <span class="attr">reconnectTotalTimeThreshold:</span> <span class="string">3600s</span>    <span class="comment"># 尝试重新连接的总时间</span></span><br><span class="line">        <span class="attr">connTimeout:</span> <span class="string">3s</span>    <span class="comment"># 订购服务节点连接超时</span></span><br><span class="line">        <span class="attr">reConnectBackoffThreshold:</span> <span class="string">3600s</span>    <span class="comment"># 最大延迟时间</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">localMspType:</span> <span class="string">bccsp</span>    <span class="comment"># 本地MSP类型（默认情况下，是bccsp类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仅在非生产环境中与Go分析工具一起使用。在生产中，它应该被禁用</span></span><br><span class="line">    <span class="attr">profile:</span></span><br><span class="line">        <span class="attr">enabled:</span>     <span class="literal">false</span></span><br><span class="line">        <span class="attr">listenAddress:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:6060</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于管理操作，如控制日志模块的严重程度等。只有对等管理员才能使用该服务</span></span><br><span class="line">    <span class="attr">adminService:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义处理程序可以过滤和自定义处理程序在对等点内传递的对象</span></span><br><span class="line">    <span class="attr">handlers:</span></span><br><span class="line">        <span class="attr">authFilters:</span></span><br><span class="line">          <span class="bullet">-</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">DefaultAuth</span></span><br><span class="line">          <span class="bullet">-</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">ExpirationCheck</span>   </span><br><span class="line">        <span class="attr">decorators:</span></span><br><span class="line">          <span class="bullet">-</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">DefaultDecorator</span></span><br><span class="line">        <span class="attr">endorsers:</span></span><br><span class="line">          <span class="attr">escc:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">DefaultEndorsement</span></span><br><span class="line">            <span class="attr">library:</span></span><br><span class="line">        <span class="attr">validators:</span></span><br><span class="line">          <span class="attr">vscc:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">DefaultValidation</span></span><br><span class="line">            <span class="attr">library:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并行执行事务验证的goroutines的数量（注意重写此值可能会对性能产生负面影响）</span></span><br><span class="line">    <span class="attr">validatorPoolSize:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户端使用发现服务查询关于对等点的信息</span></span><br><span class="line">    <span class="comment"># 例如——哪些同行加入了某个频道，最新消息是什么通道配置</span></span><br><span class="line">    <span class="comment"># 最重要的是——给定一个链码和通道，什么可能的对等点集满足背书政策</span></span><br><span class="line">    <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>        </span><br><span class="line">        <span class="attr">authCacheEnabled:</span> <span class="literal">true</span>        </span><br><span class="line">        <span class="attr">authCacheMaxSize:</span> <span class="number">1000</span>       </span><br><span class="line">        <span class="attr">authCachePurgeRetentionRatio:</span> <span class="number">0.75</span>       </span><br><span class="line">        <span class="attr">orgMembersAllowedAccess:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="1-3-vm部分："><a href="#1-3-vm部分：" class="headerlink" title="1.3 vm部分："></a>1.3 vm部分：</h4><p>对链码运行环境的配置，目前主要支持 <code>Docker</code> 容器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">unix:///var/run/docker.sock</span>    <span class="comment"># vm管理系统的端点</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">docker:</span>    <span class="comment"># 设置docker</span></span><br><span class="line">        <span class="attr">tls:</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">ca:</span></span><br><span class="line">                <span class="attr">file:</span> <span class="string">docker/ca.crt</span></span><br><span class="line">            <span class="attr">cert:</span></span><br><span class="line">                <span class="attr">file:</span> <span class="string">docker/tls.crt</span></span><br><span class="line">            <span class="attr">key:</span></span><br><span class="line">                <span class="attr">file:</span> <span class="string">docker/tls.key</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">attachStdout:</span> <span class="literal">false</span>    <span class="comment"># 启用/禁用链码容器中的标准out/err</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建docker容器的参数</span></span><br><span class="line">        <span class="comment"># 使用用于集群的ipam和dns-server可以有效地创建容器设置容器的网络模式</span></span><br><span class="line">        <span class="comment"># 支持标准值是：“host”(默认)、“bridge”、“ipvlan”、“none”</span></span><br><span class="line">        <span class="comment"># Dns -供容器使用的Dns服务器列表</span></span><br><span class="line">        <span class="comment">#注:'Privileged'、'Binds'、'Links'和'PortBindings'属性不支持Docker主机配置，设置后将不使用</span></span><br><span class="line">        <span class="attr">hostConfig:</span></span><br><span class="line">            <span class="attr">NetworkMode:</span> <span class="string">host</span></span><br><span class="line">            <span class="attr">Dns:</span></span><br><span class="line">               <span class="comment"># - 192.168.0.1</span></span><br><span class="line">            <span class="attr">LogConfig:</span></span><br><span class="line">                <span class="attr">Type:</span> <span class="string">json-file</span></span><br><span class="line">                <span class="attr">Config:</span></span><br><span class="line">                    <span class="attr">max-size:</span> <span class="string">"50m"</span></span><br><span class="line">                    <span class="attr">max-file:</span> <span class="string">"5"</span></span><br><span class="line">            <span class="attr">Memory:</span> <span class="number">2147483648</span></span><br></pre></td></tr></table></figure><h4 id="1-4-chaincode部分："><a href="#1-4-chaincode部分：" class="headerlink" title="1.4 chaincode部分："></a>1.4 chaincode部分：</h4><p>与链码相关的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">chaincode:</span></span><br><span class="line">    <span class="attr">id:</span>    </span><br><span class="line">        <span class="attr">path:</span></span><br><span class="line">        <span class="attr">name:</span></span><br><span class="line">    <span class="comment"># 通用构建器环境，适用于大多数链代码类型</span></span><br><span class="line">    <span class="attr">builder:</span> <span class="string">$(DOCKER_NS)/fabric-ccenv:latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在用户链码实例化过程中启用/禁用基本docker镜像的拉取</span></span><br><span class="line">    <span class="attr">pull:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">golang:</span>    <span class="comment"># golang的baseos</span></span><br><span class="line">        <span class="attr">runtime:</span> <span class="string">$(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)</span></span><br><span class="line">        <span class="attr">dynamicLink:</span> <span class="literal">false</span>    <span class="comment"># 是否动态链接golang链码</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">car:</span></span><br><span class="line">        <span class="comment">#　平台可能需要更多的扩展工具(JVM等)。目前，只能使用baseos</span></span><br><span class="line">        <span class="attr">runtime:</span> <span class="string">$(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">java:</span></span><br><span class="line">        <span class="comment"># 用于Java链代码运行时，基于java:openjdk-8和加法编译器的镜像</span></span><br><span class="line">        <span class="attr">Dockerfile:</span>  <span class="string">|</span></span><br><span class="line">            <span class="string">from</span> <span class="string">$(DOCKER_NS)/fabric-javaenv:$(ARCH)-1.1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">node:</span>  </span><br><span class="line">        <span class="comment"># js引擎在运行时，指定的baseimage（不是baseos）</span></span><br><span class="line">        <span class="attr">runtime:</span> <span class="string">$(BASE_DOCKER_NS)/fabric-baseimage:$(ARCH)-$(BASE_VERSION)</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">startuptimeout:</span> <span class="string">300s</span>    <span class="comment"># 启动超时时间</span></span><br><span class="line">    <span class="attr">executetimeout:</span> <span class="string">30s</span>        <span class="comment"># 调用和Init调用的超时持续时间</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">net</span>    <span class="comment"># 指定模式（dev、net两种）</span></span><br><span class="line">    <span class="attr">keepalive:</span> <span class="number">0</span>    <span class="comment"># Peer和链码之间的心跳超时，值小于或等于0会关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">system:</span>    <span class="comment"># 系统链码白名单</span></span><br><span class="line">        <span class="attr">cscc:</span> <span class="string">enable</span></span><br><span class="line">        <span class="attr">lscc:</span> <span class="string">enable</span></span><br><span class="line">        <span class="attr">escc:</span> <span class="string">enable</span></span><br><span class="line">        <span class="attr">vscc:</span> <span class="string">enable</span></span><br><span class="line">        <span class="attr">qscc:</span> <span class="string">enable</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">systemPlugins:</span>    <span class="comment"># 系统链码插件:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">logging:</span>   <span class="comment"># 链码容器的日志部分  </span></span><br><span class="line">      <span class="attr">level:</span>  <span class="string">info</span></span><br><span class="line">      <span class="attr">shim:</span>   <span class="string">warning</span></span><br><span class="line">      <span class="attr">format:</span> <span class="string">'<span class="template-variable">%&#123;color&#125;</span><span class="template-variable">%&#123;time:2006-01-02 15:04:05.000 MST&#125;</span> [<span class="template-variable">%&#123;module&#125;</span>] <span class="template-variable">%&#123;shortfunc&#125;</span> -&gt; <span class="template-variable">%&#123;level:.4s&#125;</span> <span class="template-variable">%&#123;id:03x&#125;</span><span class="template-variable">%&#123;color:reset&#125;</span> <span class="template-variable">%&#123;message&#125;</span>'</span></span><br></pre></td></tr></table></figure><h4 id="1-5-ledger部分："><a href="#1-5-ledger部分：" class="headerlink" title="1.5 ledger部分："></a>1.5 ledger部分：</h4><p>分类帐的配置信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ledger:</span></span><br><span class="line">  <span class="attr">blockchain:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">state:</span> </span><br><span class="line">    <span class="attr">stateDatabase:</span> <span class="string">goleveldb</span>    <span class="comment"># 指定默认的状态数据库</span></span><br><span class="line">    <span class="attr">couchDBConfig:</span>    <span class="comment"># 配置couchDB信息</span></span><br><span class="line">       <span class="attr">couchDBAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5984</span>    <span class="comment"># 监听地址</span></span><br><span class="line">       <span class="attr">username:</span></span><br><span class="line">       <span class="attr">password:</span></span><br><span class="line">       <span class="attr">maxRetries:</span> <span class="number">3</span>    <span class="comment"># 重新尝试CouchDB错误的次数</span></span><br><span class="line">       <span class="attr">maxRetriesOnStartup:</span> <span class="number">10</span>      <span class="comment">#　对等启动期间对CouchDB错误的重试次数 </span></span><br><span class="line">       <span class="attr">requestTimeout:</span> <span class="string">35s</span>      <span class="comment">#　对等启动期间对CouchDB错误的重试次数 </span></span><br><span class="line">       <span class="attr">queryLimit:</span> <span class="number">10000</span>     <span class="comment">#　限制每个查询返回的记录数量  </span></span><br><span class="line">       <span class="attr">maxBatchUpdateSize:</span> <span class="number">1000</span>      <span class="comment">#　限制每个CouchDB批量更新的记录数量</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">#　值为１时将在每次提交块后对进行索引</span></span><br><span class="line">       <span class="comment"># 增加值可以提高peer和CouchDB的写效率，但是可能会降低查询响应时间</span></span><br><span class="line">       <span class="attr">warmIndexesAfterNBlocks:</span> <span class="number">1</span>    </span><br><span class="line"></span><br><span class="line">  <span class="attr">history:</span>    </span><br><span class="line">    <span class="attr">enableHistoryDatabase:</span> <span class="literal">true</span>        <span class="comment"># 是否开启历史数据库</span></span><br></pre></td></tr></table></figure><h4 id="1-6-metrics部分："><a href="#1-6-metrics部分：" class="headerlink" title="1.6 metrics部分："></a>1.6 metrics部分：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>    <span class="comment"># 启用或禁用metrics服务器</span></span><br><span class="line">    <span class="comment"># 当启用metrics服务器时</span></span><br><span class="line">    <span class="comment"># 必须使用特定的metrics报告程序类型当前支持的类型:“statsd”、“prom”</span></span><br><span class="line">    <span class="attr">reporter:</span> <span class="string">statsd</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">1s</span>    <span class="comment"># 确定报告度量的频率</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">statsdReporter:</span></span><br><span class="line">          <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8125</span>    <span class="comment"># 要连接的statsd服务器地址</span></span><br><span class="line">          <span class="attr">flushInterval:</span> <span class="string">2s</span>    <span class="comment"># 确定向statsd服务器推送指标的频率</span></span><br><span class="line">          <span class="comment"># 每个push metrics请求的最大字节数 #内部网推荐1432，互联网推荐512</span></span><br><span class="line">          <span class="attr">flushBytes:</span> <span class="number">1432</span>    </span><br><span class="line"></span><br><span class="line">    <span class="attr">promReporter:</span></span><br><span class="line">          <span class="attr">listenAddress:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8080</span>    <span class="comment"># http服务器监听地址</span></span><br></pre></td></tr></table></figure><h3 id="2-orderer-yaml详解"><a href="#2-orderer-yaml详解" class="headerlink" title="2 orderer.yaml详解"></a>2 orderer.yaml详解</h3><p><code>orderer.yaml</code> 配置文件是 Orderer 节点的示例配置文件，具体路径在 <code>fabric-samples/config</code> 目录下；该 orderer.yaml 示例配置文件中共指定了五大部分内容，详细解释见如下内容。</p><blockquote><p>在 Fabirc 源码中的路径为：<code>$GOPATH/src/github.com/hyperledger/fabric/sampleconfig/orderer.yaml</code></p></blockquote><p>该 <code>orderer.yaml</code> 示例配置文件中共指定了五大部分内容：</p><h4 id="2-1-General部分："><a href="#2-1-General部分：" class="headerlink" title="2.1 General部分："></a>2.1 General部分：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">General:</span></span><br><span class="line">    <span class="attr">LedgerType:</span> <span class="string">file</span>    <span class="comment"># 指定账本类型（可选file、RAM、json三种）</span></span><br><span class="line">    <span class="attr">ListenAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>    <span class="comment"># 监听地址</span></span><br><span class="line">    <span class="attr">ListenPort:</span> <span class="number">7050</span>    <span class="comment"># 监听端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">TLS:</span>    <span class="comment"># GRPC服务器的TLS设置</span></span><br><span class="line">        <span class="attr">Enabled:</span> <span class="literal">false</span>    <span class="comment"># 默认不启用</span></span><br><span class="line">        <span class="attr">PrivateKey:</span> <span class="string">tls/server.key</span>    <span class="comment"># 签名的私钥文件</span></span><br><span class="line">        <span class="attr">Certificate:</span> <span class="string">tls/server.crt</span>    <span class="comment"># 证书文件</span></span><br><span class="line">        <span class="attr">RootCAs:</span>    <span class="comment"># 可信任的根CA证书</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">tls/ca.crt</span></span><br><span class="line">        <span class="attr">ClientAuthRequired:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">ClientRootCAs:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Keepalive:</span>    <span class="comment"># GRPC服务器的激活设置</span></span><br><span class="line">        <span class="attr">ServerMinInterval:</span> <span class="string">60s</span>    <span class="comment"># 客户机ping之间的最小允许时间</span></span><br><span class="line">        <span class="attr">ServerInterval:</span> <span class="string">7200s</span>    <span class="comment"># 连接到客户机的ping之间的时间</span></span><br><span class="line">        <span class="attr">ServerTimeout:</span> <span class="string">20s</span>    <span class="comment"># 服务器等待响应的超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">LogLevel:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">LogFormat:</span> <span class="string">'<span class="template-variable">%&#123;color&#125;</span><span class="template-variable">%&#123;time:2006-01-02 15:04:05.000 MST&#125;</span> [<span class="template-variable">%&#123;module&#125;</span>] <span class="template-variable">%&#123;shortfunc&#125;</span> -&gt; <span class="template-variable">%&#123;level:.4s&#125;</span> <span class="template-variable">%&#123;id:03x&#125;</span><span class="template-variable">%&#123;color:reset&#125;</span> <span class="template-variable">%&#123;message&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">GenesisMethod:</span> <span class="string">provisional</span>    <span class="comment"># 生成初始区块的提供方式（可选provisional、file两种）</span></span><br><span class="line">    <span class="attr">GenesisProfile:</span> <span class="string">SampleInsecureSolo</span>    <span class="comment"># 用于动态生成初始区块的概要</span></span><br><span class="line">    <span class="attr">GenesisFile:</span> <span class="string">genesisblock</span>    <span class="comment"># 生成初始区块的配置文件 </span></span><br><span class="line"></span><br><span class="line">    <span class="attr">LocalMSPDir:</span> <span class="string">msp</span>    <span class="comment"># 本地MSP目录 </span></span><br><span class="line">    <span class="attr">LocalMSPID:</span> <span class="string">SampleOrg</span>    <span class="comment"># MSP ID</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Profile:</span>    <span class="comment"># 是否为Go“profiling”配置启用HTTP服务</span></span><br><span class="line">        <span class="attr">Enabled:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">Address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:6060</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">BCCSP:</span>    <span class="comment"># 区块链加密实现</span></span><br><span class="line">        <span class="attr">Default:</span> <span class="string">SW</span>    <span class="comment"># 默认使用SW</span></span><br><span class="line">        <span class="attr">SW:</span></span><br><span class="line">            <span class="attr">Hash:</span> <span class="string">SHA2</span></span><br><span class="line">            <span class="attr">Security:</span> <span class="number">256</span></span><br><span class="line">            <span class="attr">FileKeyStore:</span></span><br><span class="line">                <span class="attr">KeyStore:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Authentication:</span>    <span class="comment"># 与身份验证相关的配置</span></span><br><span class="line">        <span class="attr">TimeWindow:</span> <span class="string">15m</span>    <span class="comment"># # 当前服务器时间与客户端请求消息中指定的客户端时间差异</span></span><br></pre></td></tr></table></figure><h4 id="2-2-FileLedger部分："><a href="#2-2-FileLedger部分：" class="headerlink" title="2.2 FileLedger部分："></a>2.2 FileLedger部分：</h4><p>文件账本配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FileLedger:</span></span><br><span class="line">    <span class="attr">Location:</span> <span class="string">/var/hyperledger/production/orderer</span>    <span class="comment"># 区块存储路径</span></span><br><span class="line">    <span class="attr">Prefix:</span> <span class="string">hyperledger-fabric-ordererledger</span>    <span class="comment"># 在临时空间中生成分类目录时使用的前缀</span></span><br></pre></td></tr></table></figure><h4 id="2-3-RAMLedger部分："><a href="#2-3-RAMLedger部分：" class="headerlink" title="2.3 RAMLedger部分："></a>2.3 RAMLedger部分：</h4><p>内存账本配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RAMLedger:</span></span><br><span class="line">    <span class="attr">HistorySize:</span> <span class="number">1000</span>    <span class="comment"># 如果设置为保存在内存中，分类帐最大保留的块的数量</span></span><br></pre></td></tr></table></figure><h4 id="2-4-Kafka部分："><a href="#2-4-Kafka部分：" class="headerlink" title="2.4 Kafka部分："></a>2.4 Kafka部分：</h4><p>Kafka 集群的配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Kafka:</span></span><br><span class="line">    <span class="attr">Retry:</span>    <span class="comment"># 无法建立到Kafka集群的连接时的重试请求    </span></span><br><span class="line">        <span class="attr">ShortInterval:</span> <span class="string">5s</span>    <span class="comment"># 重试时间间隔</span></span><br><span class="line">        <span class="attr">ShortTotal:</span> <span class="string">10m</span>        <span class="comment"># 重试的总时间</span></span><br><span class="line">        <span class="attr">LongInterval:</span> <span class="string">5m</span>    <span class="comment"># 重试失败后再次发送重试的时间间隔</span></span><br><span class="line">        <span class="attr">LongTotal:</span> <span class="string">12h</span>        <span class="comment"># 重试的最长总时间</span></span><br><span class="line">        <span class="attr">NetworkTimeouts:</span>    <span class="comment"># 网络超时设置</span></span><br><span class="line">            <span class="attr">DialTimeout:</span> <span class="string">10s</span></span><br><span class="line">            <span class="attr">ReadTimeout:</span> <span class="string">10s</span></span><br><span class="line">            <span class="attr">WriteTimeout:</span> <span class="string">10s</span></span><br><span class="line">        <span class="attr">Metadata:</span>    <span class="comment"># 请求领导人选举时影响元数据的设置</span></span><br><span class="line">            <span class="attr">RetryBackoff:</span> <span class="string">250ms</span>    <span class="comment"># 指定重试的最大时间</span></span><br><span class="line">            <span class="attr">RetryMax:</span> <span class="number">3</span>    <span class="comment"># 重试的最大次数</span></span><br><span class="line">        <span class="attr">Producer:</span>    <span class="comment"># 向Kafka集群发送消息失败的设置</span></span><br><span class="line">            <span class="attr">RetryBackoff:</span> <span class="string">100ms</span>    <span class="comment"># 指定重试的最大时间</span></span><br><span class="line">            <span class="attr">RetryMax:</span> <span class="number">3</span>    <span class="comment"># 重试的最大次数</span></span><br><span class="line">        <span class="attr">Consumer:</span>    <span class="comment"># 向Kafka集群读取消息失败的设置</span></span><br><span class="line">            <span class="attr">RetryBackoff:</span> <span class="string">2s</span>    <span class="comment"># 指定重试的最大时间</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Verbose:</span> <span class="literal">false</span>    <span class="comment"># 是否为与Kafka集群的交互启用日志记录</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">TLS:</span>    <span class="comment"># Orderer连接到Kafka集群的TLS设置</span></span><br><span class="line">      <span class="attr">Enabled:</span> <span class="literal">false</span>    <span class="comment"># 连接到Kafka集群时是否使用TLS</span></span><br><span class="line">      <span class="attr">PrivateKey:</span>      </span><br><span class="line">      <span class="attr">Certificate:</span>       </span><br><span class="line">      <span class="attr">RootCAs:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Version:</span>    <span class="comment"># Kafka版本(未指定默认值为0.10.2.0)</span></span><br></pre></td></tr></table></figure><h4 id="2-5-Debug部分："><a href="#2-5-Debug部分：" class="headerlink" title="2.5 Debug部分："></a>2.5 Debug部分：</h4><p>调试配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Debug:</span></span><br><span class="line">    <span class="attr">BroadcastTraceDir:</span>    <span class="comment"># 对广播服务的每个请求写入此目录中的文件</span></span><br><span class="line">    <span class="attr">DeliverTraceDir:</span>    <span class="comment"># 对交付服务的每个请求写入此目录中的文件</span></span><br></pre></td></tr></table></figure><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>这些配置文件的内容需要全部都记下吗？</p><p>不需要死记硬背，重要的是理解这些配置信息都指定的什么重要内容。</p></li></ol><h3 id="三、确保安全的Fabric交易流程分析"><a href="#三、确保安全的Fabric交易流程分析" class="headerlink" title="三、确保安全的Fabric交易流程分析"></a>三、确保安全的Fabric交易流程分析</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>Hyperledger Fabric 网络中的节点分类</li><li>熟知 Hyperledger Fabric 交易流程</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>现在我们深入 Hyperledger Fabric 内部，详细了解 Hyperledger Fabric 的交易实现流程，理解相应的核心内容。</p></blockquote><p>区块链技术最重要特征之一就是能够保证实现安全的交易。Hyperledger Fabric 与公有链的交易实现又有很大的区别。如：<strong>权限、认证、数据隔离等等。</strong></p><p>Hyperledger Fabric 典型的交易流程如下图所示：</p><p><img src="http://image.chaindesk.cn/2.3.png/mark" alt="Fabric交易流程"></p><p>完整的交易流程解释如下：</p><ol><li><h5 id="应用程序使用相应的-SDK（Node，Java，Python）提供的-API-构建交易提案并提交给相应的背书节点，交易提案中包含："><a href="#应用程序使用相应的-SDK（Node，Java，Python）提供的-API-构建交易提案并提交给相应的背书节点，交易提案中包含：" class="headerlink" title="应用程序使用相应的 SDK（Node，Java，Python）提供的 API 构建交易提案并提交给相应的背书节点，交易提案中包含："></a>应用程序使用相应的 SDK（Node，Java，Python）提供的 API 构<strong>建交易提案并提交给相应的背书节点</strong>，交易提案中包含：</h5><ul><li>channelID：通道信息</li><li>chaincodeID：要调用的链码信息</li><li>timestamp：时间戳</li><li>sign：客户端的签名</li><li>txPayload：提交的事务本身包含的内容，包含两项：<ul><li>operation：要调用的链码的函数及相应的参数</li><li>metadata：调用的相关属性</li></ul></li></ul></li></ol><p>   <img src="http://image.chaindesk.cn/step1.png/mark" alt="step1"></p><p>   交易提案（Proposal）消息结构如下：</p><p>   <img src="http://image.chaindesk.cn/2.4.png/mark" alt="交易提案消息结构"></p><ol start="2"><li><h5 id="背书节点对接收到的交易提案请求进行验证："><a href="#背书节点对接收到的交易提案请求进行验证：" class="headerlink" title="背书节点对接收到的交易提案请求进行验证："></a><strong>背书节点对接收到的交易提案请求进行验证：</strong></h5><ul><li>交易提案格式是否正确</li><li>交易在之前并未提交过（重复性攻击保护）</li><li>提交交易提案的客户端签名是否有效（使用MSP）</li><li>提交交易提案的请求者是否在该通道中有相应的执行权限</li></ul><p>验证通过后调用链码进行模拟执行， 产生包括响应值、读集和写集的事务结果。对结果进行背书并响应给客户端。</p><blockquote><p>注意，此时的调用链码是模拟执行，不会对账本中的数据进行真正意义上的更改。</p><p>提示：关于MSP的相关内容，请参见第六章</p></blockquote><p><img src="http://image.chaindesk.cn/step2.png/mark" alt="step2"></p><p>交易提案响应（ProposalResponse）消息结构如下：</p><p><img src="http://image.chaindesk.cn/2.5.png/mark" alt="交易提案响应消息结构"></p></li></ol><ol><li><p>应用程序收集到足够的消息和背书签名之后，构建合法的交易请求并将交易请求广播给 Ordering服务节点。</p><p>1.如果应用程序的<strong>请求仅仅是查询分类帐</strong>，则应用程序将检查查询响应信息，并且不会将事务提交给 Ordering 服务。</p><p>2.如果客户端应用程序的<strong>请求是更新分类账本数据</strong>，则会将事务提交给 Ordering 服务以继续下一步的操作，并且应用程序在提交事务之前检查确定请求是否已满足指定的认可策略（即指定的背书节点都认可）。</p><p><img src="http://image.chaindesk.cn/step3.png/mark" alt="step3"></p></li><li><p>交易请求被提交到 Ordering 服务节点，该事务将包含读/写集，背书签名和通道ID；Orderer 节点接收到事务请求之后，并不需要检查交易中的具体数据，它只是从网络中的所有通道接收交易，按时间顺序对它们进行排序，并创建交易区块。之后广播给同一通道内所有组织的 Leader 节点。</p><p><img src="http://image.chaindesk.cn/step4.png/mark" alt="step4"></p></li><li><p>Leader节点：Leader 节点对接收到的区块进行验证（交易消息结构是否正确、是否重复、是否有足够的背书、读写集版本），通过验证后将结果写入到本地的分类账本中。</p><p><img src="http://image.chaindesk.cn/step5.png/mark" alt="step5"></p></li><li><p>同步广播：Leader 节点同步广播给组织内的其它节点（保证在同一通道内的）。</p><blockquote><p>提示：在 Fabric 中，广播给其它节点默认为临近的3个节点。此广播数量可以通过配置进行修改。</p><p>注：跨组织广播则由组织内的 Anchor 节点负责。</p></blockquote></li></ol><p>分类账本更新：</p><p>每个Peer节点将区块附加到区块链中，写集被提交到当前的状态数据库中。并且对于每个有效的事务，发出一个事件，通知客户端应用程序事务（调用）已被不可变地附加到链中，以及通知该事务是否已经过验证或为无效事务。</p><p><img src="http://image.chaindesk.cn/step6.png/mark" alt="step6"></p><p>本文地址: <a href="https://www.chaindesk.cn/witbook/11/104" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/104</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章fabric网络搭建</title>
      <link href="/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC3%E7%AB%A0Fabric%E7%BD%91%E7%BB%9C%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/03/21/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC3%E7%AB%A0Fabric%E7%BD%91%E7%BB%9C%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="生成组织结构与身份证书"><a href="#生成组织结构与身份证书" class="headerlink" title="生成组织结构与身份证书"></a>生成组织结构与身份证书</h3><h3 id="一、生成组织结构与身份证书"><a href="#一、生成组织结构与身份证书" class="headerlink" title="一、生成组织结构与身份证书"></a>一、生成组织结构与身份证书</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>明确生成组织结构及身份证书所需的配置文件及其内容含义</li><li>如何使用命令生成对应的组织结构信身份证书</li></ol><h4 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>自动化脚本 byfn.sh 可以自动帮我们创建网络环境运行时所需的所有内容，但在一些特定情况之下，我们根据不同的需求需要自定义一些设置。</p><p>现在，我们来实现最重要的环节，哪些配置文件的相关设置会影响创建 Hyperledger Fabric 网络环境运行时所需要的相应内容。</p></blockquote><a id="more"></a><h3 id="1-与组织结构及身份证书关联的配置文件"><a href="#1-与组织结构及身份证书关联的配置文件" class="headerlink" title="1 与组织结构及身份证书关联的配置文件"></a>1 与组织结构及身份证书关联的配置文件</h3><p>如果要生成 Hyperledger Fabric 网络环境中所需的组织结构及身份证书信息，组织中的成员提供节点服务，相应的证书代表身份，可以在实体间进行通信以及交易时进行签名与验证。生成过程依赖<code>crypto-config.yaml</code> 配置文件，该配置文件路径 ：<code>fabric-samples/first-network/crypto-config.yaml</code></p><p>crypto-config.yaml 配置文件包含如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hanxiaodong</span></span><br><span class="line"><span class="comment"># QQ群（专业Fabric交流群）：862733552</span></span><br><span class="line"><span class="attr">OrdererOrgs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Orderer</span>    <span class="comment"># Orderer的名称</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">example.com</span>    <span class="comment"># 域名</span></span><br><span class="line">    <span class="attr">Specs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">Hostname:</span> <span class="string">orderer</span>    <span class="comment"># hostname + Domain的值组成Orderer节点的完整域名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PeerOrgs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org1</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org1.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">true</span>        <span class="comment"># 在msp下生成config.yaml文件</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">2</span><span class="comment">#节点数量</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span><span class="comment">#用户数量</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Name:</span> <span class="string">Org2</span></span><br><span class="line">    <span class="attr">Domain:</span> <span class="string">org2.example.com</span></span><br><span class="line">    <span class="attr">EnableNodeOUs:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">Template:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">Users:</span></span><br><span class="line">      <span class="attr">Count:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>该配置文件指定了 OrdererOrgs 及 PeerOrgs 两个组织信息。在 PeerOrgs 配置信息中指定了 Org1 与 Org2 两个组织。每个组织使用 <strong>Template</strong> 属性下的 Count 指定了<strong>两个节点</strong>， <strong>Users</strong> 属性下的 Count 指定了<strong>一个用户。</strong></p><p>组织信息中还包含组织名称、域名、节点数量、及新增的用户数量等相关信息。</p><p>Peer 节点的域名组成为 peer + 起始数字0 + Domain，如 Org1 中的两个 peer 节点的完整域名为：</p><p><code>peer0.org1.example.com，peer1.org1.example.com</code>。</p><h3 id="2-如何生成组织结构及身份证书"><a href="#2-如何生成组织结构及身份证书" class="headerlink" title="2 如何生成组织结构及身份证书"></a>2 如何生成组织结构及身份证书</h3><p>下面我们来实现组织结构及身份证书的生成。在 Hyperledger Fabric 中提供了一个工具 <strong>cryptogen</strong> ，该工具根据指定的配置文件实现标准化自动生成。执行过程如下：</p><p>进入 <code>fabric-samples/first-network</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> hyfa/fabric-samples/first-network/</span></span><br></pre></td></tr></table></figure><p>使用 cryptogen 工具为Hyperledger Fabric网络生成指定拓扑结构的<strong>组织关系和身份证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/cryptogen generate --config=./crypto-config.yaml</span></span><br></pre></td></tr></table></figure><p>执行成功会有如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org1.example.com</span><br><span class="line">org2.example.com</span><br></pre></td></tr></table></figure><p>证书和密钥（即MSP材料）将被输出到当前一个名为 <code>crypto-config</code> 的目录中，该目录下有两个子目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hg</span>@ubuntu:~/hyfa/fabric-samples/first-network/crypto-config$ ls</span><br><span class="line">$ ordererOrganizations  peerOrganizations</span><br></pre></td></tr></table></figure><p><strong>ordererOrganizations</strong> 子目录下包括构成 Orderer 组织(1个 Orderer 节点)的身份信息</p><p><strong>peerOrganizations</strong> 子目录下为所有的 Peer 节点组织(2个组织，4个节点)的相关身份信息. 其中最关键的是 MSP 目录, 代表了实体的身份信息</p><p><strong>Cryptogen 工具按照配置文件中指定的结构生成了对应的组织和密钥、及相关的证书文件</strong></p><p>生成的 crypto-config 的完整结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">crypto-config</span><br><span class="line">├── ordererOrganizations    #orderer组织</span><br><span class="line">│   └── example.com</span><br><span class="line">│       ├── ca</span><br><span class="line">│       │   ├── c674f2c6028c39dd8d8fddb5e0ed4b94c0e4a620691ec70bd8e3cf3c1a3c904d_sk</span><br><span class="line">│       │   └── ca.example.com-cert.pem</span><br><span class="line">│       ├── msp</span><br><span class="line">│       │   ├── admincerts  #管理员的身份证书文件</span><br><span class="line">│       │   │   └── Admin@example.com-cert.pem</span><br><span class="line">│       │   ├── cacerts  #信任的根证书文件</span><br><span class="line">│       │   │   └── ca.example.com-cert.pem</span><br><span class="line">│       │   └── tlscacerts #TLS 连接用的证书</span><br><span class="line">│       │       └── tlsca.example.com-cert.pem</span><br><span class="line">│       ├── orderers</span><br><span class="line">│       │   └── orderer.example.com</span><br><span class="line">│       │       ├── msp</span><br><span class="line">│       │       │   ├── admincerts  #管理员的身份证书文件</span><br><span class="line">│       │       │   │   └── Admin@example.com-cert.pem</span><br><span class="line">│       │       │   ├── cacerts#信任的根证书文件</span><br><span class="line">│       │       │   │   └── ca.example.com-cert.pem</span><br><span class="line">│       │       │   ├── keystore  #节点的签名私钥文件</span><br><span class="line">│       │       │   │   └── 4279c65c46e367e2dc0f83127a2fe5bf398ddf84010e18b070de3adfdc638158_sk</span><br><span class="line">│       │       │   ├── signcerts  #节点的签名身份证书文件</span><br><span class="line">│       │       │   │   └── orderer.example.com-cert.pem</span><br><span class="line">│       │       │   └── tlscacerts  #TLS 连接用的证书</span><br><span class="line">│       │       │       └── tlsca.example.com-cert.pem</span><br><span class="line">│       │       └── tls</span><br><span class="line">│       │           ├── ca.crt</span><br><span class="line">│       │           ├── server.crt</span><br><span class="line">│       │           └── server.key</span><br><span class="line">│       ├── tlsca</span><br><span class="line">│       │   ├── ab8411233f3d73dea3f15f9618a1c5e06919135ccc78b292208434717c13d2d0_sk</span><br><span class="line">│       │   └── tlsca.example.com-cert.pem</span><br><span class="line">│       └── users   #users</span><br><span class="line">│           └── Admin@example.com  #管理者</span><br><span class="line">│               ├── msp</span><br><span class="line">│               │   ├── admincerts</span><br><span class="line">│               │   │   └── Admin@example.com-cert.pem</span><br><span class="line">│               │   ├── cacerts</span><br><span class="line">│               │   │   └── ca.example.com-cert.pem</span><br><span class="line">│               │   ├── keystore</span><br><span class="line">│               │   │   └── 5de8388b453294c5fa6c55eb38f253b81d0832e196543e41d153db0e6cd59d5d_sk</span><br><span class="line">│               │   ├── signcerts</span><br><span class="line">│               │   │   └── Admin@example.com-cert.pem</span><br><span class="line">│               │   └── tlscacerts</span><br><span class="line">│               │       └── tlsca.example.com-cert.pem</span><br><span class="line">│               └── tls</span><br><span class="line">│                   ├── ca.crt</span><br><span class="line">│                   ├── client.crt</span><br><span class="line">│                   └── client.key</span><br><span class="line">└── peerOrganizations     #peer组织</span><br><span class="line">    ├── org1.example.com   #org1</span><br><span class="line">    │   ├── ca</span><br><span class="line">    │   │   ├── b8ec81e19fcd99d304e24b25981236671fe55cb230938be9a08ccc82b08eba43_sk</span><br><span class="line">    │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │   ├── msp</span><br><span class="line">    │   │   ├── admincerts</span><br><span class="line">    │   │   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">    │   │   ├── cacerts</span><br><span class="line">    │   │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │   │   ├── config.yaml</span><br><span class="line">    │   │   └── tlscacerts</span><br><span class="line">    │   │       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │   ├── peers #peers</span><br><span class="line">    │   │   ├── peer0.org1.example.com  #peer0</span><br><span class="line">    │   │   │   ├── msp</span><br><span class="line">    │   │   │   │   ├── admincerts</span><br><span class="line">    │   │   │   │   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">    │   │   │   │   ├── cacerts</span><br><span class="line">    │   │   │   │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │   │   │   │   ├── config.yaml</span><br><span class="line">    │   │   │   │   ├── keystore</span><br><span class="line">    │   │   │   │   │   └── ba8156132aac14d0904e5d14fa5f13e1497509223d4fa100064f91f4f2a3d15f_sk</span><br><span class="line">    │   │   │   │   ├── signcerts</span><br><span class="line">    │   │   │   │   │   └── peer0.org1.example.com-cert.pem</span><br><span class="line">    │   │   │   │   └── tlscacerts</span><br><span class="line">    │   │   │   │       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │   │   │   └── tls</span><br><span class="line">    │   │   │       ├── ca.crt</span><br><span class="line">    │   │   │       ├── server.crt</span><br><span class="line">    │   │   │       └── server.key</span><br><span class="line">    │   │   └── peer1.org1.example.com   #peer1</span><br><span class="line">    │   │       ├── msp</span><br><span class="line">    │   │       │   ├── admincerts</span><br><span class="line">    │   │       │   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">    │   │       │   ├── cacerts</span><br><span class="line">    │   │       │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │   │       │   ├── config.yaml</span><br><span class="line">    │   │       │   ├── keystore</span><br><span class="line">    │   │       │   │   └── a37b7a22d765b2e9cc7804bc883235cc1981b24182bb4d3403fc82698159233f_sk</span><br><span class="line">    │   │       │   ├── signcerts</span><br><span class="line">    │   │       │   │   └── peer1.org1.example.com-cert.pem</span><br><span class="line">    │   │       │   └── tlscacerts</span><br><span class="line">    │   │       │       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │   │       └── tls</span><br><span class="line">    │   │           ├── ca.crt</span><br><span class="line">    │   │           ├── server.crt</span><br><span class="line">    │   │           └── server.key</span><br><span class="line">    │   ├── tlsca</span><br><span class="line">    │   │   ├── 9d76be67281dbe32018ee5e6c1595a4a0da1645c81f4ed7680481c521a31cdbc_sk</span><br><span class="line">    │   │   └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │   └── users#users</span><br><span class="line">    │       ├── Admin@org1.example.com  #admin</span><br><span class="line">    │       │   ├── msp</span><br><span class="line">    │       │   │   ├── admincerts</span><br><span class="line">    │       │   │   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">    │       │   │   ├── cacerts</span><br><span class="line">    │       │   │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │       │   │   ├── keystore</span><br><span class="line">    │       │   │   │   └── 493e7191fa4b9f3fce46e2fb9bbf6f0ec077ed217c7a94a5ee72a93a22f8a2bd_sk</span><br><span class="line">    │       │   │   ├── signcerts</span><br><span class="line">    │       │   │   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">    │       │   │   └── tlscacerts</span><br><span class="line">    │       │   │       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │       │   └── tls</span><br><span class="line">    │       │       ├── ca.crt</span><br><span class="line">    │       │       ├── client.crt</span><br><span class="line">    │       │       └── client.key</span><br><span class="line">    │       └── User1@org1.example.com  #user1</span><br><span class="line">    │           ├── msp</span><br><span class="line">    │           │   ├── admincerts</span><br><span class="line">    │           │   │   └── User1@org1.example.com-cert.pem</span><br><span class="line">    │           │   ├── cacerts</span><br><span class="line">    │           │   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">    │           │   ├── keystore</span><br><span class="line">    │           │   │   └── 63d2bb7a402b6bc694ff242471d86a6512bb69726d8c3dc6c3d91952901abe85_sk</span><br><span class="line">    │           │   ├── signcerts</span><br><span class="line">    │           │   │   └── User1@org1.example.com-cert.pem</span><br><span class="line">    │           │   └── tlscacerts</span><br><span class="line">    │           │       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">    │           └── tls</span><br><span class="line">    │               ├── ca.crt</span><br><span class="line">    │               ├── client.crt</span><br><span class="line">    │               └── client.key</span><br><span class="line">    └── org2.example.com  #org2</span><br><span class="line">        ├── ca</span><br><span class="line">        │   ├── a86cfdc1ad188e7abc301cd21d7820fe1fa6a3cf81cdc25942405d632c1a4717_sk</span><br><span class="line">        │   └── ca.org2.example.com-cert.pem</span><br><span class="line">        ├── msp</span><br><span class="line">        │   ├── admincerts</span><br><span class="line">        │   │   └── Admin@org2.example.com-cert.pem</span><br><span class="line">        │   ├── cacerts</span><br><span class="line">        │   │   └── ca.org2.example.com-cert.pem</span><br><span class="line">        │   ├── config.yaml</span><br><span class="line">        │   └── tlscacerts</span><br><span class="line">        │       └── tlsca.org2.example.com-cert.pem</span><br><span class="line">        ├── peers  #peers</span><br><span class="line">        │   ├── peer0.org2.example.com #peer0</span><br><span class="line">        │   │   ├── msp</span><br><span class="line">        │   │   │   ├── admincerts</span><br><span class="line">        │   │   │   │   └── Admin@org2.example.com-cert.pem</span><br><span class="line">        │   │   │   ├── cacerts</span><br><span class="line">        │   │   │   │   └── ca.org2.example.com-cert.pem</span><br><span class="line">        │   │   │   ├── config.yaml</span><br><span class="line">        │   │   │   ├── keystore</span><br><span class="line">        │   │   │   │   └── 6321e899b8467adca9a795cb1006789e2fecd168c162157aec895a54e86c7ff7_sk</span><br><span class="line">        │   │   │   ├── signcerts</span><br><span class="line">        │   │   │   │   └── peer0.org2.example.com-cert.pem</span><br><span class="line">        │   │   │   └── tlscacerts</span><br><span class="line">        │   │   │       └── tlsca.org2.example.com-cert.pem</span><br><span class="line">        │   │   └── tls</span><br><span class="line">        │   │       ├── ca.crt</span><br><span class="line">        │   │       ├── server.crt</span><br><span class="line">        │   │       └── server.key</span><br><span class="line">        │   └── peer1.org2.example.com    #peer2</span><br><span class="line">        │       ├── msp</span><br><span class="line">        │       │   ├── admincerts</span><br><span class="line">        │       │   │   └── Admin@org2.example.com-cert.pem</span><br><span class="line">        │       │   ├── cacerts</span><br><span class="line">        │       │   │   └── ca.org2.example.com-cert.pem</span><br><span class="line">        │       │   ├── config.yaml</span><br><span class="line">        │       │   ├── keystore</span><br><span class="line">        │       │   │   └── e90b33aae87ca50849e91b243188c41f7b6de8a082602ea67b94deabff710a83_sk</span><br><span class="line">        │       │   ├── signcerts</span><br><span class="line">        │       │   │   └── peer1.org2.example.com-cert.pem</span><br><span class="line">        │       │   └── tlscacerts</span><br><span class="line">        │       │       └── tlsca.org2.example.com-cert.pem</span><br><span class="line">        │       └── tls</span><br><span class="line">        │           ├── ca.crt</span><br><span class="line">        │           ├── server.crt</span><br><span class="line">        │           └── server.key</span><br><span class="line">        ├── tlsca</span><br><span class="line">        │   ├── 5b19cc3c436ba95d25047525aa73b58f151a267cec6b365ce11c659740296134_sk</span><br><span class="line">        │   └── tlsca.org2.example.com-cert.pem</span><br><span class="line">        └── users #users</span><br><span class="line">            ├── Admin@org2.example.com  #管理者</span><br><span class="line">            │   ├── msp</span><br><span class="line">            │   │   ├── admincerts</span><br><span class="line">            │   │   │   └── Admin@org2.example.com-cert.pem</span><br><span class="line">            │   │   ├── cacerts</span><br><span class="line">            │   │   │   └── ca.org2.example.com-cert.pem</span><br><span class="line">            │   │   ├── keystore</span><br><span class="line">            │   │   │   └── 73aed893a0a298db80bdd8bf85fe54483cdfe70529e00fc641e09ac1ce97dbd5_sk</span><br><span class="line">            │   │   ├── signcerts</span><br><span class="line">            │   │   │   └── Admin@org2.example.com-cert.pem</span><br><span class="line">            │   │   └── tlscacerts</span><br><span class="line">            │   │       └── tlsca.org2.example.com-cert.pem</span><br><span class="line">            │   └── tls</span><br><span class="line">            │       ├── ca.crt</span><br><span class="line">            │       ├── client.crt</span><br><span class="line">            │       └── client.key</span><br><span class="line">            └── User1@org2.example.com  #user1</span><br><span class="line">                ├── msp</span><br><span class="line">                │   ├── admincerts</span><br><span class="line">                │   │   └── User1@org2.example.com-cert.pem</span><br><span class="line">                │   ├── cacerts</span><br><span class="line">                │   │   └── ca.org2.example.com-cert.pem</span><br><span class="line">                │   ├── keystore</span><br><span class="line">                │   │   └── 74280f530cdea1e89bfd28ff9c576942eeceb4e4a64b9b58a0d6ea821cd2c8ea_sk</span><br><span class="line">                │   ├── signcerts</span><br><span class="line">                │   │   └── User1@org2.example.com-cert.pem</span><br><span class="line">                │   └── tlscacerts</span><br><span class="line">                │       └── tlsca.org2.example.com-cert.pem</span><br><span class="line">                └── tls</span><br><span class="line">                    ├── ca.crt</span><br><span class="line">                    ├── client.crt</span><br><span class="line">                    └── client.key</span><br></pre></td></tr></table></figure><p>在生成的目录结构中最关键的是各个资源下的 msp 目录内容，存储了生成的代表 MSP 实体身份的各种证书文件，一般包括：</p><ul><li>admincerts ：管理员的身份证书文件</li><li>cacerts ：信任的根证书文件</li><li>keystore ：节点的签名私钥文件</li><li>signcerts ：节点的签名身份证书文件</li><li>tlscacerts:：TLS 连接用的证书</li><li>intermediatecerts （可选）：信任的中间证书</li><li>crls （可选）：证书撤销列表</li><li>config.yaml （可选）：记录OrganizationalUnitldentifiers 信息，包括根证书位置和ID信息</li></ul><p>这些身份文件随后可以分发到对应的Orderer 节点和Peer 节点上，并放到对应的MSP路径下，用于签名验证使用。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>组织结构中可以添加新的组织吗？</p><p>生成组织结构前，可以通过 crypto-config.yaml 配置文件指定具体的组织信息，如果是多个组织，只需要在该配置文件中 PeerOrgs 节点最后添加新的组织信息即可。</p></li><li><p>Org 组织中可以指定多个 Peer 节点吗？</p><p>可以指定多个节点，只需要修改 Template 下的 Count 值即可（该值代表组织下有几个节点）。</p></li><li><p>组织结构生成之后可以随时添加或修改吗？</p><p>目前，Hyperledger Fabric 无法对已生成的组织结构进行修改；所以需要提前做好规划。在未来会支持对组织结构的节点进行动态修改。</p></li></ol><h3 id="二、不可或缺的配置文件"><a href="#二、不可或缺的配置文件" class="headerlink" title="二、不可或缺的配置文件"></a>二、不可或缺的配置文件</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><ol><li><p>理解 configtx.yaml 配置文件中的各项含义</p></li><li><p>掌握创建 Orderer 服务启动初始区块的命令及参数</p></li><li><p>掌握创建应用通道交易配置文件的命令及参数</p><h4 id="任务实现-1"><a href="#任务实现-1" class="headerlink" title="任务实现"></a>任务实现</h4><h3 id="1-configtx-yaml配置文件指定哪些核心内容"><a href="#1-configtx-yaml配置文件指定哪些核心内容" class="headerlink" title="1 configtx.yaml配置文件指定哪些核心内容"></a>1 configtx.yaml配置文件指定哪些核心内容</h3><p>创建服务启动初始区块及应用通道交易配置文件需要指定 Orderer 服务的相关配置以及当前的联盟信息， 这些信息定义在一个名为 <strong>configtx.yaml</strong> 文件中。</p><p>configtx.yaml 配置文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$hg@ubuntu:~/hyfa/fabric-samples/first-network$</span> <span class="string">cat</span> <span class="string">configtx.yaml</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Organizations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;OrdererOrg</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">OrdererOrg</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">OrdererMSP</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/ordererOrganizations/example.com/msp</span> </span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;Org1</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">Org1MSP</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">Org1MSP</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/peerOrganizations/org1.example.com/msp</span>  </span><br><span class="line"></span><br><span class="line">        <span class="attr">AnchorPeers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">              <span class="attr">Port:</span> <span class="number">7051</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="meta">&amp;Org2</span></span><br><span class="line">        <span class="attr">Name:</span> <span class="string">Org2MSP</span></span><br><span class="line">        <span class="attr">ID:</span> <span class="string">Org2MSP</span></span><br><span class="line">        <span class="attr">MSPDir:</span> <span class="string">crypto-config/peerOrganizations/org2.example.com/msp</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">AnchorPeers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">              <span class="attr">Port:</span> <span class="number">7051</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Capabilities:</span></span><br><span class="line">    <span class="attr">Global:</span> <span class="meta">&amp;ChannelCapabilities</span></span><br><span class="line">        <span class="attr">V1_1:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Orderer:</span> <span class="meta">&amp;OrdererCapabilities</span></span><br><span class="line">        <span class="attr">V1_1:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Application:</span> <span class="meta">&amp;ApplicationCapabilities</span></span><br><span class="line">        <span class="attr">V1_2:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Application:</span> <span class="meta">&amp;ApplicationDefaults</span></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Orderer:</span> <span class="meta">&amp;OrdererDefaults</span></span><br><span class="line">    <span class="attr">OrdererType:</span> <span class="string">solo</span> <span class="comment">#共识排序服务的实现方式，有两种选择（solo 及 Kafka）</span></span><br><span class="line">    <span class="attr">Addresses:</span><span class="comment">#指定了 Orderer 节点的服务地址与端口号</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">orderer.example.com:7050</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">BatchTimeout:</span> <span class="string">2s</span>  </span><br><span class="line">    <span class="attr">BatchSize:</span><span class="comment">#指定了批处理大小，如最大交易数量，最大字节数及建议字节数</span></span><br><span class="line">        <span class="attr">MaxMessageCount:</span> <span class="number">10</span><span class="comment">#最大交易数量</span></span><br><span class="line">        <span class="attr">AbsoluteMaxBytes:</span> <span class="number">99</span> <span class="string">MB</span><span class="comment">#最大字节数</span></span><br><span class="line">        <span class="attr">PreferredMaxBytes:</span> <span class="number">512</span> <span class="string">KB</span> <span class="comment">#建议字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Kafka:</span></span><br><span class="line">        <span class="attr">Brokers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Organizations:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Profiles:</span></span><br><span class="line">    <span class="attr">TwoOrgsOrdererGenesis:</span> <span class="comment">#2 orderer模板用来生成Orderer服务的初始区块文件</span></span><br><span class="line">        <span class="attr">Capabilities:</span><span class="comment">#指定通道的权限信息</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*ChannelCapabilities</span></span><br><span class="line">        <span class="attr">Orderer:</span><span class="comment">#指定了Orderer服务的信息（OrdererOrg）及权限信息</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*OrdererDefaults</span></span><br><span class="line">            <span class="attr">Organizations:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*OrdererOrg</span></span><br><span class="line">            <span class="attr">Capabilities:</span></span><br><span class="line">                <span class="string">&lt;&lt;:</span> <span class="meta">*OrdererCapabilities</span></span><br><span class="line">        <span class="attr">Consortiums:</span><span class="comment">#定义了联盟组成成员（Org1&amp;Org2）</span></span><br><span class="line">            <span class="attr">SampleConsortium:</span></span><br><span class="line">                <span class="attr">Organizations:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="meta">*Org1</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="meta">*Org2</span></span><br><span class="line">    <span class="attr">TwoOrgsChannel:</span> <span class="comment">#2channel</span></span><br><span class="line">        <span class="attr">Consortium:</span> <span class="string">SampleConsortium</span> <span class="comment">#指定了联盟信息</span></span><br><span class="line">        <span class="attr">Application:</span> <span class="comment">#指定了组织及权限信息。</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="string">*ApplicationDefaults</span></span><br><span class="line">            <span class="attr">Organizations:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*Org1</span></span><br><span class="line">                <span class="bullet">-</span> <span class="meta">*Org2</span></span><br><span class="line">            <span class="attr">Capabilities:</span></span><br><span class="line">                <span class="string">&lt;&lt;:</span> <span class="meta">*ApplicationCapabilities</span></span><br></pre></td></tr></table></figure><p>该配置文件中由 <strong>Organizations</strong> 定义了三个成员 Orderer Org、Org1、Org2，并且设置每个成员的MSP 目录的位置，从而允许在 orderer genesis 块中存储每个 Org 的根证书。<strong>通过这些信息实现与Orderer 服务通信的任何网络实体都可以验证其数字签名。</strong>而且为每个 PeerOrg 指定了相应的锚节点（Org1 组织中<code>peer0.org1.example.com</code>与 Org2 组织中<code>peer0.org2.example.com</code>）。</p></li></ol><p>   <strong>Orderer</strong>部分指定了Orderer节点的信息：</p><ol><li><strong>OrdererType</strong> 指定了共识排序服务的实现方式，有两种选择（solo 及 Kafka）。</li><li><strong>Addresses</strong> 指定了 Orderer 节点的服务地址与端口号。</li><li><strong>BatchSize</strong> 指定了批处理大小，如最大交易数量，最大字节数及建议字节数。</li></ol><p>   <strong>Profiles</strong> 部分指定了两个模板：TwoOrgsOrdererGenesis 与 TwoOrgsChannel 。</p><ol><li><p><strong>TwoOrgsOrdererGenesis</strong> 模板用来生成Orderer服务的初始区块文件，该模板由三部分组成：<br>1.1 Capabilities 指定通道的权限信息。</p><p>1.2 Orderer 指定了Orderer服务的信息（OrdererOrg）及权限信息。</p><p>1.3 Consortiums 定义了联盟组成成员（Org1&amp;Org2）。</p></li><li><p><strong>TwoOrgsChannel</strong> 模板用来生成应用通道交易配置文件。由两部分组成：</p><p>2.1 Consortium 指定了联盟信息。</p><p>2.2 Application 指定了组织及权限信息。</p><h3 id="2-Orderer服务启动初始区块的创建"><a href="#2-Orderer服务启动初始区块的创建" class="headerlink" title="2 Orderer服务启动初始区块的创建"></a>2 Orderer服务启动初始区块的创建</h3><p>熟悉了配置文件中的相关信息后，就可以创建 Orderer 服务启动初始区块；确认当前在 <strong>fabric-samples/first-network</strong> 目录下。</p><p>指定使用 <code>configtx.yaml</code> 文件中定义的 <code>TwoOrgsOrdererGenesis</code> 模板,，生成 Orderer 服务系统通道的初始区块文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span></span><br></pre></td></tr></table></figure><p>命令执行后输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">10:49:21.181 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">10:49:21.207 CST [msp] getMspConfig -&gt; INFO 002 Loading NodeOUs</span><br><span class="line">10:49:21.208 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs</span><br><span class="line">10:49:21.210 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 004 Generating genesis block</span><br><span class="line">10:49:21.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 005 Writing genesis block</span><br><span class="line">---我的自己的启动输出</span><br><span class="line"></span><br><span class="line">2020-03-22 20:05:17.434 CST [common/tools/configtxgen] main -&gt; WARN 001 Omitting the channel ID for configtxgen is deprecated.  Explicitly passing the channel ID will be required in the future, defaulting to 'testchainid'.</span><br><span class="line">//configtxgen的通道ID已弃用。 将来需要明确传递频道ID，默认为'testchainid'</span><br><span class="line">2020-03-22 20:05:17.434 CST [common/tools/configtxgen] main -&gt; INFO 002 Loading configuration</span><br><span class="line">2020-03-22 20:05:17.496 CST [common/tools/configtxgen/encoder] NewChannelGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml</span><br><span class="line"><span class="meta">//NewChannelGroup-&gt;</span><span class="bash"> WARN 003不建议使用默认策略发射，请在configtx.yaml中包括通道组的策略规范</span></span><br><span class="line">2020-03-22 20:05:17.498 CST [common/tools/configtxgen/encoder] NewOrdererGroup -&gt; WARN 004 Default policy emission is deprecated, please include policy specificiations for the orderer group in configtx.yaml</span><br><span class="line">2020-03-22 20:05:17.514 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the orderer org group OrdererOrg in configtx.yaml</span><br><span class="line">2020-03-22 20:05:17.527 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">2020-03-22 20:05:17.528 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org1MSP in configtx.yaml</span><br><span class="line">2020-03-22 20:05:17.534 CST [msp] getMspConfig -&gt; INFO 008 Loading NodeOUs</span><br><span class="line">2020-03-22 20:05:17.535 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 009 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org2MSP in configtx.yaml</span><br><span class="line">2020-03-22 20:05:17.535 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00a Generating genesis block</span><br><span class="line">2020-03-22 20:05:17.539 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00b Writing genesis block</span><br><span class="line"></span><br><span class="line">10:49:21.181 CST [common/tools/configtxgen] main -&gt; INFO 002 Loading configuration</span><br><span class="line">10:49:21.207 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">10:49:21.208 CST [msp] getMspConfig -&gt; INFO 008 Loading NodeOUs</span><br><span class="line">10:49:21.210 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00a Generating genesis block</span><br><span class="line">10:49:21.211 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00b Writing genesis block</span><br></pre></td></tr></table></figure><blockquote><p>为了方便管理，我们将所有创建的文件都指定保存在默认的 channel-artifacts 目录下。</p></blockquote><h3 id="3-创建必须的应用通道交易配置文件"><a href="#3-创建必须的应用通道交易配置文件" class="headerlink" title="3 创建必须的应用通道交易配置文件"></a>3 创建必须的应用通道交易配置文件</h3></li></ol><p>   <strong>指定通道名称的环境变量：</strong></p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel</span></span><br></pre></td></tr></table></figure><blockquote><p>因为我们后面的命令需要多次使用同一个通道名称，所以先指定一个通道名称将其设为环境变量，后期需要使用该通道名称时时只需要使用对应的环境变量名称即可。</p></blockquote><p>   <strong>生成应用通道交易配置文件：</strong></p><p>   指定使用 <code>configtx.yaml</code> 配置文件中的 <code>TwoOrgsChannel</code> 模板, 来生成新建通道的配置交易文件, <code>TwoOrgsChannel</code> 模板指定了 Org1 和 Org2 都属于后面新建的应用通道</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID <span class="variable">$CHANNEL_NAME</span></span></span><br></pre></td></tr></table></figure><p>   执行完成后输出如下内容：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">11:13:24.984 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">11:13:24.992 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx</span><br><span class="line">11:13:24.993 CST [msp] getMspConfig -&gt; INFO 003 Loading NodeOUs</span><br><span class="line">11:13:24.994 CST [msp] getMspConfig -&gt; INFO 004 Loading NodeOUs</span><br><span class="line">11:13:25.016 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 005 Writing new channel tx</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">2020-03-22 21:19:46.389 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2020-03-22 21:19:46.436 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx</span><br><span class="line">2020-03-22 21:19:46.436 CST [common/tools/configtxgen/encoder] NewApplicationGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the application group in configtx.yaml</span><br><span class="line">2020-03-22 21:19:46.438 CST [msp] getMspConfig -&gt; INFO 004 Loading NodeOUs</span><br><span class="line">2020-03-22 21:19:46.441 CST [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the application org group Org1MSP in configtx.yaml</span><br><span class="line">2020-03-22 21:19:46.442 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">2020-03-22 21:19:46.443 CST [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the application org group Org2MSP in configtx.yaml</span><br><span class="line">2020-03-22 21:19:46.456 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 008 Writing new channel tx</span><br><span class="line">-----整理</span><br><span class="line">2020-03-22 21:19:46.389 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2020-03-22 21:19:46.436 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx</span><br><span class="line">2020-03-22 21:19:46.438 CST [msp] getMspConfig -&gt; INFO 004 Loading NodeOUs</span><br><span class="line">2020-03-22 21:19:46.442 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">2020-03-22 21:19:46.456 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 008 Writing new channel tx</span><br></pre></td></tr></table></figure><h3 id="4-生成锚节点更新配置文件"><a href="#4-生成锚节点更新配置文件" class="headerlink" title="4 生成锚节点更新配置文件"></a>4 生成锚节点更新配置文件</h3><p>   同样基于 <code>configtx.yaml</code> 配置文件中的 TwoOrgsChannel 模板，<strong>为每个组织分别生成锚节点更新配置，且注意指定对应的组织名称。</strong></p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org1MSP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org2MSP</span></span><br></pre></td></tr></table></figure>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-03-22 21:26:29.818 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2020-03-22 21:26:29.881 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update</span><br><span class="line">2020-03-22 21:26:29.883 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update</span><br><span class="line">-----------------------------</span><br><span class="line"></span><br><span class="line">TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org2MSP</span><br><span class="line">2020-03-22 21:28:56.762 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2020-03-22 21:28:56.808 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update</span><br><span class="line">2020-03-22 21:28:56.810 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update</span><br></pre></td></tr></table></figure><p>   上述所有命令执行完成后，channel-artifacts目录下会有4个被创建的文件，如下所示：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel-artifacts/</span><br><span class="line">├── channel.tx</span><br><span class="line">├── genesis.block</span><br><span class="line">├── Org1MSPanchors.tx</span><br><span class="line">└── Org2MSPanchors.tx</span><br></pre></td></tr></table></figure><h4 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>我可以查看生成的文件中的详细内容吗？</p><p>可以查看。我们可以在命令提示符下输入 ../bin/configtxgen -help 命令（当前在 fabric-samples/first-network 目录下）查看相应的参数，会发现有 inspectBlock、inspectChannelCreateTx 两个参数。通过这两个参数即可查看相应的配置文件内容。</p></li></ol><h3 id="三、启动我们的分布式网络"><a href="#三、启动我们的分布式网络" class="headerlink" title="三、启动我们的分布式网络"></a>三、启动我们的分布式网络</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><ol><li>深入理解 Hyperledger Fabric 网络启动过程</li><li>掌握网络启动命令及其所需参数</li></ol><h4 id="任务实现-2"><a href="#任务实现-2" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>网络启动之前所需的所有内容我们已经准备就绪，下面我们深入分析网络中各节点运行时所需要指定的必备信息</p></blockquote><h3 id="1-网络服务如何配置"><a href="#1-网络服务如何配置" class="headerlink" title="1 网络服务如何配置"></a>1 网络服务如何配置</h3><p>启动网络，就是启动提供网络服务的各个节点。那么这些节点如何启动，需要哪些信息，由于要启动多个网络节点，Hyperledger Fabric 采用了容器技术，所以需要一个简化的方式来集中化管理这这些节点容器，我们使用 docker-compose 这个工具个来实现一步到位的节点容器管理，实现方式只需要编写相应的配置文件即可。</p><p>Hyperledger Fabric 同样给我们提供了一个 docker-compose 工具的示例配置文件，该配置文件在 fabric-samples/first-network 目录下，文件名称为： docker-compose-cli.yaml， 我们打开这个配置文件可以看到如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">byfn:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>   <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span>  <span class="string">base/docker-compose-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cli:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cli</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-tools:$IMAGE_TAG</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GOPATH=/opt/gopath</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">      <span class="comment">#- CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=INFO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=cli</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/bin/bash</span></span><br><span class="line">    <span class="attr">volumes:</span><span class="comment">#将系统中的链码、组织结构及证书、生成的配置文件映射到容器中指定的目录下</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./../chaincode/:/opt/gopath/src/github.com/chaincode</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts</span></span><br><span class="line">    <span class="attr">depends_on:</span>  <span class="comment">#制定所依赖的相关容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderer.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br></pre></td></tr></table></figure><p>该配置文件中指定了网络中各个节点容器（共计六个容器，一个 Orderer，属于两个 Orgs 组织的四个 Peer，还有一个 CLI）的信息；我们仔细观察会发现 orderer 与各 peer 容器都设置了container_name 与 networks 信息；其它信息都由 extends 指向了 base/docker-compose-base.yaml 文件。</p><p>CLI 容器指定了所代表的 peer 节点（CORE_PEER_ADDRESS=peer0.org1.example.com:7051），通过 <strong>volumes</strong> 指定了<strong>将系统中的链码、组织结构及证书、生成的配置文件映射到容器中指定的目录下</strong>。且通过 <strong>depends_on</strong> 指定了<strong>所依赖的相关容器。</strong></p><h3 id="2-关联的docker-compose-base-yaml"><a href="#2-关联的docker-compose-base-yaml" class="headerlink" title="2 关联的docker-compose-base.yaml"></a>2 关联的docker-compose-base.yaml</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment">#orderer</span></span><br><span class="line">  <span class="attr">orderer.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">orderer.example.com</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-orderer:$IMAGE_TAG</span></span><br><span class="line">     <span class="comment">#environment  指定日志级别、监听地址、生成初始区块的提供方式、初始区块配置文件路径、本地 MSPID 及对应的目录、开启 TLS 验证及对应的证书、私钥信息等诸多重要信息。</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOGLEVEL=INFO</span>  <span class="comment">#日志级别</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LISTENADDRESS=0.0.0.0</span> <span class="comment">#监听地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISMETHOD=file</span><span class="comment">#生成初始区块的提供方式</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block</span> <span class="comment">#初始区块配置文件路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPID=OrdererMSP</span><span class="comment">#本地 MSPID 及对应的目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp</span></span><br><span class="line">      <span class="comment"># enabled TLS</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ENABLED=true</span> <span class="comment">#开启 TLS 验证及对应的证书，私钥信息等诸多重要信息。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric</span> <span class="comment">#进入容器后的默认工作目录</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">orderer</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment">#指定系统中的初始区块配置文件、MSP、TLS目录映射到容器中的指定路径下</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">orderer.example.com:/var/hyperledger/production/orderer</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#指定当前节点的监听端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7050</span><span class="string">:7050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#peers</span></span><br><span class="line">  <span class="attr">peer0.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span>  <span class="comment">#基本信息来源于哪个文件。</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span>  <span class="comment">#指定了容器的的 ID、监听地址及端口号、本地 MSPID</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment">#将系统的 msp 及 tls 目录映射到容器中的指定路径下</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org1.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#指定当前节点的监听端口。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org1.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org1.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org1.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org1MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org1.example.com:/var/hyperledger/production</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer0.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer0.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer0.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org2MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer0.org2.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9053</span><span class="string">:7053</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">peer1.org2.example.com:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">peer1.org2.example.com</span></span><br><span class="line">    <span class="attr">extends:</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">peer-base.yaml</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">peer-base</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ID=peer1.org2.example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_ADDRESS=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_LOCALMSPID=Org2MSP</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/var/run/:/host/var/run/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp:/etc/hyperledger/fabric/msp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls:/etc/hyperledger/fabric/tls</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">peer1.org2.example.com:/var/hyperledger/production</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10051</span><span class="string">:7051</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10053</span><span class="string">:7053</span></span><br></pre></td></tr></table></figure><p>该配置文件中指定了 Orderer 与 Peers 节点的相关信息。</p><p>Orderer 设置如下信息：</p><ul><li><strong>environment：</strong>指定日志级别、监听地址、生成初始区块的提供方式、初始区块配置文件路径、本地 MSPID 及对应的目录、开启 TLS 验证及对应的证书、私钥信息等诸多重要信息。</li><li><strong>working_dir：</strong>进入容器后的默认工作目录</li><li><strong>volumes：</strong>指定系统中的初始区块配置文件、MSP、TLS目录映射到容器中的指定路径下。</li><li><strong>ports：</strong> 指定当前节点的监听端口。</li></ul><p>各 Peers 设置了如下信息：</p><ul><li><p><strong>extends：</strong>基本信息来源于哪个文件。</p></li><li><p><strong>environment：</strong>指定了容器的的 ID、监听地址及端口号、本地 MSPID。</p></li><li><p><strong>volumes：</strong>将系统的 msp 及 tls 目录映射到容器中的指定路径下。</p></li><li><p><strong>ports：</strong> 指定当前节点的监听端口。</p></li></ul><h3 id="3-又被关联的peer-base-yaml"><a href="#3-又被关联的peer-base-yaml" class="headerlink" title="3 又被关联的peer-base.yaml"></a>3 又被关联的peer-base.yaml</h3><p>配置文件内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">peer-base:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hyperledger/fabric-peer:$IMAGE_TAG</span></span><br><span class="line">    <span class="comment">#指定日志级别、监听地址、生成初始区块的提供方式、初始区块配置文件路径、本地 MSPID 及对应的目录、开启 TLS 验证及对应的证书、私钥信息等诸多重要信息。</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock</span></span><br><span class="line">      <span class="comment"># the following setting starts chaincode containers on the same</span></span><br><span class="line">      <span class="comment"># bridge network as the peers</span></span><br><span class="line">      <span class="comment"># https://docs.docker.com/compose/networking/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=$&#123;COMPOSE_PROJECT_NAME&#125;_byfn</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_LOGGING_LEVEL=INFO</span> <span class="comment">#日志级别</span></span><br><span class="line">      <span class="comment">#- CORE_LOGGING_LEVEL=DEBUG</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ENABLED=true</span><span class="comment">#是否开启 TLS 验证</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_USELEADERELECTION=true</span><span class="comment">#是否采用 Leader 选举</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_GOSSIP_ORGLEADER=false</span><span class="comment">#是否将当前节点设为 Leader</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_PROFILE_ENABLED=true</span><span class="comment">#</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt</span> <span class="comment">#TLS 证书</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key</span><span class="comment">#私钥</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt</span><span class="comment">#根证书的路径</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/opt/gopath/src/github.com/hyperledger/fabric/peer</span> <span class="comment">#进入容器后的默认工作目录</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">peer</span> <span class="string">node</span> <span class="string">start</span> <span class="comment">#容器启动命令</span></span><br></pre></td></tr></table></figure><p>该配置文件设置了所有 peer 容器的基本的共同信息，日志级别，是否开启 TLS 验证，是否采用 Leader 选举， 是否将当前节点设为 Leader， TLS 证书、私钥、根证书的路径、容器的默认工作路径、容器启动命令。</p><h3 id="4-启动网络"><a href="#4-启动网络" class="headerlink" title="4 启动网络"></a>4 启动网络</h3><p>万事具备，只欠东风，下面我们通过一条命令来方便的启动 Hyperledger Fabric 网络中所有节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml up -d</span></span><br></pre></td></tr></table></figure><p>命令执行后终端输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating network "net_byfn" with the default driver</span><br><span class="line">Creating volume "net_peer0.org2.example.com" with default driver</span><br><span class="line">Creating volume "net_peer1.org2.example.com" with default driver</span><br><span class="line">Creating volume "net_peer1.org1.example.com" with default driver</span><br><span class="line">Creating volume "net_peer0.org1.example.com" with default driver</span><br><span class="line">Creating volume "net_orderer.example.com" with default driver</span><br><span class="line">Creating orderer.example.com</span><br><span class="line">Creating peer1.org2.example.com</span><br><span class="line">Creating peer0.org2.example.com</span><br><span class="line">Creating peer1.org1.example.com</span><br><span class="line">Creating peer0.org1.example.com</span><br><span class="line">Creating cli</span><br></pre></td></tr></table></figure><p>docker-compose 命令可以加许多的子命令，从而实现不同的操作， <code>up</code> 子命令是根据指定的配置文件启动相应的容器（网络环境）。还有一个 <code>down</code> 子命令则是<strong>关闭已启动的容器</strong>（网络环境）。如：</p><ul><li><p>使用指定的 docker-compose-cli.yaml 配置文件关闭网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose -f docker-compose-cli.yaml down</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明：</strong></p><ul><li><p><strong>-f：</strong> 指定启动容器时用所使用的 docker-compose 配置文件。</p></li><li><p><strong>-d：</strong> 指定是否显示网络启动过程中的实时日志信息，如果需要查看详细网络启动日志，则可以不提供此参数。</p></li></ul><p>网络启动顺序：首先启动 Orderer 服务节点，然后启动 Peer 节点，终端输出日志内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">orderer.example.com       | 02:48:25.080 UTC [orderer/common/server] initializeServerConfig -&gt; INFO 002 Starting orderer with TLS enabled</span><br><span class="line">orderer.example.com       | 02:48:25.101 UTC [fsblkstorage] newBlockfileMgr -&gt; INFO 003 Getting block information from block storage</span><br><span class="line">orderer.example.com       | 02:48:25.138 UTC [orderer/commmon/multichannel] NewRegistrar -&gt; INFO 004 Starting system channel 'testchainid' with genesis block hash 67662e918ab76b4a8863cc625d67fcc31e9cb3a7c3c4f9f707af1c05ba5be686 and orderer type solo</span><br><span class="line">orderer.example.com       | 02:48:25.138 UTC [orderer/common/server] Start -&gt; INFO 005 Starting orderer:</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p>Peer 节点启动后，默认情况下没有加入网络中的任何应用通道，也不会与 Orderer 服务建立连接。需要通过客户端对其进行操作，让它加入网络和指定的应用通道中。</p></blockquote><p>启动会我们使用如下命令查看网络信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps</span></span><br></pre></td></tr></table></figure><p>命令执行后会发现有六个容器处于活动状态（分别为：cli、peer1.org1.example.com、peer0.org1.example.com、peer1.org2.example.com、orderer.example.com、peer0.org2.example.com），说明网络启动成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                               COMMAND             CREATED             STATUS              PORTS                                              NAMES</span><br><span class="line">ccf586b68b5b        hyperledger/fabric-tools:latest     <span class="string">"/bin/bash"</span>         2 minutes ago       Up 2 minutes                                                           *cli*</span><br><span class="line">4eda41547208        hyperledger/fabric-peer:latest      <span class="string">"peer node start"</span>   3 minutes ago       Up 2 minutes        0.0.0.0:8051-&gt;7051/tcp, 0.0.0.0:8053-&gt;7053/tcp     *peer1.org1.example.com*</span><br><span class="line">5694763481bd        hyperledger/fabric-orderer:latest   <span class="string">"orderer"</span>           3 minutes ago       Up 3 minutes        0.0.0.0:7050-&gt;7050/tcp                             *orderer.example.com*</span><br><span class="line">96f33d31949e        hyperledger/fabric-peer:latest      <span class="string">"peer node start"</span>   3 minutes ago       Up 3 minutes        0.0.0.0:9051-&gt;7051/tcp, 0.0.0.0:9053-&gt;7053/tcp     *peer0.org2.example.com*</span><br><span class="line">ed93213ba1f1        hyperledger/fabric-peer:latest      <span class="string">"peer node start"</span>   3 minutes ago       Up 2 minutes        0.0.0.0:10051-&gt;7051/tcp, 0.0.0.0:10053-&gt;7053/tcp   *peer1.org2.example.com*</span><br><span class="line">b55ed1fc8c0f        hyperledger/fabric-peer:latest      <span class="string">"peer node start"</span>   3 minutes ago       Up 2 minutes        0.0.0.0:7051-&gt;7051/tcp, 0.0.0.0:7053-&gt;7053/tcp     *peer0.org1.example.com*</span><br></pre></td></tr></table></figure><h4 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>启动网络报错误怎么办？</p><p>如果在启动网络时没有使用 -d 参数，那么在启动后会输出如下图所示的错误信息：</p><p><img src="http://image.chaindesk.cn/3.3.1.png/mark" alt="启动网络的错误信息"></p><p>此错误信息对于我们后期操作没有影响，可以无需理会。</p><p>如果在查看详细日志时发现有错误，那么就需要根据对应的错误提示信息进行处理。注：红色的内容并不代表错误，一般是为了方便区分各节点而使用不同的颜色。</p></li></ol><h3 id="四、以最快的方式完成应用通道的创建"><a href="#四、以最快的方式完成应用通道的创建" class="headerlink" title="四、以最快的方式完成应用通道的创建"></a>四、以最快的方式完成应用通道的创建</h3><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><ol><li>掌握应用通道创建的命令及其必须指定的参数所表示的含义</li><li>实现将节点加入到指定的应用通道中</li></ol><h4 id="任务实现-3"><a href="#任务实现-3" class="headerlink" title="任务实现"></a>任务实现</h4><blockquote><p>网络已经启动成功，准备等待处理交易信息，但为了保证交易安全，实现不相干的实体成员不能访问其无权限访问的数据，所以我们需要做出进一步的设置–&gt;创建应用通道来实现交易及数据的隔离。</p></blockquote><h3 id="1-如何创建应用通道"><a href="#1-如何创建应用通道" class="headerlink" title="1 如何创建应用通道"></a>1 如何创建应用通道</h3><p>在创建及使用应用通道之前，我们先理解一下 <code>channel（通道）</code> 的概念及其作用：</p><ul><li><strong>概念：</strong>将一个大的网络分割成为不同的私有”子网”，关于多个通道的概念及实现请参见第7章第三节内容。</li><li><strong>作用：</strong>通道提供一种通讯机制，能够将 Peer 和 Orderer 连接在一起，形成一个具有保密性的通讯链路（虚拟）， 实现数据隔离。</li></ul><blockquote><p>要加入通道的每个节点都必须拥有自己的通过成员服务提供商（MSP）获得的身份标识，MSP 内容请参见第六章。</p></blockquote><p>下面我们来看怎么创建应用通道。</p><p><strong>进入 Docker cli 容器</strong></p><p>执行如下命令进入到 CLI 容器中(后继操作都在容器中执行)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker <span class="built_in">exec</span> -it cli bash</span></span><br></pre></td></tr></table></figure><p>如果成功, 命令提示符会变为如下内容（代表成功进入 CLI 容器）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@b240e1643244:/opt/gopath/src/github.com/hyperledger/fabric/peer#`</span><br><span class="line"></span><br><span class="line">其中 @ 符号后面的内容根据不同的设备会显示不同的内容。</span><br></pre></td></tr></table></figure><p><strong>创建应用通道</strong></p><p>检查环境变量是否正确设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CHANNEL_NAME</span></span></span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> CHANNEL_NAME=mychannel</span></span><br></pre></td></tr></table></figure><p>创建通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel create -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><strong>-o：</strong> 指定 orderer 节点的地址</li><li><strong>-c：</strong> 指定要创建的应用通道的名称(必须与在创建应用通道交易配置文件时的通道名称一致)</li><li><strong>-f：</strong> 指定创建应用通道时所使用的应用通道交易配置文件</li><li><strong>–tls：</strong> 开启 TLS 验证</li><li><strong>–cafile：</strong> 指定 TLS_CA 证书的所在路径</li></ul><blockquote><p>该命令执行后，会自动在本地生成一个与应用通道名称同名的初始区块 <strong>mychannel.block</strong>, 网络节点只有拥有该文件才可以加入创建的应用通道中</p></blockquote><p>命令执行后输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 002 Got status: &amp;&#123;NOT_FOUND&#125;</span><br><span class="line">[channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized</span><br><span class="line">[cli/common] readBlock -&gt; INFO 004 Received block: 0</span><br><span class="line">-----my---</span><br><span class="line">2020-03-23 06:42:16.273 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-23 06:42:16.426 UTC [cli/common] readBlock -&gt; INFO 002 Got status: &amp;&#123;NOT_FOUND&#125;</span><br><span class="line">2020-03-23 06:42:16.463 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized</span><br><span class="line">2020-03-23 06:42:16.681 UTC [cli/common] readBlock -&gt; INFO 004 Received block: 0</span><br></pre></td></tr></table></figure><p>使用 <code>ll</code> 命令查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ll</span></span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 5 root root  4096 Apr 29 03:34 ./</span><br><span class="line">drwxr-xr-x 3 root root  4096 Apr 29 02:48 ../</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr 29 02:47 channel-artifacts/</span><br><span class="line">drwxr-xr-x 4 root root  4096 Apr 29 02:35 crypto/</span><br><span class="line">-rw-r--r-- 1 root root 15660 Apr 29 03:34 mychannel.block</span><br><span class="line">drwxr-xr-x 2 root root  4096 Apr 29 02:13 scripts/</span><br></pre></td></tr></table></figure><h3 id="2-节点怎么加入应用通道"><a href="#2-节点怎么加入应用通道" class="headerlink" title="2 节点怎么加入应用通道"></a>2 节点怎么加入应用通道</h3><p>应用通道所包含组织的成员节点可以加入通道中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel join -b mychannel.block</span></span><br></pre></td></tr></table></figure><p><strong>join命令：</strong> 将本 Peer 节点加入到应用通道中</p><p><strong>参数说明：</strong></p><ul><li><strong>-b:</strong> 指定当前节点要加入/联接至哪个应用通道</li></ul><p>命令执行后输出内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-23 06:45:44.847 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-23 06:45:45.018 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br></pre></td></tr></table></figure><h3 id="3-更新锚节点"><a href="#3-更新锚节点" class="headerlink" title="3 更新锚节点"></a>3 更新锚节点</h3><p>使用 Org1 的管理员身份更新锚节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> peer channel update -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-23 06:53:04.382 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-23 06:53:04.484 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update</span><br></pre></td></tr></table></figure><p>使用 Org2 的管理员身份更新锚节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_LOCALMSPID=<span class="string">"Org2MSP"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_ADDRESS=peer0.org2.example.com:7051 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> peer channel update -o orderer.example.com:7050 -c <span class="variable">$CHANNEL_NAME</span> -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2020-03-23 06:54:54.942 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2020-03-23 06:54:55.012 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update</span><br></pre></td></tr></table></figure><p>手动配置网络并启动完成，之后我们可以进入 Chaincode 环节。</p><p>如果您能顺利完成走到这一步，那么您可以小小的庆祝一下了。</p></blockquote><h4 id="FAQ-3"><a href="#FAQ-3" class="headerlink" title="FAQ"></a>FAQ</h4><ol><li><p>创建应用通道失败怎么办？</p><p>在执行创建应用通道命令后可能会遇到如下几种错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. Error on outputChannelCreateTx: config update generation failure: could not parse application to application group: </span><br><span class="line">setting up the MSP manager failed: the supplied identity is not valid: x509:</span><br><span class="line">certificate signed by unknown authority (possibly because of "x509: ECDSA verification failure" </span><br><span class="line">while trying to verify candidate authority certificate "ca.org1.example.com")</span><br><span class="line">如果遇到此错误，说明生成的证书有问题（要么没有生成，要么生成的证书不符合x509标准），请重新生成。</span><br><span class="line"></span><br><span class="line">2. Error:got unexpected status: FORBIDDEN -- Failed to reach implicit threshold of 1 sub-policies, required 1 remaining: permission denied</span><br><span class="line">从错误中可以看到是因为权限而造成，请检查生成的文件对应的所属访问权限。</span><br><span class="line"></span><br><span class="line">3. hdr.format undefined (type *tar.header has no field or method format) ......</span><br><span class="line">如果遇到此错误，则检查go语言的版本是否符合官方指定的 Hyperledger Fabric 版本要求。</span><br><span class="line"></span><br><span class="line">4. Error: got unexpected status: BAD_REQUEST -- error authorizing update: error validating ReadSet: readset expected key [Group]  /Channel/Application at version 0, but got version 1</span><br><span class="line">出现如上错误，说明指定的通道名称已经在当前处于运行状态的 Fabric 网络中存在。</span><br></pre></td></tr></table></figure></li><li><h4 id="节点为什么要创建并加入应用通道中？"><a href="#节点为什么要创建并加入应用通道中？" class="headerlink" title="节点为什么要创建并加入应用通道中？"></a>节点为什么要创建并加入应用通道中？</h4><p>创建应用通道交易配置文件，可以指定创建的应用通道中可以有哪些组织加入及指定相应的权限；网络上的每个交易都需要在一个指定的通道中执行，在通道中交易必须通过通道的认证和授权。要加入一个通道的每个节点都必须有自己的通过成员服务提供商（MSP）获得的身份标识，用于鉴定每个节点在通道中的是什么节点和服务。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Untitled</title>
      <link href="/2020/03/21/Untitled/"/>
      <url>/2020/03/21/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>超级账本结构网络</title>
      <link href="/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/04%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC%E7%9A%84%E7%BB%93%E6%9E%84%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/04%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC%E7%9A%84%E7%BB%93%E6%9E%84%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="超级账本结构网络"><a href="#超级账本结构网络" class="headerlink" title="超级账本结构网络"></a>超级账本结构网络</h1><h2 id="什么是结构网络？"><a href="#什么是结构网络？" class="headerlink" title="什么是结构网络？"></a>什么是结构网络？</h2><p>Fabric许可的区块链网络是一种技术基础架构，可为应用程序使用者和管理员提供分类帐服务。在大多数情况下，多个<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#organization" target="_blank" rel="noopener">组织</a>会作为一个<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#consortium" target="_blank" rel="noopener">联盟</a>聚集在一起以形成网络，并且它们的权限由最初配置网络时联盟所同意的一组<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#policy" target="_blank" rel="noopener">策略</a>来确定。此外，网络政策可以根据财团组织的协议随时间变化。</p><a id="more"></a><p>本文档将指导您完成组织配置和部署Hyperledger Fabric网络所需的决策，形成在网络内进行交易的渠道，以及如何在网络生命周期内更新这些决策。您还将学习如何将这些决策嵌入Hyperledger Fabric的体系结构和组件中。</p><h2 id="区块链网络的业务需求–示例"><a href="#区块链网络的业务需求–示例" class="headerlink" title="区块链网络的业务需求–示例"></a>区块链网络的业务需求–示例</h2><p>RA，RB，RC和RD组织已决定共同投资Fabric区块链网络。组织RA将贡献3个对等方，RA的2个客户端应用程序将使用区块链网络的服务。组织RB将贡献4个对等方，并且有1个客户端应用程序。组织RC贡献了3个对等方，并且有2个客户端应用程序。组织RD贡献了4个订购者。组织RA和RB已决定组成一个联盟，并在两者之间利用单独的应用程序渠道。组织RB和RC已决定组建另一个财团，并在两者之间利用单独的应用程序渠道。每个应用程序渠道都有其自己的策略。</p><h2 id="网络组成"><a href="#网络组成" class="headerlink" title="网络组成"></a>网络组成</h2><p>一个网络包括：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#ledger" target="_blank" rel="noopener">分类帐</a>（每个通道一个-由<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#block" target="_blank" rel="noopener">区块链</a>和<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#state-database" target="_blank" rel="noopener">状态数据库组成</a>）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#smart-contract" target="_blank" rel="noopener">智能合约（</a> aka链码）</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#peer" target="_blank" rel="noopener">对等</a>节点</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#ordering-service" target="_blank" rel="noopener">订购服务</a></li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#channel" target="_blank" rel="noopener">频道</a></li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#hyperledger-fabric-ca" target="_blank" rel="noopener">面料证书颁发机构</a></li></ul><h3 id="网络服务的消费者"><a href="#网络服务的消费者" class="headerlink" title="网络服务的消费者"></a>网络服务的消费者</h3><ul><li>组织拥有的客户应用程序</li><li>区块链网络管理员的客户</li></ul><h3 id="网络政策和身份"><a href="#网络政策和身份" class="headerlink" title="网络政策和身份"></a>网络政策和身份</h3><p>架构证书颁发机构（CA）颁发证书，以使组织可以向网络进行身份验证。网络上可以有一个或多个CA，组织可以选择使用自己的CA。此外，财团中的组织所拥有的客户端应用程序使用证书来认证<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#transaction" target="_blank" rel="noopener">交易</a> <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#proposal" target="_blank" rel="noopener">提议</a>，而对等方则使用它们来认可提议并将交易提交给分类账（如果有效）。</p><p><em>该图的说明如下：存在一个具有网络策略NP1和订购服务O的光纤网络N。通道C1由通道策略CP1支配。渠道C1已由财团RARB建立。通道C1通过订购服务O进行管理，对等体P1和P2以及客户端应用程序A1和A2已被授予在C1上进行交易的权限。客户应用程序A1由组织RA拥有。证书颁发机构CA1为组织RA服务。对等点P2维护与通道C1关联的分类帐L1和与C2关联的分类帐L2。对等点P2使用链码S4和S5。订购服务O的订购者节点由组织RD拥有。</em></p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.1_1.png" alt="网络结构"></p><h2 id="建立网络"><a href="#建立网络" class="headerlink" title="建立网络"></a>建立网络</h2><p>根据联盟的定义创建网络，包括其客户，对等方，渠道和订购服务。订购服务是网络的管理点，因为它包含网络中通道的配置。每个通道的配置包括该通道的策略和该通道每个成员的<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#membership-services" target="_blank" rel="noopener">成员资格</a>信息（在此示例中为X509根证书）。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.2.png" alt="网络创造"></p><h2 id="定义财团"><a href="#定义财团" class="headerlink" title="定义财团"></a>定义财团</h2><p>联盟由网络上的两个或多个组织组成。联盟是由需要彼此进行业务交易的组织定义的，它们必须同意管理网络的策略。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.3.png" alt="网络组织"></p><h2 id="为财团创建渠道"><a href="#为财团创建渠道" class="headerlink" title="为财团创建渠道"></a>为财团创建渠道</h2><p>通道是一种用于连接网络组件和/或成员客户端应用程序的通信方式。通过在订购服务上生成配置模块来创建通道，该模块评估通道配置的有效性。通道之所以有用，是因为它们允许数据隔离和机密性。交易组织必须经过渠道身份验证才能与之交互。通道受配置它们的策略支配。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.4.png" alt="网络通道"></p><h2 id="同行和渠道"><a href="#同行和渠道" class="headerlink" title="同行和渠道"></a>同行和渠道</h2><p>对等点是由拥有它们的组织加入渠道的，并且网络中的渠道上可以有多个对等节点。同行可以扮演多个角色：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#endorsement" target="_blank" rel="noopener"><em>认可对等方</em></a> -由策略定义为在仿真中执行智能合约交易并将提议响应（认可）返回给客户端应用程序的特定节点。</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#commitment" target="_blank" rel="noopener"><em>提交对等方</em></a> –验证有序交易的块并将其提交（写入/追加）到它维护的分类帐的副本中。</li></ul><p>因为所有对等方都为其加入的每个通道维护一个分类帐的副本，所以所有对等方都是提交对等方。但是，只有智能合约的签约策略指定的对等方可以背书。可以通过以下角色进一步定义对等方：</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#anchor-peer" target="_blank" rel="noopener"><em>锚点对等点</em></a> -在通道配置中定义，是网络上其他组织将在其加入的第一个对等点。</li><li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#leading-peer" target="_blank" rel="noopener"><em>领先对等方</em></a> –存在于网络上，用于代表具有多个对等方的组织与订购服务进行通信。</li></ul><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.5.png" alt="网络政策"></p><h2 id="应用程序和智能合约"><a href="#应用程序和智能合约" class="headerlink" title="应用程序和智能合约"></a>应用程序和智能合约</h2><p>必须在对等方上<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#install" target="_blank" rel="noopener">安装</a>并<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#instantiate" target="_blank" rel="noopener">实例化</a>智能合约链代码，以便客户端应用程序能够<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#invoke" target="_blank" rel="noopener">调用</a>智能合约。客户应用程序是网络之外唯一生成交易建议的地方。当客户端应用程序提议交易时，智能签约将在背书对等方上调用，这些对等端根据账本的副本模拟智能合约的执行并将提议响应（背书）发送回客户端应用程序。客户端应用程序将这些响应组合成一个事务，并将其广播到订购服务。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.6.png" alt="网络配置"></p><h2 id="扩大网络"><a href="#扩大网络" class="headerlink" title="扩大网络"></a>扩大网络</h2><p>尽管对网络的规模没有理论上的限制，但是随着网络的发展，重要的是要考虑有助于优化网络吞吐量，稳定性和弹性的设计选择。对网络策略的评估和<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/gossip.html#gossip-protocol" target="_blank" rel="noopener">八卦协议的</a>实现以适应大量对等节点是潜在的考虑因素。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.7.png" alt="网络成长"></p><h2 id="简化视觉词汇"><a href="#简化视觉词汇" class="headerlink" title="简化视觉词汇"></a>简化视觉词汇</h2><p><em>在下图中，我们看到有两个客户端应用程序连接到两个对等节点，并且在一个通道上有一个订购服务。由于只有一个通道，因此在此示例中只有一个逻辑分类帐。与在单个通道中一样，P1和P2将具有分类帐（L1）和智能合约（也称为链码（S4））的相同副本。</em></p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.8.png" alt="网络词汇"></p><h2 id="添加另一个联盟定义"><a href="#添加另一个联盟定义" class="headerlink" title="添加另一个联盟定义"></a>添加另一个联盟定义</h2><p>在定义了联盟后，将其添加到现有渠道中，我们必须通过将渠道配置更新事务发送到订购服务来更新渠道配置。如果交易有效，则订购服务将生成一个新的配置块。然后，网络上的对等方将必须验证订购服务生成的新通道配置模块，并在验证新模块时更新其通道配置。重要的是要注意，通道配置更新事务是由区块链网络管理员调用的<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#system-chain" target="_blank" rel="noopener"><em>系统链代码</em></a>处理的，而不是由客户端应用程序事务提议所调用的。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.9.png" alt="network.consortium2"></p><h2 id="新增频道"><a href="#新增频道" class="headerlink" title="新增频道"></a>新增频道</h2><p>组织是什么形式和加入渠道，随着网络的发展，可以修改渠道配置以添加组织。将新通道添加到网络时，通道策略与在同一网络上配置的其他通道保持分开。</p><p><em>在此示例中，订购服务上通道1和通道2的配置将保持彼此独立。</em></p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.10.png" alt="network.channel2"></p><h2 id="添加另一个同伴"><a href="#添加另一个同伴" class="headerlink" title="添加另一个同伴"></a>添加另一个同伴</h2><p><em>在此示例中，组织3拥有的对等方3（P3）已添加到通道2（C2）。请注意，尽管网络上可以有多个订购服务，但是也可以有一个管理多个渠道的订购服务。在此示例中，C2的通道策略与C1的通道策略是隔离的。对等体3（P3）也与C1隔离，因为仅对C2进行了身份验证。</em></p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.11.png" alt="network.peer2"></p><h2 id="将同伴加入多个渠道"><a href="#将同伴加入多个渠道" class="headerlink" title="将同伴加入多个渠道"></a>将同伴加入多个渠道</h2><p><em>在此示例中，对等体2（P2）已加入通道2（C2）。P2将使通道C1和C2及其关联的交易保持私有和隔离。此外，客户端应用程序A3也将与C1隔离。订购服务通过评估所有通道上配置的所有节点的策略和数字签名来维护网络管理和通道隔离。</em></p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.12.png" alt="网络多渠道"></p><h2 id="网络全面形成"><a href="#网络全面形成" class="headerlink" title="网络全面形成"></a>网络全面形成</h2><p><em>在此示例中，网络已开发为包括多个客户端应用程序，对等方和连接到单个订购服务的渠道。对等2（P2）是连接到通道C1和C2的唯一对等节点，它们将保持彼此隔离，并且其数据将保持私有。在此示例中，现在有两个逻辑分类帐，一个用于C1，一个用于C2。</em></p><p>简单的词汇</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.13.png" alt="网络。最终网络"></p><p>更好的安排</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/network.diagram.14.png" alt="network.finalnetwork2"></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超级帐本结构模型</title>
      <link href="/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/03%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/03%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="超级账本结构模型"><a href="#超级账本结构模型" class="headerlink" title="超级账本结构模型"></a>超级账本结构模型</h1><p>本节概述了编织到Hyperledger Fabric中的关键设计功能，这些功能可以实现其对全面而可定制的企业区块链解决方案的承诺：</p><ul><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#assets" target="_blank" rel="noopener">资产</a> -资产定义允许通过网络交换几乎所有具有货币价值的东西，从完整食品到古董车再到货币期货。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#chaincode" target="_blank" rel="noopener">链码</a> -链码执行从事务顺序中划分出来，限制了节点类型之间所需的信任和验证级别，并优化了网络可伸缩性和性能。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#ledger-features" target="_blank" rel="noopener">分类帐功能</a> -不变的共享分类帐对每个通道的整个交易历史进行编码，并包括类似SQL的查询功能，以进行有效的审计和争议解决。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#privacy" target="_blank" rel="noopener">隐私</a> -渠道和私人数据收集可实现私有和机密的多边交易，这通常是竞争企业和受监管行业在公共网络上交换资产所必需的。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#security-membership-services" target="_blank" rel="noopener">安全和会员服务</a> -允许的会员提供了一个受信任的区块链网络，参与者知道所有交易都可以由授权的监管机构和审计员检测和追踪。</p></li><li><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#consensus" target="_blank" rel="noopener">共识</a> -达成<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/fabric_model.html#consensus" target="_blank" rel="noopener">共识</a>的独特方法可实现企业所需的灵活性和可扩展性。</p><a id="more"></a></li></ul><h2 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h2><p>资产的范围从有形的（房地产和硬件）到无形的（合同和知识产权）。Hyperledger Fabric提供了使用链码交易修改资产的功能。</p><p>资产在Hyperledger Fabric中表示为键值对的集合，状态更改记录为<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#channel" target="_blank" rel="noopener">通道</a> 分类账中的事务。资产可以二进制和/或JSON形式表示。</p><p>您可以使用<a href="https://github.com/hyperledger/composer" target="_blank" rel="noopener">Hyperledger Composer</a>工具在Hyperledger Fabric应用程序中轻松定义和使用资产。</p><h2 id="链码"><a href="#链码" class="headerlink" title="链码"></a>链码</h2><p>Chaincode是定义一项或多项资产的软件，以及用于修改资产的交易指令；换句话说，这是业务逻辑。Chaincode强制执行用于读取或更改键值对或其他状态数据库信息的规则。链码功能针对分类帐的当前状态数据库执行，并通过交易建议启动。链码执行会产生一组键值写操作（写集），这些键值写操作可以提交给网络，并应用于所有对等方的分类帐中。</p><h2 id="分类帐功能"><a href="#分类帐功能" class="headerlink" title="分类帐功能"></a>分类帐功能</h2><p>分类帐是结构中所有状态转换的有序，防篡改记录。状态转换是参与方提交的链码调用（“交易”）的结果。每笔交易都会产生一组资产键值对，这些键值对在创建，更新或删除时将被提交到分类账。</p><p>分类账由一个区块链（“ chain”）和一个状态数据库组成，该区块链将不可变的顺序记录存储在块中，该状态数据库用于维护当前的结构状态。每个频道有一个分类帐。每个对等方都为其所属的每个通道维护一个分类帐的副本。</p><p>Fabric分类帐的一些功能：</p><ul><li>使用基于键的查找，范围查询和组合键查询来查询和更新分类帐</li><li>使用丰富查询语言的只读查询（如果使用CouchDB作为状态数据库）</li><li>只读历史记录查询—查询密钥的分类帐历史记录，从而启用数据出处场景</li><li>事务包括以链码读取的键/值（读集）和以链码写入的键/值（写集）的版本</li><li>交易包含每个背书对等方的签名，并提交给订购服务</li><li>交易被分为几大块，并从订购服务“交付”给渠道上的对等方</li><li>对等方根据背书政策验证交易并执行政策</li><li>在附加块之前，执行版本检查，以确保自链码执行以来，已读取资产的状态未更改</li><li>交易一旦经过验证并提交，便具有不变性</li><li>通道的分类帐包含一个配置块，用于定义策略，访问控制列表和其他相关信息</li><li>通道包含<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/glossary.html#msp" target="_blank" rel="noopener">成员资格服务提供者</a>实例，允许从不同的证书颁发机构派生加密材料</li></ul><p>有关数据库，存储结构和“查询能力”的更深入了解，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/ledger.html" target="_blank" rel="noopener">分类账</a>主题。</p><h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>Hyperledger Fabric在每个通道的基础上使用不变的分类帐，以及可以操纵和修改资产当前状态（即更新键值对）的链码。分类账存在于渠道范围内-可以在整个网络中共享（假设每个参与者都在一个公共渠道上工作）-或可以将其私有化以仅包括一组特定的参与者。</p><p>在后一种情况下，这些参与者将创建一个单独的渠道，从而隔离/隔离他们的交易和分类帐。为了解决想要弥合总体透明度和隐私之间的差距的方案，只能在需要访问资产状态以执行读写的对等方上安装链码（换句话说，如果未在对等方上安装链码） ，它将无法与分类帐正确连接）。</p><p>当该通道上的组织子集需要对其交易数据保密时，可以使用私有数据收集（集合）将这些数据隔离在逻辑上与渠道分类帐分离的私有数据库中，该数据库只能由组织的授权子集访问。</p><p>因此，渠道使交易对于更广泛的网络而言是私有的，而集合则对渠道上组织子集之间的数据保持私有。</p><p>为了进一步混淆数据，可以在将交易发送到订购服务并将块附加到分类账之前，使用AES等通用加密算法对链码中的值进行加密（部分或全部）。一旦加密的数据已写入分类帐，则只有拥有用于生成密文的相应密钥的用户才能对其解密。有关链码加密的更多详细信息，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/chaincode4ade.html" target="_blank" rel="noopener">开发人员链码</a> 主题。</p><p>有关如何在区块链网络上实现隐私的更多详细信息，请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/private-data-arch.html" target="_blank" rel="noopener">私有数据</a>主题。</p><h2 id="安全和会员服务"><a href="#安全和会员服务" class="headerlink" title="安全和会员服务"></a>安全和会员服务</h2><p>Hyperledger Fabric支持所有参与者都具有已知身份的交易网络。公钥基础结构用于生成与组织，网络组件以及最终用户或客户端应用程序绑定的加密证书。结果，可以在更广泛的网络和通道级别上操纵和控制数据访问控制。Hyperledger Fabric的这种“允许”概念，再加上渠道的存在和功能，有助于解决隐私和机密性是最重要的问题。</p><p>请参阅<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/msp.html" target="_blank" rel="noopener">成员资格服务提供商（MSP）</a>主题，以更好地了解加密实现以及Hyperledger Fabric中使用的签名，验证，验证方法。</p><h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>在分布式分类帐技术中，共识最近已成为单一功能内特定算法的同义词。但是，共识不仅包括简单地同意交易顺序，而且这种区别在Hyperledger Fabric中得到了体现，它在整个交易流程中（从提案和认可到订购，验证和承诺）都起着根本性作用。简而言之，共识被定义为对包含一个区块的一组交易的正确性的全面验证。</p><p>当区块交易的顺序和结果满足明确的策略标准检查时，最终才能达成共识。这些检查和余额发生在事务的生命周期中，包括使用背书策略来指示哪些特定成员必须背书某个事务类，以及系统链代码以确保这些政策得到执行和维护。在作出承诺之前，对等方将使用这些系统链码来确保存在足够的认可，并且它们是从适当的实体派生的。此外，在将包含交易的任何块追加到分类账之前，将进行版本控制检查，在此期间将对分类账的当前状态进行同意或同意。</p><p>除了进行大量的背书，有效性和版本检查外，还在交易流程的各个方向上都在进行身份验证。访问控制列表是在网络的分层层上实现的（将服务订购到各个通道），有效载荷在交易建议书通过不同的体系结构组件时被重复签名，验证和认证。总而言之，共识不仅限于一批交易的商定顺序。相反，它是一项总体特征，它是交易从提案到承诺的整个过程中不断进行的验证的副产品。</p><p>查看<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/txflow.html" target="_blank" rel="noopener">交易流程图</a>以直观表示共识。</p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超级账本结构功能</title>
      <link href="/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/02%E8%B6%85%E7%BA%A7%E5%B8%90%E6%9C%AC%E7%9A%84%E7%BB%93%E6%9E%84%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/03/12/%E8%81%94%E7%9B%9F%E9%93%BE/02%E8%B6%85%E7%BA%A7%E5%B8%90%E6%9C%AC%E7%9A%84%E7%BB%93%E6%9E%84%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="超级账本结构功能"><a href="#超级账本结构功能" class="headerlink" title="超级账本结构功能"></a>超级账本结构功能</h1><p>Hyperledger Fabric是分布式账本技术（DLT）的实现，它以模块化的区块链架构提供企业就绪的网络安全性，可伸缩性，机密性和性能。Hyperledger Fabric提供以下区块链网络功能：</p><a id="more"></a><h2 id="身份管理"><a href="#身份管理" class="headerlink" title="身份管理"></a>身份管理</h2><p>为了启用许可的网络，Hyperledger Fabric提供了成员身份服务，该服务管理用户ID并验证网络上的所有参与者。访问控制列表可用于通过特定网络操作的授权来提供其他权限层。例如，可以允许特定的用户ID调用链码应用程序，但是阻止其部署新的链码。</p><h2 id="隐私权和机密性"><a href="#隐私权和机密性" class="headerlink" title="隐私权和机密性"></a>隐私权和机密性</h2><p>Hyperledger Fabric使竞争的商业利益以及任何需要私人机密交易的组能够共存于同一许可的网络上。专用<strong>通道</strong>是受限制的消息传递路径，可用于为网络成员的特定子集提供交易隐私和机密性。通道上的所有数据（包括事务，成员和通道信息）对于任何未明确授予该通道访问权限的网络成员都是不可见和不可访问的。</p><h2 id="高效处理"><a href="#高效处理" class="headerlink" title="高效处理"></a>高效处理</h2><p>Hyperledger Fabric通过节点类型分配网络角色。为了向网络提供并发性和并行性，将事务执行与事务排序和承诺分开。在订购交易之前执行交易使每个对等节点可以同时处理多个交易。这种并发执行可以提高每个对等方的处理效率，并加快向订购服务的交易交付。</p><p>除了启用并行处理外，分工还减轻了订购节点的负担，使其无需执行事务和进行分类帐维护，而对等节点则无需进行订购（协商）工作。角色的这种分叉还限制了授权和身份验证所需的处理。所有对等节点都不必信任所有排序节点，反之亦然，因此一个对等节点可以独立于另一个进行验证而运行。</p><h2 id="链码功能"><a href="#链码功能" class="headerlink" title="链码功能"></a>链码功能</h2><p>链码应用程序对逻辑进行编码，该逻辑由通道上的特定类型的事务调用。例如，定义用于资产所有权变更的参数的链码可确保所有转让所有权的交易都遵循相同的规则和要求。<strong>系统链码</strong>被区分为定义整个通道的操作参数的链码。生命周期和配置系统链码定义了通道规则；背书和验证系统链代码定义了背书和验证交易的要求。</p><h2 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h2><p>Hyperledger Fabric实现了模块化架构，可以为网络设计人员提供功能选择。例如，可以将用于身份，排序（共识）和加密的特定算法插入任何Hyperledger Fabric网络。结果是任何行业或公共领域均可采用的通用区块链架构，并确保其网络可跨市场，法规和地理边界进行互操作。</p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链介绍</title>
      <link href="/2020/03/10/%E8%81%94%E7%9B%9F%E9%93%BE/01%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/03/10/%E8%81%94%E7%9B%9F%E9%93%BE/01%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链介绍"><a href="#区块链介绍" class="headerlink" title="区块链介绍"></a>区块链介绍</h1><p>Hyperledger Fabric是分布式账本解决方案的平台，该平台以模块化架构为基础，提供高度的机密性，灵活性，灵活性和可扩展性。它旨在支持不同组件的可插拔实现，并适应整个经济生态系统中存在的复杂性和复杂性。</p><h2 id="什么是区块链？"><a href="#什么是区块链？" class="headerlink" title="什么是区块链？"></a>什么是区块链？</h2><h5 id="分布式分类帐"><a href="#分布式分类帐" class="headerlink" title="分布式分类帐"></a>分布式分类帐</h5><p>区块链网络的核心是分布式账本，记录了网络上发生的所有交易。</p><p>区块链分类帐经常被描述为<strong>分散式的，</strong>因为它是在许多网络参与者之间复制的，每个参与者都在维护方面进行<strong>协作</strong>。我们将看到，分散和协作是强大的属性，反映了企业在现实世界中交换商品和服务的方式。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/basic_network.png" alt="_images / basic_network.png"></p><p>除了去中心化和协作之外，记录到区块链的信息仅是追加的，使用加密技术来保证一旦将交易添加到分类账中就无法修改。“不变性”的这种特性使确定信息的来源变得简单，因为参与者可以确定事实之后信息没有被更改。这就是为什么有时将区块链描述为<strong>证明系统的原因</strong>。</p><h5 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h5><p>为了支持信息的一致更新-并启用总账功能（交易，查询等），区块链网络使用<strong>智能合约</strong>来提供对账本的受控访问。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/Smart_Contract.png" alt="_images / Smart_Contract.png"></p><p>智能合约不仅是封装信息并使之在网络上保持简单的关键机制，还可以编写为允许参与者自动执行交易的某些方面的关键机制。</p><p>例如，可以编写智能合约来规定运输物品的成本，其中运输费用取决于物品到达的速度而变化。在双方同意并写入总账的条款下，相应的资金会在收到项目后自动转手。</p><h5 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h5><p>保持分类账交易在整个网络上同步的过程-确保分类账仅在相应参与者批准交易后更新，并且当分类账确实更新时，它们将以相同顺序更新相同的交易-称为<strong>共识</strong>。</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/consensus.png" alt="_images / consensus.png"></p><p>稍后，您将学到更多有关分布式账本，智能合约和共识的知识。就目前而言，将区块链视为共享的，复制的交易系统就足够了，该系统通过智能合约进行更新，并通过称为共识的协作流程保持一致的同步。</p><h2 id="为什么区块链有用？"><a href="#为什么区块链有用？" class="headerlink" title="为什么区块链有用？"></a>为什么区块链有用？</h2><h5 id="当今的记录系统"><a href="#当今的记录系统" class="headerlink" title="当今的记录系统"></a><strong>当今的记录系统</strong></h5><p>如今的交易网络是自保存业务记录以来已经存在的网络的稍微更新版本。<strong>业务网络</strong>的成员彼此进行事务处理，但是它们维护各自的交易记录。他们正在交易的东西-无论是16世纪的佛兰德挂毯还是今天的证券-每次出售时都必须确定其出处，以确保出售物品的企业具有所有权链来验证其所有权它。</p><p>您剩下的是一个如下所示的业务网络：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/current_network.png" alt="_images / current_network.png"></p><p>现代技术已将这一过程从石碑和纸质文件夹转移到硬盘驱动器和云平台，但是其基本结构是相同的。尚不存在用于管理网络参与者身份的统一系统，建立来源非常繁琐，需要数天才能完成证券交易（其全球交易量已达数万亿美元），必须手动签署和执行合同，并且系统中的每个数据库都包含唯一信息，因此代表单点故障。</p><p>尽管对可见性和信任的需求很明确，但如今采用零散的信息和流程共享方法来建立跨业务网络的记录系统是不可能的。</p><h5 id="区块链差异"><a href="#区块链差异" class="headerlink" title="区块链差异"></a><strong>区块链差异</strong></h5><p>如果业务网络具有在网络上建立身份，执行事务和存储数据的标准方法，而不是由“现代”交易系统所代表的效率低下的嵌套，那该怎么办？如果可以通过查看一系列交易来确定资产的来源，该交易一经写入便无法更改，因此可以被信任，该怎么办？</p><p>该业务网络看起来像这样：</p><p><img src="https://hyperledger-fabric.readthedocs.io/en/release-1.2/_images/future_net.png" alt="_images / future_net.png"></p><p>这是一个区块链网络，其中每个参与者都有自己的总账副本。除了共享分类帐信息之外，还共享更新分类帐的过程。与当今的系统（其中参与者的<strong>私人</strong>程序用于更新其<strong>私人</strong>分类帐）不同，区块链系统具有<strong>共享</strong>程序以更新<strong>共享的</strong>分类帐。</p><p>通过共享账本协调业务网络的能力，区块链网络可以减少与私人信息和处理相关的时间，成本和风险，同时提高信任度和可见性。</p><p>您现在知道什么是区块链以及为什么有用。还有许多其他重要的细节，但它们都与共享信息和流程的这些基本思想有关。</p><h2 id="什么是Hyperledger-Fabric？"><a href="#什么是Hyperledger-Fabric？" class="headerlink" title="什么是Hyperledger Fabric？"></a>什么是Hyperledger Fabric？</h2><p>Linux基金会于2015年创建了Hyperledger项目，以推进跨行业的区块链技术。它没有声明单一的区块链标准，而是鼓励通过社区流程以协作方式开发区块链技术，并具有鼓励开放开发和随着时间推移采用关键标准的知识产权。</p><p>Hyperledger Fabric是Hyperledger中的区块链项目之一。像其他区块链技术一样，它具有分类帐，使用智能合约，并且是参与者用来管理其交易的系统。</p><p>Hyperledger Fabric与其他一些区块链系统的不同之处在于它是<strong>私有的</strong>并且被<strong>许可</strong>。Hyperledger Fabric网络的成员不是通过允许未知身份参与网络的开放式无权限系统（需要诸如“工作量证明”之类的协议来验证交易并保护网络），而是通过受信任的<strong>成员资格服务提供商（MSP）来注册</strong>。</p><p>Hyperledger Fabric还提供了几种可插拔选项。账本数据可以以多种格式存储，共识机制可以互换，也可以支持不同的MSP。</p><p>Hyperledger Fabric还提供了创建<strong>渠道的功能</strong>，允许一组参与者创建单独的交易分类账。对于某些参与者可能是竞争对手并且不希望他们进行的每笔交易（例如，他们向某些参与者而不是其他参与者提供的特殊价格）的网络，每个参与者都知道这是一个特别重要的选择。如果有两个参与者组成一个渠道，则这些参与者（没有其他参与者）拥有该渠道的分类帐副本。</p><h5 id="共享分布式账本"><a href="#共享分布式账本" class="headerlink" title="共享分布式账本"></a>共享分布式账本</h5><p>Hyperledger Fabric具有一个账本子系统，该子系统包括两个组件：<strong>世界状态</strong>和<strong>事务日志</strong>。每个参与者都有一份账本到他们所属的每个Hyperledger Fabric网络的副本。</p><p>世界状态组件描述分类帐在给定时间点的状态。这是分类帐的数据库。事务日志组件记录所有导致当前世界状态值的事务；这是世界状态的更新历史。然后，分类帐是世界状态数据库和事务日志历史记录的组合。</p><p>分类帐具有世界状态的可替换数据存储。默认情况下，这是一个LevelDB键值存储数据库。事务日志不需要是可插入的。它仅记录区块链网络使用的分类帐数据库的前后值。</p><h5 id="智能合约-1"><a href="#智能合约-1" class="headerlink" title="智能合约"></a><strong>智能合约</strong></h5><p>Hyperledger Fabric智能合约以<strong>链码</strong>编写，并在<strong>区块</strong>链外部的应用程序需要与分类账进行交互时由该应用程序调用。在大多数情况下，chaincode仅与分类帐的数据库组件，世界状态（例如，查询状态）交互，而不与事务日志交互。</p><p>链码可以用几种编程语言实现。当前，支持Go和Node。</p><h5 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a><strong>隐私</strong></h5><p>根据网络的需求，企业对企业（B2B）网络的参与者可能对他们共享多少信息非常敏感。对于其他网络，隐私将不是头等大事。</p><p>Hyperledger Fabric支持以隐私（使用通道）为主要操作要求的网络以及相对开放的网络。</p><h5 id="共识-1"><a href="#共识-1" class="headerlink" title="共识"></a><strong>共识</strong></h5><p>即使交易可能在网络中不同的参与者集之间，也必须按照交易发生的顺序将其写入分类帐。为此，必须建立交易顺序，并且必须采用一种方法来拒绝错误（或恶意）插入分类帐中的不良交易。</p><p>这是计算机科学的一个经过全面研究的领域，有很多方法可以实现，但都需要权衡取舍。例如，PBFT（实用拜占庭式容错）可以提供一种机制，使文件副本可以相互通信，即使在发生损坏的情况下也可以使每个副本保持一致。另外，在比特币中，排序是通过称为挖掘的过程进行的，在该过程中，竞争的计算机竞相解决一个密码难题，该难题定义了随后所有进程所依据的顺序。</p><p>Hyperledger Fabric旨在允许网络初学者选择一种共识机制，以最能代表参与者之间存在的关系。与隐私一样，也有各种各样的需求。从关系高度结构化的网络到点对点的网络。</p><p>我们将了解有关Hyperledger Fabric共识机制的更多信息，该机制目前包括SOLO和Kafka。</p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章Ubuntu安装fabric并启动</title>
      <link href="/2020/03/10/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC1%E7%AB%A0Ubuntu%E5%AE%89%E8%A3%85fabric%E5%B9%B6%E5%90%AF%E5%8A%A8/"/>
      <url>/2020/03/10/%E8%81%94%E7%9B%9F%E9%93%BE/%E7%AC%AC1%E7%AB%A0Ubuntu%E5%AE%89%E8%A3%85fabric%E5%B9%B6%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="第一步：安装必要的软件"><a href="#第一步：安装必要的软件" class="headerlink" title="第一步：安装必要的软件"></a>第一步：安装必要的软件</h3><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1. 操作系统"></a>1. 操作系统</h3><p>博主使用的操作系统为64位的 <strong>Ubuntu 16.04 LTS</strong>，系统内核为 GNU/Linux 4.13.0-36-generic x86_64。</p><p>硬件资源要求：内存最低为2GB，最好3G以上； 磁盘空间为30GB或更高。</p><p>如果计算机默认为Windows操作系统， 可以在Windows系统中安装一个VMware虚拟机应用程序， 然后在VMWare虚拟机中安装Ubuntu 16.04系统， 最后在Window操作系统中再安装一个远程连接工具（如XShell或SecureCRT），以方便连接并操作Ubuntu系统。</p><a id="more"></a><h3 id="2-安装所需工具"><a href="#2-安装所需工具" class="headerlink" title="2.安装所需工具"></a>2.安装所需工具</h3><blockquote><p>git、docker、golang、node.js、npm</p></blockquote><h4 id="2-1-安装git"><a href="#2-1-安装git" class="headerlink" title="2.1 安装git"></a>2.1 安装git</h4><p>首先，我们来安装git工具，git是一个非常优秀的免费、开源的版本管理控制工具， 我们可以使用git工具方便地下载官方（Golang、Hyperledger Fabric等等）在Github网站上发布的相关源代码或其它内容。</p><p>安装git工具使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install git</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git version</span></span><br><span class="line">git version 2.7.0</span><br></pre></td></tr></table></figure><blockquote><p>MAC OS系统中默认已安装。如未安装，可以在git官方网站：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> 页面中选择相应系统的安装包下载并安装</p></blockquote><h4 id="2-2-安装cURL"><a href="#2-2-安装cURL" class="headerlink" title="2.2 安装cURL"></a>2.2 安装cURL</h4><p>使用如下命令安装cURL:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install curl</span></span><br></pre></td></tr></table></figure><blockquote><p>各系统的cURL安装包可以在 <a href="https://curl.haxx.se/download.html" target="_blank" rel="noopener">https://curl.haxx.se/download.html</a> 页面中选择下载并安装</p></blockquote><h4 id="2-3-安装Docker"><a href="#2-3-安装Docker" class="headerlink" title="2.3 安装Docker"></a>2.3 安装Docker</h4><p>查看系统中是否已经安装Docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker --version</span></span><br></pre></td></tr></table></figure><p>使用如下命令安装Docker的最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install docker.io</span></span><br></pre></td></tr></table></figure><p><strong>查看Docker版本信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker --version</span></span><br></pre></td></tr></table></figure><p>输出: <code>Docker version 17.03.2-ce, build f5ec1e2</code></p><h4 id="2-4-安装Docker-compose"><a href="#2-4-安装Docker-compose" class="headerlink" title="2.4 安装Docker-compose"></a>2.4 安装Docker-compose</h4><p>确定系统中是否已安装docker－compose工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br></pre></td></tr></table></figure><p>如系统提示未安装，则使用如下命令安装docker-compose工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install docker-compose</span></span><br></pre></td></tr></table></figure><p>安装成功后，查看Docker－Compose版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br></pre></td></tr></table></figure><p>输出: <code>docker-compose version 1.8.0, build unknown</code></p><h4 id="2-5-安装Golang"><a href="#2-5-安装Golang" class="headerlink" title="2.5 安装Golang"></a>2.5 安装Golang</h4><blockquote><p>Fabric1.0.0版本要求Go语言1.7以上版本，Fabric1.1.0版本要求Go1.9以上版本，Fabric1.2.0版本要求Go1.10以上版本， 我们使用Fabric1.2.0版本， 所以从官方下载最新版本的Golang。</p></blockquote><h5 id="1-下载Golang"><a href="#1-下载Golang" class="headerlink" title="1.下载Golang"></a>1.下载Golang</h5><h5 id="下载方式一"><a href="#下载方式一" class="headerlink" title="下载方式一"></a>下载方式一</h5><p>使用wget工具下载Golang的最新版本压缩包文件 go1.10.3.linux-amd64.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>下载Golang压缩包文件，需要操作系统能够保证正常访问Golang官方网站</strong>。</p><p>下载过程可能耗时较长（取决于具体网络情况），请耐心等待。</p><p>其它系统可以在Golang官方： <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> 下载页面中查找相应的安装包下载安装。</p></blockquote><p>下载完成后，文件会保存在当前目录下。可以使用 <code>ll</code> 命令查看</p><p><img src="http://image.chaindesk.cn/1.1.jpg/mark" alt="Golang下载文件"></p><h5 id="2-解压文件"><a href="#2-解压文件" class="headerlink" title="2 解压文件"></a>2 解压文件</h5><p>使用 tar 命令将下载后的压缩包文件解压到指定的 /usr/local/ 路径下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf go1.10.3.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>/</span></span><br></pre></td></tr></table></figure><hr><p>如果在解压过程中出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Unexpected EOF in archive</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br><span class="line">或</span><br><span class="line">gzip: stdin: unexpected end of file</span><br><span class="line">tar: 归档文件中异常的 EOF</span><br><span class="line">tar: 归档文件中异常的 EOF</span><br><span class="line">tar: Error is not recoverable: exiting now</span><br></pre></td></tr></table></figure><p>说明下载的tar压缩包文件有问题， 如没有下载完整或压缩包数据损坏。请删除后重新下载并解压至指定的目录中。</p><hr><h5 id="下载方式二"><a href="#下载方式二" class="headerlink" title="下载方式二"></a>下载方式二</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install go   //直接下载</span><br></pre></td></tr></table></figure><h5 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3 配置环境变量"></a>3 配置环境变量</h5><p>解压后，Golang可以让系统的所有用户正常使用， 所以我们使用 vim 文件编辑工具打开系统的 profile 文件进行编辑：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/profile</span></span><br></pre></td></tr></table></figure><blockquote><p>如果只想让当前登录用户使用Golang， 其它用户不能使用， 则编辑当前用户$HOME目录下的 .bashrc 或 .profile 文件， 在该文件中添加相应的环境变量即可。</p></blockquote><p>在profile文件最后添加如下内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/go   我的是//$HOME=/home/hg</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$GOROOT/bin:$PATH</span><br></pre></td></tr></table></figure><p>使用 source 命令，使刚刚添加的配置信息生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><p>通过 go version命令验证是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br></pre></td></tr></table></figure><p>输出: <code>go version go1.13.3 linux/amd64</code></p><blockquote><p>如果系统中有旧版本的golang,则使用如下命令卸载旧版本的golang,然后再重新安装并配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> su -</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt-get remove golang-go --purge &amp;&amp; apt-get autoremove --purge &amp;&amp; apt-get clean</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-安装Node及npm"><a href="#1-3-安装Node及npm" class="headerlink" title="1.3 安装Node及npm"></a>1.3 安装Node及npm</h3><h4 id="1-安装nvm"><a href="#1-安装nvm" class="headerlink" title="1 安装nvm"></a>1 安装nvm</h4><p>nvm：Node Version Manager，Node.js的版本管理软件， 可以根据不同的需求场景方便地随时在Node.js的各个版本之间进行切换。</p><p>由于Node.js版本更新较快，且各版本之间差异较大；直接从Node官网安装可能需要很长时间，而且中间可能会因为网络访问及数据传输原因造成下载中断或失败等问题。为了方便安装及后期管理Node.js的版本，我们首先需要在系统中安装nvm管理工具。</p><p>使用如下命令安装nvm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.10/install.sh | bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span></span><br></pre></td></tr></table></figure><h4 id="2-安装Node"><a href="#2-安装Node" class="headerlink" title="2 安装Node"></a>2 安装Node</h4><p>nvm工具安装并配置成功后， 可以直接使用nvm命令安装Node；且Node安装成功后，nvm会自动将npm工具进行安装。</p><p>使用如下命令安装Node：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm install v8.11.1</span></span><br></pre></td></tr></table></figure><blockquote><p>安装Node时须注意：安装版本为8.9.x或以上的Node.js，<strong>Fabric目前不支持9.x系列的Node.js版本.</strong></p></blockquote><p>安装成功输出如下内容：</p><p><img src="http://image.chaindesk.cn/1.2.jpg/mark" alt="Node安装成功"></p><h4 id="1-2-3-3-检查Node及npm版本"><a href="#1-2-3-3-检查Node及npm版本" class="headerlink" title="1.2.3.3 检查Node及npm版本"></a>1.2.3.3 检查Node及npm版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v &amp;&amp; npm -v</span></span><br></pre></td></tr></table></figure><p>输出内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8.11.1</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p><strong>Fabric只支持Ubuntu系统吗？</strong></p><p>Hyperledger Fabric支持常见的Linux相关系统（如：Debian、CentOS等）和MacOS。</p><p>由于不同操作系统或各系统的不同版本可能会造成一些问题， 所以在此推荐使用的操作系统为64位的 Ubuntu 16.04 LTS。</p></li><li><p><strong>cURL是什么，有什么作用？</strong></p><p>cURL是一个可以终端命令行下使用URL语法执行的开源文件传输工具。cURL支持SSL证书，HTTP POST，HTTP PUT，FTP上传，基于HTTP表单的上传，代理，HTTP / 2，cookie，用户+密码认证（Basic，Plain，Digest，CRAM-MD5，NTLM，Negotiate和Kerberos），文件转移简历，代理隧道等。</p></li><li><p><strong>为什么要安装Docker及Docker-compose?</strong></p><p>Docker是一个开源的应用容器引擎， 可以为应用创建一个轻量级的、可移植的容器。</p><p>Fabric环境依赖于Docker提供的容器服务，所以必须安装Docker环境；推荐使用1.13或更高版本。</p><p>Compose是一个用于定义和运行多个容器的Docker应用程序的工具， 可以使用YAML文件配置相关的指定服务，运行该服务时，只需要一个简单的命令即可。</p></li><li><p><strong>能否不使用Golang而换作其它语言环境？</strong></p><p>Hyperledger Fabric中的很多组件使用Golang实现，并且我们会使用Golang来编写链式代码的应用程序， 所以需要在我们的系统中安装并设置Golang环境。</p></li><li><p><strong>一定要安装Node与npm吗？</strong></p><p>Node与npm工具为可选安装工具。如果后期使用Node.js的Hyperledger Fabric SDK开发Hyperledger Fabric的应用程序，则需要安装；否则无需安装。</p></li></ol><h3 id="第二步：安装Fabric"><a href="#第二步：安装Fabric" class="headerlink" title="第二步：安装Fabric"></a>第二步：安装Fabric</h3><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>顺利下载Hyperledger Fabric</li><li>明确bootstrap.sh脚本做了哪些事</li></ol><h3 id="1-下载Fabric-samples与二进制文件"><a href="#1-下载Fabric-samples与二进制文件" class="headerlink" title="1. 下载Fabric-samples与二进制文件"></a>1. 下载Fabric-samples与二进制文件</h3><p>为了方便后期管理，在当前登录用户的HOME目录下创建一个空目录并进入该目录我的home是/home/hg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir hyfa &amp;&amp; <span class="built_in">cd</span> hyfa</span></span><br></pre></td></tr></table></figure><p><strong>新建文件bootstrap.sh并添加内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo touch bootstrap.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim bootstrap.sh</span></span><br></pre></td></tr></table></figure><p>将 <code>https://github.com/hyperledger/fabric/blob/master/scripts/bootstrap.sh</code> 中的内容拷贝保存退出。这是最新v2.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright IBM Corp. All Rights Reserved.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: Apache-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if version not passed in, default to latest released version</span></span><br><span class="line">VERSION=2.0.0</span><br><span class="line"><span class="comment"># if ca version not passed in, default to latest released version</span></span><br><span class="line">CA_VERSION=1.4.6</span><br><span class="line"><span class="comment"># current version of thirdparty images (couchdb, kafka and zookeeper) released</span></span><br><span class="line">THIRDPARTY_IMAGE_VERSION=0.4.18</span><br><span class="line">ARCH=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$(uname -s|tr '[:upper:]' '[:lower:]'|sed 's/mingw64_nt.*/windows/')</span>-<span class="variable">$(uname -m | sed 's/x86_64/amd64/g')</span>"</span>)</span><br><span class="line">MARCH=$(uname -m)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">printHelp</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"options:"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"-h : this help"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"-d : bypass docker image download"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"-s : bypass fabric-samples repo clone"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"-b : bypass download of platform-specific binaries"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"e.g. bootstrap.sh 2.0.0 1.4.6 0.4.18 -s"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"would download docker images and binaries for Fabric v2.0.0 and Fabric CA v1.4.6"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dockerPull() pulls docker images from fabric and chaincode repositories</span></span><br><span class="line"><span class="comment"># note, if a docker image doesn't exist for a requested release, it will simply</span></span><br><span class="line"><span class="comment"># be skipped, since this script doesn't terminate upon errors.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dockerPull</span></span>() &#123;</span><br><span class="line">    <span class="comment">#three_digit_image_tag is passed in, e.g. "1.4.6"</span></span><br><span class="line">    three_digit_image_tag=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="comment">#two_digit_image_tag is derived, e.g. "1.4", especially useful as a local tag for two digit references to most recent baseos, ccenv, javaenv, nodeenv patch releases</span></span><br><span class="line">    two_digit_image_tag=$(<span class="built_in">echo</span> <span class="variable">$three_digit_image_tag</span> | cut -d<span class="string">'.'</span> -f1,2)</span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        image_name=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"====&gt; hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>"</span></span><br><span class="line">        docker pull <span class="string">"hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>"</span></span><br><span class="line">        docker tag <span class="string">"hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>"</span> <span class="string">"hyperledger/fabric-<span class="variable">$image_name</span>"</span></span><br><span class="line">        docker tag <span class="string">"hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$three_digit_image_tag</span>"</span> <span class="string">"hyperledger/fabric-<span class="variable">$image_name</span>:<span class="variable">$two_digit_image_tag</span>"</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">cloneSamplesRepo</span></span>() &#123;</span><br><span class="line">    <span class="comment"># clone (if needed) hyperledger/fabric-samples and checkout corresponding</span></span><br><span class="line">    <span class="comment"># version to the binaries and docker images to be downloaded</span></span><br><span class="line">    <span class="keyword">if</span> [ -d first-network ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if we are in the fabric-samples repo, checkout corresponding version</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Checking out v<span class="variable">$&#123;VERSION&#125;</span> of hyperledger/fabric-samples"</span></span><br><span class="line">        git checkout v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">elif</span> [ -d fabric-samples ]; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># if fabric-samples repo already cloned and in current directory,</span></span><br><span class="line">        <span class="comment"># cd fabric-samples and checkout corresponding version</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Checking out v<span class="variable">$&#123;VERSION&#125;</span> of hyperledger/fabric-samples"</span></span><br><span class="line">        <span class="built_in">cd</span> fabric-samples &amp;&amp; git checkout v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Cloning hyperledger/fabric-samples repo and checkout v<span class="variable">$&#123;VERSION&#125;</span>"</span></span><br><span class="line">        git <span class="built_in">clone</span> -b master https://github.com/hyperledger/fabric-samples.git &amp;&amp; <span class="built_in">cd</span> fabric-samples &amp;&amp; git checkout v<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will download the .tar.gz</span></span><br><span class="line"><span class="function"><span class="title">download</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> BINARY_FILE=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> URL=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"===&gt; Downloading: "</span> <span class="string">"<span class="variable">$&#123;URL&#125;</span>"</span></span><br><span class="line">    curl -L --retry 5 --retry-delay 3 <span class="string">"<span class="variable">$&#123;URL&#125;</span>"</span> | tar xz || rc=$?</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$rc</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"==&gt; There was an error downloading the binary file."</span></span><br><span class="line">        <span class="built_in">return</span> 22</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"==&gt; Done."</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullBinaries</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"===&gt; Downloading version <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binaries"</span></span><br><span class="line">    download <span class="string">"<span class="variable">$&#123;BINARY_FILE&#125;</span>"</span> <span class="string">"https://github.com/hyperledger/fabric/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/<span class="variable">$&#123;BINARY_FILE&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"------&gt; <span class="variable">$&#123;FABRIC_TAG&#125;</span> platform specific fabric binary is not available to download &lt;----"</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"===&gt; Downloading version <span class="variable">$&#123;CA_TAG&#125;</span> platform specific fabric-ca-client binary"</span></span><br><span class="line">    download <span class="string">"<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>"</span> <span class="string">"https://github.com/hyperledger/fabric-ca/releases/download/v<span class="variable">$&#123;CA_VERSION&#125;</span>/<span class="variable">$&#123;CA_BINARY_FILE&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 22 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"------&gt; <span class="variable">$&#123;CA_TAG&#125;</span> fabric-ca-client binary is not available to download  (Available from 1.1.0-rc1) &lt;----"</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">pullDockerImages</span></span>() &#123;</span><br><span class="line">    <span class="built_in">command</span> -v docker &gt;&amp; /dev/null</span><br><span class="line">    NODOCKER=$?</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;NODOCKER&#125;</span>"</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        FABRIC_IMAGES=(peer orderer ccenv tools)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$VERSION</span>"</span> <span class="keyword">in</span></span><br><span class="line">        1.*)</span><br><span class="line">            FABRIC_IMAGES+=(javaenv)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        2.*)</span><br><span class="line">            FABRIC_IMAGES+=(nodeenv baseos javaenv)</span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"FABRIC_IMAGES:"</span> <span class="string">"<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Pulling fabric Images"</span></span><br><span class="line">        dockerPull <span class="string">"<span class="variable">$&#123;FABRIC_TAG&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;FABRIC_IMAGES[@]&#125;</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Pulling fabric ca Image"</span></span><br><span class="line">        CA_IMAGE=(ca)</span><br><span class="line">        dockerPull <span class="string">"<span class="variable">$&#123;CA_TAG&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;CA_IMAGE[@]&#125;</span>"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; Pulling thirdparty docker images"</span></span><br><span class="line">        THIRDPARTY_IMAGES=(zookeeper kafka couchdb)</span><br><span class="line">        dockerPull <span class="string">"<span class="variable">$&#123;THIRDPARTY_TAG&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;THIRDPARTY_IMAGES[@]&#125;</span>"</span></span><br><span class="line">        <span class="built_in">echo</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"===&gt; List out hyperledger docker images"</span></span><br><span class="line">        docker images | grep hyperledger</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"========================================================="</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Docker not installed, bypassing download of Fabric images"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"========================================================="</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOCKER=<span class="literal">true</span></span><br><span class="line">SAMPLES=<span class="literal">true</span></span><br><span class="line">BINARIES=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse commandline args pull out</span></span><br><span class="line"><span class="comment"># version and/or ca-version strings first</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;1:0:1&#125;</span>"</span> != <span class="string">"-"</span> ]; <span class="keyword">then</span></span><br><span class="line">    VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]  &amp;&amp; [ <span class="string">"<span class="variable">$&#123;1:0:1&#125;</span>"</span> != <span class="string">"-"</span> ]; <span class="keyword">then</span></span><br><span class="line">        CA_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">if</span> [ -n  <span class="string">"<span class="variable">$1</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;1:0:1&#125;</span>"</span> != <span class="string">"-"</span> ]; <span class="keyword">then</span></span><br><span class="line">            THIRDPARTY_IMAGE_VERSION=<span class="variable">$1</span>;<span class="built_in">shift</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># prior to 1.2.0 architecture was determined by uname -m</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$VERSION</span> =~ ^1\.[0-1]\.* ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> FABRIC_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> CA_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span></span><br><span class="line">    <span class="built_in">export</span> THIRDPARTY_TAG=<span class="variable">$&#123;MARCH&#125;</span>-<span class="variable">$&#123;THIRDPARTY_IMAGE_VERSION&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># starting with 1.2.0, multi-arch images will be default</span></span><br><span class="line">    : <span class="string">"<span class="variable">$&#123;CA_TAG:="$CA_VERSION"&#125;</span>"</span></span><br><span class="line">    : <span class="string">"<span class="variable">$&#123;FABRIC_TAG:="$VERSION"&#125;</span>"</span></span><br><span class="line">    : <span class="string">"<span class="variable">$&#123;THIRDPARTY_TAG:="$THIRDPARTY_IMAGE_VERSION"&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">BINARY_FILE=hyperledger-fabric-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;VERSION&#125;</span>.tar.gz</span><br><span class="line">CA_BINARY_FILE=hyperledger-fabric-ca-<span class="variable">$&#123;ARCH&#125;</span>-<span class="variable">$&#123;CA_VERSION&#125;</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># then parse opts</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">"h?dsb"</span> opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"<span class="variable">$opt</span>"</span> <span class="keyword">in</span></span><br><span class="line">        h|\?)</span><br><span class="line">            printHelp</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d)  DOCKER=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        s)  SAMPLES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">        b)  BINARIES=<span class="literal">false</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SAMPLES</span>"</span> == <span class="string">"true"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Clone hyperledger/fabric-samples repo"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    cloneSamplesRepo</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$BINARIES</span>"</span> == <span class="string">"true"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Pull Hyperledger Fabric binaries"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullBinaries</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$DOCKER</span>"</span> == <span class="string">"true"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Pull Hyperledger Fabric docker images"</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    pullDockerImages</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>该 <code>bootstrap.sh</code> 可执行脚本文件的作用：</p><ol><li>如果在当前目录中没有 <code>hyperledger/fabric-samples</code>，则从 <code>github.com</code> 克隆 <code>hyperledger/fabric-samples</code> 存储库</li><li>使用 <code>checkout</code> 签出对应指定的版本标签</li><li>将指定版本的Hyperledger Fabric平台特定的二进制文件和配置文件安装到 <code>fabric-samples</code> 存储库的根目录中</li><li>下载指定版本的 <code>Hyperledger Fabric docker</code> 镜像文件</li><li>将下载的 docker 镜像文件标记为 “latest”</li></ol><p><strong>赋予bootstrap.sh可执行权限并运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x bootstrap.sh</span></span><br></pre></td></tr></table></figure><p><strong>执行<code>bootstrap.sh 指定版本</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./bootstrap.sh 1.2.0</span></span><br></pre></td></tr></table></figure><blockquote><p>确定网络稳定，否则会导致各种问题，例如下载到一半时网络超时，下载失败等等；由于Docker的各种镜像文件下载时间较长，所以请耐心等待。</p></blockquote><p>下载完成后，查看相关输出内容；如果下载有失败的镜像, 可再次执行 <code>$ sudo ./bootstrap.sh 1.2.0</code> 命令重新下载。</p><blockquote><p>重新执行脚本命令对于已下载的Docker镜像文件不会再次重新下载。</p></blockquote><p>安装完成后终端自动输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">===&gt;</span> <span class="string">List</span> <span class="string">out</span> <span class="string">hyperledger</span> <span class="string">docker</span> <span class="string">images</span></span><br><span class="line"><span class="string">hyperledger/fabric-ca</span>          <span class="number">1.2</span><span class="number">.0</span>       <span class="string">66cc132bd09c</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">252</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-ca</span>          <span class="string">latest</span>      <span class="string">66cc132bd09c</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">252</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-tools</span>       <span class="number">1.2</span><span class="number">.0</span>       <span class="number">379602873003</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.51</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-tools</span>       <span class="string">latest</span>      <span class="number">379602873003</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.51</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-ccenv</span>       <span class="number">1.2</span><span class="number">.0</span>       <span class="string">6acf31e2d9a4</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.43</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-ccenv</span>       <span class="string">latest</span>      <span class="string">6acf31e2d9a4</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.43</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-orderer</span>     <span class="number">1.2</span><span class="number">.0</span>       <span class="string">4baf7789a8ec</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">152</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-orderer</span>     <span class="string">latest</span>      <span class="string">4baf7789a8ec</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">152</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-peer</span>        <span class="number">1.2</span><span class="number">.0</span>       <span class="string">82c262e65984</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">159</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-peer</span>        <span class="string">latest</span>      <span class="string">82c262e65984</span>    <span class="number">4</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">159</span> <span class="string">MB</span></span><br><span class="line"><span class="string">hyperledger/fabric-zookeeper</span>   <span class="number">0.4</span><span class="number">.10</span>      <span class="string">2b51158f3898</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.44</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-zookeeper</span>   <span class="string">latest</span>      <span class="string">2b51158f3898</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.44</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-kafka</span>       <span class="number">0.4</span><span class="number">.10</span>      <span class="string">936aef6db0e6</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.45</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-kafka</span>       <span class="string">latest</span>      <span class="string">936aef6db0e6</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.45</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-couchdb</span>     <span class="number">0.4</span><span class="number">.10</span>      <span class="string">3092eca241fc</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.61</span> <span class="string">GB</span></span><br><span class="line"><span class="string">hyperledger/fabric-couchdb</span>     <span class="string">latest</span>      <span class="string">3092eca241fc</span>    <span class="number">5</span> <span class="string">weeks</span> <span class="string">ago</span>     <span class="number">1.61</span> <span class="string">GB</span></span><br></pre></td></tr></table></figure><p><strong>添加环境变量（可选执行命令）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=&lt;path to download location&gt;/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><blockquote><p>表示 <code>fabric-samples</code> 文件目录所在路径</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例:  $ export PATH=$HOME/hyfa/fabric-samples/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="2-Fabric源码方式编译"><a href="#2-Fabric源码方式编译" class="headerlink" title="2 Fabric源码方式编译"></a>2 Fabric源码方式编译</h3><p>上一小节中，我们以提供脚本的方式，可以下载并安装 samples 和二进制文件到操作系统中，大大简化的安装过程。</p><p>Hyperledger Fabric 还有另外的一种安装方式，就是以源代码的方式进行本地编译安装，此方式相较上一小节的方式，略微复杂，需要手动编译生成相应的工具，我们在此给大家逐一介绍</p><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>首先，使用 <code>mkdir</code> 命令创建相应的目录，然后使用 <code>git clone</code> 命令将 <code>Hyperledger Fabric</code> 源代码克隆至该目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$GOPATH</span>/src/github.com/hyperledger/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/hyperledger/fabric.git</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：也可以使用 <code>go get</code> 命令下载源码，需要手动创建相应的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/hyperledger/fabric</span></span><br></pre></td></tr></table></figure><p>注：下载时间可能需要几分钟，也可能需要十几分钟，取决于当前的网络环境，请耐心等待。</p></blockquote><p>然后使用 <code>git checkout</code> 命令切换至指定的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b v1.2.0</span></span><br></pre></td></tr></table></figure><p>源码下载完成之后，并不能直接使用，我们需要对其进行编译，生成所需要的各种节点及相应的工具。我们直接使用源码中提供的 <code>Makefile</code> 来进行编译，首先对 <code>Makefile</code> 文件进行编辑，指定相应的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim Makefile</span></span><br></pre></td></tr></table></figure><p>将文件中 <code>BASE_VERSION、PREV_VERSION、CHAINTOOL_RELEASE、BASEIMAGE_RELEASE</code> 的值进行修改，修改之后的内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASE_VERSION = 1.2.1</span><br><span class="line">PREV_VERSION = 1.2.0</span><br><span class="line">CHAINTOOL_RELEASE=1.1.1</span><br><span class="line">BASEIMAGE_RELEASE=0.4.10</span><br></pre></td></tr></table></figure><h4 id="编译Orderer"><a href="#编译Orderer" class="headerlink" title="编译Orderer"></a>编译Orderer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make orderer</span></span><br></pre></td></tr></table></figure><p>命令执行后终端输出如下：</p><p><img src="http://image.chaindesk.cn/makeorderer.png/mark" alt="make_orderer"></p><h4 id="编译Peer"><a href="#编译Peer" class="headerlink" title="编译Peer"></a>编译Peer</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo make peer</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/makepeer.png/mark" alt="make_peer"></p><p>查看 <code>.build/bin</code> 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build/bin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/buildbindir.png/mark" alt="buildbindir"></p><h3 id="编译生成相关工具"><a href="#编译生成相关工具" class="headerlink" title="编译生成相关工具"></a>编译生成相关工具</h3><p><code>Hyperledger Fabric</code> 除了 <code>Orderer</code> 和 <code>Peer</code> 之外，还为我们提供了在搭建网络环境时所需要的一系列辅助工具：</p><ul><li><strong>configtxgen：</strong>生成初始区块及通道交易配置文件的工具</li><li><strong>cryptogen：</strong>生成组织结构及相应的的身份文件的工具</li><li><strong>configtxlator：</strong>将指定的文件在二进制格式与JSON格式之间进行转换</li></ul><p>编译生成这些工具同样使用 <code>make</code> 即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo make configtxgen </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make cryptogen </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sduo make configtxlator</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/maketools.png/mark" alt="make_tools"></p><h4 id="编译生成-docker-镜像"><a href="#编译生成-docker-镜像" class="headerlink" title="编译生成 docker 镜像"></a>编译生成 docker 镜像</h4><p>将当前用户添加到 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker hg  //hg使用户名</span></span><br></pre></td></tr></table></figure><p>添加成功后注销或重启系统。</p><p>安装依赖的 <code>libltdl-dev</code> 库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libltdl-dev</span></span><br></pre></td></tr></table></figure><p>获取镜像方式有两种我用的第二种</p><p><strong>获取镜像方式一：</strong></p><p>编译生成docker镜像需要使用到Go的工具，所以我们需要通过 <code>git clone</code> 命令从 <code>github.com</code> 克隆至当前系统中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$GOPATH</span>/src/golang.org/x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/golang/tools.git</span></span><br></pre></td></tr></table></figure><p>执行命令后将指定的环境变量设置到用户的环境文件中(.bashrc)中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.bashrc</span></span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>Fabric代码由Golang 构建，所以需要安装Go相关的工具，以方便开发和调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p <span class="variable">$GOPATH</span>/src/golang.org/x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/golang.org/x</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/golang/net.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/golang/tools.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/kardianos/govendor</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/onsi/ginkgo/ginkgo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/golang/protobuf/protoc-gen-go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/axw/gocov/...</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/AlekSi/gocov-xml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/client9/misspell/cmd/misspell</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u golang.org/x/tools/cmd/goimports</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go get -u github.com/golang/lint/golint</span></span><br></pre></td></tr></table></figure><p>将之前安装的 Go工具复制到Fabric目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p .build/docker/gotools/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp ~/go/bin/* .build/docker/gotools/bin</span></span><br></pre></td></tr></table></figure><p>使用 <code>make docker</code> 编译生成相关的 <code>docker</code> 镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make docker</span></span><br></pre></td></tr></table></figure><p><strong>获取镜像方式二：</strong></p><p>可以直接从Dockerhub拉取镜像，使用 <code>docker pull</code> 命令拉取指定的 docker 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> FABRIC_TAG=1.2.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CA_TAG=1.2.0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> THIRDPARTY_IMAGE_VERSION=0.4.10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull hyperledger/fabric-peer:<span class="variable">$FABRIC_TAG</span> \</span></span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-orderer:$FABRIC_TAG \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-ca:$CA_TAG \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-tools:$FABRIC_TAG \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-ccenv:$FABRIC_TAG \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-baseimage:$THIRDPARTY_IMAGE_VERSION \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-baseos:$THIRDPARTY_IMAGE_VERSION \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-couchdb:$THIRDPARTY_IMAGE_VERSION \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-kafka:$THIRDPARTY_IMAGE_VERSION \</span><br><span class="line">&amp;&amp; docker pull hyperledger/fabric-zookeeper:$THIRDPARTY_IMAGE_VERSION</span><br></pre></td></tr></table></figure><p>将已下载的镜像标记为最新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker tag hyperledger/fabric-peer:<span class="variable">$FABRIC_TAG</span> hyperledger/fabric-peer \</span></span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-orderer:$FABRIC_TAG hyperledger/fabric-orderer \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-ca:$CA_TAG hyperledger/fabric-ca \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-tools:$FABRIC_TAG hyperledger/fabric-tools \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-ccenv:$FABRIC_TAG hyperledger/fabric-ccenv \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-baseimage:$THIRDPARTY_IMAGE_VERSION hyperledger/fabric-baseimage \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-baseos:$THIRDPARTY_IMAGE_VERSION hyperledger/fabric-baseos \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-couchdb:$THIRDPARTY_IMAGE_VERSION hyperledger/fabric-couchdb \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-kafka:$THIRDPARTY_IMAGE_VERSION hyperledger/fabric-kafka \</span><br><span class="line">&amp;&amp; docker tag hyperledger/fabric-zookeeper:$THIRDPARTY_IMAGE_VERSION hyperledger/fabric-zookeeper</span><br></pre></td></tr></table></figure><p>之后使用 <code>docker images</code> 命令查看相关的镜像信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br></pre></td></tr></table></figure><p><img src="http://image.chaindesk.cn/docker-tag.png/mark" alt="dockertag"></p><blockquote><p>Hyperledger Fabric 可以有两种方式进行编译安装，第一种方式（bootstrap.sh脚本方式）进行环境的安装，优点是简单、方便，能够快速上手；第二种方式以 Fabric 源码方式进行编译，适合动手能力较强的人员，优点是可以对 Hyperledger Fabric 相关组件有深入的理解，但缺点是容易出现各种错误且修正比较麻烦。</p><p>注：本书的 Hyperledger Fabric 环境为方便起见，所以采用第一种方式（bootstrap.sh脚本方式）进行的安装构建。</p></blockquote><h2 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li><p><strong>bootstrap.sh脚本中的内容是干什么用的？</strong></p><p>脚本执行后将下载并提取设置网络所需的所有特定于平台的二进制文件，并保存在本地仓库中，</p><p>然后将Docker Hub中的Hyperledger Fabric docker镜像下载到本地Docker注册表中，并将其标记为”最新”。</p></li><li><p><strong>下载Docker镜像文件速度特别慢，有什么好的解决方式？</strong></p><p>可在 <code>https://www.daocloud.io/</code> 网站中注册一个账号, 注册成功后， 可以点击加速器图标（如下图所示）以获取Docker加速器。</p><p><img src="http://image.chaindesk.cn/1.3.jpg/mark" alt="Docker加速器图标"></p><p><strong>配置Docker加速器</strong></p><p>在命令提示符中输入如下图所示的daocloud.io分配的加速器脚本命令（将输入框中的脚本命令复制到命令提示符窗口中执行即可）， 执行完脚本之后， 不要忘记重启Docker服务</p><p><img src="http://image.chaindesk.cn/1.4.jpg/mark" alt="Docker加速器脚本命令"></p><p><strong>重启Docker服务</strong></p><p>执行完该命令后，必须重启Docker服务以生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart docker.service</span></span><br></pre></td></tr></table></figure></li><li><p><strong>下载完成后，添加的环境变量有什么意义？</strong></p><p>执行该命令后，意义为在系统中任何路径下使用Fabric相关的命令都可以让系统能够找到该命令并且顺利执行。后期我们会进入到Fabric目录中执行相应的命令，所以该环境变量也可以不添加。</p></li></ol><h2 id="第三步：测试Fabric网络环境"><a href="#第三步：测试Fabric网络环境" class="headerlink" title="第三步：测试Fabric网络环境"></a>第三步：测试Fabric网络环境</h2><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ol><li><p>熟悉 byfn.sh 脚本的相关命令</p></li><li><p>能够自动实现你的第一个Fabric网络环境</p><h2 id="任务实现"><a href="#任务实现" class="headerlink" title="任务实现"></a>任务实现</h2><p><code>Hyperledger Fabric</code> 网络环境的构成较为复杂，由N个节点组成一个分布式网络，每个节点都有自己的实体身份标识；而且 <code>Hyperledger Fabric</code> 还可以通过 <code>channel（通道）</code> 将一个网络分割成为不同的私有子网，从而实现不同账本数据的隔离性。所以，我们在使用 <code>Hyperledger Fabric</code> 之前，必须先搭建所需的网络环境。</p><p>搭建 <code>Hyperledger Fabric</code> 网络环境可以有两种方式实现：</p></li><li><p>使用自动化脚本实现</p><p>使用一个名为自动化脚本 <code>byfn.sh</code> 的脚本文件自动构建一个简易的 <code>Hyperledger Fabric</code> 网络环境并引导启动，且自动生成相应的一些配置文件，一般作为测试环境使用，本节内容主要就是讲解此方式。</p></li><li><p>手动实现</p><p>为了适应不同的且较为复杂的场景，自动化脚本方式就有些力不从心，这时，必须由开发/运维人员根据不同的情况，手动输入相关命令构建一个相当复杂的网络环境。此种实现方式参见第三章的相关内容。</p><h3 id="1-测试Fabric环境"><a href="#1-测试Fabric环境" class="headerlink" title="1. 测试Fabric环境"></a>1. 测试Fabric环境</h3><h4 id="1-1-byfn-sh都有哪些命令"><a href="#1-1-byfn-sh都有哪些命令" class="headerlink" title="1.1 byfn.sh都有哪些命令"></a>1.1 byfn.sh都有哪些命令</h4><p>进入fabric-samples目录中的 first-networkd 子目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> fabric-samples/first-network</span></span><br></pre></td></tr></table></figure><p>在<code>first-network</code>目录下有一个自动化脚本 <code>byfn.sh</code>，可以查看相应命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./byfn.sh --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure><p>部分输出内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">up：启动</span><br><span class="line">down：清除网络</span><br><span class="line">restart：重新启动</span><br><span class="line">generate：生成证书及创世区块</span><br><span class="line">upgrade：将网络从1.1.x升级到1.2.x</span><br><span class="line"></span><br><span class="line">-c：用于指定channelName，默认值"mychannel"</span><br><span class="line">-t：CLI timeout时间，默认值10</span><br><span class="line">-d：延迟启动，默认值3</span><br><span class="line">-f：使用指定的网络拓扑结构文件，默认使用docker-compose-cli.yaml</span><br><span class="line">-s：指定使用的数据库，可选 goleveldb/couchdb</span><br><span class="line">-l：指定chaincode使用的语言，可选golang/node</span><br><span class="line">-i：指定镜像tag，默认 "latest"</span><br><span class="line">详细参数可通过./byfn.sh help查看</span><br></pre></td></tr></table></figure><h3 id="2-构建你的第一个Fabric网络"><a href="#2-构建你的第一个Fabric网络" class="headerlink" title="2 构建你的第一个Fabric网络"></a>2 构建你的第一个Fabric网络</h3><h4 id="2-1-生成证书和密钥"><a href="#2-1-生成证书和密钥" class="headerlink" title="2.1 生成证书和密钥"></a>2.1 生成证书和密钥</h4><p><code>byfn.sh</code> 自动化脚本文件为各种 <code>fabric</code> 网络实体生成所有证书和密钥，并且可以实现引导服务启动及配置通道所需的一系列配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./byfn.sh -m generate</span></span><br></pre></td></tr></table></figure><p>命令成功执行后会生成1个orderer + 4个peer + 1个CLI的网络结构，4个peer包含在2个org中。</p><p>在提示中输入 <code>y</code>，之后 终端输出日志内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Generating certs and genesis block for channel 'mychannel' with CLI timeout of '10' seconds and CLI delay of '3' seconds</span><br><span class="line">Continue? [Y/n] y</span><br><span class="line">proceeding ...</span><br><span class="line">/home/kevin/hyfa/fabric-samples/first-network/../bin/cryptogen</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### Generate certificates using cryptogen tool #########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################################</span></span></span><br><span class="line">+ cryptogen generate --config=./crypto-config.yaml</span><br><span class="line">org1.example.com</span><br><span class="line">org2.example.com</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line"></span><br><span class="line">/home/kevin/hyfa/fabric-samples/first-network/../bin/configtxgen</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">########  Generating Orderer Genesis block ##############</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################################</span></span></span><br><span class="line">+ configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block</span><br><span class="line">2018-08-28 10:33:52.689 CST [common/tools/configtxgen] main -&gt; WARN 001 Omitting the channel ID for configtxgen is deprecated.  Explicitly passing the channel ID will be required in the future, defaulting to 'testchainid'.</span><br><span class="line">2018-08-28 10:33:52.691 CST [common/tools/configtxgen] main -&gt; INFO 002 Loading configuration</span><br><span class="line">2018-08-28 10:33:52.700 CST [common/tools/configtxgen/encoder] NewChannelGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the channel group in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.700 CST [common/tools/configtxgen/encoder] NewOrdererGroup -&gt; WARN 004 Default policy emission is deprecated, please include policy specificiations for the orderer group in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.701 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the orderer org group OrdererOrg in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.702 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">2018-08-28 10:33:52.703 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org1MSP in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.703 CST [msp] getMspConfig -&gt; INFO 008 Loading NodeOUs</span><br><span class="line">2018-08-28 10:33:52.703 CST [common/tools/configtxgen/encoder] NewOrdererOrgGroup -&gt; WARN 009 Default policy emission is deprecated, please include policy specificiations for the orderer org group Org2MSP in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.704 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00a Generating genesis block</span><br><span class="line">2018-08-28 10:33:52.720 CST [common/tools/configtxgen] doOutputBlock -&gt; INFO 00b Writing genesis block</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Generating channel configuration transaction 'channel.tx' ###</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line">+ configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel</span><br><span class="line">2018-08-28 10:33:52.754 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2018-08-28 10:33:52.762 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx</span><br><span class="line">2018-08-28 10:33:52.763 CST [common/tools/configtxgen/encoder] NewApplicationGroup -&gt; WARN 003 Default policy emission is deprecated, please include policy specificiations for the application group in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.763 CST [msp] getMspConfig -&gt; INFO 004 Loading NodeOUs</span><br><span class="line">2018-08-28 10:33:52.764 CST [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 005 Default policy emission is deprecated, please include policy specificiations for the application org group Org1MSP in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.764 CST [msp] getMspConfig -&gt; INFO 006 Loading NodeOUs</span><br><span class="line">2018-08-28 10:33:52.765 CST [common/tools/configtxgen/encoder] NewApplicationOrgGroup -&gt; WARN 007 Default policy emission is deprecated, please include policy specificiations for the application org group Org2MSP in configtx.yaml</span><br><span class="line">2018-08-28 10:33:52.768 CST [common/tools/configtxgen] doOutputChannelCreateTx -&gt; INFO 008 Writing new channel tx</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######    Generating anchor peer update for Org1MSP   ##########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line">+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</span><br><span class="line">2018-08-28 10:33:52.801 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2018-08-28 10:33:52.813 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update</span><br><span class="line">2018-08-28 10:33:52.815 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######    Generating anchor peer update for Org2MSP   ##########</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################################################</span></span></span><br><span class="line">+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</span><br><span class="line">2018-08-28 10:33:52.852 CST [common/tools/configtxgen] main -&gt; INFO 001 Loading configuration</span><br><span class="line">2018-08-28 10:33:52.864 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update</span><br><span class="line">2018-08-28 10:33:52.865 CST [common/tools/configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br></pre></td></tr></table></figure><h4 id="2-2-启动网络"><a href="#2-2-启动网络" class="headerlink" title="2.2 启动网络"></a>2.2 启动网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./byfn.sh -m up</span></span><br></pre></td></tr></table></figure><p>在提示符中输入 <code>y</code>，最后输出如下内容代表启动且测试成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Starting for channel 'mychannel' with CLI timeout of '10' seconds and CLI delay of '3' seconds</span><br><span class="line">Continue? [Y/n] y</span><br><span class="line">proceeding ...</span><br><span class="line">LOCAL_VERSION=1.2.0</span><br><span class="line">DOCKER_IMAGE_VERSION=1.2.0</span><br><span class="line">Creating network "net_byfn" with the default driver</span><br><span class="line">Creating volume "net_peer0.org2.example.com" with default driver</span><br><span class="line">Creating volume "net_peer1.org2.example.com" with default driver</span><br><span class="line">Creating volume "net_peer1.org1.example.com" with default driver</span><br><span class="line">Creating volume "net_peer0.org1.example.com" with default driver</span><br><span class="line">Creating volume "net_orderer.example.com" with default driver</span><br><span class="line">Creating peer0.org2.example.com</span><br><span class="line">Creating peer0.org1.example.com</span><br><span class="line">Creating peer1.org2.example.com</span><br><span class="line">Creating orderer.example.com</span><br><span class="line">Creating peer1.org1.example.com</span><br><span class="line">Creating cli</span><br><span class="line"></span><br><span class="line"> ____    _____      _      ____    _____ </span><br><span class="line">/ ___|  |_   _|    / \    |  _ \  |_   _|</span><br><span class="line">\___ \    | |     / _ \   | |_) |   | |  </span><br><span class="line"> ___) |   | |    / ___ \  |  _ &lt;    | |  </span><br><span class="line">|____/    |_|   /_/   \_\ |_| \_\   |_|  </span><br><span class="line"></span><br><span class="line">Build your first network (BYFN) end-to-end test</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">===================== Query successful on peer1.org2 on channel 'mychannel' ===================== </span><br><span class="line"></span><br><span class="line">========= All GOOD, BYFN execution completed =========== </span><br><span class="line"></span><br><span class="line"> _____   _   _   ____   </span><br><span class="line">| ____| | \ | | |  _ \  </span><br><span class="line">|  _|   |  \| | | | | | </span><br><span class="line">| |___  | |\  | | |_| | </span><br><span class="line">|_____| |_| \_| |____/</span><br></pre></td></tr></table></figure><h4 id="2-3-关闭网络"><a href="#2-3-关闭网络" class="headerlink" title="2.3 关闭网络"></a>2.3 关闭网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./byfn.sh -m down</span></span><br></pre></td></tr></table></figure><p>在提示符中输入 <code>y</code>， 命令执行后终端输出如下日志内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Stopping for channel 'mychannel' with CLI timeout of '10' seconds and CLI delay of '3' seconds</span><br><span class="line">Continue? [Y/n] y</span><br><span class="line">proceeding ...</span><br><span class="line">Stopping cli ... done</span><br><span class="line">Stopping peer1.org1.example.com ... done</span><br><span class="line">Stopping peer1.org2.example.com ... done</span><br><span class="line">Stopping orderer.example.com ... done</span><br><span class="line">Stopping peer0.org1.example.com ... done</span><br><span class="line">Stopping peer0.org2.example.com ... done</span><br><span class="line">Removing cli ... done</span><br><span class="line">Removing peer1.org1.example.com ... done</span><br><span class="line">Removing peer1.org2.example.com ... done</span><br><span class="line">Removing orderer.example.com ... done</span><br><span class="line">Removing peer0.org1.example.com ... done</span><br><span class="line">Removing peer0.org2.example.com ... done</span><br><span class="line">Removing network net_byfn</span><br><span class="line">Removing volume net_peer0.org3.example.com</span><br><span class="line">WARNING: Volume net_peer0.org3.example.com not found.</span><br><span class="line">Removing volume net_peer1.org3.example.com</span><br><span class="line">WARNING: Volume net_peer1.org3.example.com not found.</span><br><span class="line">Removing volume net_orderer.example.com</span><br><span class="line">Removing volume net_peer0.org2.example.com</span><br><span class="line">Removing volume net_peer0.org1.example.com</span><br><span class="line">Removing volume net_peer1.org1.example.com</span><br><span class="line">Removing volume net_peer1.org2.example.com</span><br><span class="line">7fb4e7907b3c</span><br><span class="line">708576aff44f</span><br><span class="line">0a8805ff393d</span><br><span class="line">Untagged: dev-peer1.org2.example.com-mycc-1.0-26c2ef32838554aac4f7ad6f100aca865e87959c9a126e86d764c8d01f8346ab:latest</span><br><span class="line">Deleted: sha256:687d517a67c1b236724deb84c50e310fb87f39341de5c66857e3049222a99504</span><br><span class="line">Deleted: sha256:6d8c7e0948accd5bc445134533008f6f34946a49f880088a7cf3db1882412448</span><br><span class="line">Deleted: sha256:e37dd3859185b936bbed2206a865785dddc0cfad1de53fe11ae6a462edd39073</span><br><span class="line">Deleted: sha256:9a71f7af36db323a66ef9fb259d5b91ed36b272fcbab3d1b8c535d2b3c605862</span><br><span class="line">Untagged: dev-peer0.org1.example.com-mycc-1.0-384f11f484b9302df90b453200cfb25174305fce8f53f4e94d45ee3b6cab0ce9:latest</span><br><span class="line">Deleted: sha256:8d42a6a8edc43269d12833eced7dc7a5c3ab4fa93f42d9fe478f5d71059ee93f</span><br><span class="line">Deleted: sha256:044f5beb69724fc61c0a2320deaa63a60f61e253057e16d55f37716467045ea3</span><br><span class="line">Deleted: sha256:63ba54da2202bc9e96002b45b0a2be7978c2063dcb160cdfddf6cbac36d9ad34</span><br><span class="line">Deleted: sha256:c2136be4ddeccb607ca5e5ac54eb6fcd0c568f402cd37a66e459389c3ff41c5f</span><br><span class="line">Untagged: dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b:latest</span><br><span class="line">Deleted: sha256:828c1b18f7e8e811f7b06adab1bdf2f6c33bfc7cc49cfe38b9281293f917d7da</span><br><span class="line">Deleted: sha256:bb7469d1a150118cc475568fe11325a6e53a0fc5d61db54ec50b3efbd44d5eeb</span><br><span class="line">Deleted: sha256:4609bc59481cb8c10dee0bd85c48f3e1c36bd897f5176cf35d43860beda5acd7</span><br><span class="line">Deleted: sha256:be2477e444d06842e81fb691e4e94f7ed4a547aeb8ba4a963660356a915b61c7</span><br></pre></td></tr></table></figure><p>关闭网络之后， 将杀死容器，删除加密文件，并从Docker Registry中删除链码图像。</p><blockquote><p>请在网络不再使用时，务必关闭网络，以防止后期启动网络时造成的错误。</p></blockquote><h2 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h2></li><li><p><strong>如果启动网络失败怎么办？</strong></p><p>如果启动网络时发生错误，则执行关闭命令后重新生成组织结构及证书，然后再次执行启动网络的命令。</p></li></ol><p>转载：<a href="https://www.chaindesk.cn/witbook/11/99" target="_blank" rel="noopener">https://www.chaindesk.cn/witbook/11/99</a></p>]]></content>
      
      
      <categories>
          
          <category> Hyperledger Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09椭圆曲线密码学简介</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/09%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/09%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="椭圆曲线密码学简介"><a href="#椭圆曲线密码学简介" class="headerlink" title="椭圆曲线密码学简介"></a>椭圆曲线密码学简介</h1><p>这一节要聊的是 ECC （ Elliptic Curve Cryptography ），也就是椭圆曲线密码学。跟 RSA 一样，ECC 也属于公开密钥加密，<strong>ECC 算法也是用来生成公钥的私钥的</strong>。本节我们不会深入椭圆曲线算法本身，只是对 ECC 做一下简介。</p><a id="more"></a><h2 id="ECC-的作用"><a href="#ECC-的作用" class="headerlink" title="ECC 的作用"></a>ECC 的作用</h2><p>ECC 跟 RSA 算法一样，都可以生成公钥和私钥，然后进行加密通信和数字签名操作。ECC 在区块链领域有着特殊的地位。<strong>因为比特币就是用 ECC 来生成地址和私钥的</strong>。注意，比特币地址不是原封不动的公钥，而是公钥的一种转换形式。著名的以太坊项目，也使用了 ECC 。既然区块链领域的两个老大都会用到 ECC ，其他的公链项目中当然也都非常可能用到。HTTPS 也会用到 ECC 。现代的浏览器也都支持基于椭圆曲线密钥对的认证证书。</p><p>总之，ECC 应用范围很广，有人说”ECC是下一代的公开密钥加密算法”，似乎有取代 RSA 的意味。</p><h2 id="对比-RSA-的改进"><a href="#对比-RSA-的改进" class="headerlink" title="对比 RSA 的改进"></a>对比 RSA 的改进</h2><p>我们知道 RSA 是公钥密码学的鼻祖，那么后来者 ECC 到底有何改进呢？其实简单来说就是两个字“<strong>性能</strong>”。</p><p>我们先说 RSA 的不足。RSA 基于整数分解问题，我们可以相信只要两个大素数的乘积的反向求解问题没有解决，RSA 算法就是安全的，所以 RSA 可以说是非常简单的密码学。但是 RSA 的性能是短板，需要设置很长的秘钥，才能保证算法的安全。而<strong>秘钥越长，运算效率就越低</strong>。一个很尴尬的情况是，我们的超级计算机越来越厉害，所以就要求 RSA 的秘钥要越来越长。但是矛盾的是，移动设备又很流行，这就要求秘钥不能太长，不然在资源有限的移动设备上 RSA 算法就不能用了。这个矛盾越来越尖锐，所以更高效的算法就呼声很高。</p><p>ECC 算法从 2004 年开始才被广泛应用，要比 RSA 要晚很多，它的关键改进就是性能。同样的秘钥长度下，ECC 要安全很多。ECC 和 RSA 基于的都是正向运算很容易，反向运算很难的单向函数来设计的。运算越难，也就是意味着破解它运算所耗费的能源越多，或者说对应的碳排放量越多。比如给定一个228字节长度 RSA 秘钥，破解需要花费煮沸一勺水的能量。而同样长度的 ECC 秘钥，需要煮沸整个地球上所有水的能量。</p><p>可见，ECC 作为后来出现的算法要比 RSA 高效很多。</p><h2 id="ECC-的缺陷"><a href="#ECC-的缺陷" class="headerlink" title="ECC 的缺陷"></a>ECC 的缺陷</h2><p>但是，ECC 虽好也不是没有问题，如果真的是完美的，那么 RSA 应该早就被彻底替代了。</p><p>ECC 的数学原理是椭圆曲线和离散对数，椭圆曲线并不是一个很好理解的数学理论。造成了 ECC 其实要比 RSA 复杂很多。复杂带来的好处就是性能的提升，但是也同时潜藏了一些问题。椭圆曲线理论不展开讨论，但是粗略的讲，设计 ECC 的一套运算标准，涉及到的一个问题就是要选择一条合适的椭圆曲线。注意，ECC 使用的所谓的椭圆曲线其实并不是椭圆形，而只是在运算上跟椭圆运算有关联，实际上是一个类似乳头的形状。根据曲线选择的不同，ECC 的运算也会不同，所以就会形成不同的标准。</p><p><img src="https://img.haoqicat.com/2018100701.jpg" alt="img"></p><p>首先第一个潜藏的问题是，一套标准对应的这条曲线，是不是有可能有人暗藏数学机关呢？造成算法其实是可以通过后门来破解的。目前使用面很广的一套标准是 NSA ，也就是美国国家安全局发布的，这套标准就被怀疑是有后门的。</p><p>另外一个问题就是专利。基于 ECC 的各种使用方式，有人申请了很多个专利。而且这些专利很多都被一个公司所持有，这个公司就是黑莓。你永远也不知道自己开发一套新的 ECC 方案，会不会被认为触犯了某个专利，这一点也是很恶心的。</p><p>总之，虽然 ECC 目前发展良好，但是也面临着各种挑战。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先比较重要的是大家要理解什么是加密，这样才能理解 ECC 的使用场景。<strong>ECC 被称为新一代公开密钥加密技术，就是因为它比 RSA 算法更高效。但是 ECC 也因为算法复杂，导致了出各种问题的可能，例如被植入后门或者涉及专利之争。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08Merkle树</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/08Merkle%E6%A0%91/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/08Merkle%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h1><p>Merkle Tree 是由计算机科学家 Ralph Merkle 在很多年前提出的，并以他本人的名字来命名，中文翻译过来叫默克尔树，也叫哈希树。<strong>Merkle Tree 号称区块链面试必考题</strong>，因为的确太常用了。说到根本上 Merkle Tree 就是<strong>用来做完整性校验</strong>的，所谓的完整性校验，就是检查一下数据有没有损坏或者被恶意篡改。Merkle Tree 的最大的应用场合就是在点对点网络上，Git 版本控制系统，IPFS 协议以及比特币以太坊等等项目，都用到了它。</p><a id="more"></a><h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希 Hash"></a>哈希 Hash</h2><p>Merkle Tree 如果直接去看定义，会看到一张比较复杂的图，可能会把你一下子吓到，然后就不想学了。但是别忘了，Merkle Tree 还有另外一个名字，叫哈希树。这里会先讲哈希，再讲什么是哈希列表，最后在递进到哈希树，这样三步下来，每一步都其实很好理解，保证你能一下子就掌握 Merkle Tree 的概念。</p><p>先介绍什么是哈希。其实要实现完整性校验，最简单的方法就是对要校验的整个的数据文件做个哈希运算，把得到的哈希值公布在网上，这样我们把数据下载到手之后，再次运算一下哈希值，如果运算结果相等，就表示我们下载过程中文件没有任何的损坏。因为哈希的最大特点是，如果数据稍微变了一点点，那么经过哈希运算，得到的哈希值将会变得面目全非。没有人可以把数据篡改了，同时还能保证数据的哈希不变。</p><p><img src="https://img.haoqicat.com/2018092401.jpg" alt="img"></p><p>这种简单的采用哈希的方式做数据运算，比较适合数据本身不做分割，同时是放在一台服务器上的情况。例如，如果去某个公司网站上去下载他们的一个软件，就会看到公司网站上公布了这个下载包的哈希值，这个哈希值非常重要，因为有了这串数，我们就可以放心的去下载这个软件，<strong>下载完做一下完整性校验</strong>，就知道这个软件没有损坏。甚至可以放心从其他的不可信网站上去下载这个软件包，因为有了校验机制，也一样可以保证这个包是跟官方的包丝毫不差的。</p><h2 id="哈希列表-Hash-List"><a href="#哈希列表-Hash-List" class="headerlink" title="哈希列表 Hash List"></a>哈希列表 Hash List</h2><p>但是在去中心化网络，或者叫点对点网络上，数据往往都是拆分成很多小碎片去下载的，而且其中很多机器可以认为是不稳定或者是不可信的，这时需要有更加巧妙的做法。最简单的方式就是用 Hash List ，也就是哈希列表。</p><p><img src="https://img.haoqicat.com/2018092402.jpg" alt="img"></p><p>实际中，点对点网络在传输数据的时候，其实都是把比较大的一个文件，切成小的数据块。这样的好处是，如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，不用重新下载整个文件。当然这就要求对每个数据块计算哈希值，所有这些小数据块的哈希值都是兄弟关系，这样大家就组成了一个哈希列表。BT 下载的时候，在下载真正的数据之前，会先下载一个哈希列表的，这个就是所谓的种子文件。有了各个 hash 之后，数据本身就可以从任意的机器上下载了，不用管那些机器是否是安全可信的。</p><p>这时有一个问题就出现了，那么多的哈希，我们怎么保证它们本身都是正确地呢？</p><p><img src="https://img.haoqicat.com/2018092403.jpg" alt="img"></p><p>答案是我们需要一个根哈希，根就是树根的根。<strong>把每个小块的哈希值拼到一起，然后对整个这个长长的字符串再做一次哈希运算，最终的结果就是哈希列表的根哈希。</strong>于是，如果我们能够保证从一个绝对可信的网站，或者从我们的朋友手里拿到一个正确的根哈希，就可以用它来校验哈希列表中的每一个哈希都是正确的，进而可以保证下载的每一个数据块的正确性了。</p><p>Hash List 也就是哈希列表形式，就非常适合在点对点网络上存储的大型数据了。</p><h2 id="Merkle-Tree-哈希树"><a href="#Merkle-Tree-哈希树" class="headerlink" title="Merkle Tree 哈希树"></a>Merkle Tree 哈希树</h2><p>其实 Merkle Tree 本身也算是一个哈希列表，只不过是在这个基础上又引入了树形结构，从而获得了更高的灵活性。</p><p>我们先说计算机科学中的树的概念，树跟自然界一棵树有着类似的结构，只不过计算机科学中的树通常都是倒着画，根在上面，然后一路往下开枝散叶。举一个最简单的例子，所有的文件都存放在一个文件夹中，这个文件夹就叫根文件夹，根就是树根的意思，这个文件夹又会包含其他文件夹，子文件夹中又会包含孙子辈的文件夹。这样层层的包含或者说从属关系，画成图就是一棵倒挂的树，而这个结构就是计算机科学中随处可见的树的概念，怎么样，简单吧？</p><p><img src="https://img.haoqicat.com/2018092404.jpg" alt="img"></p><p>然后就说到主角 Merkle Tree 了。在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root 。需要补充一下的是，根哈希有时候也叫主哈希 Master Hash ，也有人叫它顶哈希 Top Hash ，因为画图的时候通常都是倒着画这根树，反正不管叫什么，说的都是一个东西。</p><p><img src="https://img.haoqicat.com/2018092405.jpg" alt="img"></p><p>于是我们看到 Merkle Tree 比普通的哈希列表稍微复杂了一点点，那么优点是什么呢？相对于 Hash List，Merkle Tree 的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这给很多使用场合就带来了哈希列表所不能比拟的灵活和高性能。</p><p><img src="https://img.haoqicat.com/2018092406.jpg" alt="img"></p><p>Merkle Tree 是三个概念的叠加，一个是哈希，第二个是哈希列表，第三个是树。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哈希和树都是计算机科学中最基础最重要的两个概念，可以用在很多不同场合。单个哈希不能担当大文件在分布式点对点网络上的校验工作，于是我们有了哈希列表的概念。 Merkle Tree 可以认为是哈希列表的一个变体，让哈希列表变得更加灵活高效，因为每次校验都可以单纯拿出树的一个分支来操作。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07RSA算法--基本原理</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/07RSA-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/07RSA-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA-算法–基本原理篇"><a href="#RSA-算法–基本原理篇" class="headerlink" title="RSA 算法–基本原理篇"></a>RSA 算法–基本原理篇</h1><p>RSA 算法是非对称加密算法鼻祖，至今仍然是最为广泛使用的算法之一，所以我们就来拆解一下 RSA 算法本身。</p><a id="more"></a><h2 id="宏观思路"><a href="#宏观思路" class="headerlink" title="宏观思路"></a>宏观思路</h2><p>说到最底层，<strong>RSA 算法的作用非常简单，就是生成公钥和私钥的</strong>。公钥用于加密信息，私钥用来解密，先上锁，后开锁。实现加密和解密的第一步就是找到一个函数，函数的正向运算很容易，但是逆向运算很难。对应 RSA 的情况，也就是把公钥和信息作为参数进行运算，得到密文，这个过程要很容易，而逆向运算，由密文和公钥想要获得信息，是很难做到的。</p><p><img src="https://img.haoqicat.com/2018100401.jpg" alt="img"></p><p>当然，这个函数还必须有另外一个特点。就是逆向操作虽然默认很难做到的，但是如果拥有了特定的提示信息，操作就变得非常容易了。这里的提示信息，显然就是<strong>私钥</strong>。</p><p>总之，找到这样一个正向容易运算，反向默认很难，但是如果有了私钥就很容易运算的函数，就是实现 RSA 算法的核心思路。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面我们就来看看 RSA 算法具体的实现方式。</p><p>先来补充一个数学知识：取模运算。取模运算其实就是算余数。例如 3 mod 2 的结果就是1，mod 就是取模的意思。</p><p><img src="https://img.haoqicat.com/2018100402.jpg" alt="img"></p><p>RSA 使用的单向函数是这样的，拿出要<strong>加密的信息 m</strong> ，我们知道任何的计算机信息都能转换成二进制数，所以当然也能转换成十进制的一个整数。这里 m 是一个整数，接下来<strong>随机选择一个 e</strong> ，来作为 m 的指数。注意，这里的指数 e 的选择范围是有一定限制的，但是在这个范围内是任意选择的。接下来，进行 m 的 e 次方运算，然后对另一个<strong>随机选取整数 N</strong> 进行取模运算，最后得到的结果就是<strong>密文，用 c</strong> 表示 。举个例子，m 等于7 ，e 选择为2 ，N 选择23，这样，最后的密文 c 就等于49对23取模，结果是6。也就是说7经过加密，最后密文是6。这个运算有个特点，给定 m 和 e 以及 N 的值，很容易算出 c ，但是给定 c 和 e 以及 N 很难算出 m 来。这就是我们需要的单向函数。</p><p><img src="https://img.haoqicat.com/2018100403.jpg" alt="img"></p><p>于是，我们的锁就有了，也就是 ”e 次方然后对 N 取模“。那么，开这把锁的钥匙是什么呢？简单来说，就是让逆向运算过程变得简单的信息。</p><p><img src="https://img.haoqicat.com/2018100404.jpg" alt="img"></p><p>逆向运算，就是从密文得到信息。经过数学推导，可以得到这样的逆向运算过程，一定存在一个整数 d ，使得 c 的 d 次方对 N 取模，是可以得到 m 的。最终，<strong>e 和 N 按照一定规范组合到一起，就是公钥，（加密），而 d 和 N 组合到一起就是私钥。（解密）</strong></p><p>总之，RSA 算法的单向函数找到了，于是加密用的锁也就找到了。但是其实这个函数本身不是 RSA 算法最复杂的地方，最复杂的内容在于如何由 e 算出 d 。<strong>而如何给定 e ，算出合适的 d ，其实是要引入第二个单向运算了，这就是整数分解问题了。</strong></p><h2 id="安全性取决与整数分解问题"><a href="#安全性取决与整数分解问题" class="headerlink" title="安全性取决与整数分解问题"></a>安全性取决与整数分解问题</h2><p>如何运算出 d 的过程本节不展开。粗略来讲，从 e 运算出 d 的过程，涉及到 N 的整数分解问题。整个 RSA 算法的安全性就取决于整数分解这个基本数学问题。</p><p>来解释一下整数分解问题。<strong>整数分解就是把一个数分解成多个素数的乘积</strong>。<strong>素数就是那些只能被1和自己整除的整数</strong>，这个小时候咱们学过的。例如 45 可以分解成 3x3x5 。而 RSA 算法中的整数分解有一定的特殊性。<strong>被分解的数需要是两个</strong>，而不是多个素数的乘积。虽然由两个素数相乘获得结果非常简单，但是反过来，分解过程是很难的。很难的意思就是如果数足够大，即使用计算机也需要成千上万年才能算出来的问题，或者可以说“很难”就等于”实际中不能实现“。而这一点就是 RSA 算法的安全基石。如果有一天，有数学家找出整数分解的有效运算方法，那么 RSA 算法也就不能用了。</p><p>实际生成公钥和私钥的过程是，我们选出 p1 和 p2 两个大素数，让 N = p1 * p2 。随机选择一个指数 e ，这样公钥就有了。而在知道 p1 和 p2 的前提下，从公钥算出私钥，也就是算出 d ，是非常容易的。而外人，因为不知道 p1 和 p2 ，而只知道 N ，所以不可能从 e 算出 d ，<strong>也就是不可能用公钥算出私钥。</strong></p><p>总之只要整数分解问题无解，那么 RSA 就是安全的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏观上的思路就是，要找到一个包含取模运算的单向函数，保证信息加密容易，而反向解密很难。另外，还要找到第二个单向函数，也就是整数分解问题的函数，保证在知道分解结果的条件下，从公钥算出私钥是容易的，而如果不知道，就不可能算出私钥。真正的 RSA 算法，是这两个单向函数的综合使用。但是对于如何进行解密，公钥和私钥生成的细节，我们没有展开，因为这涉及到更多的数学推导，下个小节 Peter 再给大家介绍。</p><h1 id="RSA-算法–粗略数学推导篇"><a href="#RSA-算法–粗略数学推导篇" class="headerlink" title="RSA 算法–粗略数学推导篇"></a>RSA 算法–粗略数学推导篇</h1><p>上节我们介绍完 RSA 算法的基本原理了，了解了 RSA 算法的加密锁就是先幂后模的运算。这个锁的特点是正向运算很容易，也就是<strong>加密过程很容易，但是解密过程很难</strong>，也就是要直接反向运算是不可能的。而要想让反向运算成为可能，就要在先幂后模运算的各项参数上做文章，让各项参数之间通过整数分解问题建立关系，这样只要我们把握住这种关系，那么反向运算就变得容易了。所以本节就来深入到整数分解问题，看看如何来构建先幂后模中的各项参数之间的关系，进而引申出如何生成公钥和私钥。</p><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>下面我们把要解决的问题进一步明确一下，抽象成具体的数学任务。先幂后模函数的正向运算，从信息 m 获得密文 c 是简单的，而反向运算，从 c 运算获得 m 是很难的。但是如果我们能够合理的构建 e 和 N 之间的关系，同时把握体现 e 和 N 之间关系的关键信息，这个反向运算将不再困难。</p><p><img src="https://img.haoqicat.com/2018100402.jpg" alt="img"></p><p>实际上，我们总能找到一个合适的 d ，<strong>使得 c 的 d 次方对 N 求模的结果就是 m</strong> 。所以问题进一步的就是要构建 e , d 以及 N 的数学联系。</p><p><img src="https://img.haoqicat.com/2018100403.jpg" alt="img"></p><p>实际上我们要做到的是，给定两个大素数 p1 和 p2 ，让 p1*p2 = N ，由 e 容易算出 d 的前提是我们知道 p1 和 p2 的值，也就是是知道 N 的整数分解的结果。而如果不知道 ，那么根据 e 和 N 算出 d 的难度就相当于对两个大素数的乘积做反向分解，这个是很难的。“很难”在这里的意思就是没有有效的求解方法，只能靠暴力搜索去解决，于是运算量超大，所以实际中不可能做到。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><p>问题的关键就是使用<strong>欧拉函数</strong>。</p><p>在 RSA 这里，欧拉函数的本来目的不重要，重要的是要使用的是它的一个属性：也就是，只有满足特定条件下才容易计算出它的结果，否则，就很难。推导过程我们就不说了，那这个特定条件是什么呢？<strong>其实就是当 N 是两个素数 p1 和 p2 的乘积的时候</strong>，因为此时可以保证下面的等式成立。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">φ<span class="comment">(N)</span> = <span class="comment">(p1-1)</span><span class="comment">(p2-1)</span></span><br></pre></td></tr></table></figure><p>例如 ，77 的欧拉函数其实是很难运算出来了，但是如果我们知道 77 可以分解为 7 和 11，那么就可以很容易得到结果 60 了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">φ(<span class="number">77</span>) = (<span class="number">7</span><span class="number">-1</span>)*(<span class="number">11</span><span class="number">-1</span>) = <span class="number">60</span></span><br></pre></td></tr></table></figure><p>基于欧拉函数的这个特点，只要我们能推导出 e ，d 跟 φ(n) 的关系，那就能保证在 φ（n) 能够运算出结果的时候，从 e 很容易得到 d ，否则，从 e 就很难算出 d 。推导过程要基于欧拉定理来进行。欧拉定理的具体意义我们不必深究。</p><p><img src="https://img.haoqicat.com/2018100601.jpg" alt="img"></p><p>其中三个横杠是组成的等式叫做同余式。例如，正整数 a，b 对 p 取模，它们的余数相同，就记做 a ≡ b (mod p)。</p><p>推导过程我们也从略了。最终，经过欧拉定义和上面其他结论进行推导，可以得到下面两个等式是同时成立的。</p><p><img src="https://img.haoqicat.com/2018100602.jpg" alt="img"></p><p>这样，就可以得到 e 和 d 的关系了：也就是 e 和 d 的乘积，等于 k 乘以 φ(N) 加 1 ：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = (<span class="name">k*</span>φ(<span class="name">N</span>) + <span class="number">1</span>)/e</span><br></pre></td></tr></table></figure><p>只要知道 φ(N) ，d 就可以算出来了。而如果不知道 φ(N) ，有了 e 也根本算不出 d 来。上面的 k 没有预先的固定值，而是要在运算过程中算出来的。<strong>k 的取值要保证给定一个 e 的数值</strong>， d 最终可以算出整数来。</p><p>通过上面的讨论，如何生成公钥和私钥的方法就有了，公钥是 N 和 e ，e 是在一定范围内随机选择的，而且是公开的。私钥是由 N 和 d 组成的，而 d 是在知道 N 的整数分解结果的条件下，通过上面的运算计算出来的。同时，加密函数也有了，就是信息 m 的 e 次方对 N 取模，解密函数就是密文 c 的 d 次方对 N 取模。</p><h2 id="运算公钥和私钥"><a href="#运算公钥和私钥" class="headerlink" title="运算公钥和私钥"></a>运算公钥和私钥</h2><p>下面我们就来实际使用一下上面的结论，生成一下公钥和私钥，并且做一遍加密和解密。</p><p>首先选择两个比较大的素数，实际中一般是几百位，但是我们这里为了演示方便，选择小的一点的。p1 = 53 , p2 = 59 ，这样 N = 53*59=3127 。</p><p>首先来生成公钥和私钥，Alice 选取 e = 3 。于是公钥就是 e 和 N 这两个数的组合。公钥有了。下一步来生成私钥，也就是去运算 d 。 因为知道 p1 和 p2 的值，所以 φ(N) 很容易算出结果，就是 3016 。根据上面运算 d 的公式，当 k 等于 2 的时候，d 可以取得整数值，d 就等于</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = (<span class="number">2</span>*<span class="number">3016</span>+<span class="number">1</span>)/<span class="number">3</span> = <span class="number">2011</span></span><br></pre></td></tr></table></figure><p>私钥就是 N 和 d 的组合。</p><p>接下来看加密和解密过程。Alice 把 e 和 N ，也就是公钥发送给了 Bob 。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">89</span>^<span class="number">3</span> mod <span class="number">3127</span> = <span class="number">1394</span></span><br></pre></td></tr></table></figure><p>Bob 把原文 89 ，e 和 N 带入到加密函数中，最终得到密文 c = 1394 。加密过程完成。</p><p>Alice 收到密文之后，可以用私钥进行解密。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1394</span>^<span class="number">2011</span> mod <span class="number">3127</span> = <span class="number">89</span></span><br></pre></td></tr></table></figure><p>也就是，把密文，d 和 n 都带入解密函数，这样就得到了信息 m = 89 。</p><p>这样我们就完成了整个的过程。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>我们的问题是，如何构建先幂后模运算的各项参数之间的关系，从而保证如果一个人掌握了这种关系，是可以对加密锁进行反向运算的。关系是通过整数分解问题去构建的，推导过程中会用到欧拉函数的一个重要特性，也就是如果参数的整数分解结果是知道的，那么欧拉函数的结果也就很容易算出来，否则欧拉函数很难被求解。于是经过推导，我们可以得出 <code>e*d</code> 跟欧拉函数的值有着固定的联系，于是得到了从公钥（基本就是 e ）运算出私钥（基本就是 d ）的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06数字证书</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/06%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/06%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>先来个预警，没有婚姻的社会里面，没有人能理解结婚证是干什么的，同理，不理解公开密钥加密技术的加密通信和数字签名这两个概念，也不会理解数字证书什么用。这些话题之前，前面小节中咱们都聊过了，不知道你有没有记住呢？好，那么什么是数字证书，发证机构的作用是什么，加密通信和数字签名过程中证书发挥什么作用呢？下面一一揭晓。</p><a id="more"></a><h2 id="什么是数字证书？证明公钥是你的"><a href="#什么是数字证书？证明公钥是你的" class="headerlink" title="什么是数字证书？证明公钥是你的"></a>什么是数字证书？证明公钥是你的</h2><p>数字证书是一个由可信的第三方发出的，用来证明所有人身份以及所有人拥有这个公钥的电子文件。</p><p>拿出一份典型的数字证书，看看里面到底都包含哪几项内容。<strong>首先是发证机构 CA。第二个是所有人姓名，例如 Peter 。第三个是所有人公钥，以及公钥的过期时间。最后一项就是 CA 的数字签名。</strong>好，根据咱们已有的数字签名的知识，可以得出几个结论。首先，数字签名是 CA 发出的，也就是说 CA 用自己的信用为这个证书做背书。第二点，证书上同时带有所有人信息和公钥，数字签名保证了证书是不可篡改的，所以说，只要大家信任 CA ，就可以信任所有人和公钥之间的绑定关系。</p><p><img src="https://img.haoqicat.com/2018093001.jpg" alt="img"></p><p>所以说，<strong>数字证书就是第三方机构发行的证书，主要作用就是证明你的公钥的确是属于你的</strong>，而公钥其实就是我们在数字世界的身份，所以说数字证书的作用实际上就是证明你是你自己。</p><h2 id="数字证书的作用"><a href="#数字证书的作用" class="headerlink" title="数字证书的作用"></a>数字证书的作用</h2><p>常见的两个应用场合，<strong>一个是用在数字签名方面</strong>，<strong>另外一个就是 HTTPS</strong> 。我们首先看一个完整的数字签名的使用过程，分析其中的安全隐患，再看看数字证书是怎么解决这个问题的。</p><p>Bob 想要把一个带数字签名的文件传递给 Alice 。于是 Bob 生成了公钥和私钥，用私钥签署了文件。然后把公钥上传到一个公共服务器上。如果一切顺利，那 Alice 去下载这个公钥，然后就可以验证签名，确认文件的确是 Bob 发出的，同时没有被篡改过。但是这里的安全漏洞是明显的，那就是 Alice 无法确认她下载的公钥是不是真的是 Bob 的。这就给所谓的“中间人攻击”提供了可能。假设在 Bob 的文件还没有到达 Alice 之前，黑客发起了中间人攻击，删除 Bob 的文件，然后签署一个假文件发送给 Alice ，Alice 收到后去公共服务上下载的公钥其实也被黑客替换过的，她用这个公钥去验证了签名，自认为文件就是 Bob 发出的，所以被骗了。其实仔细想想，问题就出在公钥本身没有办法证明自己的主人是谁。</p><p>所以要避免中间人攻击，就要使用数字证书。<strong>Bob 签名文件之后，给 Alice 发送时附上自己的证书</strong>。Alice 收到证书之后，就可以信任证书中的公钥的确就是 Bob 的了。有了这个公钥，可以验证文件附带的数字签名是 Bob 的。数字签名没问题，就保证了文件是没有被篡改过的。至于 Alice 如何确认证书本身是可信的，稍后我们聊 HTTPS 的过程中再展开聊。</p><p>到这里，我们就明白了数字证书在验证数字签名的过程中发挥的作用了。</p><h2 id="通过-HTTPS-理解证书"><a href="#通过-HTTPS-理解证书" class="headerlink" title="通过 HTTPS 理解证书"></a>通过 HTTPS 理解证书</h2><p>日常中非常常见的加密通信过程就是 HTTPS ，下面我们就详细聊聊 HTTPS 的原理，来帮大家加深一下对数字证书的理解。</p><p>HTTPS 就是安全的 HTTP 的意思，是一套用在浏览器和服务器之间通信的协议。使用了 HTTPS 后，浏览器跟服务器之间所有的通信内容都是加密过的。这个过程中的主角就是 SSL 证书，<strong>SSL 证书就是用在 HTTPS 条件下的数字证书</strong>，也是由可信的第三方 CA 来颁发。只不过验证的不是人的身份，而是用来<strong>验证服务器身份和它的公钥</strong>，目的是建立浏览器和服务器之间的信任。</p><p>比如，我现在用浏览器来访问谷歌服务器。要建立加密通道，首先第一步是要传递公钥过来，但是服务器传递过来的公钥如果过程中被篡改过，那么后续的加密通信也就全无安全性可言了。所以谷歌需要先去 CA 机构申请 SSL 证书，放到自己的服务器上。这样，我在浏览器中输入谷歌的网址，谷歌那边会首先给浏览器发送 SSL 证书。注意，各个浏览器中都内置了对全球各大 CA 机构的验证机制，底层的原理就是拥有 CA 们的公钥，可以验证证书上 CA 的签名。如果证书没有问题，浏览器就可以断定证书中携带过来的公钥就是谷歌的。这时候，浏览器会生成一个秘钥，注意这里就是对称加密的思路了，发送给谷歌服务器。这样，谷歌拥有浏览器的加密秘钥，可以用对称加密的思路来跟浏览器通信了，这样一个双向的加密通信通道也就开通了。对称加密的加密效率要比非对称高，所以大量数据的传递首选对称加密。</p><p><img src="https://img.haoqicat.com/2018093002.jpg" alt="img"></p><p>这个就是 HTTPS 的基本原理了。加密通信过程中，证书的作用是判断公钥所有人。HTTPS 整个过程中，同时涉及到了数字签名和加密通信，还用到了对称加密和公钥加密两种不同的加密方式，算是比较综合的一个知识点了。但是要提醒一下，SSL 证书，尤其是免费的 SSL 证书，一般对于申请人的身份本身没有很严格的审查，CA 只能保障我拥有这个域名和这个服务器，而且这个公钥是跟这个域名和服务器绑定的。但是究竟我是不是好人，网站是不是会干坏事，CA 机构也不知道。所以一个网站拥有了 HTTPS，浏览器地址栏上面出现了绿色的安全小锁，也并不代表你就可以完全信任这个网站。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>证书的作用就是认证所有人和公钥的关系。有了证书就可以避免中间人攻击，可以安全的建立起加密通道。但是我们要知道的是，这里的安全完全基于对一个第三方机构，也就是 CA ，的信任。而 CA 为何值得信任呢？基本上就是因为 CA 一般都是大机构，都是政府认证的，等等这些传统的信任机制。不过当前，已经有区块链公司会通过去中心化的思路来“去信任”，来实现无 CA 机构的数字证书，让我们共同期待。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05数字签名</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/05%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/05%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>公开密钥加密技术有两大应用，之前已经聊了一个，就是加密通信，本节来聊另外一个：数字签名。数字签名的基本作用跟现实世界的纸笔形式的签名有什么相同点和不同点，数字签名的基本原理和流程又是什么呢？</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>先说数字签名的基本原理。数字签名过程跟加密通信有着一定的对称性，这种对称有着一种逻辑上的美。</p><p><strong>加密通信是用公钥进行加密，而用私钥进行解密。而数字签名刚好相反，是采用私钥加密，公钥解密。</strong>对于加密通信，公钥加密过程就是通过加密算法把信息加密成密文，私钥解密过程就是通过解密算法解密密文。<strong>而对于数字签名，私钥加密过程是通过签名算法来生成数字签名的过程，而公钥解密过程是通过验证算法来确定数字签名是不是有私钥持有者签署的。</strong>可以看到，加密算法，解密算法，签名算法，验证算法，对称性是很明显的。</p><p><img src="https://img.haoqicat.com/2018092901.jpg" alt="img"></p><p>数字签名的主要的作用是认证签署人身份，说得具体点，就是让所有人能够确认这个数字签名是不是由私钥的持有人创建的。数字签名是由签名算法去生成的，签名算法的输入有两个，一个是私钥，另一个是被签署的信息，输出的一个字符串就是数字签名了。签名到底是不是由私钥持有人签署的，要通过验证算法判断。验证算法有三个输入，一个是信息本身，另外一个是数字签名，第三个是公钥，输出的结果就是验证成功或者验证失败。数字签名过程中，私钥是“签名 key”，公钥是“验证 key”。</p><p><img src="https://img.haoqicat.com/2018092902.jpg" alt="img"></p><p>所以说数字签名的原理是非常清晰的，因为数字签名本身跟加密通信形成一个对称关系，而数字签名自己的签名过程跟验证过程，也是个对称关系。把握这种对称性，就比较容易记住基本原理了。</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>静态的基本原理懂了，咱们再来从时间维度看看数字签名动态流程。</p><p>Alice 要签署一个文件，于是她就拿出自己的私钥，执行签名算法，得到数字签名。那么其他人如何去验证这个数字签名的确出自 Alice 呢？首先，Alice 要把自己的公钥放到一个大家都可以访问到的服务器上，这样其他人都可以获得 Alice 的公钥，大家把文件，数字签名以及公钥下载到自己的计算机上，调用验证算法，就可以判断这个文件是不是 Alice 签署的了。不管是签名算法还是验证算法都是全球公开的，每个人都可以在自己的计算机上安装软件来执行这两个算法。</p><p><img src="https://img.haoqicat.com/2018092903.jpg" alt="img"></p><p>这就是一个 Alice 签署文件，其他人验证签名的完整过程了。这个过程中有一点要注意，就是签名本身是不会加密文件本身的。在底层，签名过程其实是加密了文件的哈希值，总之签名的目的不在于加密文件信息，而在于生成数字签名。</p><h2 id="实际作用"><a href="#实际作用" class="headerlink" title="实际作用"></a>实际作用</h2><p><strong>数字签名有三大作用</strong></p><p><strong>第一个是认证</strong></p><p>先看第一个认证，意思就是确认签署人身份，这个跟纸笔签名的作用是一致的。</p><p><strong>第二个是防止抵赖</strong></p><p>再看第二个防止抵赖，同样是纸笔签名也拥有的特性，一份合同签署了，就要承担责任，白纸黑字，不能耍赖。</p><p><strong>第三个是保证文件完整性，也就是没有被篡改过。</strong></p><p>第三个作用是保证文件没有被篡改过，这个作用纸笔签名很难保证，比如签名只签署了最后一页，那么如果有人想悄悄换掉了前几页的内容，签名本身是阻止不了的。但是数字签名就可以，因为数字签名是由两个输入运算得出的，一个是私钥，另一个就是文件，所以如果在验证过程中，发现文件有改动，验证会失败。这个很类似于现实世界签合同的时候，有时候需要故意用签名或者图章覆盖有文字的区域，或者在写信的时候，给信封加上蜡封，这些措施也都是为了防篡改。</p><p>这就是数字签名的三大作用，主要用在各种防伪造场合，在世界上很多国家，数字签名都是有法律效力的。另外要注意，数字签名属于电子签名的一种，但并不是所有的电子签名都是数字签名，这两个概念要区分一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数字签名是公钥加密技术的两大应用之一。主要采用了私钥加密，公钥解密的方式，文件签署者用私钥签署文件，就表示他认可了这个文件的内容。要验证数字签名，只需要签名人公布自己的公钥即可，其他人通过验证数字签名即可验证文件是私钥签署的。签署人不需要暴露自己的私钥，就可以间接证明自己拥有私钥。除了认证签署人身份，数字签名还有两个作用，分别是防止抵赖和保证文件完整性。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04加密通信</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/04%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/04%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h1><p>早期人们的解决方案其实跟密室是一个道理，就是通过私有网络，也就是从物理上隔绝其他人。但是私有网络衰落，互联网兴起后，客观条件就不同了，互联网是一个公开场合，数据在通信过程中默认是能够被别人获取到的，那么这个时候保证私密的策略就从“不让你看见”变成“看见你也看不懂”了。具体做法就是：首先把信息加密成密文，到达接收方之后，再把密文解密成信息了，这个过程就是加密通信。</p><a id="more"></a><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>先说加密通信的一种最简单的方式，就是对称加密。这个是人类用了几千年的方式，凯撒密码就属于这种。所谓对称，意思就是发送方和接收方使用的是同一个钥匙，或者英文叫 key 。但是互联网上的加密通信，也使用了另外一种形式，也就是非对称加密，或者叫公开密钥加密。</p><p>说说类似于凯撒密码的对称加密的基本工作原理。发送方会按照一定规则，把信息变成密文，密文说白了就是谁也看不懂的东西。等密文到了接收方手里，接收者需要按照同样的规则，也就是同一个 key ，把密文翻译成信息。加密通信过程就完成了。</p><p><img src="https://img.haoqicat.com/2018092601.jpg" alt="img"></p><p>但是对称加密的问题就在于如何安全的传递 key 本身。没有 key ，就不能建立安全的通信通道，没有安全的通信通道，就无法安全的把 key 传递给接收方，所以这就是一个鸡生蛋蛋生鸡的问题了。于是，互联网上做加密通信就用到了非对称加密。非对称加密，也叫做公开密钥加密，<strong>特点是发送方和接收方使用的不是同一个 key</strong> 。这种方式略微有点反直觉了吧，具体原理稍候会讲到。</p><p><img src="https://img.haoqicat.com/2018092602.jpg" alt="img"></p><p>总之，加密通信可以采用的方式有两种，一种是对称加密，一种是非对称或者叫公开密钥加密。对称加密的特点是发送方和接收方采用相同的 key ，非对称加密发送方和接收方采用的是不同的 key 。</p><h2 id="公开密钥加密基本原理"><a href="#公开密钥加密基本原理" class="headerlink" title="公开密钥加密基本原理"></a>公开密钥加密基本原理</h2><p>下面来详细说说用公开密钥加密的基本原理。主要是要理解公钥和私钥的关系。</p><p>首先，可以在自己的机器上安装类似 ssh-keygen 这样的软件来生成公钥和私钥。公钥和私钥之所以是一对，是因为二者有天然的数学联系，但是同时要保证给定公钥不能够算出私钥，不然就相当于加密方法被破解了。公钥和私钥的联系一般就是通过一些无解的数学问题来确定的，这类问题只能正向运算，不能反向运算。比如 8616460799 这个数是两个数相乘得到的，但是要从结果反推出这两个数，是基本不可能的。实际中 RSA 和 ECC 算法，都是基于这一类的数学问题。</p><p><strong>加密通信过程是怎么样的呢？</strong></p><p>首先，如果 Alice 想让 Bob 给她发信息，注意这里 Bob 是发送方，而 Alice 是接收方。首先 Alice 要把自己的公钥传递给 Bob ，然后 Bob 用 Alice 的公钥去加密信息，Alice 收到密文之后可以用私钥进行解密。这就是非对称加密的基本逻辑了，<strong>发送者将接收者公钥用于加密，接收者将自己的私钥用于解密</strong>。</p><p><img src="https://img.haoqicat.com/2018092603.jpg" alt="img"></p><p>当然，上面所说的过程还只是单向通信，要实现双向通信，就需要双方把各自的公钥传递给对方了。</p><h2 id="公开密钥加密的更多技术细节"><a href="#公开密钥加密的更多技术细节" class="headerlink" title="公开密钥加密的更多技术细节"></a>公开密钥加密的更多技术细节</h2><p>公开密钥加密的基本思路是比较简单的，就是用公钥去加密，用私钥去解密。</p><p>如果公钥就是用来加密信息的，那为啥不叫 lock 也就是锁，而要叫 key ，钥匙呢？所以说既然公钥也是钥匙，那么它就是一定也有解密功能。公钥加密技术其实有两个重大应用，一个就是我们本文所述的加密通信，但是还有第二个，就是数字签名。<strong>加密通信是用来保证机密性的，而数字签名是用来认证的</strong>。<strong>数字签名的基本原理是用私钥去加密，而用公钥去解密。</strong>也就是我用私钥签名一份文件，而全世界的人都可以用我的公钥去解密数字签名，如果解密成功，就可以认定，这个文件的确是我签署的。所以说，加密通信条件下，私钥可以叫做“解密 key”，而在数字签名条件下，公钥可以叫做“验证 key”。这样，我们就理解了为啥公钥也是 key 了。</p><p>另外一个问题是，公开密钥加密都有哪些实际应用呢？首先就是加密通信，银行政府传递数据也是用这个思路的，所以加密通信还真是关系重大。如果你是程序员，可能会经常用 ssh 登录服务器，这个背后也是用公开密钥加密技术来实现安全通信的。另外网站现在都流行使用 HTTPS 协议，也就是安全的 HTTP ，来达成浏览器跟服务器之间的加密通信，这个背后也是公开密钥加密技术。另外，比特币等加密货币，背后也都是公开密钥加密技术。</p><p>最后一个问题会引发我们进一步的学习，那就是如何解决公钥加密过程中的一些具体问题，例如，如何安全的把公钥发送给对方，保证公钥没有被篡改过。实际上这个问题还真的是非常困难的，所以会涉及到发证机构（ CA ）这样的概念。后面我们专门有一节介绍 CA 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要实现加密通信，有对称加密和非对称加密，也就是公开密钥加密两种方式。所谓非对称，就是加密和解密是采用不同的 key 。<strong>公钥用来加密信息，私钥用来解密信息</strong>。双方通信之前，要先互相交换公钥，这样才能建立起安全的双向通道。公钥加密的应用有两个，一个就是本节聊的加密通信，另一个就是数字签名。】</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03公开密钥加密</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/03%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/03%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h1><p>当代密码学的核心是“公开密钥加密”（ Public-key cryptography ）。本节的目的是梳理清楚学习密码学的大思路，以便在后续课程中，遇到椭圆曲线，RSA ，加密通信，数字签名这些术语的时候，起码知道它们的大致归属。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>公开密钥加密也称为”<strong>非对称加密</strong>“，加密和解密的时候使用<strong>不同的秘钥（key）</strong>，其中一个是公钥，是可以公开出去的，另外一个是私钥，要严格保密。<strong>公开密钥加密有两个应用，一个是加密通信，另外一个是数字签名。</strong></p><h4 id="公开密钥加密要实现的功能有两个："><a href="#公开密钥加密要实现的功能有两个：" class="headerlink" title="公开密钥加密要实现的功能有两个："></a>公开密钥加密要实现的功能有两个：</h4><ol><li><strong>保密</strong>，发送者用接收者的公钥去加密信息，接收者就用自己的私钥去解密信息。</li><li><strong>认证</strong>，发出信息的人用自己的私钥去进行数字签名来签署信息，这样任何人拿到公钥之后都可以去确认信息是不是由私钥持有人发出的。</li></ol><p>公钥和私钥首先应该是有数学联系的，不然所谓的解密和签名操作也就不可能实现了，但是同时<strong>不能由公钥去算出私钥</strong>，如果可以算出来，那么安全性就丧失了。所以加密算法都是基于一些目前无解的数学问题，或者叫单向函数，例如整数分解或者离散对数。具体的算法有 RSA 和 ECC 等。什么叫单向函数呢？8616460799 是两个数相乘得到的，给这两个数，可以很容易算出结果，但是如果给出结果，要分解出两个乘数，就是一个数学上还没有解决的问题，叫做”整数分解“问题。换句话说，如果有一天整数分解问题解决了，攻击者就可以把公钥分解，那么私钥就很容易被算出来了，基于整数分解的加密算法也就失效了。</p><h2 id="应用（加密通信和数字签名的基本原理）"><a href="#应用（加密通信和数字签名的基本原理）" class="headerlink" title="应用（加密通信和数字签名的基本原理）"></a>应用（加密通信和数字签名的基本原理）</h2><h5 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h5><p>信息发送者A需要发送一个信息给信息接收者B，需要先使用B的公钥对信息加密，B收到后，使用自己（B）的私钥就可以对这一信息进行解密，而其他人没有私钥，是没有办法对这个加密信息进行解密的。</p><table><thead><tr><th>发送者A                                                                                           接收者B</th></tr></thead><tbody><tr><td>明文———B的公钥加密———-密文———–发送给B———&gt;  密文————–B的私钥解密———-明文</td></tr><tr><td>加密                                                                                                   解密</td></tr></tbody></table><h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>发送者A先用哈希函数对原文生成一个摘要（Digest），然后使用私钥对摘要进行加密，生成数字签名（Signature）之后将数字签名与原文用B的公钥加密形成密文一起发送给接收者B；B收到信息后使用A的公钥对数字签名进行签名得到摘要，由此确保信息是A发出的，然后再对收到的密文使用B的私钥解密得到原文，原文使用哈希函数产生摘要，并与解密得到的摘要进行对比，如果相同，则说明收到的信息在传输过程中没有被修改过。</p><h2 id="主要算法"><a href="#主要算法" class="headerlink" title="主要算法"></a>主要算法</h2><p>最知名的算法有两个，一个是 RSA 算法，一个是 ECC 算法。</p><p>RSA 算法是开山鼻祖。1970 年，一位英国密码学家预见了“无秘密加密”的可能性，公钥加密思想产生了。公钥加密的比对称加密有明显优势，因为通信之前，双方不用传递密码，只需要传递公钥即可，而公钥不是秘密，被截获也不会影响通信安全。之后几年，人们开发了 RSA 算法，第一次真正实现了这个想法。RSA 算法标志着公开密钥加密真正诞生了。RSA 算法的安全性基于整数分解问题，具体来说就是根据大素数相乘的结果，不可能被反向分解的数学原理。</p><p>另外一种加密算法叫做 ECC ，也就是椭圆曲线算法。世界上不可解的数学问题并不是只有整数分解一个，ECC 就是基于另外一个问题：离散对数。一个加密算法的安全性取决于，由公钥去运算私钥的难度。毕竟私钥的位数是有限的，所以即使用暴力搜索的方式，也肯定是能够算出来的。而且各种单向函数虽然无解，但是不代表不能缩小求解范围，所以不同的算法其实安全性还是有差别的。而 ECC 用离散对数原理，同样的 Key 长度，<strong>安全性比 RSA 更高。</strong>比特币就是用 ECC 来生成地址和私钥。这里你可能会有疑问，为何不能把私钥位数尽量弄长一些呢？的确，越长就越安全，但是同时执行效率也低，所以实际使用中还是要保证一种平衡的。</p><p>这里我们要记住的是，加密算法很多，但是最重要的就是 RSA 和 ECC 两个，同时加密算法跟哈希算法是两个东西，所以 SHA1 ，MD5 这些哈希算法跟 RSA 和 ECC 根本不是一类运算，不要弄混淆。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住的是：首先公开密钥加密是<strong>基于单向函数的数学原理开发出来的</strong>，主要由两个应用，一个是<strong>加密通信</strong>，一个是<strong>数字签名</strong>。最著名的公开密钥加密的算法有两个，一个是 <strong>RSA</strong> 一个是 <strong>ECC</strong> 。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02哈希算法</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/02%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/02%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>哈希是密码学的基础，理解哈希是理解数字签名和加密通信等技术的必要前提。</p><a id="more"></a><h2 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h2><p>哈希，英文是 hash ，本来意思是”切碎并搅拌“，有一种食物就叫 Hash ，就是把食材切碎并搅拌一下做成的。哈希函数的运算结果就是哈希值，通常简称为哈希。<strong>哈希函数有时候也翻译做散列函数</strong>。</p><p><img src="https://img.haoqicat.com/2018100101.jpg" alt="img"></p><p>哈希函数要做的事情是<strong>给一个任意大小的数据生成出一个固定长度的数据</strong>，作为它的映射。所谓映射就是一一对应。一个可靠的哈希算法要满足三点。</p><ol><li><p><strong>安全</strong>，给定数据 M 容易算出哈希值 X ，而给定 X 不能算出 M ，或者说哈希算法应该是一个单向算法。</p></li><li><p><strong>独一无二</strong>，两个不同的数据，要拥有不相同的哈希。</p></li><li><p><strong>长度固定</strong>，给定一种哈希算法，不管输入是多大的数据，输出长度都是固定的。</p><p>但是仔细想一下，如果哈希的长度是固定的，也就是取值范围是有限的，而输入数据的取值范围是无限的，所以总会找到两个不同的输入拥有相同的哈希。所以，哈希函数的安全性肯定是个相对概念。如果出现了两个不同输入有相同输出的情况，就叫<strong>碰撞（collision ）</strong>。不同的哈希算法，<strong>哈希位数越多，</strong>也就基本意味着安全级别越高，或者说它的<strong>”抗碰撞性</strong>“就越好。</p></li></ol><h4 id="哈希函数的主要作用"><a href="#哈希函数的主要作用" class="headerlink" title="哈希函数的主要作用"></a>哈希函数的主要作用</h4><p>哈希的独一无二性，保证了如果数据在存储或者传输过程中有丝毫损坏，那么它的哈希就会变。哈希函数的最常见的一个作用就是<strong>进行完整性校验（ Integrity Check ）</strong>，完整的意思是数据无损坏。哈希有很多不同的称呼，有时候叫 <strong>Digest 摘要</strong>，有时候叫 <strong>Checksum 校验值</strong>，有时候叫 <strong>Fingerprint 指纹</strong>，其实说的意思差不多，也就是说哈希可以用来代表数据本身。例如朋友给我传递一份数据，传完之后，我有一份，他手里也有一份，如果两份数据的哈希值是一样的，那么这两份数据的内容就是一样的，或者说可以认为传递过程中数据没有损坏，我手里拿到的数据是完整的。</p><p>所以说<strong>，哈希函数</strong>的<strong>基本作用</strong>就是给大数据算出一个摘要性的长度固定的字符串，也就是所谓的哈希。<strong>哈希的作用主要是进行完整性校验。</strong></p><h2 id="哈希算法的分类"><a href="#哈希算法的分类" class="headerlink" title="哈希算法的分类"></a>哈希算法的分类</h2><p>首先说哈希算法有很多种，例如 md5 ，sha256 等等，但是它们总体上可以分为两大类，一类是<strong>普通哈希</strong>，另外一类是<strong>加密哈希</strong>（cryptographic hash function）</p><p>哈希算法的安全性不单单是跟哈希长度有关，但是一般哈希值越长也就是越安全。</p><table><thead><tr><th>哈希算法</th><th>输出二进制位长度</th><th>输出十六进制位长度</th></tr></thead><tbody><tr><td>CRC-32</td><td>32</td><td>8</td></tr><tr><td>MD5</td><td>128</td><td>32</td></tr><tr><td>SHA-256</td><td>256</td><td>64</td></tr></tbody></table><p>例如本来 <strong>MD5</strong> 就是设计出来做加密哈希的，但是后来由于计算机的发展 MD5 出现<strong>碰撞的可能性就很大</strong>了，所以目前 MD5 只能当<strong>普通哈希</strong>用，用来做数据校验。<strong>加密哈希跟普通哈希的区别就是安全性</strong>，一般原则是只要一种哈希算法出现过碰撞，就会不被推荐成为加密哈希了，只有安全度高的哈希算法才能用作加密哈希。同时加密哈希其实也能当普通哈希来用，Git 版本控制工具就是用 SHA-1 这个加密哈希算法来做完整性校验的。<strong>一般来讲越安全的哈希算法，处理速度也就越慢，所以并不是所有的场合都适合用加密哈希来替代普通哈希。</strong></p><img src="https://img.haoqicat.com/2018100102.jpg" alt="img" style="zoom: 80%;" /><h4 id="哈希函数和加密函数的区别"><a href="#哈希函数和加密函数的区别" class="headerlink" title="哈希函数和加密函数的区别"></a>哈希函数和加密函数的区别</h4><p>在密码学领域，有两个算法都是把数据做输入，而输出是一段谁也看不懂的数据。其中一个就是<strong>哈希算法</strong>，另外一个是<strong>加密算法</strong>。首先哈希算法的输出长度是固定的，而加密算法的输出长度是跟数据本身长度直接相关的，第二，哈希是不可以逆向运算出数据的，而加密算法的输出是要能够逆向运算出数据的。关于加密算法，我们这里就不展开聊了。Peter 这里主要是强调加密哈希算法只是被用在加密过程中，但是它本身不是加密算法。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总之，哈希算法有很多种，长度越长的算法基本认为越安全。<strong>安全度低的哈希算法被认为是普通哈希算法，主要用来做完整性校验。安全度高的被称为加密哈希算法，会被用在加密算法中。</strong>所谓的高低都是相对概念，例如 MD5 曾经属于加密哈希，但是目前只能用来做安全校验了。而从2017年开始，SHA-1 算法生成的加密证书也会被各大浏览器拒绝了。目前最流行的加密算法是 SHA-2 ，但是跟 SHA-1 不同，SHA-2 不是一种算法，而是一系列算法的统称，其中就包括咱们之前提过的 SHA-256 。</p><h2 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h2><p>首先一个场景是网站注册。当我们提交用户名密码的时候，用户名被会直接保存到网站的数据库中，但是密码却不是直接保存的，而是先把密码转换成哈希，保存到数据库中的其实是哈希。所以，即使是公司后台管理人员，也拿不到用户的密码。这样，如果万一公司数据库泄露了，用户的密码依然是安全的。而当用户自己登录网站的时候，输入密码提交到服务器，服务器上进行相同的哈希运算，因为输入数据没变，所以哈希也不会变，登录也就成功了。</p><p>另外一个场景是区块链和加密货币中。比特币地址生成的时候，就用到了 SHA-256 算法，POW 也就是工作量证明，用的也是这个算法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>哈希的基本作用就是提供一个数据的摘要或者指纹，通常的使用场景就是完整性校验。</strong>哈希算法有很多种，一般来讲哈希越长的算法，安全性也就越高，安全度足够高的哈希，或者说没有任何人能够成功实现碰撞的哈希，才有资格被考虑用在加密场合，而这类的哈希算法也被叫做加密哈希算法。实际中常见的哈希算法有 MD5 ，SHA-1 ，和 SHA-256 等等，其中 MD5 通常用来进行数据校验，SHA-1 曾经是加密哈希算法，但是目前已经被除名，也只能做为一种安全度更高的校验算法了。<strong>SHA-256 依然是广泛使用的加密哈希算法，在比特币生成地址以及 POW 工作量证明算法中都会用到。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01什么是密码学</title>
      <link href="/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/01%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2020/03/09/%E5%AF%86%E7%A0%81%E5%AD%A6/01%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>密码学是对安全通信技术的研究，要能够有效的防范潜在攻击。</p><a id="more"></a><h4 id="主要应用（两个方面）"><a href="#主要应用（两个方面）" class="headerlink" title="主要应用（两个方面）"></a>主要应用（两个方面）</h4><p>密码学是数学和计算机科学的一个交叉。</p><p>一个就是<strong>加密通信</strong>，这个方向的主要任务是保证信息在传送过程中不会被篡改和窃听，这也是咱们比较容易想到的一个方向。但是，另一个方向其实也同样重要，那就是<strong>数字签名</strong>。数字签名跟现实世界中的纸笔签名类似，可以用来认证签署人身份，防止抵赖。</p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>密码学最基础的几个概念是<strong>加密，解密，密文和密钥</strong>。比如 Alice 有一段数据要传递给 Bob ，就要首先运行<strong>加密</strong>算法把数据转换成密文，密文就是一些看起来不知所云的内容。密文到了 Bob 机器上，Bob 运行对应的<strong>解密</strong>算法，就可以把密文再转换成数据。</p><p>那么什么是密钥呢？其实在加密和解密运算过程中有两个要素，一个是<strong>算法</strong>，另外一个是<strong>密钥</strong>（英文叫 <strong>key</strong>） 。key 就是参与加密解密运算过程的一小段数据。其实目前流行的加密解密算法一般都是公开的，因为不公开一般也没人敢用，怕有后门。所以信息的安全完全在于加密人和解密人手里是握有 key 的。如果我们把加密算法封装到一个加密函数中，函数的输入就是两个，一个是信息，一个是 key ，而函数的返回结果就是密文。解密过程也类似，就是把密文和 key 传递给解密函数，返回结果就是信息。我们以凯撒密码为例，凯撒要给他的将军发一封密信，这里凯撒使用的算法是把字母按照字母表顺序往后移动一定的位数，比如信息本来是 A ，现在往后移动3个位数，就变成了 D ，这样生成的密文就谁也看不懂了。那这个过程中算法是“字母偏移”，而 key 就是3。将军收到密文后，根据同样的算法和 key 反推就可以解密。</p><h3 id="公钥加密的核心地位"><a href="#公钥加密的核心地位" class="headerlink" title="公钥加密的核心地位"></a>公钥加密的核心地位</h3><p>当代密码学一直以来是分两套系统：<strong>对称加密和非对称加密</strong>。其中非对称加密也被叫做公钥加密，密码学的最核心技术。</p><h5 id="对称加密和非对称加密是如何区分"><a href="#对称加密和非对称加密是如何区分" class="headerlink" title="对称加密和非对称加密是如何区分"></a>对称加密和非对称加密是如何区分</h5><p>如果加密和解密使用同一个 key ，这就是对称加密技术，否则则是非对称加密技术。具体做法是首先生成一对 key ，其中一个是<strong>公钥（Public Key）</strong> ，公钥是可以公开给任何人的。另外一个是<strong>私钥（Private Key）</strong> ，要严格保密。发送方首先拿到接收方的公钥，用公钥把信息加密，接收方收到密文后，用私钥解密获得信息。</p><h5 id="非对称加密中最著名的算法有两种"><a href="#非对称加密中最著名的算法有两种" class="headerlink" title="非对称加密中最著名的算法有两种"></a>非对称加密中最著名的算法有两种</h5><p>一个是 <strong>RSA</strong> ，这是用三个作者的名字的缩写命名的算法， 另外一个是 <strong>ECC</strong> ，也就是椭圆曲线算法。RSA 是非对称加密技术的开山鼻祖。ECC 是更高效的一种加密算法，比特币就是使用了这种加密算法。</p><p>对称加密在发送方和接收方使用相同的 key ，所以建立安全通信的前提是双方先要有共享的 key 。相对比之下，公钥加密技术要分享的是公钥，不用担心泄露问题，相对要安全一些，另外公钥加密技术也衍生出了数字签名技术。</p><p>当然，公钥加密技术也需要考虑如何确认公钥所有人等技术问题，所以就有了 CA 也就是发证机构，以及 PKI 公钥基础设施等等这些的概念，这里我们就不展开了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们对密码学做了一个简要的介绍，大体上要点有这么几个：</p><ol><li>密码学是对安全通信技术的研究，要能抵御各种恶意攻击。</li><li>密码学的底层是数学，密码学的安全取决于一个难度足够高的数学问题，保证计算机在可接受的时间跨度内根本不可能运算出密钥。</li><li>当代密码学是互联网环境下的密码学，关键性技术是公钥加密技术。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka软件配置</title>
      <link href="/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h3><a id="more"></a><h4 id="第一步：安装java-JDK"><a href="#第一步：安装java-JDK" class="headerlink" title="第一步：安装java JDK"></a>第一步：安装java JDK</h4><h5 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h5><p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-jdk13-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk13-downloads.html</a></p><h5 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h5><p>双击下一步</p><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>在系统中新建</p><p>JAVA_HOME :C:\Program Files\Java\jdk-13.0.2</p><p>在PATH后面加上<code>;%JAVA_HOME%\bin</code></p><h5 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h5><p>打开cmd，输入javac，回车，</p><h5 id="第二步：安装zookeerper-java-jdk-kafka自带，可以跳过"><a href="#第二步：安装zookeerper-java-jdk-kafka自带，可以跳过" class="headerlink" title="第二步：安装zookeerper(java jdk  kafka自带，可以跳过)"></a>第二步：安装zookeerper(java jdk  kafka自带，可以跳过)</h5><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>下载地址<a href="http://apache.fayea.com/zookeerper" target="_blank" rel="noopener">http://apache.fayea.com/zookeerper</a></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><p>将下载好的压缩包解压到本地即可</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1.将conf\zoo_sample.cfg复制一份，并重命名为zoo.cfg</p><p>2.打开上一步得到的zoo.cfg文件，修改dataDir=E:\zookeerper3.5.5\data(文件路径)</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>在zookeerper目录中执行bin\zkServer.cmd</p><h4 id="第三步：安装kafka-（自带zookeerper）"><a href="#第三步：安装kafka-（自带zookeerper）" class="headerlink" title="第三步：安装kafka  （自带zookeerper）"></a>第三步：安装kafka  （自带zookeerper）</h4><h5 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h5><p>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a>,下载kafka_2.12-2.3.0.tgz.</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>将下好的压缩在本地就可以</p><p>kafka的安装目录不允许有空格</p><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>1.打开config目录下的server.properties文件</p><p>2.修改log.dirs=C:/tmp/kafka-logs   //存放数据文件位置</p><p>1.打开C:\Program Files\kafka\kafka_2.12-2.3.0\config下面的zookeerper.properties </p><p>2.dataDir=C:/tmp/zookeeper</p><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><p>执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启zookeerper 在C:\Program Files\kafka\kafka_2.12-2.3.0文件下执行</span></span><br><span class="line">$bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br><span class="line">$bin\zookeeper-server-start.sh  <span class="comment">//mac linux</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启kafka  在C:\Program Files\kafka\kafka_2.12-2.3.0文件下执行 cmd</span></span><br><span class="line">$bin\windows\kafka-server-start.bat config\server.properties    <span class="comment">//windows</span></span><br><span class="line">$bin\kafka-server-start.sh config\server.properties   <span class="comment">//mac linux</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库context</title>
      <link href="/2020/03/02/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93context/"/>
      <url>/2020/03/02/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93context/</url>
      
        <content type="html"><![CDATA[<h1 id="Go标准库Context"><a href="#Go标准库Context" class="headerlink" title="Go标准库Context"></a>Go标准库Context</h1><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><a id="more"></a><h2 id="为什么需要Context"><a href="#为什么需要Context" class="headerlink" title="为什么需要Context"></a>为什么需要Context</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何接收外部命令实现退出</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker()</span><br><span class="line"><span class="comment">// 如何优雅的实现结束子goroutine</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量方式"><a href="#全局变量方式" class="headerlink" title="全局变量方式"></a>全局变量方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> exit <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量方式存在的问题：</span></span><br><span class="line"><span class="comment">// 1. 使用全局变量在跨包调用时不容易统一</span></span><br><span class="line"><span class="comment">// 2. 如果worker中再启动goroutine，就不太好控制了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> exit &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker()</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// sleep3秒以免程序过快退出</span></span><br><span class="line">exit = <span class="literal">true</span>                 <span class="comment">// 修改全局变量实现子goroutine的退出</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道方式存在的问题：</span></span><br><span class="line"><span class="comment">// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(exitChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-exitChan: <span class="comment">// 等待接收上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(exitChan)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// sleep3秒以免程序过快退出</span></span><br><span class="line">exitChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;      <span class="comment">// 给子goroutine发送退出信号</span></span><br><span class="line"><span class="built_in">close</span>(exitChan)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方版的方案"><a href="#官方版的方案" class="headerlink" title="官方版的方案"></a>官方版的方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> worker2(ctx)</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker2"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context初识"><a href="#Context初识" class="headerlink" title="Context初识"></a>Context初识</h2><p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel返回取消的函数</code>、<code>WithDeadline返回截至的时间</code>、<code>WithTimeout超时</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><h2 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h2><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>Deadline</code>方法需要返回当前<code>Context</code>被取消的时间，也就是完成工作的截止时间（deadline）；</p></li><li><p><code>Done</code>方法需要返回一个<code>Channel</code>，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用<code>Done</code>方法会返回同一个Channel；</p></li><li><pre><code>Err<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法会返回当前</span><br></pre></td></tr></table></figure>Context<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结束的原因，它只会在</span><br></pre></td></tr></table></figure>Done<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  返回的Channel被关闭时才会返回非空的值；</span><br><span class="line"></span><br><span class="line">  - 如果当前`Context`被取消就会返回`Canceled`错误；</span><br><span class="line">  - 如果当前`Context`超时就会返回`DeadlineExceeded`错误；</span><br><span class="line"></span><br><span class="line">- `Value`方法会从`Context`中返回键对应的值，对于同一个上下文来说，多次调用`Value` 并传入相同的`Key`会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</span><br><span class="line"></span><br><span class="line">### Background()和TODO()</span><br><span class="line"></span><br><span class="line">Go内置两个函数：`Background()`和`TODO()`，这两个函数分别返回一个实现了`Context`接口的`background`和`todo`。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的`partent context`，衍生出更多的子上下文对象。</span><br><span class="line"></span><br><span class="line">`Background()`主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</span><br><span class="line"></span><br><span class="line">`TODO()`，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</span><br><span class="line"></span><br><span class="line">`background`和`todo`本质上都是`emptyCtx`结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</span><br><span class="line"></span><br><span class="line">## With系列函数</span><br><span class="line"></span><br><span class="line">此外，`context`包中还定义了四个With系列函数。</span><br><span class="line"></span><br><span class="line">### WithCancel</span><br><span class="line"></span><br><span class="line">`WithCancel`的函数签名如下：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>WithCancel</code>返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// return结束该goroutine，防止泄露</span></span><br><span class="line"><span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//context.Background根节点造子节点ctx</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 当我们取完需要的整数后调用cancel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p><h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><p><code>WithDeadline</code>的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span></span><br><span class="line"><span class="comment">// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以<code>ctx.Done()</code>会先接收到值，上面的代码会打印ctx.Err()取消原因。</p><h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h3><p><code>WithTimeout</code>的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p><code>WithTimeout</code>返回<code>WithDeadline(parent, time.Now().Add(timeout))</code>。</p><p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"db connecting ..."</span>)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"worker done!"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p><p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p><p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithValue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TraceCode <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">key := TraceCode(<span class="string">"TRACE_CODE"</span>)</span><br><span class="line">traceCode, ok := ctx.Value(key).(<span class="keyword">string</span>) <span class="comment">// 在子goroutine中获取trace code</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"invalid trace code"</span>)</span><br><span class="line">&#125;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"worker, trace code:%s\n"</span>, traceCode)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"worker done!"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line"><span class="comment">// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合</span></span><br><span class="line">ctx = context.WithValue(ctx, TraceCode(<span class="string">"TRACE_CODE"</span>), <span class="string">"12512312234"</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Context的注意事项"><a href="#使用Context的注意事项" class="headerlink" title="使用Context的注意事项"></a>使用Context的注意事项</h2><ul><li>推荐以参数的方式显示传递Context</li><li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li><li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li><li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li><li>Context是线程安全的，可以放心的在多个goroutine中传递</li></ul><h2 id="客户端超时取消示例"><a href="#客户端超时取消示例" class="headerlink" title="客户端超时取消示例"></a>客户端超时取消示例</h2><p>调用服务端API时如何在客户端实现超时控制？</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/server/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server端，随机出现慢响应</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">number := rand.Intn(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> number == <span class="number">0</span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>) <span class="comment">// 耗时10秒的慢响应</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">"slow response"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprint(w, <span class="string">"quick response"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, indexHandler)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/client/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> respData <span class="keyword">struct</span> &#123;</span><br><span class="line">resp *http.Response</span><br><span class="line">err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCall</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">transport := http.Transport&#123;</span><br><span class="line">   <span class="comment">// 请求频繁可定义全局的client对象并启用长链接</span></span><br><span class="line">   <span class="comment">// 请求不频繁使用短链接</span></span><br><span class="line">   DisableKeepAlives: <span class="literal">true</span>, &#125;</span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">respChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *respData, <span class="number">1</span>)</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://127.0.0.1:8000/"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"new requestg failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">req = req.WithContext(ctx) <span class="comment">// 使用带超时的ctx创建一个新的client request</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> wg.Wait()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line">fmt.Printf(<span class="string">"client.do resp:%v, err:%v\n"</span>, resp, err)</span><br><span class="line">rd := &amp;respData&#123;</span><br><span class="line">resp: resp,</span><br><span class="line">err:  err,</span><br><span class="line">&#125;</span><br><span class="line">respChan &lt;- rd</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//transport.CancelRequest(req)</span></span><br><span class="line">fmt.Println(<span class="string">"call api timeout"</span>)</span><br><span class="line"><span class="keyword">case</span> result := &lt;-respChan:</span><br><span class="line">fmt.Println(<span class="string">"call server api success"</span>)</span><br><span class="line"><span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"call server api failed, err:%v\n"</span>, result.err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> result.resp.Body.Close()</span><br><span class="line">data, _ := ioutil.ReadAll(result.resp.Body)</span><br><span class="line">fmt.Printf(<span class="string">"resp:%v\n"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个100毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 调用cancel释放子goroutine资源</span></span><br><span class="line">doCall(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用go module导入本地</title>
      <link href="/2020/03/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go-module%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/"/>
      <url>/2020/03/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go-module%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用go-module导入本地包"><a href="#如何使用go-module导入本地包" class="headerlink" title="如何使用go module导入本地包"></a>如何使用go module导入本地包</h1><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p><p>这几天已经有很多教程讲解如何使用<code>go module</code>，以及如何使用<code>go module</code>导入gitlab私有仓库，我这里就不再啰嗦了。但是最近我发现很多小伙伴在群里问如何使用<code>go module</code>导入本地包，作为初学者大家刚开始接触package的时候肯定都是先在本地创建一个包，然后本地调用一下，然后就被卡住了。。。</p><p>这里就详细介绍下如何使用<code>go module</code>导入本地包。</p><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p><p><code>mypackage/mypackage.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"mypackage.New"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在分两种情况讨论：</p><h2 id="在同一个项目下"><a href="#在同一个项目下" class="headerlink" title="在同一个项目下"></a>在同一个项目下</h2><p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">moduledemo</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"moduledemo/mypackage"</span>  <span class="comment">// 导入同一项目下的mypackage包</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>举一反三，假设我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── bubble</span><br><span class="line">    ├── dao</span><br><span class="line">    │   └── mysql.go</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure><p>其中<code>bubble/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/bubble</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>bubble/dao/mysql.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"mypackage.New"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bubble/main.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/q1mi/bubble/dao"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dao.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不在同一个项目下"><a href="#不在同一个项目下" class="headerlink" title="不在同一个项目下"></a>不在同一个项目下</h2><h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── moduledemo</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h3 id="导入包-1"><a href="#导入包-1" class="headerlink" title="导入包"></a>导入包</h3><p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"mypackage"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p><p>在调用方也就是<code>packagedemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">"mypackage"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"mypackage"</span> =&gt; <span class="string">"../mypackage"</span></span><br></pre></td></tr></table></figure><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><p>最后我们再举个例子巩固下上面的内容。</p><p>我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── p2</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── p2.go</span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p><p><code>p2/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中按如下方式导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"liwenzhou.com/q1mi/p2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p2.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p><p><code>p1/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/p1</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">"liwenzhou.com/q1mi/p2"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"liwenzhou.com/q1mi/p2"</span> =&gt; <span class="string">"../p2"</span></span><br></pre></td></tr></table></figure><p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p><p>说再多也没用，自己动手试试吧。</p>]]></content>
      
      
      <categories>
          
          <category> Go进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO依赖管理GO Module的使用</title>
      <link href="/2020/03/02/GO%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86GO-Module%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/02/GO%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86GO-Module%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言之依赖管理"><a href="#Go语言之依赖管理" class="headerlink" title="Go语言之依赖管理"></a>Go语言之依赖管理</h1><p>Go语言的依赖管理随着版本的更迭正逐渐完善起来。</p><a id="more"></a><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h2><p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p><h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p><p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装<code>godep</code>工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/tools/godep</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">godep save     将依赖项输出并复制到Godeps.json文件中</span><br><span class="line">godep go       使用保存的依赖项运行go工具</span><br><span class="line">godep get      下载并安装具有指定依赖项的包</span><br><span class="line">godep path     打印依赖的GOPATH路径</span><br><span class="line">godep restore  在GOPATH中拉取依赖的版本</span><br><span class="line">godep update   更新选定的包或go版本</span><br><span class="line">godep diff     显示当前和以前保存的依赖项集之间的差异</span><br><span class="line">godep version  查看版本信息</span><br></pre></td></tr></table></figure><p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p><h3 id="使用godep"><a href="#使用godep" class="headerlink" title="使用godep"></a>使用godep</h3><p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p><p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p><h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p><p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p><h3 id="godep开发流程"><a href="#godep开发流程" class="headerlink" title="godep开发流程"></a>godep开发流程</h3><ol><li>保证程序能够正常编译</li><li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li><li>提交Godeps目录和vender目录到代码库。</li><li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li></ol><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p><ol><li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li><li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li><li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li></ol><p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p><p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.11之后设置GOPROXY命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn  //mac</span><br><span class="line"><span class="built_in">set</span> GOPROXY=https://goproxy.cn  //window</span><br></pre></td></tr></table></figure><p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014" target="_blank" rel="noopener">goproxy.cn</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的<code>go mod</code>命令如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）</span><br><span class="line"><span class="comment">/*require github.com/Shopify/sarama v1.19.0</span></span><br><span class="line"><span class="comment">$ go mod download</span></span><br><span class="line"><span class="comment">go: finding github.com/Shopify/sarama v1.19.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">go</span> mod edit        编辑<span class="keyword">go</span>.mod文件</span><br><span class="line"><span class="keyword">go</span> mod graph       打印模块依赖图</span><br><span class="line"><span class="keyword">go</span> mod init        初始化当前文件夹, 创建<span class="keyword">go</span>.mod文件</span><br><span class="line"><span class="keyword">go</span> mod tidy        增加缺少的module，删除无用的module</span><br><span class="line"><span class="keyword">go</span> mod vendor      将依赖复制到vendor下</span><br><span class="line"><span class="keyword">go</span> mod verify      校验依赖</span><br><span class="line"><span class="keyword">go</span> mod why         解释为什么需要依赖</span><br></pre></td></tr></table></figure><h3 id="go-sum-pkg文件下"><a href="#go-sum-pkg文件下" class="headerlink" title="go  sum  pkg文件下"></a>go  sum  pkg文件下</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体使用方式</span></span><br><span class="line"><span class="keyword">go</span> get github.com/xxxxx</span><br><span class="line">$set GOMODULE=on</span><br><span class="line">$set GOPROxy=https:<span class="comment">//goproxy.cn</span></span><br><span class="line">$<span class="keyword">go</span> mod init</span><br><span class="line"><span class="keyword">go</span> get github.com/xxxxx <span class="comment">//会拉去相关的依赖在，mod.go文件中可以查看到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mod文件</span></span><br><span class="line">module studygo/day01/<span class="number">64</span>tailf_demo</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.13</span></span><br><span class="line">require (</span><br><span class="line">github.com/hpcloud/tail v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200302150141</span><span class="number">-5</span>c8b2ff67527 <span class="comment">// indirect</span></span><br><span class="line">gopkg.in/fsnotify.v1 v1<span class="number">.4</span><span class="number">.7</span> <span class="comment">// indirect</span></span><br><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7 <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>go.mod文件记录了项目所有的依赖信息和版本信息，其结构大致如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Q1mi/studygo/blogger</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586</span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br><span class="line">github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">github.com/jmoiron/sqlx v1.2.0</span><br><span class="line">github.com/satori/go.uuid v1.2.0</span><br><span class="line">google.golang.org/appengine v1.6.1 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>module</code>用来定义包名</li><li><code>require</code>用来定义依赖包及版本</li><li><code>indirect</code>表示间接引用</li></ul><h4 id="依赖的版本"><a href="#依赖的版本" class="headerlink" title="依赖的版本"></a>依赖的版本</h4><p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922</span>f4815f713 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p><ol><li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li><li>运行<code>go get package@version</code>将会升级到指定的版本号version</li></ol><p>如果下载所有依赖可以使用<code>go mod download</code>命令。</p><h3 id="整理依赖"><a href="#整理依赖" class="headerlink" title="整理依赖"></a>整理依赖</h3><p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p><h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require=golang.org/x/text</span><br></pre></td></tr></table></figure><h4 id="移除依赖项"><a href="#移除依赖项" class="headerlink" title="移除依赖项"></a>移除依赖项</h4><p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -droprequire=golang.org/x/text</span><br></pre></td></tr></table></figure><p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p><h2 id="在项目中使用go-module"><a href="#在项目中使用go-module" class="headerlink" title="在项目中使用go module"></a>在项目中使用go module</h2><h3 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h3><p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p><ol><li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li><li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录<strong>每个依赖库的版本和哈希值。</strong></li></ol><h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p><ol><li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li><li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库time</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93time/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93time/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之time包"><a href="#Go语言基础之time包" class="headerlink" title="Go语言基础之time包"></a>Go语言基础之time包</h1><p>时间和日期是我们编程中经常会用到的，本文主要介绍了Go语言内置的time包的基本用法。</p><a id="more"></a><h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p>time包提供了时间的显示和测量用的函数。日历的计算采用的是公历。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p><code>time.Time</code>类型表示时间。我们可以通过<code>time.Now()</code>函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">fmt.Printf(<span class="string">"current time:%v\n"</span>, now)</span><br><span class="line"></span><br><span class="line">year := now.Year()     <span class="comment">//年</span></span><br><span class="line">month := now.Month()   <span class="comment">//月</span></span><br><span class="line">day := now.Day()       <span class="comment">//日</span></span><br><span class="line">hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := now.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。</p><p>基于时间对象获取时间戳的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()            <span class="comment">//获取当前时间</span></span><br><span class="line">timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">fmt.Printf(<span class="string">"current timestamp1:%v\n"</span>, timestamp1)</span><br><span class="line">fmt.Printf(<span class="string">"current timestamp2:%v\n"</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>time.Unix()</code>函数可以将时间戳转为时间格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo2</span><span class="params">(timestamp <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p><p>time包中定义的时间间隔类型的常量如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure><p>举个例子，求一个小时之后的时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">later := now.Add(time.Hour) <span class="comment">// 当前时间加1小时后的时间</span></span><br><span class="line">fmt.Println(later)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>求两个时间之间的差值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure><p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p><h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之前，返回真；否则返回假。</p><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之后，返回真；否则返回假。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>时间类型有一个自带的方法<code>Format</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。也许这就是技术人员的浪漫吧。</p><p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line"><span class="comment">// 24小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 15:04:05.000 Mon Jan"</span>))</span><br><span class="line"><span class="comment">// 12小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 03:04:05.000 PM Mon Jan"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006/01/02 15:04"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"15:04 2006/01/02"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006/01/02"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">"Asia/Shanghai"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">"2006/01/02 15:04:05"</span>, <span class="string">"2019/08/04 14:15:20"</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure><p>练习题：</p><ol><li>获取当前时间，格式化输出为2017/06/19 20:30:05`格式。</li><li>编写程序统计一段代码的执行耗时时间，单位精确到微秒。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库strconv</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93strconv/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93strconv/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言内置包之strconv"><a href="#Go语言内置包之strconv" class="headerlink" title="Go语言内置包之strconv"></a>Go语言内置包之strconv</h1><p>Go语言中<code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p><a id="more"></a><h1 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h1><p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： <code>Atoi()</code>、<code>Itia()</code>、parse系列、format系列、append系列。</p><p>更多函数请查看<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="string与int类型转换"><a href="#string与int类型转换" class="headerlink" title="string与int类型转换"></a>string与int类型转换</h2><p>这一组函数是我们平时编程中用的最多的。</p><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"100"</span></span><br><span class="line">i1, err := strconv.Atoi(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"can't convert to int"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, i1, i1) <span class="comment">//type:int value:100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i2 := <span class="number">200</span></span><br><span class="line">s2 := strconv.Itoa(i2)</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, s2, s2) <span class="comment">//type:string value:"200"</span></span><br></pre></td></tr></table></figure><h3 id="a的典故"><a href="#a的典故" class="headerlink" title="a的典故"></a>a的典故</h3><p>【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以<code>Itoa</code>对很多C系的程序员很好理解。</p><h2 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h2><p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p><h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p><h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>返回字符串表示的整数值，接受正负号。</p><p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p><p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p><p>返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p><h3 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p><h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>解析一个表示浮点数的字符串并返回其值。</p><p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。</p><p>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；</p><p>返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b, err := strconv.ParseBool(<span class="string">"true"</span>)</span><br><span class="line">f, err := strconv.ParseFloat(<span class="string">"3.1415"</span>, <span class="number">64</span>)</span><br><span class="line">i, err := strconv.ParseInt(<span class="string">"-2"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">u, err := strconv.ParseUint(<span class="string">"2"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p><h2 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h2><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p><h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>根据b的值返回”true”或”false”。</p><h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p><h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>是FormatInt的无符号整数版本。</p><h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>函数将浮点数表示为字符串并返回。</p><p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p><p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p><p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := strconv.FormatBool(<span class="literal">true</span>)</span><br><span class="line">s2 := strconv.FormatFloat(<span class="number">3.1415</span>, <span class="string">'E'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">s3 := strconv.FormatInt(<span class="number">-2</span>, <span class="number">16</span>)</span><br><span class="line">s4 := strconv.FormatUint(<span class="number">2</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="isPrint"><a href="#isPrint" class="headerlink" title="isPrint()"></a>isPrint()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>返回一个字符是否是可打印的，和<code>unicode.IsPrint</code>一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p><h3 id="CanBackquote"><a href="#CanBackquote" class="headerlink" title="CanBackquote()"></a>CanBackquote()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanBackquote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>除上文列出的函数外，<code>strconv</code>包中还有Append系列、Quote系列等函数。具体用法可查看<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库strconv</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93nethttp/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93nethttp/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之net-http"><a href="#Go语言基础之net-http" class="headerlink" title="Go语言基础之net/http"></a>Go语言基础之net/http</h1><p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p><a id="more"></a><h2 id="net-http介绍"><a href="#net-http介绍" class="headerlink" title="net/http介绍"></a>net/http介绍</h2><p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><h3 id="基本的HTTP-HTTPS请求"><a href="#基本的HTTP-HTTPS请求" class="headerlink" title="基本的HTTP/HTTPS请求"></a>基本的HTTP/HTTPS请求</h3><p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">"http://example.com/upload"</span>, <span class="string">"image/jpeg"</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>,</span><br><span class="line">url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>程序在使用完response后必须关闭回复的主体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="GET请求示例"><a href="#GET请求示例" class="headerlink" title="GET请求示例"></a>GET请求示例</h3><p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.liwenzhou.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from resp.Body failed,err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>liwenzhou.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p><h3 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h3><p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apiUrl := <span class="string">"http://127.0.0.1:9090/get"</span></span><br><span class="line"><span class="comment">// URL param</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">"name"</span>, <span class="string">"小王子"</span>)</span><br><span class="line">data.Set(<span class="string">"age"</span>, <span class="string">"18"</span>)</span><br><span class="line">u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"parse url requestUrl failed,err:%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line">resp, err := http.Get(u.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">data := r.URL.Query()</span><br><span class="line">fmt.Println(data.Get(<span class="string">"name"</span>))</span><br><span class="line">fmt.Println(data.Get(<span class="string">"age"</span>))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post请求示例"><a href="#Post请求示例" class="headerlink" title="Post请求示例"></a>Post请求示例</h3><p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http post demo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := <span class="string">"http://127.0.0.1:9090/post"</span></span><br><span class="line"><span class="comment">// 表单数据</span></span><br><span class="line"><span class="comment">//contentType := "application/x-www-form-urlencoded"</span></span><br><span class="line"><span class="comment">//data := "name=小王子&amp;age=18"</span></span><br><span class="line"><span class="comment">// json</span></span><br><span class="line">contentType := <span class="string">"application/json"</span></span><br><span class="line">data := <span class="string">`&#123;"name":"小王子","age":18&#125;`</span></span><br><span class="line">resp, err := http.Post(url, contentType, strings.NewReader(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"><span class="comment">// 1. 请求类型是application/x-www-form-urlencoded时解析form数据</span></span><br><span class="line">r.ParseForm()</span><br><span class="line">fmt.Println(r.PostForm) <span class="comment">// 打印form数据</span></span><br><span class="line">fmt.Println(r.PostForm.Get(<span class="string">"name"</span>), r.PostForm.Get(<span class="string">"age"</span>))</span><br><span class="line"><span class="comment">// 2. 请求类型是application/json时从r.Body读取数据</span></span><br><span class="line">b, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read request.Body failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Client"><a href="#自定义Client" class="headerlink" title="自定义Client"></a>自定义Client</h3><p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"http://example.com"</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="自定义Transport"><a href="#自定义Transport" class="headerlink" title="自定义Transport"></a>自定义Transport</h3><p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">TLSClientConfig:    &amp;tls.Config&#123;RootCAs: pool&#125;,</span><br><span class="line">DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="默认的Server"><a href="#默认的Server" class="headerlink" title="默认的Server"></a>默认的Server</h3><p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p><p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><h3 id="默认的Server示例"><a href="#默认的Server示例" class="headerlink" title="默认的Server示例"></a>默认的Server示例</h3><p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http server</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">"Hello 沙河！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"http server failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="https://www.liwenzhou.com/images/Go/socket/hello.png" alt="hello页面"></p><h3 id="自定义Server"><a href="#自定义Server" class="headerlink" title="自定义Server"></a>自定义Server</h3><p>要管理服务端的行为，可以创建一个自定义的Server：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">Addr:           <span class="string">":8080"</span>,</span><br><span class="line">Handler:        myHandler,</span><br><span class="line">ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库log</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93log/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93log/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库log介绍"><a href="#Go语言标准库log介绍" class="headerlink" title="Go语言标准库log介绍"></a>Go语言标准库log介绍</h1><p>无论是软件开发的调试阶段还是软件上线之后的运行阶段，日志一直都是非常重要的一个环节，我们也应该养成在程序中记录日志的好习惯。</p><a id="more"></a><h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p><h2 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h2><p>log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数<code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和<code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。</p><p>例如，我们可以像下面的代码一样直接通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">v := <span class="string">"很普通的"</span></span><br><span class="line">log.Printf(<span class="string">"这是一条%s日志。\n"</span>, v)</span><br><span class="line">log.Fatalln(<span class="string">"这是一条会触发fatal的日志。"</span>)</span><br><span class="line">log.Panicln(<span class="string">"这是一条会触发panic的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上面的代码会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017/06/19 14:04:17 这是一条很普通的日志。</span><br><span class="line">2017/06/19 14:04:17 这是一条很普通的日志。</span><br><span class="line">2017/06/19 14:04:17 这是一条会触发fatal的日志。</span><br></pre></td></tr></table></figure><p>logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p><h2 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h2><h3 id="标准logger的配置"><a href="#标准logger的配置" class="headerlink" title="标准logger的配置"></a>标准logger的配置</h3><p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p><p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h3><p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 控制输出日志信息的细节，不能控制输出的顺序和格式。</span></span><br><span class="line">    <span class="comment">// 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</span></span><br><span class="line">    Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 日期：2009/01/23</span></span><br><span class="line">    Ltime                         <span class="comment">// 时间：01:23:23</span></span><br><span class="line">    Lmicroseconds                 <span class="comment">// 微秒级别的时间：01:23:23.123123（用于增强Ltime位）</span></span><br><span class="line">    Llongfile                     <span class="comment">// 文件全路径名+行号： /a/b/c/d.go:23</span></span><br><span class="line">    Lshortfile                    <span class="comment">// 文件名+行号：d.go:23（会覆盖掉Llongfile）</span></span><br><span class="line">    LUTC                          <span class="comment">// 使用UTC时间</span></span><br><span class="line">    LstdFlags     = Ldate | Ltime <span class="comment">// 标准logger的初始值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们在记录日志之前先设置一下标准logger的输出选项如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后得到的输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">17.494943</span> .../log_demo/main.<span class="keyword">go</span>:<span class="number">11</span>: 这是一条很普通的日志。</span><br></pre></td></tr></table></figure><h3 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h3><p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prefix</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPrefix</span><span class="params">(prefix <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">log.SetPrefix(<span class="string">"[小王子]"</span>)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。</span><br></pre></td></tr></table></figure><p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p><h3 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure><p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p><p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFile, err := os.OpenFile(<span class="string">"./xx.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open log file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">log.SetPrefix(<span class="string">"[小王子]"</span>)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFile, err := os.OpenFile(<span class="string">"./xx.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open log file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建logger"><a href="#创建logger" class="headerlink" title="创建logger"></a>创建logger</h2><p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。<code>New</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span></span><br></pre></td></tr></table></figure><p>New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger := log.New(os.Stdout, <span class="string">"&lt;New&gt;"</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">logger.Println(<span class="string">"这是自定义的logger记录的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译执行之后，得到结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如<a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a>、<a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a>等。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库flag</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93flag/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93flag/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库flag基本使用"><a href="#Go语言标准库flag基本使用" class="headerlink" title="Go语言标准库flag基本使用"></a>Go语言标准库flag基本使用</h1><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><a id="more"></a><h1 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h1><p>如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//os.Args demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">"args[%d]=%v\n"</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><strong><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</strong></p><h1 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a><strong>flag包基本使用</strong></h1><p>本文介绍了flag包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="导入flag包"><a href="#导入flag包" class="headerlink" title="导入flag包"></a>导入flag包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flag</span><br></pre></td></tr></table></figure><h2 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><table><thead><tr><th align="center">flag参数</th><th align="center">有效值</th></tr></thead><tbody><tr><td align="center">字符串flag</td><td align="center">合法字符串</td></tr><tr><td align="center">整数flag</td><td align="center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td align="center">浮点数flag</td><td align="center">合法浮点数</td></tr><tr><td align="center">bool类型flag</td><td align="center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td align="center">时间段flag</td><td align="center">任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td></tr></tbody></table><h2 id="定义命令行flag参数"><a href="#定义命令行flag参数" class="headerlink" title="定义命令行flag参数"></a>定义命令行flag参数</h2><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">age := flag.Int(<span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">married := flag.Bool(<span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"时间间隔"</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"时间间隔"</span>)</span><br></pre></td></tr></table></figure><h2 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h2><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p><h2 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义命令行参数方式1</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"延迟的时间间隔"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析命令行参数</span></span><br><span class="line">flag.Parse()<span class="comment">//解析传入命令参数，传递给对应变量</span></span><br><span class="line">fmt.Println(name, age, married, delay)</span><br><span class="line"><span class="comment">//返回命令行参数后的其他参数</span></span><br><span class="line">fmt.Println(flag.Args())</span><br><span class="line"><span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">fmt.Println(flag.NArg())</span><br><span class="line"><span class="comment">//返回使用的命令行参数个数</span></span><br><span class="line">fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>命令行参数使用提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -<span class="built_in">help</span></span><br><span class="line">Usage of ./flag_demo:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -married</span><br><span class="line">        婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default <span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure><p>正常使用命令行flag参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -name 沙河娜扎 --age 28 -married=<span class="literal">false</span> -d=1h30m</span><br><span class="line">沙河娜扎 28 <span class="literal">false</span> 1h30m0s</span><br><span class="line">[]</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>使用非flag命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo a b c</span><br><span class="line">张三 18 <span class="literal">false</span> 0s</span><br><span class="line">[a b c]</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言性能优化</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Go性能调优"><a href="#Go性能调优" class="headerlink" title="Go性能调优"></a>Go性能调优</h1><p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库，这篇文章就要讲解怎么在 golang 中做 profiling。</p><a id="more"></a><h1 id="Go性能优化"><a href="#Go性能优化" class="headerlink" title="Go性能优化"></a>Go性能优化</h1><p>Go语言项目中的性能优化主要有以下几个方面：</p><ul><li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li><li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li><li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li><li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li></ul><h2 id="采集性能数据"><a href="#采集性能数据" class="headerlink" title="采集性能数据"></a>采集性能数据</h2><p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p><ul><li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li><li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li></ul><p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取格格函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p><p>注意，我们只应该在性能测试的时候才在代码中引入pprof。</p><h2 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h2><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime/pprof"</span></span><br></pre></td></tr></table></figure><h3 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h3><p>开启CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>停止CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用<code>go tool pprof</code>工具进行CPU性能分析。</p><h3 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h3><p>记录程序的堆栈信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>得到采样数据之后，使用<code>go tool pprof</code>工具进行内存性能分析。</p><p><code>go tool pprof</code>默认是使用<code>-inuse_space</code>进行统计，还可以使用<code>-inuse-objects</code>查看分配对象的数量。</p><h2 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h2><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p><p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure><p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/trace"</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>如果你使用的是gin框架，那么推荐使用<code>&quot;github.com/DeanThompson/ginpprof&quot;</code>。</p><p>不管哪种方式，你的 HTTP 服务都会多出<code>/debug/pprof</code> endpoint，访问它会得到类似下面的内容：<img src="https://www.liwenzhou.com/images/Go/performance_optimisation/pprof2.png" alt="debug/pprof">这个路径下还有几个子页面：</p><ul><li>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载</li><li>/debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li><li>/debug/pprof/block：block Profiling 的路径</li><li>/debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系</li></ul><h2 id="go-tool-pprof命令"><a href="#go-tool-pprof命令" class="headerlink" title="go tool pprof命令"></a>go tool pprof命令</h2><p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code>命令行工具。</p><p><code>go tool pprof</code>最简单的使用方式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>binary 是应用的二进制文件，用来解析各种符号；</li><li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li></ul><p><strong>注意事项：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>首先我们来写一段有问题的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime_pprof/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime/pprof"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段有问题的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">fmt.Printf(<span class="string">"recv from chan, value:%v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> isCPUPprof <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> isMemPprof <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;isCPUPprof, <span class="string">"cpu"</span>, <span class="literal">false</span>, <span class="string">"turn cpu pprof on"</span>)</span><br><span class="line">flag.BoolVar(&amp;isMemPprof, <span class="string">"mem"</span>, <span class="literal">false</span>, <span class="string">"turn mem pprof on"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isCPUPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">"./cpu.pprof"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"create cpu pprof failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.StartCPUProfile(file)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> logicCode()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> isMemPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">"./mem.pprof"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"create mem pprof failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.WriteHeapProfile(file)</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过flag我们可以在命令行控制是否开启CPU和Mem的性能分析。 将上面的代码保存并编译成<code>runtime_pprof</code>可执行文件，执行时加上<code>-cpu</code>命令行参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./runtime_pprof -cpu</span><br></pre></td></tr></table></figure><p>等待30秒后会在当前目录下生成一个<code>cpu.pprof</code>文件。</p><h3 id="命令行交互界面"><a href="#命令行交互界面" class="headerlink" title="命令行交互界面"></a>命令行交互界面</h3><p>我们使用go工具链里的<code>pprof</code>来分析一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof cpu.pprof</span><br></pre></td></tr></table></figure><p>执行上面的代码会进入交互界面如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtime_pprof $ go tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Jun 28, 2019 at 11:28am (CST)</span><br><span class="line">Duration: 20.13s, Total samples = 1.91mins (568.60%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>我们可以在交互界面输入<code>top 3</code>来查看程序中占用CPU前3位的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top 3</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> 100.37s, 87.68% of 114.47s total</span><br><span class="line">Dropped 17 nodes (cum &lt;= 0.57s)</span><br><span class="line">Showing top 3 nodes out of 4</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    42.52s 37.15% 37.15%     91.73s 80.13%  runtime.selectnbrecv</span><br><span class="line">    35.21s 30.76% 67.90%     39.49s 34.50%  runtime.chanrecv</span><br><span class="line">    22.64s 19.78% 87.68%    114.37s 99.91%  main.logicCode</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>flat：当前函数占用CPU的耗时</li><li>flat：:当前函数占用CPU的耗时百分比</li><li>sun%：函数占用CPU的耗时累计百分比</li><li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li><li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li><li>最后一列：函数名称</li></ul><p>在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p><p>我们还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list logicCode</code>查看我们编写的函数的详细分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list logicCode</span><br><span class="line">Total: 1.91mins</span><br><span class="line">ROUTINE ================ main.logicCode <span class="keyword">in</span> .../runtime_pprof/main.go</span><br><span class="line">    22.64s   1.91mins (flat, cum) 99.91% of Total</span><br><span class="line">         .          .     12:func <span class="function"><span class="title">logicCode</span></span>() &#123;</span><br><span class="line">         .          .     13:   var c chan int</span><br><span class="line">         .          .     14:   <span class="keyword">for</span> &#123;</span><br><span class="line">         .          .     15:           select &#123;</span><br><span class="line">         .          .     16:           <span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">    22.64s   1.91mins     17:                   fmt.Printf(<span class="string">"recv from chan, value:%v\n"</span>, v)</span><br><span class="line">         .          .     18:           default:</span><br><span class="line">         .          .     19:</span><br><span class="line">         .          .     20:           &#125;</span><br><span class="line">         .          .     21:   &#125;</span><br><span class="line">         .          .     22:&#125;</span><br></pre></td></tr></table></figure><p>通过分析发现大部分CPU资源被17行占用，我们分析出select语句中的default没有内容会导致上面的<code>case v:=&lt;-c:</code>一直执行。我们在default分支添加一行<code>time.Sleep(time.Second)</code>即可。</p><h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。 想要查看图形化的界面首先需要安装<a href="https://graphviz.gitlab.io/" target="_blank" rel="noopener">graphviz</a>图形化工具。</p><p>Mac：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>Windows: 下载<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html" target="_blank" rel="noopener">graphviz</a> 将<code>graphviz</code>安装目录下的bin文件夹添加到Path环境变量中。 在终端输入<code>dot -version</code>查看是否安装成功。</p><p><img src="https://www.liwenzhou.com/images/Go/performance_optimisation/cpu_pprof.png" alt="CPU占比图">关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。 线条上的数字表示函数调用的次数。 方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p><h2 id="go-torch和火焰图"><a href="#go-torch和火焰图" class="headerlink" title="go-torch和火焰图"></a>go-torch和火焰图</h2><p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling 结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：<code>go-torch</code>。这是 uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。</p><h3 id="安装go-touch"><a href="#安装go-touch" class="headerlink" title="安装go-touch"></a>安装go-touch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -v github.com/uber/go-torch</span><br></pre></td></tr></table></figure><p>火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in 分析它上面的内容。</p><p>火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用 CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p><p>go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从<code>http://localhost:8080/debug/pprof/profile</code>获取 profiling 数据。它有三个常用的参数可以调整：</p><ul><li>-u –url：要访问的 URL，这里只是主机和端口部分</li><li>-s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile</li><li>–seconds：要执行 profiling 的时间长度，默认为 30s</li></ul><h3 id="安装-FlameGraph"><a href="#安装-FlameGraph" class="headerlink" title="安装 FlameGraph"></a>安装 FlameGraph</h3><p>要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。</p><ol><li>下载安装perl：<a href="https://www.perl.org/get.html" target="_blank" rel="noopener">https://www.perl.org/get.html</a></li><li>下载FlameGraph：<code>git clone https://github.com/brendangregg/FlameGraph.git</code></li><li>将<code>FlameGraph</code>目录加入到操作系统的环境变量中。</li><li>Windows平台的同学，需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code>按如下方式修改，然后在<code>go-torch</code>目录下执行<code>go install</code>即可。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) &#123;</span></span><br><span class="line">flameGraph := findInPath(flameGraphScripts)</span><br><span class="line"><span class="keyword">if</span> flameGraph == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errNoPerlScript</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> runScript(<span class="string">"perl"</span>, <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;flameGraph&#125;, args...), graphInput)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> runScript(flameGraph, args, graphInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h3><p>推荐使用<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">https://github.com/wg/wrk</a> 或 <a href="https://github.com/adjust/go-wrk" target="_blank" rel="noopener">https://github.com/adjust/go-wrk</a></p><h3 id="使用go-torch"><a href="#使用go-torch" class="headerlink" title="使用go-torch"></a>使用go-torch</h3><p>使用wrk进行压测:<code>go-wrk -n 50000 http://127.0.0.1:8080/book/list</code> 在上面压测进行的同时，打开另一个终端执行<code>go-torch -u http://127.0.0.1:8080 -t 30</code>，30秒之后终端会初夏如下提示：<code>Writing svg to torch.svg</code></p><p>然后我们使用浏览器打开<code>torch.svg</code>就能看到如下火焰图了。<img src="https://www.liwenzhou.com/images/Go/performance_optimisation/pprof3.png" alt="火焰图">火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p><h2 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h2><p><code>go test</code>命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p><ul><li>-cpuprofile：cpu profiling 数据要保存的文件地址</li><li>-memprofile：memory profiling 数据要报文的文件地址</li></ul><p>我们还可以选择将pprof与性能测试相结合，比如：</p><p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.prof</span><br></pre></td></tr></table></figure><p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -memprofile=./mem.prof</span><br></pre></td></tr></table></figure><p>需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下 Profiling 才有意义。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用gin框架编写一个接口，使用<code>go-wrk</code>进行压测，使用性能调优工具采集数据绘制出调用图和火焰图。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言操作Mysql</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMysql/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言操作MySQL"><a href="#Go语言操作MySQL" class="headerlink" title="Go语言操作MySQL"></a>Go语言操作MySQL</h1><p>MySQL是常用的关系型数据库，本文介绍了Go语言如何操作MySQL数据库。</p><a id="more"></a><h1 id="Go操作MySQL"><a href="#Go操作MySQL" class="headerlink" title="Go操作MySQL"></a>Go操作MySQL</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>Go语言中的<code>database/sql</code>包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用<code>database/sql</code>包时必须注入（至少）一个数据库驱动。</p><p>我们常用的数据库基本上都有完整的第三方实现。例如：<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">MySQL驱动</a></p><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><h3 id="使用MySQL驱动"><a href="#使用MySQL驱动" class="headerlink" title="使用MySQL驱动"></a>使用MySQL驱动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span></span><br></pre></td></tr></table></figure><p>Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般包至少括数据库文件名和（可能的）连接信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/dbname"</span></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()  <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题</strong>： 为什么上面代码中的<code>defer db.Close()</code>语句不应该写在<code>if err != nil</code>的前面呢？</p><h3 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h3><p>Open函数可能只是验证其参数，而不创建与数据库的连接。如果要检查数据源的名称是否合法，应调用返回值的Ping方法。</p><p>返回的DB可以安全的被多个goroutine同时使用，并会维护自身的闲置连接池。这样一来，Open函数只需调用一次。很少需要关闭DB。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span></span><br><span class="line"><span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line"><span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">db, err = sql.Open(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"init db failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sql.DB</code>是一个数据库（操作）句柄，代表一个具有零到多个底层连接的连接池。它可以安全的被多个go程同时使用。<code>database/sql</code>包会自动创建和释放连接；它也会维护一个闲置连接的连接池。</p><h3 id="SetMaxOpenConns"><a href="#SetMaxOpenConns" class="headerlink" title="SetMaxOpenConns"></a>SetMaxOpenConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxOpenConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>SetMaxOpenConns</code>设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会限制最大开启连接数，默认为0（无限制）。</p><h3 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a>SetMaxIdleConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxIdleConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>SetMaxIdleConns设置连接池中的最大闲置连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会保留闲置连接。</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h3><p>我们先在MySQL中创建一个名为<code>sql_test</code>的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sql_test;</span><br></pre></td></tr></table></figure><p>进入该数据库:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> sql_test;</span><br></pre></td></tr></table></figure><p>执行以下命令创建一张用于测试的数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`age`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="单行查询"><a href="#单行查询" class="headerlink" title="单行查询"></a>单行查询</h4><p>单行查询<code>db.QueryRow()</code>执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryRow</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br></pre></td></tr></table></figure><p>具体示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id=?"</span></span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line"><span class="comment">// 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放</span></span><br><span class="line">err := db.QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多行查询"><a href="#多行查询" class="headerlink" title="多行查询"></a>多行查询</h4><p>多行查询<code>db.Query()</code>执行一次查询，返回多行结果（即Rows），一般用于执行select命令。参数args表示query中的占位参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure><p>具体示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询多条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line">rows, err := db.Query(sqlStr, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非常重要：关闭rows释放持有的数据库链接</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取结果集中的数据</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入、更新和删除操作都使用*[Math Processing Error]*方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Exec</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br></pre></td></tr></table></figure><p>Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。</p><p>具体插入数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="string">"王五"</span>, <span class="number">38</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get lastinsert ID failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"insert success, the id is %d.\n"</span>, theID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>具体更新数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"update user set age=? where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"update failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"update success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>具体删除数据的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"delete from user where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"delete failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"delete success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySQL预处理"><a href="#MySQL预处理" class="headerlink" title="MySQL预处理"></a>MySQL预处理</h2><h3 id="什么是预处理？"><a href="#什么是预处理？" class="headerlink" title="什么是预处理？"></a>什么是预处理？</h3><p>普通SQL语句执行过程：</p><ol><li>客户端对SQL语句进行占位符替换得到完整的SQL语句。</li><li>客户端发送完整SQL语句到MySQL服务端</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><p>预处理执行过程：</p><ol><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><h3 id="为什么要预处理？"><a href="#为什么要预处理？" class="headerlink" title="为什么要预处理？"></a>为什么要预处理？</h3><ol><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ol><h3 id="Go实现MySQL预处理"><a href="#Go实现MySQL预处理" class="headerlink" title="Go实现MySQL预处理"></a>Go实现MySQL预处理</h3><p>Go中的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Prepare</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br></pre></td></tr></table></figure><p><code>Prepare</code>方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p><p>查询操作的预处理示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理查询示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareQueryDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prepare failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">rows, err := stmt.Query(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="comment">// 循环读取结果集中的数据</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入、更新和删除操作的预处理十分类似，这里以插入操作的预处理为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理插入示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareInsertDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prepare failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">_, err = stmt.Exec(<span class="string">"小王子"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = stmt.Exec(<span class="string">"沙河娜扎"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"insert success."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go实现MySQL事务"><a href="#Go实现MySQL事务" class="headerlink" title="Go实现MySQL事务"></a>Go实现MySQL事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。</p><p>在MySQL中只有使用了<code>Innodb</code>数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>通常事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><table><thead><tr><th align="center">条件</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">原子性</td><td align="center">一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</td></tr><tr><td align="center">一致性</td><td align="center">在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</td></tr><tr><td align="center">隔离性</td><td align="center">数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</td></tr><tr><td align="center">持久性</td><td align="center">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td></tr></tbody></table><h3 id="事务相关方法"><a href="#事务相关方法" class="headerlink" title="事务相关方法"></a>事务相关方法</h3><p>Go语言中使用以下三个方法实现MySQL中的事务操作。 开始事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Begin</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span></span><br></pre></td></tr></table></figure><p>提交事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>回滚事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h3 id="事务示例"><a href="#事务示例" class="headerlink" title="事务示例"></a>事务示例</h3><p>下面的代码演示了一个简单的事务操作，该事物操作能够确保两次更新操作要么同时成功要么同时失败，不会存在中间状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务操作示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx, err := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"begin trans failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr1 := <span class="string">"Update user set age=30 where id=?"</span></span><br><span class="line">_, err = tx.Exec(sqlStr1, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"exec sql1 failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr2 := <span class="string">"Update user set age=40 where id=?"</span></span><br><span class="line">_, err = tx.Exec(sqlStr2, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"exec sql2 failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"commit failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"exec trans success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sqlx使用"><a href="#sqlx使用" class="headerlink" title="sqlx使用"></a>sqlx使用</h1><p>第三方库<code>sqlx</code>能够简化操作，提高开发效率。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/jmoiron/sqlx</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span></span><br><span class="line"><span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">db, err = sqlx.Connect(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"connect DB failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>查询单行数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id=?"</span></span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := db.Get(&amp;u, sqlStr, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.ID, u.Name, u.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询多行数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询多条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line"><span class="keyword">var</span> users []user</span><br><span class="line">err := db.Select(&amp;users, sqlStr, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"users:%#v\n"</span>, users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入、更新和删除"><a href="#插入、更新和删除" class="headerlink" title="插入、更新和删除"></a>插入、更新和删除</h3><p>sqlx中的exec方法与原生sql中的exec使用基本一致：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="string">"沙河小王子"</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get lastinsert ID failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"insert success, the id is %d.\n"</span>, theID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"update user set age=? where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"update failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"update success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"delete from user where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"delete failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"delete success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>对于事务操作，我们可以使用<code>sqlx</code>中提供的<code>db.Beginx()</code>和<code>tx.MustExec()</code>方法来简化错误处理过程。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx, err := db.Beginx() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"begin trans failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr1 := <span class="string">"Update user set age=40 where id=?"</span></span><br><span class="line">tx.MustExec(sqlStr1, <span class="number">2</span>)</span><br><span class="line">sqlStr2 := <span class="string">"Update user set age=50 where id=?"</span></span><br><span class="line">tx.MustExec(sqlStr2, <span class="number">4</span>)</span><br><span class="line">err = tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"commit failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"exec trans success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="SQL中的占位符"><a href="#SQL中的占位符" class="headerlink" title="SQL中的占位符"></a>SQL中的占位符</h2><p>不同的数据库中，SQL语句使用的占位符语法不尽相同。</p><table><thead><tr><th align="center">数据库</th><th align="center">占位符语法</th></tr></thead><tbody><tr><td align="center">MySQL</td><td align="center"><code>?</code></td></tr><tr><td align="center">PostgreSQL</td><td align="center"><code>$1</code>, <code>$2</code>等</td></tr><tr><td align="center">SQLite</td><td align="center"><code>?</code> 和<code>$1</code></td></tr><tr><td align="center">Oracle</td><td align="center"><code>:name</code></td></tr></tbody></table><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p><strong>我们任何时候都不应该自己拼接SQL语句！</strong></p><p>这里我们演示一个自行拼接SQL语句的示例，编写一个根据name字段查询user表的函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql注入示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlInjectDemo</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">sqlStr := fmt.Sprintf(<span class="string">"select id, name, age from user where name='%s'"</span>, name)</span><br><span class="line">fmt.Printf(<span class="string">"SQL:%s\n"</span>, sqlStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users []user</span><br><span class="line">err := db.Select(&amp;users, sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"exec failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%#v\n"</span>, u)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时以下输入字符串都可以引发SQL注入问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlInjectDemo(<span class="string">"xxx' or 1=1#"</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">"xxx' union select * from user #"</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">"xxx' and (select count(*) from user) &lt;10 #"</span>)</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>结合<code>net/http</code>和<code>sqlx</code>包实现一个注册及登陆的web程序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18GO语言基础之单元测试</title>
      <link href="/2020/02/27/18GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/27/18GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之单元测试"><a href="#Go语言基础之单元测试" class="headerlink" title="Go语言基础之单元测试"></a>Go语言基础之单元测试</h1><p>不写测试的开发不是好程序员。我个人非常崇尚TDD（Test Driven Development）的，然而可惜的是国内的程序员都不太关注测试这一部分。 这篇文章主要介绍下在Go语言中如何做单元测试和基准测试。</p><a id="more"></a><h1 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a>go test工具</h1><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th align="center">类型</th><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">测试函数</td><td align="center">函数名前缀为Test</td><td align="center">测试程序的一些逻辑行为是否正确</td></tr><tr><td align="center">基准函数</td><td align="center">函数名前缀为Benchmark</td><td align="center">测试函数的性能</td></tr><tr><td align="center">示例函数</td><td align="center">函数名前缀为Example</td><td align="center">为文档提供示例文档</td></tr></tbody></table><p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><h1 id="1-测试函数"><a href="#1-测试函数" class="headerlink" title="1.测试函数"></a>1.测试函数</h1><h2 id="测试函数的格式"><a href="#测试函数的格式" class="headerlink" title="测试函数的格式"></a>测试函数的格式</h2><p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>其中参数<code>t</code>用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Parallel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h2 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a>测试函数示例</h2><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p><p>接下来，我们定义一个<code>split</code>的包，包中定义了一个<code>Split</code>函数，具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="number">1</span>:]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下，我们创建一个<code>split_test.go</code>的测试文件，并定义一个测试函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">got := Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能比较直接，借助反射包中的方法比较</span></span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>split</code>这个包中的文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ ls -l</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 liwenzhou  staff  408  4 29 15:50 split.go</span><br><span class="line">-rw-r--r--  1 liwenzhou  staff  466  4 29 16:04 split_test.go</span><br></pre></td></tr></table></figure><p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以看到输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在<code>split_test.go</code>中添加如下测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMoreSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(<span class="string">"abcd"</span>, <span class="string">"bc"</span>)</span><br><span class="line">want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行<code>go test</code>命令，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestMultiSplit (0.00s)</span><br><span class="line">    split_test.go:20: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这一次，我们的测试失败了。<strong>我们可以为<code>go test</code>命令添加<code>-v</code>参数，查看测试函数名称和运行时间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- FAIL: TestMoreSplit (0.00s)</span><br><span class="line">    split_test.go:21: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>这一次我们能清楚的看到是<code>TestMoreSplit</code>这个测试没有成功。 <strong>还可以在<code>go test</code>命令后添加<code>-run</code>参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被<code>go test</code>命令执行。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v -run=<span class="string">"More"</span></span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- FAIL: TestMoreSplit (0.00s)</span><br><span class="line">    split_test.go:21: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>现在我们回过头来解决我们程序中的问题。很显然我们最初的<code>split</code>函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- PASS: TestMoreSplit (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这一次我们的测试都通过了。</p><h2 id="2-测试组"><a href="#2-测试组" class="headerlink" title="2.测试组"></a>2.测试组</h2><p>我们现在还想要测试一下<code>split</code>函数对中文字符串的支持，这个时候我们可以再编写一个<code>TestChineseSplit</code>测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">tests := []test&#123;</span><br><span class="line">&#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过上面的代码把多个测试用例合到一起，再次执行<code>go test</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:42: excepted:[河有 又有河], got:[ 河有 又有河]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>我们的测试出现了问题，仔细看打印的测试失败提示信息：<code>excepted:[河有 又有河], got:[ 河有 又有河]</code>，你会发现<code>[ 河有 又有河]</code>中有个不明显的空串，这种情况下十分推荐使用<code>%#v</code>的格式化方式。</p><p>我们修改下测试用例的格式化输出错误提示部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行<code>go test</code>命令后就能看到比较明显的提示信息了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:42: excepted:[]string&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;, got:[]string&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><h2 id="3-子测试"><a href="#3-子测试" class="headerlink" title="3.子测试"></a>3.子测试</h2><p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"name:%s excepted:%#v, got:%#v"</span>, name, tc.want, got) <span class="comment">// 将测试用例的name格式化输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用<code>t.Run</code>执行子测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再执行<code>go test</code>命令就能够看到更清晰的输出内容了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">=== RUN   TestSplit/leading_sep</span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/leading_sep (0.00s)</span><br><span class="line">        split_test.go:83: excepted:[]string&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;, got:[]string&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;</span><br><span class="line">    --- PASS: TestSplit/simple (0.00s)</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (0.00s)</span><br><span class="line">    --- PASS: TestSplit/more_sep (0.00s)</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这个时候我们要把测试用例中的错误修改回来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道可以通过<code>-run=RegExp</code>来指定运行的测试用例，还可以通过<code>/</code>来指定要运行的子测试用例，例如：<code>go test -v -run=Split/simple</code>只会运行<code>simple</code>对应的子测试用例。</p><h2 id="4-测试覆盖率"><a href="#4-测试覆盖率" class="headerlink" title="4.测试覆盖率"></a>4.测试覆盖率</h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p><p>Go提供内置功能来检查你的代码覆盖率。<strong>我们可以使用<code>go test -cover</code>来查看测试覆盖率。</strong>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p><p>Go还提供了一个额外的<code>-coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -cover -coverprofile=c.out</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的<code>c.out</code>文件中，<strong>然后我们执行<code>go tool cover -html=c.out</code>，使用<code>cover</code>工具来处理生成的记录信息</strong>，该命令会打开本地的浏览器窗口生成一个HTML报告。<img src="https://www.liwenzhou.com/images/Go/unit_test/cover.png" alt="Go test cover">上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。</p><h1 id="5-基准测试"><a href="#5-基准测试" class="headerlink" title="5.基准测试"></a>5.基准测试</h1><h2 id="基准测试函数格式"><a href="#基准测试函数格式" class="headerlink" title="基准测试函数格式"></a>基准测试函数格式</h2><p><strong>基准测试就是在一定的工作负载之下检测程序性能的一种方法</strong>。基准测试的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基准测试以<code>Benchmark</code>为前缀</strong>，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ReportAllocs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ResetTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(b *B)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">RunParallel</span><span class="params">(body <span class="keyword">func</span>(*PB)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetBytes</span><span class="params">(n <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetParallelism</span><span class="params">(p <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StartTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StopTimer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h2><p>我们为split包中的<code>Split_test.go</code>函数编写基准测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试并不会默认执行，需要增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Split</code>命令执行基准测试，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split   //(BenchmarkName  后缀的Name Split)</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8//(8核)        10000000//(次数)               203 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s</span><br></pre></td></tr></table></figure><p>其中<code>BenchmarkSplit-8</code>表示对Split函数进行基准测试，数字<code>8</code>表示<code>GOMAXPROCS</code>（最大线程数）的值，这个对于并发基准测试很重要。<code>10000000</code>和<code>203ns/op</code>表示每次调用<code>Split</code>函数耗时<code>203ns</code>，这个结果是<code>10000000</code>次调用的平均值。</p><p><strong>我们还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000 //次数              215 ns/op //每次操作执行时间    112 B/op//每次操作耗费内存       </span><br><span class="line">3 allocs/op //申请多少次内存</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s</span><br></pre></td></tr></table></figure><p>其中，<code>112 B/op</code>表示每次操作内存分配了112字节，<code>3 allocs/op</code>则表示每次操作进行了3次内存分配。 我们将我们的<code>Split</code>函数优化如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">result = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000               127 ns/op              48 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       1.423s</span><br></pre></td></tr></table></figure><p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p><h2 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h2><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p><p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="keyword">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure><p>例如我们编写了一个计算斐波那契数列的函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写的性能比较函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Fib(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure><p>运行基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns/op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns/op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns/op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns/op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns/op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 12.944s</span><br></pre></td></tr></table></figure><p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p><p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用<code>-benchtime</code>标志增加最小基准时间，以产生更准确的结果。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Fib40 -benchtime=20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s</span><br></pre></td></tr></table></figure><p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p><p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">Fib(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a>重置时间</h2><p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line">b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure><p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p><h1 id="Setup与TearDown"><a href="#Setup与TearDown" class="headerlink" title="Setup与TearDown"></a>Setup与TearDown</h1><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p><h2 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a>TestMain</h2><p>通过在<code>*_test.go</code>文件中定义<code>TestMain</code>函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p><p>如果测试文件包含函数:<code>func TestMain(m *testing.M)</code>那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。<code>TestMain</code>运行在主<code>goroutine</code>中, 可以在调用 <code>m.Run</code>前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用<code>m.Run</code>的返回值作为参数调用<code>os.Exit</code>。</p><p>一个使用<code>TestMain</code>来设置Setup和TearDown的示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write setup code here..."</span>) <span class="comment">// 测试之前的做一些设置</span></span><br><span class="line"><span class="comment">// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()</span></span><br><span class="line">retCode := m.Run()                         <span class="comment">// 执行测试</span></span><br><span class="line">fmt.Println(<span class="string">"write teardown code here..."</span>) <span class="comment">// 测试之后做一些拆卸工作</span></span><br><span class="line">os.Exit(retCode)                           <span class="comment">// 退出测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：在调用<code>TestMain</code>时, <code>flag.Parse</code>并没有被调用。所以如果<code>TestMain</code> 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用<code>flag.Parse</code>。</p><h2 id="子测试的Setup与Teardown"><a href="#子测试的Setup与Teardown" class="headerlink" title="子测试的Setup与Teardown"></a>子测试的Setup与Teardown</h2><p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试集的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupTestCase</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:测试之前的setup"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:测试之后的teardown"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子测试的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubTest</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:子测试之前的setup"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:子测试之后的teardown"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">teardownTestCase := setupTestCase(t) <span class="comment">// 测试之前执行setup操作</span></span><br><span class="line"><span class="keyword">defer</span> teardownTestCase(t)            <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">teardownSubTest := setupSubTest(t) <span class="comment">// 子测试之前执行setup操作</span></span><br><span class="line"><span class="keyword">defer</span> teardownSubTest(t)           <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">=== RUN   TestSplit/leading_sep</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">    split_test.go:71: 如有需要在此执行:测试之前的setup</span><br><span class="line">    --- PASS: TestSplit/simple (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/more_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/leading_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    split_test.go:73: 如有需要在此执行:测试之后的teardown</span><br><span class="line">=== RUN   ExampleSplit</span><br><span class="line">--- PASS: ExampleSplit (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><h1 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h1><h2 id="示例函数的格式"><a href="#示例函数的格式" class="headerlink" title="示例函数的格式"></a>示例函数的格式</h2><p>被<code>go test</code>特殊对待的第三种函数就是示例函数，它们的函数名以<code>Example</code>为前缀。它们既没有参数也没有返回值。标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a>示例函数示例</h2><p>下面的代码是我们为<code>Split</code>函数编写的一个示例函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSplit</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split.Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>))</span><br><span class="line">fmt.Println(split.Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line"><span class="comment">// [ 河有 又有河]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为你的代码编写示例代码有如下三个用处：</p><ol><li><p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p></li><li><p>示例函数只要包含了<code>// Output:</code>也是可以通过<code>go test</code>运行的可执行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -run Example</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure></li><li><p>示例函数提供了可以直接运行的示例代码，可以直接在<code>golang.org</code>的<code>godoc</code>文档服务器上使用<code>Go Playground</code>运行示例代码。下图为<code>strings.ToUpper</code>函数在Playground的示例函数效果。<img src="https://www.liwenzhou.com/images/Go/unit_test/example.png" alt="Go Playground"></p></li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写一个回文检测函数，并为其编写单元测试和基准测试，根据测试的结果逐步对其进行优化。（回文：一个字符串正序和逆序一样，如“Madam,I’mAdam”、“油灯少灯油”等。）</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20Go语言Cookie和Session</title>
      <link href="/2020/02/27/20Go%E8%AF%AD%E8%A8%80Cookie%E5%92%8CSession/"/>
      <url>/2020/02/27/20Go%E8%AF%AD%E8%A8%80Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><p>Cookie和Session是Web开发绕不开的一个环节，本文介绍了Cookie和Session的原理及在Go语言中如何操作Cookie。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的由来"><a href="#Cookie的由来" class="headerlink" title="Cookie的由来"></a>Cookie的由来</h3><p>HTTP协议是无状态的，这就存在一个问题。</p><p>无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响，也不会直接影响后面的请求响应情况。</p><p>一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。</p><p>状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的，也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。</p><h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>在 Internet 中，Cookie 实际上是指小量信息，是由 Web 服务器创建的，将信息存储在用户计算机上（客户端）的数据文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。</p><h3 id="Cookie的机制"><a href="#Cookie的机制" class="headerlink" title="Cookie的机制"></a>Cookie的机制</h3><p>Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>总结一下Cookie的特点：</p><ol><li>浏览器发送请求的时候，自动把携带该站点之前存储的Cookie信息。</li><li>服务端可以设置Cookie数据。</li><li>Cookie是针对单个域名的，不同域名之间的Cookie是独立的。</li><li>Cookie数据可以配置过期时间，过期的Cookie数据会被系统清除。</li></ol><h3 id="查看Cookie"><a href="#查看Cookie" class="headerlink" title="查看Cookie"></a>查看Cookie</h3><p>我们使用Chrome浏览器打开一个网站，打开开发者工具查看该网站保存在我们电脑上的Cookie数据。</p><h2 id="Go操作Cookie"><a href="#Go操作Cookie" class="headerlink" title="Go操作Cookie"></a>Go操作Cookie</h2><h3 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h3><p>标准库<code>net/http</code>中定义了Cookie，它代表一个出现在HTTP响应头中Set-Cookie的值里或者HTTP请求头中Cookie的值的<code>HTTP cookie</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="keyword">string</span></span><br><span class="line">    Value      <span class="keyword">string</span></span><br><span class="line">    Path       <span class="keyword">string</span></span><br><span class="line">    Domain     <span class="keyword">string</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于"Max-Age: 0"</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="keyword">int</span></span><br><span class="line">    Secure   <span class="keyword">bool</span></span><br><span class="line">    HttpOnly <span class="keyword">bool</span></span><br><span class="line">    Raw      <span class="keyword">string</span></span><br><span class="line">    Unparsed []<span class="keyword">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>net/http</code>中提供了如下<code>SetCookie</code>函数，它在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><p><code>Request</code>对象拥有两个获取Cookie的方法和一个添加Cookie的方法：</p><p>获取Cookie的两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析并返回该请求的Cookie头设置的所有cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookies</span><span class="params">()</span> []*<span class="title">Cookie</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">Cookie</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Cookie, error)</span></span></span><br></pre></td></tr></table></figure><p>添加Cookie的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddCookie向请求中添加一个cookie。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">AddCookie</span><span class="params">(c *Cookie)</span></span></span><br></pre></td></tr></table></figure><h2 id="gin框架操作Cookie"><a href="#gin框架操作Cookie" class="headerlink" title="gin框架操作Cookie"></a>gin框架操作Cookie</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">"/cookie"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        cookie, err := c.Cookie(<span class="string">"gin_cookie"</span>) <span class="comment">// 获取Cookie</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cookie = <span class="string">"NotSet"</span></span><br><span class="line">            <span class="comment">// 设置Cookie</span></span><br><span class="line">            c.SetCookie(<span class="string">"gin_cookie"</span>, <span class="string">"test"</span>, <span class="number">3600</span>, <span class="string">"/"</span>, <span class="string">"localhost"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"Cookie value: %s \n"</span>, cookie)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session的由来"><a href="#Session的由来" class="headerlink" title="Session的由来"></a>Session的由来</h3><p>Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是<code>Session</code>。</p><p>问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。</p><p>用户登陆成功之后，我们在服务端为每个用户创建一个特定的session和一个唯一的标识，它们一一对应。其中：</p><ul><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li><li>唯一标识通常称为<code>Session ID</code>会写入用户的Cookie中。</li></ul><p>这样该用户后续再次访问时，请求会自动携带Cookie数据（其中包含了<code>Session ID</code>），服务器通过该<code>Session ID</code>就能找到与之对应的Session数据，也就知道来的人是“谁”。</p><p>总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在服务端为每个用户保存一个Session数据，该Session数据中能够保存具体的用户数据信息。</p><p>另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19Go语言并发编程</title>
      <link href="/2020/02/27/19Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/02/27/19Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="GO-并发编程"><a href="#GO-并发编程" class="headerlink" title="GO 并发编程"></a>GO 并发编程</h2><h2 id="协程（进程-线程）"><a href="#协程（进程-线程）" class="headerlink" title="协程（进程 线程）"></a>协程（进程 线程）</h2><ol><li><p>进程是“程序执行的一个实例” ，担当分配系统资源的实体。进程创建必须分配一个完整的独立地址空间。进程切换只发生在内核态。</p></li><li><p>线程：线程是进程的一个执行流，独立执行它自己的程序代码。</p></li><li><p>协程：协程不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。在语言级别可以创建并发协程，然后编写代码去进行管理。go将这一步承包下来，使协程并发运行成本更低。</p><a id="more"></a></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/next"</span>, handler)</span><br><span class="line">    <span class="comment">// func这个函数会是以协程的方式运行。这样就可以提供程序的并发处理能力</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            nextID &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goruntime"><a href="#goruntime" class="headerlink" title="goruntime"></a>goruntime</h2><p>参考<a href="https://studygolang.com/articles/10114" target="_blank" rel="noopener">goruntime详解</a>，操作系统对cpu有自己的scheduler方案，如任务A在执行完后，选择哪个任务来执行，使得某个因素（如进程总执行时间，或者磁盘寻道时间等）最小，达到最优的服务。<br>Go有自己的scheduler，语言级别实现了并发。</p><p>每一个Go程序都附带一个runtime，runtime负责与底层操作系统交互，也都会有scheduler对goruntines进行调度。在scheduler中有三个非常重要的概念：P，M，G。<br><code>详情后续再写。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Goroutine scheduler</span><br><span class="line"># The scheduler<span class="string">'s job is to distribute ready-to-run goroutines over worker threads.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># The main concepts are:</span></span><br><span class="line"><span class="string"># G - goroutine.</span></span><br><span class="line"><span class="string"># M - worker thread, or machine.</span></span><br><span class="line"><span class="string"># P - processor, a resource that is required to execute Go code.</span></span><br><span class="line"><span class="string">#     M must have an associated P to execute Go code, however it can be</span></span><br><span class="line"><span class="string">#     blocked or in a syscall w/o an associated P.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Design doc at https://golang.org/s/go11sched.</span></span><br></pre></td></tr></table></figure><h2 id="runtime包与goroutime"><a href="#runtime包与goroutime" class="headerlink" title="runtime包与goroutime"></a>runtime包与goroutime</h2><p>尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。</p><ul><li><code>Gosched</code>：让当前线程让出 cpu 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</li><li><code>NumCPU</code>：返回当前系统的 CPU 核数量</li><li><code>GOMAXPROCS</code>：设置最大的可同时使用的 CPU 核数</li><li><code>Goexit</code>：退出当前 goroutine(但是defer语句会照常执行)</li><li><code>NumGoroutine</code>：返回正在执行和排队的任务总数</li><li><code>GOOS</code>：目标操作系统</li></ul><h3 id="NumCPU"><a href="#NumCPU" class="headerlink" title="NumCPU"></a>NumCPU</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"cpus:"</span>, runtime.NumCPU())</span><br><span class="line">    fmt.Println(<span class="string">"goroot:"</span>, runtime.GOROOT())</span><br><span class="line">    fmt.Println(<span class="string">"archive:"</span>, runtime.GOOS)</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// /usr/local/golang</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 任务逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Golang 默认所有任务都运行在一个 cpu 核里，如果要在 goroutine 中使用多核，可以使用 runtime.GOMAXPROCS 函数修改，当参数小于 1 时使用默认值。</p><h3 id="Gosched"><a href="#Gosched" class="headerlink" title="Gosched"></a>Gosched</h3><p>这个函数的作用是让当前 goroutine 让出 CPU，当一个 goroutine 发生阻塞，Go 会自动地把与该 goroutine 处于同一系统线程的其他 goroutine 转移到另一个系统线程上去，以使这些 goroutine 不阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)  # 使用单核</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(exit)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a:"</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            runtime.Gosched()  #切换任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-exit</span><br><span class="line">&#125;</span><br><span class="line"># 运行结果</span><br><span class="line"># a: <span class="number">0</span></span><br><span class="line"># a: <span class="number">1</span></span><br><span class="line"># b: </span><br><span class="line"># a：<span class="number">2</span></span><br><span class="line"># a: <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>channel是Go语言在语言级别提供的goroutine间的通信方式。我们可以使用channel在两个或 多个goroutine之间传递消息。<br>channel 会某种情况下出现阻塞，通过控制channel的阻塞来管理协程的并发与流程控制。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T          <span class="comment">// 可以接收和发送类型为 T 的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只可以用来发送 float64 类型的数据（可以关闭）</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只可以用来接收 int 类型的数据(也不能关闭)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">        out &lt;- x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了单向channel。很明显数据的流向是单向的。获取的地方不应该对channel赋值。<code>这样把一个双向的channel转为一个单向的channel能够防止channel被滥用。降低了风险。</code></p><h3 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="非缓冲的Channel"><a href="#非缓冲的Channel" class="headerlink" title="非缓冲的Channel"></a>非缓冲的Channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">//缓冲通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//非缓冲通道</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//非缓冲通道</span></span><br></pre></td></tr></table></figure><p>非缓冲通道特性：</p><ul><li>向此类通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接收操作开始进行为止。</li><li>从此类通道接收元素值的操作会被阻塞，直到至少有一个针对该通道的发送操作开始进行为止。</li><li>针对非缓冲通道的接收操作会在与之相应的发送操作完成之前完成。</li></ul><p><code>对于第三条要特别注意，发送操作在向非缓冲通道发送元素值的时候，会等待能够接收该元素值的那个接收操作。并且确保该元素值被成功接收，它才会真正的完成执行。而缓冲通道中，刚好相反，由于元素值的传递是异步的，所以发送操作在成功向通道发送元素值之后就会立即结束(它不会关心是否有接收操作)</code>。</p><p>make(chan int) 和 make(chan int, 1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a = <span class="string">"hello world"</span></span><br><span class="line">        &lt;-c</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子会打印 “hello world”。如果改成 var c = make(chan int, 1) a 可能是 “hello world” 也可能是空，make(chan int) 是 unbuffered channel, send 之后 send 语句会阻塞执行，直到有人 receive 之后 send 解除阻塞，后面的语句接着执行。<br>所以执行 c &lt;- 0 时会阻塞，直到 &lt;-c, 这时 a 已赋值。</p><p>make(chan int, 1) 是 buffered channel, 容量为 1。在 buffer 未满时往里面 send 值并不会阻塞， 只有 buffer 满时再 send 才会阻塞，所以执行到 c &lt;- 0 时并不会阻塞</p><h3 id="send语句"><a href="#send语句" class="headerlink" title="send语句"></a>send语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- <span class="number">3</span> + <span class="number">4</span> &#125;()</span><br><span class="line">i := &lt;-c</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure><p>send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。</p><p>往一个已经被close的channel中继续发送数据会导致run-time panic。</p><p>往nil channel中发送数据会一致被阻塞着。</p><h3 id="receive语句"><a href="#receive语句" class="headerlink" title="receive语句"></a>receive语句</h3><p>&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。<br>如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;-ch</span><br><span class="line">x, ok = &lt;-ch</span><br><span class="line"><span class="keyword">var</span> x, ok = &lt;-ch</span><br></pre></td></tr></table></figure><p>如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Hour)</span><br><span class="line">    &#125;()</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i = i + <span class="number">1</span> &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Finished"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>range c产生的迭代值为Channel中发送的值，它会一直迭代知道channel被关闭。上面的例子中如果把close(c)注释掉，程序会一直阻塞在for …… range那一行。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>每个case语句里必须是一个IO操作</li><li>如果有多个case都可以运行，Select会随机公平地选出一个执行(其他不会执行)。</li><li>所有跟在case关键字右边的发送语句或接收语句中的通道表达式和元素表达式都会先被求值。无论它们所在的case是否有可能被选择都会这样。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不想等到通道被关闭后再退出循环，利用一个辅助通道模拟出操作超时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化通道</span></span><br><span class="line">    ch11 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">    sign := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给ch11通道写入数据</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        ch11 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭ch11通道</span></span><br><span class="line">    <span class="built_in">close</span>(ch11)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们不想等到通道被关闭之后再推出循环，我们创建并初始化一个辅助的通道，利用它模拟出操作超时行为</span></span><br><span class="line">    timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        time.Sleep(time.Millisecond) <span class="comment">//休息1ms</span></span><br><span class="line">        timeout &lt;- <span class="literal">false</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单独起一个Goroutine执行select</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e <span class="keyword">int</span></span><br><span class="line">        ok := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e,ok = &lt;- ch11:</span><br><span class="line">                    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        fmt.Println(<span class="string">"End."</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fmt.Printf(<span class="string">"ch11 -&gt; %d\n"</span>,e)</span><br><span class="line">                <span class="keyword">case</span> ok = &lt;- timeout:</span><br><span class="line">                <span class="comment">//向timeout通道发送元素false后，该case几乎马上就会被执行, ok = false</span></span><br><span class="line">                    fmt.Println(<span class="string">"Timeout."</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//终止for循环</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                sign &lt;- <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//惯用手法，读取sign通道数据，为了等待select的Goroutine执行。</span></span><br><span class="line">    &lt;- sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了单个操作的超时,但是那个超时触发器开始计时有点早。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化通道</span></span><br><span class="line">    ch11 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1000</span>)</span><br><span class="line">    sign := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给ch11通道写入数据</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        ch11 &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭ch11通道</span></span><br><span class="line">    <span class="comment">//close(ch11),为了看效果先注释掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单独起一个Goroutine执行select</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> e <span class="keyword">int</span></span><br><span class="line">        ok := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e,ok = &lt;- ch11:</span><br><span class="line">                    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                        fmt.Println(<span class="string">"End."</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    fmt.Printf(<span class="string">"ch11 -&gt; %d\n"</span>,e)</span><br><span class="line">                <span class="keyword">case</span> ok = &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">chan</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">                    <span class="comment">//经过大约1ms后，该接收语句会从timeout通道接收到一个新元素并赋值给ok,从而恰当地执行了针对单个操作的超时子流程，恰当地结束当前for循环</span></span><br><span class="line">                    timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        time.Sleep(time.Millisecond)<span class="comment">//休息1ms</span></span><br><span class="line">                        timeout &lt;- <span class="literal">false</span></span><br><span class="line">                    &#125;()</span><br><span class="line">                    <span class="keyword">return</span> timeout</span><br><span class="line">                &#125;():</span><br><span class="line">                    fmt.Println(<span class="string">"Timeout."</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//终止for循环</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                sign &lt;- <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//惯用手法，读取sign通道数据，为了等待select的Goroutine执行。</span></span><br><span class="line">    &lt;- sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>我们可能就需要一个超时操作，用来处理超时的情况。 下面这个例子我们会在2秒后往channel c1中发送一个数据，但是select设置为1秒超时,因此我们会打印出timeout 1,而不是result 1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// time.Sleep(time.Millisecond) 1ms</span></span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        c1 &lt;- <span class="string">"result 1"</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        fmt.Println(<span class="string">"timeout 1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实它利用的是time.After方法，它返回一个类型为&lt;-chan Time的单向的channel，在指定的时间发送一个当前时间给返回的channel中。</p><h3 id="Timer和Ticker"><a href="#Timer和Ticker" class="headerlink" title="Timer和Ticker"></a>Timer和Ticker</h3><p>我们看一下关于时间的两个Channel。 timer是一个定时器，代表未来的一个单一事件，你可以告诉timer你要等待多长时间，它提供一个Channel，在将来的那个时间那个Channel提供了一个时间值。下面的例子中第二行会阻塞2秒钟左右的时间，直到时间到了才会继续执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">&lt;-timer1.C</span><br><span class="line">fmt.Println(<span class="string">"Timer 1 expired"</span>)</span><br></pre></td></tr></table></figure><p>当然如果你只是想单纯的等待的话，可以使用time.Sleep来实现。你还可以使用timer.Stop来停止计时器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer2 := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-timer2.C</span><br><span class="line">    fmt.Println(<span class="string">"Timer 2 expired"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">stop2 := timer2.Stop()</span><br><span class="line"><span class="keyword">if</span> stop2 &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Timer 2 stopped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ticker是一个定时触发的计时器，它会以一个间隔(interval)往Channel发送一个事件(当前时间)，而Channel的接收者可以以固定的时间间隔从Channel中读取事件。下面的例子中ticker每500毫秒触发一次，你可以观察输出的时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>类似timer, ticker也可以通过Stop方法来停止。一旦它停止，接收者不再会从channel中接收数据了。</p><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>总结一下channel关闭后sender的receiver操作。 如果channel c已经被关闭,继续往它发送数据会导致panic: send on closed channel,但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">fmt.Println(&lt;-c) <span class="comment">//1</span></span><br><span class="line">fmt.Println(&lt;-c) <span class="comment">//2</span></span><br><span class="line">fmt.Println(&lt;-c) <span class="comment">//0</span></span><br><span class="line">fmt.Println(&lt;-c) <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>但是如果通过range读取，channel关闭后for循环会跳出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">   fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17GO语言基础之net/http</title>
      <link href="/2020/02/27/17GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bnet-http/"/>
      <url>/2020/02/27/17GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bnet-http/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之net-http"><a href="#Go语言基础之net-http" class="headerlink" title="Go语言基础之net/http"></a>Go语言基础之net/http</h1><p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p><a id="more"></a><h2 id="net-http介绍"><a href="#net-http介绍" class="headerlink" title="net/http介绍"></a>net/http介绍</h2><p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><h3 id="基本的HTTP-HTTPS请求"><a href="#基本的HTTP-HTTPS请求" class="headerlink" title="基本的HTTP/HTTPS请求"></a>基本的HTTP/HTTPS请求</h3><p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">"http://example.com/upload"</span>, <span class="string">"image/jpeg"</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>,</span><br><span class="line">url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>程序在使用完response后必须关闭回复的主体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="GET请求示例"><a href="#GET请求示例" class="headerlink" title="GET请求示例"></a>GET请求示例</h3><p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.liwenzhou.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from resp.Body failed,err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>liwenzhou.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p><h3 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h3><p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apiUrl := <span class="string">"http://127.0.0.1:9090/get"</span></span><br><span class="line"><span class="comment">// URL param</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">"name"</span>, <span class="string">"小王子"</span>)</span><br><span class="line">data.Set(<span class="string">"age"</span>, <span class="string">"18"</span>)</span><br><span class="line">u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"parse url requestUrl failed,err:%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line">resp, err := http.Get(u.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">data := r.URL.Query()</span><br><span class="line">fmt.Println(data.Get(<span class="string">"name"</span>))</span><br><span class="line">fmt.Println(data.Get(<span class="string">"age"</span>))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post请求示例"><a href="#Post请求示例" class="headerlink" title="Post请求示例"></a>Post请求示例</h3><p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http post demo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := <span class="string">"http://127.0.0.1:9090/post"</span></span><br><span class="line"><span class="comment">// 表单数据</span></span><br><span class="line"><span class="comment">//contentType := "application/x-www-form-urlencoded"</span></span><br><span class="line"><span class="comment">//data := "name=小王子&amp;age=18"</span></span><br><span class="line"><span class="comment">// json</span></span><br><span class="line">contentType := <span class="string">"application/json"</span></span><br><span class="line">data := <span class="string">`&#123;"name":"小王子","age":18&#125;`</span></span><br><span class="line">resp, err := http.Post(url, contentType, strings.NewReader(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"><span class="comment">// 1. 请求类型是application/x-www-form-urlencoded时解析form数据</span></span><br><span class="line">r.ParseForm()</span><br><span class="line">fmt.Println(r.PostForm) <span class="comment">// 打印form数据</span></span><br><span class="line">fmt.Println(r.PostForm.Get(<span class="string">"name"</span>), r.PostForm.Get(<span class="string">"age"</span>))</span><br><span class="line"><span class="comment">// 2. 请求类型是application/json时从r.Body读取数据</span></span><br><span class="line">b, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read request.Body failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Client"><a href="#自定义Client" class="headerlink" title="自定义Client"></a>自定义Client</h3><p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"http://example.com"</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="自定义Transport"><a href="#自定义Transport" class="headerlink" title="自定义Transport"></a>自定义Transport</h3><p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">TLSClientConfig:    &amp;tls.Config&#123;RootCAs: pool&#125;,</span><br><span class="line">DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="默认的Server"><a href="#默认的Server" class="headerlink" title="默认的Server"></a>默认的Server</h3><p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p><p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><h3 id="默认的Server示例"><a href="#默认的Server示例" class="headerlink" title="默认的Server示例"></a>默认的Server示例</h3><p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http server</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">"Hello 沙河！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"http server failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="https://www.liwenzhou.com/images/Go/socket/hello.png" alt="hello页面"></p><h3 id="自定义Server"><a href="#自定义Server" class="headerlink" title="自定义Server"></a>自定义Server</h3><p>要管理服务端的行为，可以创建一个自定义的Server：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">Addr:           <span class="string">":8080"</span>,</span><br><span class="line">Handler:        myHandler,</span><br><span class="line">ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16GO语言基础之网络编程</title>
      <link href="/2020/02/27/16GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/02/27/16GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之网络编程"><a href="#Go语言基础之网络编程" class="headerlink" title="Go语言基础之网络编程"></a>Go语言基础之网络编程</h1><p>现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。</p><a id="more"></a><h1 id="互联网协议介绍"><a href="#互联网协议介绍" class="headerlink" title="互联网协议介绍"></a>互联网协议介绍</h1><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。</p><h2 id="互联网分层模型"><a href="#互联网分层模型" class="headerlink" title="互联网分层模型"></a>互联网分层模型</h2><p>互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。<img src="https://www.liwenzhou.com/images/Go/socket/osi.png" alt="osi七层模型">如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。</p><p>接下来我们一层一层的自底向上介绍一下每一层。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用<strong>双绞线、光纤、无线电波</strong>等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些<strong>电气特性</strong>，作用是负责传送0和1的电信号。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：<strong>多少个电信号算一组？每个信号位有何意义？</strong>这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，<strong>一组电信号构成一个数据包，叫做”帧”（Frame）。</strong>每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是<strong>数据包的发送地址和接收地址，这叫做MAC地址</strong>。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。</p><p>因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。</p><p>我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。</p><p>如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/httptcpip.png" alt="HTTP数据传输图解"></p><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h2 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a>socket图解</h2><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/socket.png" alt="socket图解"></p><h2 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a>Go语言实现TCP通信</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即<strong>传输控制协议/网间协议</strong>，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p><strong>TCP服务端</strong>程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp/server/main.go</span></span><br><span class="line"><span class="comment">// TCP server端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">n, err := reader.Read(buf[:]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from client failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">recvStr := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">fmt.Println(<span class="string">"收到client端发来的数据："</span>, recvStr)</span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(recvStr)) <span class="comment">// 发送数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:20000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept() <span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn) <span class="comment">// 启动一个goroutine处理连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>一个<strong>TCP客户端</strong>进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp/client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:20000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"err :"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// 关闭连接</span></span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input, _ := inputReader.ReadString(<span class="string">'\n'</span>) <span class="comment">// 读取用户输入</span></span><br><span class="line">inputInfo := strings.Trim(input, <span class="string">"\r\n"</span>)</span><br><span class="line"><span class="keyword">if</span> strings.ToUpper(inputInfo) == <span class="string">"Q"</span> &#123; <span class="comment">// 如果输入q就退出</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(inputInfo)) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">buf := [<span class="number">512</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">n, err := conn.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recv failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h2 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h2><h3 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a>黏包示例</h3><p>服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := reader.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from client failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">recvStr := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">fmt.Println(<span class="string">"收到client发来的数据："</span>, recvStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"dial failed, err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">msg := <span class="string">`Hello, Hello. How are you?`</span></span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(msg))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br></pre></td></tr></table></figure><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/proto/proto.go</span></span><br><span class="line"><span class="keyword">package</span> proto</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode 将消息编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取消息的长度，转换成int32类型（占4个字节）</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="keyword">int32</span>(<span class="built_in">len</span>(message))</span><br><span class="line"><span class="keyword">var</span> pkg = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// 写入消息头</span></span><br><span class="line">err := binary.Write(pkg, binary.LittleEndian, length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入消息实体</span></span><br><span class="line">err = binary.Write(pkg, binary.LittleEndian, []<span class="keyword">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pkg.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decode 解码消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(reader *bufio.Reader)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取消息的长度</span></span><br><span class="line">lengthByte, _ := reader.Peek(<span class="number">4</span>) <span class="comment">// 读取前4个字节的数据</span></span><br><span class="line">lengthBuff := bytes.NewBuffer(lengthByte)</span><br><span class="line"><span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Buffered返回缓冲中现有的可读取的字节数。</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取真正的消息数据</span></span><br><span class="line">pack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(<span class="number">4</span>+length))</span><br><span class="line">_, err = reader.Read(pack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(pack[<span class="number">4</span>:]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/server2/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := proto.Decode(reader)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"decode msg failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"收到client发来的数据："</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/client2/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"dial failed, err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">msg := <span class="string">`Hello, Hello. How are you?`</span></span><br><span class="line">data, err := proto.Encode(msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"encode msg failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Write(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a>Go语言实现UDP通信</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h3 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h3><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP/server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP server端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">"udp"</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">Port: <span class="number">30000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> data [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(data[:]) <span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read udp failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"data:%v addr:%v count:%v\n"</span>, <span class="keyword">string</span>(data[:n]), addr, n)</span><br><span class="line">_, err = listen.WriteToUDP(data[:n], addr) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write to udp failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">socket, err := net.DialUDP(<span class="string">"udp"</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">Port: <span class="number">30000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"连接服务端失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> socket.Close()</span><br><span class="line">sendData := []<span class="keyword">byte</span>(<span class="string">"Hello server"</span>)</span><br><span class="line">_, err = socket.Write(sendData) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"发送数据失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, remoteAddr, err := socket.ReadFromUDP(data) <span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"接收数据失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"recv:%v addr:%v count:%v\n"</span>, <span class="keyword">string</span>(data[:n]), remoteAddr, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15GO语言基础之并发</title>
      <link href="/2020/02/27/15GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/02/27/15GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之并发"><a href="#Go语言基础之并发" class="headerlink" title="Go语言基础之并发"></a>Go语言基础之并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。<a href="http://blog.sina.com.cn/s/blog_5a2bbc860101gedc.html" target="_blank" rel="noopener">进程与线程区别和处理器调度</a></p><a id="more"></a><h1 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hello()</span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p><strong>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</strong></p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line"><span class="keyword">go</span> hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。G（线程）P（管理G）M(G在M上运行)M相当于CPU</p><ul><li><p><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</p></li><li><p><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</p></li><li><p><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</p><p><strong>M：N：把m个goroutine分配给n个操作系统线程去执行。</strong></p></li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html" target="_blank" rel="noopener">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p><strong>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。</strong>默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//gomaxprocs 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span>  wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"A:%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"B:%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">6</span>)<span class="comment">//设置多少个线程同时执行程序 默认CPU逻辑核心数是6，默认跑满整个cpu</span></span><br><span class="line">fmt.Println(runtime.NumCPU()) <span class="comment">//最大线程数是4，我的电脑</span></span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">wg.Wait() <span class="comment">//等待线程数为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</strong></p><p>创建channel的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ret := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">ch1 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">out &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">out &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> counter(ch1)</span><br><span class="line"><span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h2 id="worker-pool（goroutine池）（面试手写）"><a href="#worker-pool（goroutine池）（面试手写）" class="headerlink" title="worker pool（goroutine池）（面试手写）"></a>worker pool（goroutine池）（面试手写）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">fmt.Printf(<span class="string">"worker:%d start job:%d\n"</span>, id, j)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">"worker:%d end job:%d\n"</span>, id, j)</span><br><span class="line">results &lt;- j * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 开启3个goroutine</span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5个任务</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">    个                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个小例子来演示下<code>select</code>的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><strong>互斥锁是一种常用的控制共享资源访问的方法，</strong>它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，<strong>当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的</strong>，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x      <span class="keyword">int64</span></span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">lock   sync.Mutex</span><br><span class="line">rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">(wg * WaitGroup) Add(delta int)</td><td align="center">计数器+delta</td></tr><tr><td align="center">(wg *WaitGroup) Done()</td><td align="center">计数器-1</td></tr><tr><td align="center">(wg *WaitGroup) Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们<strong>需要确保某些操作在高并发的场景下只执行一次</strong>，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line"><span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line"><span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line"><span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">icons[<span class="string">"left"</span>] = loadIcon(<span class="string">"left.png"</span>)</span><br><span class="line">icons[<span class="string">"up"</span>] = loadIcon(<span class="string">"up.png"</span>)</span><br><span class="line">icons[<span class="string">"right"</span>] = loadIcon(<span class="string">"right.png"</span>)</span><br><span class="line">icons[<span class="string">"down"</span>] = loadIcon(<span class="string">"down.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line"><span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line"><span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line"><span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">set(key, n)</span><br><span class="line">fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, get(key))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//concurrent map writes 并发映射写</span></span><br></pre></td></tr></table></figure><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)</span><br><span class="line">value, _ := m.Load(key)</span><br><span class="line">fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td align="center">读取操作</td></tr><tr><td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td align="center">写入操作</td></tr><tr><td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td align="center">修改操作</td></tr><tr><td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td align="center">交换操作</td></tr><tr><td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td align="center">比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">test(c1) <span class="comment">//0  499.7µs</span></span><br><span class="line">c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">test(&amp;c2)<span class="comment">//1000 500.1µs</span></span><br><span class="line">c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">test(&amp;c3) <span class="comment">//1000 0s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">goroutine</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">channel</span></span><br></pre></td></tr></table></figure><p>实现一个计算int64随机数各位数和的程序。</p><ol><li><p>开启一个<code>goroutine</code>循环生成int64类型的随机数，发送到<code>jobChan</code></p></li><li><p>开启24个<code>goroutine</code>从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code></p></li><li><p>主<code>goroutine</code>从<code>resultChan</code>取出结果并打印到终端输出</p><p>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/*实现一个计算int64随机数各位数和的程序。</span></span><br><span class="line"><span class="comment">1. 开启一个`goroutine`循环生成int64类型的随机数，发送到`jobChan`</span></span><br><span class="line"><span class="comment">2. 开启24个`goroutine`从`jobChan`中取出随机数计算各位数的和，将结果发送到`resultChan`</span></span><br><span class="line"><span class="comment">3. 主`goroutine`从`resultChan`取出结果并打印到终端输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> job <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">job*job</span><br><span class="line">sum <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobChan =<span class="built_in">make</span>(<span class="keyword">chan</span> *job,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> resultChan =<span class="built_in">make</span>(<span class="keyword">chan</span> *result,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rom</span><span class="params">(z1 <span class="keyword">chan</span>&lt;- *job)</span></span>&#123;</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="comment">//1.循环生成int64类型的随机数，发送到`jobChan`</span></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"> x := rand.Int63()</span><br><span class="line">newJob := &amp;job&#123;</span><br><span class="line">x,</span><br><span class="line">&#125;</span><br><span class="line">z1 &lt;- newJob</span><br><span class="line">time.Sleep(time.Millisecond*<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(z1 &lt;-<span class="keyword">chan</span> *job,resultChan <span class="keyword">chan</span>&lt;- *result)</span></span>&#123;</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="comment">//2.从`jobChan`中取出随机数计算各位数的和，将结果发送到`resultChan`</span></span><br><span class="line"><span class="keyword">for</span>   &#123;</span><br><span class="line">job := &lt;- z1</span><br><span class="line">sum := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">n :=job.value</span><br><span class="line"><span class="keyword">for</span> n&gt;<span class="number">0</span> &#123;</span><br><span class="line">sum += n%<span class="number">10</span></span><br><span class="line">n=n/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">newResult := &amp;result&#123;</span><br><span class="line">job,</span><br><span class="line">sum,</span><br><span class="line">&#125;</span><br><span class="line">resultChan&lt;-newResult</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> rom(jobChan)</span><br><span class="line">wg.Add(<span class="number">24</span>)</span><br><span class="line"><span class="comment">//开启24个goroutine执行get方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="number">24</span>;i++&#123;</span><br><span class="line"><span class="keyword">go</span> get(jobChan,resultChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.从`resultChan`取出结果并打印到终端输出</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> resultChan&#123;</span><br><span class="line">fmt.Printf(<span class="string">"value:%d  sum:%d\n"</span>,result.job.value,result.sum)</span><br><span class="line">        <span class="comment">//value:2610529275472644968  sum:89</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。</p><p>业务代码记日志先存放到通道中，然后起一个后台goroutine专门从通道中取日志往文件里写。</p><p>1.日志库中channel怎么用？</p><p>2.什么时候起后台的goroutine去写日志到文件中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14GO语言基础之反射</title>
      <link href="/2020/02/27/14GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/02/27/14GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之反射"><a href="#Go语言基础之反射" class="headerlink" title="Go语言基础之反射"></a>Go语言基础之反射</h1><p>本文介绍了Go语言反射的意义和基本使用。</p><a id="more"></a><h1 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p><h1 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h1><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">"type:%v\n"</span>, v) <span class="comment">//type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line">reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h3><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">"type:%v kind:%v\n"</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">"沙河小王子"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">"《跟小王子学Go语言》"</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Interface() interface {}</td><td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="center">Int() int64</td><td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="center">Uint() uint64</td><td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="center">Float() float64</td><td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="center">Bool() bool</td><td align="center">将值以 bool 类型返回</td></tr><tr><td align="center">Bytes() []bytes</td><td align="center">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="center">String() string</td><td align="center">将值以字符串类型返回</td></tr></tbody></table><h3 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is int64, value is %d\n"</span>, <span class="keyword">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is float32, value is %f\n"</span>, <span class="keyword">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is float64, value is %f\n"</span>, <span class="keyword">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"><span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">"type c :%T\n"</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h3><h4 id="isNil"><a href="#isNil" class="headerlink" title="isNil()"></a>isNil()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><h4 id="isValid"><a href="#isValid" class="headerlink" title="isValid()"></a>isValid()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// *int类型空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"var a *int IsNil:"</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line"><span class="comment">// nil值</span></span><br><span class="line">fmt.Println(<span class="string">"nil IsValid:"</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从结构体中查找"abc"字段</span></span><br><span class="line">fmt.Println(<span class="string">"不存在的结构体成员:"</span>, reflect.ValueOf(b).FieldByName(<span class="string">"abc"</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找"abc"方法</span></span><br><span class="line">fmt.Println(<span class="string">"不存在的结构体方法:"</span>, reflect.ValueOf(b).MethodByName(<span class="string">"abc"</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">"map中不存在的键："</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">"娜扎"</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h1><h2 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h2><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Field(i int) StructField</td><td align="center">根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td align="center">NumField() int</td><td align="center">返回结构体成员字段数量。</td></tr><tr><td align="center">FieldByName(name string) (StructField, bool)</td><td align="center">根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td align="center">FieldByIndex(index []int) StructField</td><td align="center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td align="center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td align="center">根据传入的匹配函数匹配需要的字段。</td></tr><tr><td align="center">NumMethod() int</td><td align="center">返回该类型的方法集中方法的数目</td></tr><tr><td align="center">Method(int) Method</td><td align="center">返回该类型方法集中的第i个方法</td></tr><tr><td align="center">MethodByName(string)(Method, bool)</td><td align="center">根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h2 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h2><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为""。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    PkgPath <span class="keyword">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="keyword">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="keyword">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="keyword">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h2><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Score <span class="keyword">int</span>    <span class="string">`json:"score"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  <span class="string">"小王子"</span>,</span><br><span class="line">Score: <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line"><span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">"name:%s index:%d type:%v json tag:%v\n"</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line"><span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">"Score"</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"name:%s index:%d type:%v json tag:%v\n"</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Study</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">"好好学习，天天向上。"</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Sleep</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">"好好睡觉，快快长大。"</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType := v.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">"method name:%s\n"</span>, t.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">"method:%s\n"</span>, methodType)</span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h1><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>编写代码利用反射实现一个ini文件的解析器程序。</p><p><code>conf.ini</code></p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#mysql config []节点  下面是子孩子</span><br><span class="line">[mysql]</span><br><span class="line">address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line"></span><br><span class="line">#redis config</span><br><span class="line">[redis]</span><br><span class="line">host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">6379</span></span><br><span class="line">password=root</span><br><span class="line">database=<span class="number">0</span></span><br><span class="line">test=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ini配置文件解析器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mysqlConfig MYSQL配置结构体</span></span><br><span class="line"><span class="keyword">type</span> MysqlConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Address <span class="keyword">string</span> <span class="string">`ini:"address"`</span></span><br><span class="line">Port <span class="keyword">int</span><span class="string">`ini:"port"`</span></span><br><span class="line">Username<span class="keyword">string</span><span class="string">`ini:"username"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`ini:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//redisconfig</span></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Host  <span class="keyword">string</span><span class="string">`ini:"host"`</span></span><br><span class="line">Port  <span class="keyword">int</span><span class="string">`ini:"port"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`ini:"password"`</span></span><br><span class="line">Database <span class="keyword">int</span> <span class="string">`ini:"database"`</span></span><br><span class="line">Test <span class="keyword">bool</span><span class="string">`ini:"test"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Config</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">MysqlConfig <span class="string">`ini:"mysql"`</span></span><br><span class="line">RedisConfig<span class="string">`ini:"redis"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIni</span><span class="params">(fileName <span class="keyword">string</span>,data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line"><span class="comment">//0.参数的校验</span></span><br><span class="line"><span class="comment">//0.1传来的data参数必须是指针类型（因为需要在函数中对其赋值）</span></span><br><span class="line">t :=reflect.TypeOf(data)</span><br><span class="line">fmt.Println(t.Kind())</span><br><span class="line"><span class="keyword">if</span> t.Kind() !=reflect.Ptr&#123; <span class="comment">//ptr指针类型</span></span><br><span class="line">err =errors.New(<span class="string">"data param should be a pointer"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0.2传进来的data参数必须是结构体类型指针（以为配置文件中各种键值对需要赋值给结构体字段）</span></span><br><span class="line"><span class="keyword">if</span> t.Elem().Kind() !=reflect.Struct&#123;</span><br><span class="line">err =errors.New(<span class="string">"data param should be a struct"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.读文件得到字节类型数据</span></span><br><span class="line">b,err :=ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string(b) 将字节类型转换为字符串</span></span><br><span class="line">lineSlice :=strings.Split(<span class="keyword">string</span>(b),<span class="string">"\r\n"</span>)</span><br><span class="line"><span class="comment">//fmt.Println(lineSlice)</span></span><br><span class="line"><span class="comment">//2.一行一行的读数据</span></span><br><span class="line"><span class="keyword">var</span> structName <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> idx,line := <span class="keyword">range</span> lineSlice&#123;</span><br><span class="line"><span class="comment">//去掉字符串首尾的空格</span></span><br><span class="line">line =strings.TrimSpace(line)</span><br><span class="line"><span class="comment">//如果是空格就跳过</span></span><br><span class="line"><span class="keyword">if</span>  <span class="built_in">len</span>(line) == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.1如果是注释就跳过</span></span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(line,<span class="string">";"</span>) || strings.HasPrefix(line,<span class="string">"#"</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.2如果是[开头的就表示是节（section）</span></span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(line,<span class="string">"["</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> line[<span class="number">0</span>] !=<span class="string">'['</span> || line[<span class="built_in">len</span>(line)<span class="number">-1</span>] != <span class="string">']'</span>&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把这一行首尾的[]去掉，取到中间的内容把首尾的空格去掉拿到内容</span></span><br><span class="line">sectionName :=strings.TrimSpace(line[<span class="number">1</span>:<span class="built_in">len</span>(line)<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sectionName)==<span class="number">0</span>&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据sectionName去掉data里面根据反射找到对应的结构体</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t.Elem().NumField();i++&#123;</span><br><span class="line">filed :=t.Elem().Field(i)</span><br><span class="line"><span class="keyword">if</span> sectionName == filed.Tag.Get(<span class="string">"ini"</span>)&#123;</span><br><span class="line"><span class="comment">//说明找到了对应的嵌套结构体，吧字段名记下来</span></span><br><span class="line">structName =filed.Name</span><br><span class="line">fmt.Printf(<span class="string">"找到%s对应的潜逃结构体%s\n"</span>,sectionName,structName)<span class="comment">//mysql  MysqlConfig</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//2.3如果不是[开头就是=分割键值对</span></span><br><span class="line"><span class="comment">//1.以等号分割这一行，等号左边是key，等号右边是value</span></span><br><span class="line"><span class="keyword">if</span> strings.Index(line,<span class="string">"="</span>) == <span class="number">-1</span> || strings.HasPrefix(line,<span class="string">"="</span>)&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax errot"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">index :=strings.Index(line,<span class="string">"="</span>)</span><br><span class="line">key :=strings.TrimSpace(line[:index])</span><br><span class="line">value :=strings.TrimSpace(line[index+<span class="number">1</span>:]) <span class="comment">//自动去除空格</span></span><br><span class="line"><span class="comment">//2.根据structName去data里面把对应的嵌套结构体给取出来</span></span><br><span class="line">v:=reflect.ValueOf(data)</span><br><span class="line">sValue :=v.Elem().FieldByName(structName)</span><br><span class="line">sType :=sValue.Type()</span><br><span class="line"><span class="keyword">if</span> sValue.Kind() != reflect.Struct&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"data中的%s字段应该是一个结构体"</span>,structName)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fieldName <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> fileType reflect.StructField</span><br><span class="line"><span class="comment">//3.遍历嵌套结构体的每一个字段，判断tag是不是等于key</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;sValue.NumField();i++&#123;</span><br><span class="line">filed :=sType.Field(i)</span><br><span class="line">fileType =filed</span><br><span class="line"><span class="keyword">if</span> filed.Tag.Get(<span class="string">"ini"</span>) ==key&#123;</span><br><span class="line"><span class="comment">//找到相应的字段</span></span><br><span class="line">fieldName= filed.Name</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.如果key=tag ，给这个字段赋值</span></span><br><span class="line"><span class="comment">//4.1根据fieldName去取出这个字段</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fieldName) == <span class="number">0</span> &#123; <span class="comment">//value长度为0</span></span><br><span class="line"><span class="comment">//在结构体中找不到对应的字符</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj :=sValue.FieldByName(fieldName)</span><br><span class="line"><span class="comment">//4.2对其赋值</span></span><br><span class="line">fmt.Println(fieldName,fileType.Type.Kind())<span class="comment">//address string</span></span><br><span class="line"><span class="keyword">switch</span> fileType.Type.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fileObj.SetString(value)</span><br><span class="line"><span class="keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:</span><br><span class="line"><span class="keyword">var</span> valueInt <span class="keyword">int64</span></span><br><span class="line">valueInt,err = strconv.ParseInt(value,<span class="number">10</span>,<span class="number">64</span>)<span class="comment">//10进制，64位</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"ling:%d value type error "</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetInt(valueInt)</span><br><span class="line"><span class="keyword">case</span> reflect.Bool:</span><br><span class="line"><span class="keyword">var</span> valueBool <span class="keyword">bool</span></span><br><span class="line">valueBool,err = strconv.ParseBool(value)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d value type error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetBool(valueBool)</span><br><span class="line"><span class="keyword">case</span> reflect.Float32,reflect.Float64:</span><br><span class="line"><span class="keyword">var</span> valueFloat <span class="keyword">float64</span></span><br><span class="line">valueFloat,err = strconv.ParseFloat(value,<span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d value type error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetFloat(valueFloat)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> cfg Config</span><br><span class="line">err :=loadIni(<span class="string">"./conf.ini"</span>,&amp;cfg)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"load ini failed,err %v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>,cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">ptr</span><br><span class="line">找到mysql对应的潜逃结构体MysqlConfig</span><br><span class="line">Address <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">Username <span class="keyword">string</span></span><br><span class="line">Password <span class="keyword">string</span></span><br><span class="line">找到redis对应的潜逃结构体RedisConfig</span><br><span class="line">Host <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">Password <span class="keyword">string</span></span><br><span class="line">Database <span class="keyword">int</span></span><br><span class="line">Test <span class="keyword">bool</span></span><br><span class="line">main.Config&#123;MysqlConfig:main.MysqlConfig&#123;Address:<span class="string">"127.0.0.1"</span>, Port:<span class="number">3306</span>, Username:<span class="string">"root"</span>, Password:<span class="string">"root"</span>&#125;, RedisConfig:main.RedisConfig&#123;Host:<span class="string">"127.0.0.1"</span>, Port:<span class="number">6379</span>, Password:<span class="string">"root"</span>, Database:<span class="number">0</span>, Test:<span class="literal">false</span>&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改文件名和操作权限</title>
      <link href="/2020/02/18/Linux%E5%91%BD%E4%BB%A4/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%93%8D%E4%BD%9C%E6%9D%83%E9%99%90/"/>
      <url>/2020/02/18/Linux%E5%91%BD%E4%BB%A4/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%92%8C%E6%93%8D%E4%BD%9C%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h2 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">cd</span> 到文件目录</span><br><span class="line"><span class="variable">$sudo</span> cp localFile.py new.py</span><br><span class="line">//然后删除localFile.py</span><br><span class="line"><span class="variable">$sudo</span> rm localFile.py</span><br><span class="line"></span><br><span class="line">//文件夹操作同</span><br><span class="line"><span class="variable">$sudo</span> cp localFile  new</span><br><span class="line">//删除文件加 -rf 强制</span><br><span class="line"><span class="variable">$sudo</span> rm -rf localFile</span><br></pre></td></tr></table></figure><p>github.com/Knetic/govaluate</p><p>github.com/cloudflare/cfssl</p><p>github.com/go-kit/kit/metrics</p><p>github.com/gogo/protobuf/proto</p><p>github.com/golang/mock/gomock</p><p>github.com/golang/protobuf/jsonpb</p><p>github.com/hyperledger/fabric-lib-go/healthz</p><p>github.com/hyperledger/fabric-protos-go/common</p><p>github.com/mitchellh/mapstructure</p><p>github.com/pkg/errors</p><p>github.com/prometheus/client_golang/prometheus</p><p>github.com/prometheus/client_golang/prometheus/promhttp</p><p>github.com/spf13/cast</p><p>github.com/spf13/viper</p><p>github.com/stretchr/testify/assert</p><p>golang.org/x/crypto/ocsp</p><p>golang.org/x/crypto/sha3</p><p>golang.org/x/net/context</p><p>google.golang.org/grpc</p><p>google.golang.org/grpc/codes</p><p>google.golang.org/grpc/connectivity</p><p>gopkg.in/yaml.v2</p>]]></content>
      
      
      <categories>
          
          <category> linux常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件乱码以及编码转换</title>
      <link href="/2020/02/18/Linux%E5%91%BD%E4%BB%A4/%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/02/18/Linux%E5%91%BD%E4%BB%A4/%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E4%BB%A5%E5%8F%8A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows转到linux中，文件乱码，文件编码转换"><a href="#Windows转到linux中，文件乱码，文件编码转换" class="headerlink" title="Windows转到linux中，文件乱码，文件编码转换"></a>Windows转到linux中，文件乱码，文件编码转换</h1><p>最近，学习又重新开始Linux学习，所以一直在Centos中，昨天一朋友把他在Windows下写的C程序发给我，我欣然答应，本以为很快就能在我的Linux系统中运行起来。没想到出现了乱码，结果想把这个问题解决，一下子就搞了近三个小时没有解决。今天，又想起来这个问题，竟然一下子就解决了，现在把学到的一些东西总结如下。</p><p>首先Windows下的文件拿到Linux中来查看出现乱码是一种很常见的现象，这方面的资料在网上也有很多。但解决方法大多都类似，有些概念没有解释清楚，也许是个人没有理解清楚。</p><p><strong>尝试方法一：</strong></p><p>一碰到这个问题，我想到的是Linux课上学到的一个命令dos2unix，以前也没用过，这次用了也没有解决问题。</p><p>因为，这个命令主要是用来处理Dos与Linux之间断行的差异的。DOS下的文本文件是以\r\n作为断行标志的，表示成十六进制就是0D 0A。而Unix下的文本文件是以\n作为断行标志的，表示成十六进制就是 0A。有时我们会遇到这样一种情况，dos下的文件在unix下显示是不出现断行，显得很乱，这时用这个命令就OK。</p><p>后来在网上查了下，知道是编码格式不一致导致的。因为Dos下编辑的文本默认是以GBK存储的，而Linux默认采取的存储方式是UTF-8，当然会出现乱码了，但是如何去将Dos下的GBK文件转换成UTF-8呢？</p><p><strong>尝试方法二：更改Vim读取时采用的编码</strong></p><p>先补充一个知识，参考博客<a href="http://blog.csdn.net/kl222/article/details/4550269" target="_blank" rel="noopener">http://blog.csdn.net/kl222/article/details/4550269</a></p><p><strong>vim编码方面的基础知识：</strong><br>存在3个变量：<br>encoding—-该选项使用于缓冲的文本(你正在编辑的文件)，寄存器，Vim 脚本文件等等。你可以把 ‘encoding’ 选项当作是对 Vim 内部运行机制的设定。<br>fileencoding—-该选项是vim写入文件时采用的编码类型。<br>termencoding—-该选项代表输出到客户终端（Term）采用的编码类型。</p><p>所以，我尝试了在Vim中</p><p>:set encoding</p><p>:set fileencoding=utf-8     #让Vim将gbk的文本转换成utf-8后，显示出来</p><p>经过这样改了之后，果然，Vim中看到的乱码消失了，此时心情小小的激动了一下子。</p><p>但是，当我退出Vim再次打开文件时，乱码又出现了，原来是我更改的Vim设置只是临时的，所以我决定将其写死到vim配置文件当中去，操作如下：</p><p>编辑~/.vimrc文件，加上如下几行：</p><p>set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</p><p>set termencoding=utf-8</p><p>set encoding=utf-8</p><p>这时，每次用Vim打开文件时都不出现乱码了，本以为问题解决了，我开始编译程序，当我运行的时候，乱码还是出现了。。。。此时，欲哭无泪</p><p>后来，我仔细想了一下，我更改Vim的配置，只是让我们看到的没有乱码，但从根本上讲，文件的编码方式还是没有变，所以当我用gcc编译后，文件的编码格式应该还是gbk的。这样导致的乱码。所以，我决定找个工具，直接讲gbk文件转换成utf-8。</p><p><strong>尝试三：</strong></p><p>1.查看文件存储格式</p><p>#file test.cpp</p><p>test.cpp: ISO-8859 English text, with CRLF line terminators</p><p>可以看出文件是以ISO-8859存储的。</p><p>2.查看系统语言设置</p><p>#cat /etc/sysconfig/i18n</p><p>LANG=”en_US.UTF-8”<br>SYSFONT=”latarcyrheb-sun16”<br>可以看出Linux是以UTF-8编码的</p><p>3.利用工具将文件从ISO-8859转换成UTF-8（这里我采用的是iconv命令）</p><p>＃iconv -f ISO-8859 -t UTF-8 test.c -o test_u.c</p><p>这时竟然出现了一个错误：</p><p>iconv: conversion from `ISO-8859’ is not supported</p><p>Try <code>iconv --help&#39; or</code>iconv –usage</p><p>解决方案：</p><p>将ISO-8859换成GBK</p><p>＃iconv -f GBK -t UTF-8 test.c -o test_u.c</p><p>终于大功告成！</p><p>参考文献：</p><p>[1].<a href="http://blog.csdn.net/kl222/article/details/4550269" target="_blank" rel="noopener">http://blog.csdn.net/kl222/article/details/4550269</a></p><p>[2].<a href="http://www.cnblogs.com/cosiray/archive/2012/05/04/2483111.html" target="_blank" rel="noopener">http://www.cnblogs.com/cosiray/archive/2012/05/04/2483111.html</a></p><p>[3].<a href="http://blog.chinaunix.net/uid-26786246-id-3636785.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26786246-id-3636785.html</a></p>]]></content>
      
      
      <categories>
          
          <category> linux常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13Go语言基础之文件操作</title>
      <link href="/2020/01/28/13Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/01/28/13Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言文件操作"><a href="#Go语言文件操作" class="headerlink" title="Go语言文件操作"></a>Go语言文件操作</h1><p>主要介绍了Go语言中文件读写的相关操作。</p><p>文件是什么？</p><p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p><a id="more"></a><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 使用Read方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"读取了%d字节数据\n"</span>, n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">"./xx.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">line, err := reader.ReadString(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h2><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString区别"><a href="#Write和WriteString区别" class="headerlink" title="Write和WriteString区别"></a>Write和WriteString区别</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">file.Write([]<span class="keyword">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">"hello 小王子"</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writer.WriteString(<span class="string">"hello沙河\n"</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"./xx.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h2><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyFile 拷贝文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 以读方式打开源文件</span></span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, srcName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> src.Close()</span><br><span class="line"><span class="comment">// 以写|创建的方式打开目标文件</span></span><br><span class="line">dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, dstName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line"><span class="keyword">return</span> io.Copy(dst, src) <span class="comment">//调用io.Copy()拷贝内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := CopyFile(<span class="string">"dst.txt"</span>, <span class="string">"src.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"copy file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"copy done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h2><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat命令实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf, err := r.ReadBytes(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line"><span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有参数默认从标准输入读取内容</span></span><br><span class="line">cat(bufio.NewReader(os.Stdin))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次读取每个指定文件的内容并打印到终端</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">f, err := os.Open(flag.Arg(i))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"reading from %s failed, err:%v\n"</span>, flag.Arg(i), err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cat(bufio.NewReader(f))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12Go语言基础之包</title>
      <link href="/2020/01/25/12Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/"/>
      <url>/2020/01/25/12Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之包"><a href="#Go语言基础之包" class="headerlink" title="Go语言基础之包"></a>Go语言基础之包</h1><p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。</p><a id="more"></a><h1 id="Go语言的包（package）"><a href="#Go语言的包（package）" class="headerlink" title="Go语言的包（package）"></a>Go语言的包（package）</h1><p>1.包的路径从<code>GOPATH/src</code>后面的路径开始写起，路径分隔符用<code>/</code></p><p>2.想被别的宝地啊用的标识符都要首字母大写</p><p>3.单行导入和多行导入</p><p>4.导入包的时候可以制定别名</p><p>5.导入包不想使用包内部的标识符，需要使用匿名导入</p><p>6.每个包导入的时候会自动执行一个名为<code>init()</code>的函数，它没有参数也没有返回值</p><p>7.多个包中都定义了<code>init()</code>函数，执行顺序如下</p><h2 id="包介绍"><a href="#包介绍" class="headerlink" title="包介绍"></a>包介绍</h2><p><code>包（package）</code>是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p>我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。</p><p>举个例子， 我们定义一个包名为<code>pkg2</code>的包，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包变量可见性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="keyword">const</span> Mode = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写，外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"><span class="keyword">var</span> Age = <span class="number">18</span> <span class="comment">// 函数局部变量，外部包不可见，只能在当前函数内使用</span></span><br><span class="line">fmt.Println(Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="comment">//可在包外访问的方法</span></span><br><span class="line">class <span class="keyword">string</span> <span class="comment">//仅限包内访问的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">init() <span class="comment">//仅限包内访问的方法</span></span><br><span class="line">Pay()  <span class="comment">//可在包外访问的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>要在代码中引用其他包的内容，需要使用<code>import</code>关键字导入使用的包。具体语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>import导入语句通常放在文件开头包声明语句的下面。</li><li>导入的包名需要使用双引号包裹起来。</li><li>包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔。</li><li>Go语言中禁止循环导入包。</li></ul><h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><p>单行导入的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包2"</span></span><br></pre></td></tr></table></figure><h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><p>多行导入的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"包1"</span></span><br><span class="line">    <span class="string">"包2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a>自定义包名</h2><p>在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 别名 <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>单行导入方式定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> m <span class="string">"github.com/Q1mi/studygo/pkg_test"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m.Add(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行导入方式定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    m <span class="string">"github.com/Q1mi/studygo/pkg_test"</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m.Add(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h2><p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><h2 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h2><h3 id="init-函数介绍"><a href="#init-函数介绍" class="headerlink" title="init()函数介绍"></a>init()函数介绍</h3><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。</p><p>包初始化执行的顺序如下图所示：<img src="https://www.liwenzhou.com/images/Go/package/init01.png" alt="包中的init()执行时机"></p><h3 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init()函数执行顺序"></a>init()函数执行顺序</h3><p>Go语言包会从<code>main</code>包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p><p>在运行时，被最后导入的包会最先初始化并调用其<code>init()</code>函数， 如下图示：<img src="https://www.liwenzhou.com/images/Go/package/init02.png" alt="包之间的init()执行顺序"></p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写一个<code>clac</code>包实现加减乘除四个功能函数，在<code>snow</code>这个包中导入并使用加减乘除四个函数实现数学运算。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11Go语言基础之接口</title>
      <link href="/2020/01/25/11Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/01/25/11Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之接口"><a href="#Go语言基础之接口" class="headerlink" title="Go语言基础之接口"></a>Go语言基础之接口</h1><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><a id="more"></a><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p><p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p><h2 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"喵喵喵"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"汪汪汪"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Cat&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"猫:"</span>, c.Say())</span><br><span class="line">d := Dog&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"狗:"</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？</p><p>像类似的例子在我们编程过程中会经常遇到：</p><p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p><p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p><p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</p><p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>Go语言提倡面向接口编程。</p><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p><h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。</p><p>我们来定义一个<code>Sayer</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>dog</code>和<code>cat</code>两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Sayer</code>接口里只有一个<code>say</code>方法，所以我们只需要给<code>dog</code>和<code>cat</code>分别实现<code>say</code>方法就可以实现<code>Sayer</code>接口了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"汪汪汪"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"喵喵喵"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p><h2 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h2><p>那实现了接口有什么用呢？</p><p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，<code>Sayer</code>类型的变量能够存储<code>dog</code>和<code>cat</code>类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是<code>dog</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针<em>dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值`</em>fugui`。</p><h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*dog</code>类型，所以不能给<code>x</code>传入<code>dog</code>类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>注意：</strong>这是一道你需要回答“能”或者“不能”的题！</p><p>首先请观察下面的这段代码，然后请回答这段代码能不能通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> think == <span class="string">"sb"</span> &#123;</span><br><span class="line">talk = <span class="string">"你是个大帅比"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">talk = <span class="string">"您好"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">think := <span class="string">"bitch"</span></span><br><span class="line">fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： <code>Mover</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dog既可以实现Sayer接口，也可以实现Mover接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会叫汪汪汪\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Sayer</span><br><span class="line"><span class="keyword">var</span> y Mover</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line">x = a</span><br><span class="line">y = a</span><br><span class="line">x.say()</span><br><span class="line">y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个<code>Mover</code>接口，它要求必须由一个<code>move</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会跑\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// car类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s速度70迈\n"</span>, c.brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的<code>move</code>方法就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> a = dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = car&#123;brand: <span class="string">"保时捷"</span>&#125;</span><br><span class="line">x = a</span><br><span class="line">x.move()</span><br><span class="line">x = b</span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度<span class="number">70</span>迈</span><br></pre></td></tr></table></figure><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"甩一甩"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"洗刷刷"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Sayer</span><br><span class="line">Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"喵喵喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"猫会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x animal</span><br><span class="line">x = cat&#123;name: <span class="string">"花花"</span>&#125;</span><br><span class="line">x.move()</span><br><span class="line">x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个空接口x</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">s := <span class="string">"Hello 沙河"</span></span><br><span class="line">x = s</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">x = i</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">b := <span class="literal">true</span></span><br><span class="line">x = b</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">"name"</span>] = <span class="string">"沙河娜扎"</span></span><br><span class="line">studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>一个接口的值（简称接口值）是由<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的。这两部分分别称为接口的<code>动态类型</code>和<code>动态值</code>。</p><p>我们来看一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>请看下图分解：<img src="https://www.liwenzhou.com/images/Go/interface/interface.png" alt="接口值图解"></p><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示类型为<code>interface{}</code>的变量</li><li>T：表示断言<code>x</code>可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">"Hello 沙河"</span></span><br><span class="line">v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中如果要断言多次就需要写多个<code>if</code>判断，这个时候我们可以使用<code>switch</code>语句来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a string，value is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a int is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a bool is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"unsupport type！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p><p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10Go语言基础之结构体</title>
      <link href="/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之结构体"><a href="#Go语言基础之结构体" class="headerlink" title="Go语言基础之结构体"></a>Go语言基础之结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><a id="more"></a><h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过<code>Type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type（<span class="keyword">int</span>，<span class="keyword">string</span>，<span class="keyword">byte</span>。。。）</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="keyword">string</span></span><br><span class="line">age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">"沙河娜扎"</span></span><br><span class="line">p1.city = <span class="string">"北京"</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person&#123;name:"沙河娜扎", city:"北京", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//匿名结构体</span></span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">"小王子"</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">"小王子"</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">"上海"</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"小王子", city:"上海", age:28&#125;</span></span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。（new &amp;make申请内存空间）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person（自定义类型）</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">"七米"</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">"成都"</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"七米", city:"成都", age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p4 person</span><br><span class="line">fmt.Printf(<span class="string">"p4=%#v\n"</span>, p4) <span class="comment">//p4=main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p6=%#v\n"</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:"", city:"北京", age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">"沙河娜扎"</span>,</span><br><span class="line"><span class="string">"北京"</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p8=%#v\n"</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:"沙河娜扎", city:"北京", age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int8</span></span><br><span class="line">c <span class="keyword">int8</span></span><br><span class="line">d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"n.a %p\n"</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">"n.b %p\n"</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">"n.c %p\n"</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">"n.d %p\n"</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com" target="_blank" rel="noopener">在 Go 中恰到好处的内存对齐</a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>请问下面代码的执行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">stus := []student&#123;</span><br><span class="line">&#123;name: <span class="string">"小王子"</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"娜扎"</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"大王八"</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">m[stu.name] = &amp;stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">"=&gt;"</span>, v.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数：约定成俗new开头</span></span><br><span class="line"><span class="comment">//返回的是结构体还是结构体指针</span></span><br><span class="line"><span class="comment">//当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">"张三"</span>, <span class="string">"沙河"</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p9) <span class="comment">//&amp;main.person&#123;name:"张三", city:"沙河", age:90&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法作用于特定类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;<span class="comment">//只用dog才能使用</span></span><br><span class="line">fucn(d *dog)wang()&#123;</span><br><span class="line">    fmt.Println(<span class="string">"汪汪汪"</span>，d.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s的梦想是学好Go语言！\n"</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者：传内存地址进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge(<span class="number">30</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者 ：传拷贝进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, 我是一个int。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v  %T\n"</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">    <span class="comment">//不能再定义string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">"小王子"</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person&#123;string:"北京", int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address Address  <span class="comment">//如果换成Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">"小王子"</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">"山东"</span>,</span><br><span class="line">City:     <span class="string">"威海"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(user1.Address.city)  <span class="comment">//如果上面换成匿名Address ，user1.city 就可以直接访问</span></span><br><span class="line">    fmt.Println(user1.city)<span class="comment">//现在自己的结构体里面找，找不到就去匿名嵌套的结构体里面找</span></span><br><span class="line">    fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)<span class="comment">//user1=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.Name = <span class="string">"小王子"</span></span><br><span class="line">user2.Gender = <span class="string">"男"</span></span><br><span class="line">user2.Address.Province = <span class="string">"山东"</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">user2.City = <span class="string">"威海"</span> <span class="comment">//（user2.Address.city）               //直接访问匿名结构体的字段名</span></span><br><span class="line">fmt.Printf(<span class="string">"user2=%#v\n"</span>, user2) <span class="comment">//user2=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="keyword">string</span></span><br><span class="line">City       <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user3 User</span><br><span class="line">user3.Name = <span class="string">"沙河娜扎"</span></span><br><span class="line">user3.Gender = <span class="string">"男"</span></span><br><span class="line"><span class="comment">// user3.CreateTime = "2019" //ambiguous selector user3.CreateTime</span></span><br><span class="line">user3.Address.CreateTime = <span class="string">"2000"</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">user3.Email.CreateTime = <span class="string">"2000"</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动！\n"</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="keyword">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会汪汪汪~\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">"乐乐"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体字段的可见性（-）"><a href="#结构体字段的可见性（-）" class="headerlink" title="结构体字段的可见性（**）"></a>结构体字段的可见性（**）</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span></span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">"101"</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;"Title":"101","Students":[&#123;"ID":0,"Gender":"男","Name":"stu00"&#125;,&#123;"ID":1,"Gender":"男","Name":"stu01"&#125;,&#123;"ID":2,"Gender":"男","Name":"stu02"&#125;,&#123;"ID":3,"Gender":"男","Name":"stu03"&#125;,&#123;"ID":4,"Gender":"男","Name":"stu04"&#125;,&#123;"ID":5,"Gender":"男","Name":"stu05"&#125;,&#123;"ID":6,"Gender":"男","Name":"stu06"&#125;,&#123;"ID":7,"Gender":"男","Name":"stu07"&#125;,&#123;"ID":8,"Gender":"男","Name":"stu08"&#125;,&#123;"ID":9,"Gender":"男","Name":"stu09"&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">"value1"</span> key2:<span class="string">"value2"</span>`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 <strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key </span></span><br><span class="line">name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">name:   <span class="string">"沙河娜扎"</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json str:%s\n"</span>, data) <span class="comment">//json str:&#123;"id":1,"Gender":"男"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体中遇到的问题"><a href="#结构体中遇到的问题" class="headerlink" title="结构体中遇到的问题"></a>结构体中遇到的问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个int类型的变量，它的值是10//1</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">x =<span class="number">10</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">x :=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="keyword">var</span> myInt <span class="keyword">int</span> <span class="comment">//自定义类型</span></span><br><span class="line">m :=myInt(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>问题2结构体初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pserson <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> </span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法1，声明一个person类型的变量p</span></span><br><span class="line">    <span class="keyword">var</span> p person</span><br><span class="line">    p.name=<span class="string">"hg"</span></span><br><span class="line">    p.age=<span class="number">19</span></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    <span class="comment">//方法2，键值对初始化</span></span><br><span class="line">    <span class="keyword">var</span> p2=person&#123;</span><br><span class="line">        name :<span class="string">"hg"</span>,</span><br><span class="line">        age : <span class="number">19</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p2)</span><br><span class="line">    <span class="comment">//方法3，zhi值列表初始化</span></span><br><span class="line">    <span class="keyword">var</span> p3 = person&#123;</span><br><span class="line">        <span class="string">"理想"</span>，</span><br><span class="line">        <span class="number">12</span>，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题3：为什么要用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(x <span class="keyword">string</span>,y <span class="keyword">int</span>)</span> <span class="title">person</span></span>&#123;      <span class="comment">//返回*person</span></span><br><span class="line">    <span class="comment">//别人调用，我能给他一个person类型的变量 </span></span><br><span class="line">    <span class="keyword">return</span> person&#123;<span class="comment">//return &amp;person</span></span><br><span class="line">        name:x,</span><br><span class="line">        age :y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用“面向对象”的思维方式编写一个学生信息管理系统。<ol><li>学生有id、姓名、年龄、分数等信息</li><li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数版学生管理系统，</span></span><br><span class="line"><span class="comment">写一个系统能够产看，新增学生，删除学生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allStudent <span class="keyword">map</span>[<span class="keyword">int64</span>]*student <span class="comment">//变量声明</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudnet</span><span class="params">(id <span class="keyword">int64</span>,name <span class="keyword">string</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">id : id ,</span><br><span class="line">name : name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示所有学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showallStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k,v :=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line">fmt.Printf(<span class="string">"学号：%d 姓名：%s\n"</span>,k,v.name,)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建一个学生</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">id <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生学号："</span>)</span><br><span class="line">fmt.Scanln(&amp;id)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生姓名："</span>)</span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line">newStu :=newStudnet(id,name)</span><br><span class="line"><span class="comment">//2追加到allstudent这个map中</span></span><br><span class="line">allStudent[id]=newStu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//1.请输入删除学生的学号</span></span><br><span class="line"><span class="keyword">var</span> deleteId  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"请输入你要删除学生的学号:"</span>)</span><br><span class="line">fmt.Scanln(&amp;deleteId)</span><br><span class="line"><span class="comment">//2.去allStudent这个map中根据学号删除对应的键值对</span></span><br><span class="line"><span class="keyword">for</span> k,_:=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line"><span class="keyword">if</span> k==deleteId&#123;</span><br><span class="line"><span class="built_in">delete</span>(allStudent,deleteId)</span><br><span class="line">fmt.Println(<span class="string">"删除成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">allStudent =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*student,<span class="number">48</span>) <span class="comment">//初始化（开辟内存空间）</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//1.打印菜单</span></span><br><span class="line">fmt.Println(<span class="string">"欢迎学生管理系统"</span>)</span><br><span class="line">fmt.Println(<span class="string">`</span></span><br><span class="line"><span class="string">1.查看所用学生</span></span><br><span class="line"><span class="string">2.新增学生</span></span><br><span class="line"><span class="string">3.删除学生</span></span><br><span class="line"><span class="string">4.退出</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">fmt.Println(<span class="string">"请输入你要干啥:"</span>)</span><br><span class="line"><span class="comment">//2.等待用户选择要做什么</span></span><br><span class="line"><span class="keyword">var</span> choice <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;choice)</span><br><span class="line">fmt.Printf(<span class="string">"你选择了%d这个选项\n"</span>, choice)</span><br><span class="line"><span class="comment">//3.执行对应的函数</span></span><br><span class="line"><span class="keyword">switch</span> choice &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">showallStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">addStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">deleteStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"gun~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09Go语言基础之函数</title>
      <link href="/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之函数"><a href="#Go语言基础之函数" class="headerlink" title="Go语言基础之函数"></a>Go语言基础之函数</h1><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello 沙河"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret := intSum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名的函数值就相当于在函数中声明一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x,y <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int</span>)</span></span>&#123;  <span class="comment">//若func f(x,y int) int()&#123; return x+y&#125;</span></span><br><span class="line">res =x+y</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//命名的返回值可以不写res</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可变长参数，必须放在函数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s</span><span class="params">(s <span class="keyword">string</span>,y... <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(y)  <span class="comment">//y的类型是切片slice</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go函数没有默认参数这个概念</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">r :=f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s(<span class="string">"hg"</span>)   <span class="comment">//hg []</span></span><br><span class="line">s(<span class="string">"huang"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)<span class="comment">//huang [1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum2</span><span class="params">(x ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x) <span class="comment">//x是一个切片       </span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 := intSum2()</span><br><span class="line">ret2 := intSum2(<span class="number">10</span>)</span><br><span class="line">ret3 := intSum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret4 := intSum2(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) <span class="comment">//0 10 30 60</span></span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 := intSum3(<span class="number">100</span>)</span><br><span class="line">ret6 := intSum3(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">ret7 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret8 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) <span class="comment">//100 110 130 160</span></span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言中通过<code>return</code>关键字向外输出返回值。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testGlobalVar() <span class="comment">//num=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"x=%d\n"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) <span class="comment">// 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">// 函数中优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testNum() <span class="comment">// num=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar2</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x, y) <span class="comment">//函数的参数也是只在本函数中生效</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">100</span> <span class="comment">//变量z只在if语句块生效</span></span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(z)//此处无法使用变量z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//变量i只在当前for语句块中生效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(i) //此处无法使用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用声明calculation也可以直接函数赋值</span></span><br><span class="line">f := add                        <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line">fmt.Printf(<span class="string">"type of f:%T\n"</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>, op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">"无法识别的操作符"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：  (闭包是一个函数，函数是可以成为返回值，这个函数包含了他外部作用域的一个变量)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = adder()   <span class="comment">//func f(y int) int&#123; x+=y  return x&#125;</span></span><br><span class="line"> fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder2(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//70</span></span><br><span class="line"></span><br><span class="line">f1 := adder2(<span class="number">20</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//60</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">".jpg"</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">".txt"</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">"test"</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">"test"</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：第一步：返回值赋值。第二部：真正的return返回；</p><p>函数中如果存在defer。那么defer执行的时机是在第一步和第二步之间</p><p><img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p><h3 id="defer经典案例-面试题"><a href="#defer经典案例-面试题" class="headerlink" title="defer经典案例(面试题)"></a>defer经典案例(面试题)</h3><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">int</span></span> &#123;   <span class="comment">//f1()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//x=6</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x   <span class="comment">//x =5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f2()=6  定义了返回值</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>   <span class="comment">//返回值=x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(y <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f3()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//修改的是x的值</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x  <span class="comment">//返回值y=x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;   <span class="comment">//f4()=5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x++  <span class="comment">//改变函数中的副本</span></span><br><span class="line">&#125;(x)<span class="comment">//外部穿的参数，属于局部变量，不是返回值x传进去的参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span> <span class="comment">//返回值x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">fmt.Println(f3())</span><br><span class="line">fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"AA"</span>, x, calc(<span class="string">"A"</span>, x, y))</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"BB"</span>, x, calc(<span class="string">"B"</span>, x, y))</span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 1 2 3</span></span><br><span class="line"><span class="comment">B 0 2 2</span></span><br><span class="line"><span class="comment">BB 0 2 2</span></span><br><span class="line"><span class="comment">AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 x=1 y=2     defer 是压栈，先进后出</span></span><br><span class="line"><span class="comment">//2 defer calc("AA",x,calc("A", x, y))  压栈的时候将x存进去</span></span><br><span class="line"><span class="comment">//3 calc("A", x, y) //"A" 1 2 3</span></span><br><span class="line"><span class="comment">//4 defer calc("AA",x,3)  （x =1）</span></span><br><span class="line"><span class="comment">//5 x=0</span></span><br><span class="line"><span class="comment">//6 defer calc("BB",x,calc("B", x, y))</span></span><br><span class="line"><span class="comment">//7 calc("B", x, y) //"B" 0 2 2    </span></span><br><span class="line"><span class="comment">//8 defer calc("BB",x,2)</span></span><br><span class="line"><span class="comment">//9 y=1 （有点混淆，没有被引用过）</span></span><br><span class="line"><span class="comment">//10 calc("BB",x,2) //"BB" 0 2 2  出栈  </span></span><br><span class="line"><span class="comment">//calc("AA",x,3) //"AA" 1 3 4   这里有点特别  （x=1 为原先的）</span></span><br></pre></td></tr></table></figure><p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p><h1 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h1><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic <span class="keyword">in</span> B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        .../code/func/main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        .../code/func/main.go:20 +0x98</span><br></pre></td></tr></table></figure><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recover in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>分金币</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span></span><br><span class="line"><span class="comment">分配规则如下：</span></span><br><span class="line"><span class="comment">a. 名字中每包含1个'e'或'E'分1枚金币</span></span><br><span class="line"><span class="comment">b. 名字中每包含1个'i'或'I'分2枚金币</span></span><br><span class="line"><span class="comment">c. 名字中每包含1个'o'或'O'分3枚金币</span></span><br><span class="line"><span class="comment">d: 名字中每包含1个'u'或'U'分4枚金币</span></span><br><span class="line"><span class="comment">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span></span><br><span class="line"><span class="comment">程序结构如下，请实现 ‘dispatchCoin’ 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">coins = <span class="number">50</span></span><br><span class="line">users = []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Matthew"</span>, <span class="string">"Sarah"</span>, <span class="string">"Augustus"</span>, <span class="string">"Heidi"</span>, <span class="string">"Emilie"</span>, <span class="string">"Peter"</span>, <span class="string">"Giana"</span>, <span class="string">"Adriano"</span>, <span class="string">"Aaron"</span>, <span class="string">"Elizabeth"</span>,</span><br><span class="line">&#125;</span><br><span class="line">distribution = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">left := dispatchCoin()</span><br><span class="line">fmt.Println(<span class="string">"剩下："</span>, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08Go语言基础之Map</title>
      <link href="/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/"/>
      <url>/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之map"><a href="#Go语言基础之map" class="headerlink" title="Go语言基础之map"></a>Go语言基础之map</h1><p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p><a id="more"></a><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>Go语言中 <code>map</code>的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">"小明"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line"><span class="built_in">type</span> of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"username"</span>: <span class="string">"沙河小王子"</span>,</span><br><span class="line"><span class="string">"password"</span>: <span class="string">"123456"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//开辟内存空间，要估值好map容量，避免在程序运行期间再动态扩容</span></span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">"张三"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"查无此人"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;  <span class="comment">//默认获得key值</span></span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> _,value:=<span class="keyword">range</span> scoreMap&#123; <span class="comment">//获取value值</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">"小明"</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按照指定顺序遍历map（map本身是无序的）"><a href="#按照指定顺序遍历map（map本身是无序的）" class="headerlink" title="按照指定顺序遍历map（map本身是无序的）"></a>按照指定顺序遍历map（map本身是无序的）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"stu%02d"</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//元素类型为map的切片</span></span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"小王子"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"password"</span>] = <span class="string">"123456"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"address"</span>] = <span class="string">"沙河"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line">key := <span class="string">"中国"</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">"北京"</span>, <span class="string">"上海"</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li></ol><h4 id="看文档"><a href="#看文档" class="headerlink" title="看文档"></a>看文档</h4><p> go doc builtin.delete(delete代表方法)</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07Go语言基础之指针</title>
      <link href="/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/"/>
      <url>/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之指针"><a href="#Go语言基础之指针" class="headerlink" title="Go语言基础之指针"></a>Go语言基础之指针</h1><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><a id="more"></a><h1 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h1><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h2 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h2><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为<code>T</code></li><li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a:%d ptr:%p\n"</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">fmt.Printf(<span class="string">"b:%p type:%T\n"</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">    </span><br><span class="line">    n :=<span class="number">18</span></span><br><span class="line">p :=&amp;n</span><br><span class="line">fmt.Println(&amp;n)<span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,p) <span class="comment">//*int</span></span><br><span class="line">fmt.Println(p) <span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Println(*p)<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">m :=*p</span><br><span class="line">fmt.Println(m) <span class="comment">//18</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,m)<span class="comment">//int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：<img src="https://www.liwenzhou.com/images/Go/pointer/ptr.png" alt="取变量地址图示"></p><h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//指针取值</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b)</span><br><span class="line">c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">"value of c:%v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of b:*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="keyword">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p><strong>指针传值示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var a *int //nil pointer</span></span><br><span class="line"><span class="comment">// *a =100</span></span><br><span class="line"><span class="comment">// fmt.Println(*a)//报错无效内存地址和空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 *<span class="keyword">int</span>  </span><br><span class="line">fmt.Println(a1)  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">var</span> a2=<span class="built_in">new</span>(<span class="keyword">int</span>)  <span class="comment">//new函数申请一个内存地址</span></span><br><span class="line">fmt.Println(a2) <span class="comment">//0xc04204a0e0</span></span><br><span class="line">*a2 =<span class="number">100</span></span><br><span class="line">fmt.Println(*a2) <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>我们先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">100</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><h5 id="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："><a href="#make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：" class="headerlink" title="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："></a>make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与make的区别（面试题）"><a href="#new与make的区别（面试题）" class="headerlink" title="new与make的区别（面试题）"></a>new与make的区别（面试题）</h3><ol><li>二者都是用来做（申请）内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型（int string …）的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06Go语言基础之切片</title>
      <link href="/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/"/>
      <url>/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之切片"><a href="#Go语言基础之切片" class="headerlink" title="Go语言基础之切片"></a>Go语言基础之切片</h1><p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [3]<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="keyword">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。</p><h3 id="基于数组定义切片"><a href="#基于数组定义切片" class="headerlink" title="基于数组定义切片"></a>基于数组定义切片</h3><p>由于切片的底层就是一个数组，所以我们可以基于数组定义切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于数组定义切片</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">4</span>]                     <span class="comment">//基于数组a创建切片，前包后不包，包括元素a[1],a[2],a[3]</span></span><br><span class="line">fmt.Println(b)                  <span class="comment">//[56 57 58]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:[]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := a[<span class="number">1</span>:] <span class="comment">//[56 57 58 59]</span></span><br><span class="line">d := a[:<span class="number">4</span>] <span class="comment">//[55 56 57 58]</span></span><br><span class="line">e := a[:]  <span class="comment">//[55 56 57 58 59]</span></span><br></pre></td></tr></table></figure><h3 id="切片再切片"><a href="#切片再切片" class="headerlink" title="切片再切片"></a>切片再切片</h3><p>除了基于数组得到切片，我们还可以通过切片来得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//切片再切片</span></span><br><span class="line">a := [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"a:%v type:%T len:%d  cap:%d\n"</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))<span class="comment">//6 6</span></span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"b:%v type:%T len:%d  cap:%d\n"</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))<span class="comment">//2 5</span></span><br><span class="line">c := b[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"c:%v type:%T len:%d  cap:%d\n"</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c)) <span class="comment">//4  4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:[北京 上海 广州 深圳 成都 重庆] <span class="built_in">type</span>:[6]string len:6  <span class="built_in">cap</span>:6</span><br><span class="line">b:[上海 广州] <span class="built_in">type</span>:[]string len:2  <span class="built_in">cap</span>:5</span><br><span class="line">c:[广州 深圳 成都 重庆] <span class="built_in">type</span>:[]string len:4  <span class="built_in">cap</span>:4</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</p><p>​            切片指向一个底层数组</p><p>​            切片的长度就是它元素的个数</p><p>​            切片的容量，是最底层数组从切片的第一个元素到最后一个元素的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s6 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s7 :=s6[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//len (2 3 4)   cap(2 3 4 5 6 7)   </span></span><br><span class="line">fmt.Printf(<span class="string">"len(s7)%d   cap(s7)%d"</span>,<span class="built_in">len</span>(s7),<span class="built_in">cap</span>(s7)) <span class="comment">//3 ,6</span></span><br></pre></td></tr></table></figure><p>1.切片不保存具体的值</p><p>2.切片对应一个底层数组</p><p>3.底层数组都是占用一块连续的内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a1 :=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">a2 := a1  <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">// var a3 []int //这样定义a3为nil  没办法进行copy</span></span><br><span class="line"><span class="keyword">var</span> a3 =<span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(a3,a1)  <span class="comment">//a1复制到a3</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[1 3 5] [1 3 5] [1 3 5]</span></span><br><span class="line">a1[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[100 3 5] [100 3 5] [1 3 5]  由于切片是引用类型a1给a2赋值，都指向同一块内存地址</span></span><br><span class="line"></span><br><span class="line">x1 :=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//数组</span></span><br><span class="line">s1 :=x1[:]<span class="comment">//切片</span></span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 2 3] 3 3 </span></span><br><span class="line">s1=<span class="built_in">append</span>(s1[:<span class="number">1</span>],s1[<span class="number">2</span>:]...)</span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 3] 2 3 删除一个元素</span></span><br><span class="line">fmt.Println(x1) <span class="comment">//[1 3 3]  //修改了底层数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0]</span></span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">a =<span class="built_in">append</span>(a,i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//20扩容 面试题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 =[...]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>&#125;</span><br><span class="line">sort.Ints(b1[:]) <span class="comment">//对切片进行排序</span></span><br><span class="line">fmt.Println(b1)<span class="comment">//1，2，4，9</span></span><br></pre></td></tr></table></figure><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  <span class="comment">//创建切片</span></span><br><span class="line">fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质（引用类型）"><a href="#切片的本质（引用类型）" class="headerlink" title="切片的本质（引用类型）"></a>切片的本质（引用类型）</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。（切片就是一个框，框住了一块连续的内存，切片属于引用类型，真正的数据都保存在底层数组里的）</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><h5 id="切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："><a href="#切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：" class="headerlink" title="切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："></a>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]   切片是引用类型</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">"%v  len:%d  cap:%d  ptr:%p\n"</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"北京"</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"><a href="#由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。" class="headerlink" title="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"></a>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</h5><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1.请写出下面代码的输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a = <span class="built_in">append</span>(a, fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int{3, 7, 8, 9, 1}</code>进行排序。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05Go语言基础之数组</title>
      <link href="/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
      <url>/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之数组"><a href="#Go语言基础之数组" class="headerlink" title="Go语言基础之数组"></a>Go语言基础之数组</h1><p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><a id="more"></a><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of numArray:%T\n"</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of cityArray:%T\n"</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t"</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li><li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04Go语言基础之流程控制</title>
      <link href="/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之流程控制"><a href="#Go语言基础之流程控制" class="headerlink" title="Go语言基础之流程控制"></a>Go语言基础之流程控制</h1><p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><a id="more"></a><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域  全局变量</span></span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域    局部变量</span></span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p><p>score 的作用域不一样</p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"大拇指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"食指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"中指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"无名指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">"小拇指"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"无效的输入！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">"奇数"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"偶数"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好学习吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好工作吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好享受吧"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"活着真好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"a"</span>:</span><br><span class="line">fmt.Println(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"b"</span>:</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"c"</span>:</span><br><span class="line">fmt.Println(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;                             <span class="comment">//跳出多层循环，经常使用</span></span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">"结束for循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码打印9*9乘法表。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Go语言基础之运算符</title>
      <link href="/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之运算符"><a href="#Go语言基础之运算符" class="headerlink" title="Go语言基础之运算符"></a>Go语言基础之运算符</h1><p>运算符用于在程序运行时执行数学或逻辑运算。</p><a id="more"></a><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">//单独的语句，不能放在=号的右边赋值</span></span><br><span class="line">a-- <span class="comment">//单独语句，不能放在=的右边赋值</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!=</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">||</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+=</td><td align="center">相加后再赋值</td></tr><tr><td align="center">-=</td><td align="center">相减后再赋值</td></tr><tr><td align="center">*=</td><td align="center">相乘后再赋值</td></tr><tr><td align="center">/=</td><td align="center">相除后再赋值</td></tr><tr><td align="center">%=</td><td align="center">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;=</td><td align="center">左移后赋值</td></tr><tr><td align="center">&gt;&gt;=</td><td align="center">右移后赋值</td></tr><tr><td align="center">&amp;=</td><td align="center">按位与后赋值</td></tr><tr><td align="center">|=</td><td align="center">按位或后赋值</td></tr><tr><td align="center">^=</td><td align="center">按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基本数据类型</title>
      <link href="/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之基本数据类型"><a href="#Go语言基础之基本数据类型" class="headerlink" title="Go语言基础之基本数据类型"></a>Go语言基础之基本数据类型</h1><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><a id="more"></a><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint</td><td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td align="center">int</td><td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td align="center">uintptr</td><td align="center">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说：</p><p>v := 123_456 等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"你好"</span></span><br><span class="line">s3 :=<span class="string">'2'</span> <span class="comment">//单独字母，汉字，符号，表示一个字符，</span></span><br><span class="line"><span class="comment">//字节：1个字节=8bit（8个二进制位2^8=156）</span></span><br><span class="line"><span class="comment">//一个字符'A'=1个字节</span></span><br><span class="line"><span class="comment">//1个utf8编码汉子‘啥’=一般占3个字节</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th align="center">转义符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\r</code></td><td align="center">回车符（返回行首）</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\&#39;</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr></tbody></table><p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Code\\lesson1\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"hello沙河"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">"big"</span>    <span class="comment">//字符串不能直接修改，，不能修改的变量</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">"白萝卜"</span></span><br><span class="line">runeS2 := []<span class="keyword">rune</span>(s2)<span class="comment">//吧字符强制转换成rune一个切片</span></span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">    </span><br><span class="line">    c1 :=<span class="string">"红"</span></span><br><span class="line">    c2 :=<span class="string">'红'</span></span><br><span class="line">    fmt.Printf(<span class="string">"c1:%T  c2%T"</span>,c1 ,c2)<span class="comment">//c1:string  c2:int32  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li><li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ripple支付开源协议</title>
      <link href="/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><p>Ripple（瑞波）是一种基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。在Ripple的网络中，交易由客户端发起，经过追踪节点（tracking node）或验证节点（validating node）把交易广播到整个网络中。追踪节点的主要功能是分发交易信息以及相应客户端的账本请求。验证节点除了包含追踪节点的所有功能外，还能通过共识协议，在账本中增加新的账本实例数据。</p><a id="more"></a><p>下面我用在图形中分析具体的共识过程：</p><p><img src="http://image.chaindesk.cn/Ripple1.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple2.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple4.png/mark" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOS共识机制</title>
      <link href="/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="EOS共识机制"><a href="#EOS共识机制" class="headerlink" title="EOS共识机制"></a>EOS共识机制</h3><p>EOS在第一版白皮书中使用的DPOS共识机制，而在新一版的白书中，对共识机制进行了改进，使用BFT+DPOS混合共识机制。使出块速度从原来的3秒变为0.5秒，tps显著提高，达到测试3590次/秒。</p><a id="more"></a><h2 id="EOS第一版共识机制DPOS"><a href="#EOS第一版共识机制DPOS" class="headerlink" title="EOS第一版共识机制DPOS"></a>EOS第一版共识机制DPOS</h2><p>EOS现在系统运行的链用的共识机制是第一版白皮书的，也就是纯DPOS共识机制。<br>DPOS即授权权益证明共识机制。相比于比特币的POW机制，DPOS不用浪费算力资源去争夺记账权，而是通过赋予EOS通证持有人的投票选举，选出21个超级节点担任记账人的角色，保证整个网络的正常运行。值得一提的是，人们的投票所占的比重取决于他们持有多少token。这意味着拥有更多token的人将比拥有极少token的人更多地影响网络。这其实很好理解，因为持有网络的运行的好坏会对持有更多token的人的利益产生更大的影响，这使得他们的投票更谨慎。<br>21个超级节点轮流负责记账。<strong>每轮都会随机打乱他们的出块顺序，</strong>每个超级节点作为出块节点时，只负责出一个块。每一个区块产生后会按照顺序传递给下一个超级节点中。第二个超级节点要负责打包新的区块，同时还要确认上一个区块的内容。当某一个区块被超过2/3的超级节点确认后，则该区块将成为不可逆转区块，即上链区块。</p><p>该算法有些地方明显需要改良。比如容易出现漏块现象。21个超级节点分布世界各地，如果随机打乱顺序，导致总是依次顺序的节点相距地理位置很远，如中国和美国，这两国的网络传输单向时间是300毫秒，一来一回总共600毫秒。那么中国这边出块，然后经过其他20个节点确认后返回，假设时间总共是4秒；而接下来美国出块，反馈回来的时间是3秒，比中国快1秒，肯定是先上链的，结果中国出的块就被丢弃掉了。当前目前设的出块时间是3秒，理论上能够解决这种漏块现象，但想提高eos的性能，这块肯定是要改进的。</p><h2 id="EOS最新版共识机制BFT-DPOS"><a href="#EOS最新版共识机制BFT-DPOS" class="headerlink" title="EOS最新版共识机制BFT-DPOS"></a>EOS最新版共识机制BFT-DPOS</h2><p>BFT即拜占庭容错算法。EOS引入这个算法，主要是赋予出块节点更大的权力，加快出块速度，解决节点出的块都被漏掉的问题。</p><p>EOS共识算法的升级，势必需要超级节点们更新代码，使用新的程序，然后在当前链上继续运行。但如果超过1/3的节点拒绝更新代码，可能会出现硬分叉问题。所以如何很好地做好过渡是EOS最大难题。</p><p>我们一起分析下改进后的共识机制是如何工作的。</p><p>EOS使用BFT+DPOS共识机制后，不再按照出块顺序让超级节点一个个验证区块内容，而是让出块节点成为主节点。出块后，同时向其他20个超级节点进行广播该区块，并获得他们的验证。如果超过2/3的节点验证通过后，则该区块将成为不可逆转区块。</p><p>BFT可以使EOS出块速度显著增加。目前使用BFT+DPOS共识机制的EOS，可以实现0.5秒的出块速度，1秒实现区块的不可逆转。为避免因出块速度过快而漏块，EOS的超级节点按照其他的地理位置依次轮流成为主节点，尽可能减少超级节点的网络延迟。比如超级节点有中国、美国、加拿大、日本，那么成为主节点的顺序是中国&gt;日本&gt;美国&gt;加拿大或者反过来，总之保证相邻最近的超级节点要依次交接主节点角色。</p><p>同时规定每个主节点连续生产6个区块，至少保证6个区块的前几个能确认完成，不存在整个超级节点被跳过的现象。可以看出每轮记账节点的出块总时间还是3秒钟，在这3秒里，因为他对他自己出的块是信任的，所以可以持续出块。一边出块一边广播，3秒之内率先广播的区块肯定能够得到确认，在网络通畅的情况下，6个区块都会可能得到确认。</p><p>EOS共识处理分叉问题非常简单，和比特币一样，节点只会认可最长的链作为合法链。假如某个节点开始作恶，自己出块并生成自己的链，也就是每次轮到它就产生6个块。但是超级节点总共21个，每轮产生理论126个块。根据选择最长链作为主链原则，肯定作恶的链得不到认可。所以EOS不会发生分叉问题。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT实用拜占庭容错系统</title>
      <link href="/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>PBFT即<strong>实用拜占庭容错系统</strong>，英文全称<strong>Practical Byzantine Fault Tolerance</strong>。它是第一个基于BFT理论并结合实际产生的新的共识算法。但应用场景是私有链和联盟链，如果用于公链，需要和其他共识算法进行灵活的混用。</p><a id="more"></a><h2 id="PBFT算法原理"><a href="#PBFT算法原理" class="headerlink" title="PBFT算法原理"></a>PBFT算法原理</h2><p>PBFT是一类<strong>状态机拜占庭系统</strong>，要求共同维护一个状态，所有节点采用的行动一致。为此，需要运行三类基本协议，包括一致性协议（Agreement）、验证确认协议（Validity）和视图更换协议（Viewchange）。</p><h5 id="1-一致性协议："><a href="#1-一致性协议：" class="headerlink" title="1.一致性协议："></a>1.一致性协议：</h5><p>在PBFT系统中，节点分为两类：主节点（Lead）和从节点（Follow）。主节点就一个，其他剩余节点都是从节点。在实现PBFT系统功能之前，所有节点都是从节点，经过选举，产生一个主节点。每个节点都有被选举权和选举权，选举过程每个节点的概率都是平等的。</p><p>一致性协议包含若干个阶段：请求（Request）&gt;序列分配（Pre-prepare）&gt;相互交互（Prepare） &gt;确认（Commit） &gt;响应（Reply）。过程如下图：</p><p><img src="http://image.chaindesk.cn/pbft.jpg/mark" alt="img"></p><p>注：C为客户端或叫请求节点；0为当前视图下的主节点；1，2，3是从节点，其中3为宕机节点。<br>该视图满足拜占庭容错，即系统节点总数4 &gt;故障节点个数1x3             1&lt; 4 * (1/3)</p><p>1）Request阶段<br>也就是Lead生成请求阶段。</p><p>客户端发送请求到主节点，或者主节点主动从某数据源获取数据作为请求</p><p>2）Pre-prepare阶段<br>也就是Lead给其他所有Follow发送请求阶段。</p><p>主节点将收到的请求进行处理，给请求赋值一个序列号n，形成一个带序号的副本，然后分发给其从节点。其中序号n必须在水线（watermark）上下限h和H之间。水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间。发送副本的格式是 <code>&lt;,m&gt;</code>，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要，n是序号。</p><p>3）Prepare阶段<br>也就是Follow收到请求，但不知道其他节点请求是什么，就给收到的<strong>请求签名</strong>发给其他所有节点，告诉他们我收到了这样一个请求。</p><p>从节点接收到副本后，对副本进行校验和确认。检查副本中请求是否签名合法；检查d与m的摘要是否一致；检查当前视图编号是是否与副本v一致。满足这些条件后，从节点将副本存入消息日志中，然后对副本进行签名并转发给其他的所有节点（包括主节点）。如果不满足，则该验证节点就会进入View change阶段。</p><p>4）Commit阶段<br>也就是每个节点收到其他所有节点的签名请求，把这个合法请求跟自己之前保存的请求进行比较，如果超过有2f个请求一样，那么这个请求他会认为是大家共识的请求。然后对这个请求进行处理。</p><p>当前阶段所有节点，包括主节点，<strong>对接收到的签名副本进行签名验证和确认</strong>。签名验证通过后的副本与自己保存的副本进行比较，设和自己一样的副本个数记为 s，满足(自己+收到的副本) s+1&gt;= 2f，故障节点的个数为f，则该节点将会对这个请求进行响应，给予运算结果，并做签名。 2+1&gt;=2*1</p><p>5）Reply阶段<br>也就是将处理结果发送给客户端，客户端收到 f+1(=2)个一样结果，那么客户端会认为该结果正确。</p><p>每个收到请求的节点都会对请求进行响应处理，将结果广播给客户端。当客户端接收到 f+1的响应相同时，则会认为该响应就是请求的结果。</p><h5 id="2-验证确认协议："><a href="#2-验证确认协议：" class="headerlink" title="2.验证确认协议："></a>2.验证确认协议：</h5><p>在一致性协议使用时都用到了这个协议。在PBFT系统中，时刻保证数据的准确性，要进行数据校验和签名确认。对Lead的任何行为要进行监视，如果Lead有做越权或错误的事件，其他节点可以对其进行举报。</p><h5 id="3-视图更换协议：-更换主节点"><a href="#3-视图更换协议：-更换主节点" class="headerlink" title="3.视图更换协议：(更换主节点)"></a>3.视图更换协议：(更换主节点)</h5><p>此阶段主要是用户在设计PBFT系统时，<strong>对Lead节点权限的设定</strong>。</p><p>比如定时多长时间，正常更换Lead，其他Follow节点都有机会成为新的Lead。在Lead任期时期，如果超过2/3的节点反映它有问题，那么也会触发view change。还有Lead在运行中突然挂掉，也会触发view change。我们需要确保在新的view中如何来延续上一个view最终的状态，（比如给这时来的新请求的编号，还有如何处理上一个view还没来得及完全处理好的请求。）</p><h2 id="PBFT算法在公链中的应用"><a href="#PBFT算法在公链中的应用" class="headerlink" title="PBFT算法在公链中的应用"></a>PBFT算法在公链中的应用</h2><p>PBFT机制不需要挖矿，也不需要权益计算，所以通过它达成共识的时间会很快，为了提高公链的tps(每秒事务处理量(TransactionPerSecond))，将PBFT灵活改进并引入公链，和pow算法或pos相结合形成一套新的混合机制，非常明智。目前这样应用的公链比较多，我下边主要讲解初链（TrueChain）是怎么实现的。</p><p><strong>初链</strong>使用双链结构，即快链和慢链。运用PBFT和POW混合共识算法，前者生成快链，后者生成慢链。交易确认和挖矿是分开的。交易被打包后，通过PBFT委员会确认，生成fastBlock，此时交易已经得到确认；慢链将快链里的fastBlock打包成为一个snailBlock，经过矿工挖矿确认，实现上链。通过这种混合共识算法，tps得到很大的提升，达到3000左右，而且使用POW挖矿，实现了去中心化的思想。PBFT委员会每两天换届一次，候选委员都是POW挖矿成功后的矿工，保证了公平公正的原则。</p><p>虽然PBFT算法的设计初期是服务于私有链和公有链的，但是随着人们对它的不断改进和灵活使用，未来公链它将在共识机制中处于重要地位。</p><h2 id="Go语言实现一个网络交互的PBFT工程"><a href="#Go语言实现一个网络交互的PBFT工程" class="headerlink" title="Go语言实现一个网络交互的PBFT工程"></a>Go语言实现一个网络交互的PBFT工程</h2><p>工程思路：<br>1.开启4个终端，分别代表4个小国，开启http监听，监听路径有4个，分别是”/req”，”/prePrepare”, “/prepare”, “/commit”。<br>2.任意一个节点通过http网页发起请求；<br>3.该被请求节点会将数据写入自己的数组，然后并通过”/prePrepare”路径向其他节点广播该请求数据；<br>4.其他节点通过节点监听接收到请求数据，将请求数据写入自己的数组，并通过”/Prepare”路径向其他节点广播该请求数据；<br>5.所有节点将收到的数据进行校验，如果当前数组的长度大于所有节点个数的2/3，则输出OK，并将OK数据通过路径”/commit”广播给其他所有节点；<br>6.当节点收到OK数量达到所有节点个数的1/3，则就是最后的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明nodeInfo节点，代表各个小国家</span></span><br><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//节点名称</span></span><br><span class="line">    id <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//节点路径</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//http响应</span></span><br><span class="line">    writer http.ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map，存储各个国家的ip地址,也就是url</span></span><br><span class="line"><span class="keyword">var</span> nodeTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当http服务器，接收到网络请求并且/req 则回调request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">request</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">//该命令允许request请求参数</span></span><br><span class="line">    request.ParseForm()<span class="comment">//解析完毕，打包返回。所以该方法不需要返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.writer = writer</span><br><span class="line">        fmt.Println(<span class="string">"主节点接收到的参数信息为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment">//fmt.Println(request.Form["warTime"])打印出来是个数组，如果warTime=1111&amp;2222等等，等号后边的是数组，warTime是map的key</span></span><br><span class="line">        <span class="comment">//激活主节点后，向其他的节点发送广播</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prePrepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点发送广播的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">broadcast</span><span class="params">(msg <span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"广播"</span>, path)</span><br><span class="line">    <span class="comment">//遍历所有的节点</span></span><br><span class="line">    <span class="keyword">for</span> nodeId, url := <span class="keyword">range</span> nodeTable &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeId == node.id &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使当前节点以外的节点做响应</span></span><br><span class="line">        http.Get(<span class="string">"http://"</span> + url + path + <span class="string">"?warTime="</span> + msg + <span class="string">"&amp;nodeId="</span> + node.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理广播后接收到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prePrepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    fmt.Println(<span class="string">"接收到的广播为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收子节点的广播</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//打印消息</span></span><br><span class="line">    fmt.Println(<span class="string">"接收到的子节点的广播"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">2</span>/<span class="number">3</span>*<span class="built_in">len</span>(nodeTable) &#123;</span><br><span class="line">        node.authentication(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authenticationNodeMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> authenticationSuceess = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//校验拜占庭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">authentication</span><span class="params">(request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !authenticationSuceess &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"nodeId"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            authenticationNodeMap[request.Form[<span class="string">"nodeId"</span>][<span class="number">0</span>]] = <span class="string">"OK"</span></span><br><span class="line">            <span class="comment">//如果有两个国家节点正确的返回了结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(authenticationNodeMap) &gt; <span class="built_in">len</span>(nodeTable)/<span class="number">3</span> &#123;</span><br><span class="line">                authenticationSuceess = <span class="literal">true</span></span><br><span class="line">                node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/commit"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回成功响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">commit</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> writer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"拜占庭校验成功"</span>)</span><br><span class="line">        <span class="comment">//在网页上显示ok</span></span><br><span class="line">        io.WriteString(node.writer, <span class="string">"ok"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//接受终端参数</span></span><br><span class="line">    userId := os.Args[<span class="number">1</span>]</span><br><span class="line">    fmt.Println(userId)</span><br><span class="line">    <span class="comment">//存储4个国家的IP地址</span></span><br><span class="line">    nodeTable = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"Apple"</span>:  <span class="string">"localhost:1111"</span>,</span><br><span class="line">        <span class="string">"MS"</span>:     <span class="string">"localhost:1112"</span>,</span><br><span class="line">        <span class="string">"Google"</span>: <span class="string">"localhost:1113"</span>,</span><br><span class="line">        <span class="string">"IBM"</span>:    <span class="string">"localhost:1114"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建国家对象</span></span><br><span class="line">    node := nodeInfo&#123;id: userId, path: nodeTable[userId]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http协议的回调函数</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/req"</span>, node.request)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prePrepare"</span>, node.prePrepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prepare"</span>, node.prepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/commit"</span>, node.commit)</span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(node.path, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新打开 5 个终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./main Apple</span><br><span class="line"></span><br><span class="line">./main MS</span><br><span class="line"></span><br><span class="line">./main Google</span><br><span class="line"></span><br><span class="line">./main IBM</span><br><span class="line"></span><br><span class="line">curl -H <span class="string">"Content-Type: applicaton/json"</span> -X POST -d <span class="string">'&#123;"clientID":"ahnhwi","operation":"GetMyName","timestamp":859381532&#125;'</span> http://localhost:1111/req</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联盟链面试问题</title>
      <link href="/2020/01/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9D%A2%E8%AF%95/%E8%81%94%E7%9B%9F%E9%93%BE%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/01/10/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%9D%A2%E8%AF%95/%E8%81%94%E7%9B%9F%E9%93%BE%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li><h5 id="Peer、Endorser、Committer关系"><a href="#Peer、Endorser、Committer关系" class="headerlink" title="Peer、Endorser、Committer关系"></a>Peer、Endorser、Committer关系</h5><ul><li>所有的Peer节点都是Committer，也就是所谓的记账节点</li><li>Endorser是运行链码的节点</li></ul></li><li><h5 id="节点、通道、链码之间的关系"><a href="#节点、通道、链码之间的关系" class="headerlink" title="节点、通道、链码之间的关系"></a>节点、通道、链码之间的关系</h5><ul><li>节点比喻成火车站，轨道就是通道，链码就是在轨道上运行的火车，一个火车站可以连接多个轨道，也就意味着一个节点可以加入多个通道。同一个型号的火车可以运行在多个轨道上，但是某车次只能运行在预定的轨道上，也就是同一份链码可以部署在多个通道中，但是一旦部署就只跟这个通道相关。重点在于区分火车的型号和车次。</li></ul></li><li><h5 id="kafka共识如何保证多个orderer出块一致（如何与其他节点不交流，保持数据一致呢）"><a href="#kafka共识如何保证多个orderer出块一致（如何与其他节点不交流，保持数据一致呢）" class="headerlink" title="kafka共识如何保证多个orderer出块一致（如何与其他节点不交流，保持数据一致呢）"></a>kafka共识如何保证多个orderer出块一致（如何与其他节点不交流，保持数据一致呢）</h5><ul><li><p>排序节点与kafka之间有三种类型消息</p><ul><li><p>第一种连接消息，表示当天orderer已经连接上了kafka集群。这个消息只会在排序节点启动以及新建通道产生，一般我们收到这个消息以后会直接忽略掉。</p></li><li><p>第二种消息就是交易，这也是主要的消息内容，排序节点收到这个消息后，会先保存到自己节点的内存中，等待结块这样一个动作。</p></li><li><p>第三种就是切割区块的消息（重点），每一个切割交易的消息包含了当前要切割的是第几个区块，而且是每一个排序节点都独立地向kafka集群发送交易切割的消息，也就是说每生成一个区块有多少个排序节点实例化，也就会有多少个切割区块的消息。每一个排序节点顺序接收切割区块的时候，只要这个消息里面包含了区块编号是之前并没有受到过的，那么就还可以把保留在内存中的叫打包成区块，如果我们已经处理过了当前的区块编号，我们就可以直接忽略掉这条消息</p><p><img src="./images/1.png" alt="tx"></p><p>排序节点接受到交易1、2、3会先保留着，接着是切块1消息，表示要切割编号为1的区块。排序节点收到切块1消息之后会将交易1、2、3打包成区块，区块编号为<code>1</code>。然后是交易4，会先保存在区块中，接着收到切块1消息，然而区块1已经生成，所以我们会把切块1消息忽略。然后就是切块2消息，发现区块编号为2的区块还没生成，我们就把交易4打包城区块，区块编号为<code>2</code>。</p></li></ul></li></ul></li><li><h5 id="Committer如何验证区块提交的交易的有效性（也就是读写集验证的理解）"><a href="#Committer如何验证区块提交的交易的有效性（也就是读写集验证的理解）" class="headerlink" title="Committer如何验证区块提交的交易的有效性（也就是读写集验证的理解）"></a>Committer如何验证区块提交的交易的有效性（也就是读写集验证的理解）</h5><ul><li>主要就是验证交易读写集中的读集是否是和世界状态以及之前未被提交的写集的状态是否一致。 </li></ul></li></ol><h3 id="设计思考"><a href="#设计思考" class="headerlink" title="设计思考"></a>设计思考</h3><ol><li><p>如何看待其先执行后排序的设计思路？</p><ul><li>交易模拟</li><li>交易排序</li><li>交易提交</li></ul><p>交易体除了签名以外，还有两部分内容：一部分是交易集案，这是客户端发送给背书节点的原始内容，另一部分是背书节点执行完成后的交易读写集。也可说是交易存储的是改变后的值，而不是存的指令，如果我们存的是指令的话，我们当然可以在排好序后再执行，而存储的是具体的值的话，就不需要先排序后执行，而只是需要把至存储到状态数据库就可以了。另外还有一个角度，在fabric0.6版本的时候，节点是不区分类型的，也就是说没有peer、orderer这样的一些节点，但是在1.0版本以后，节点有了分工，orderer节点只负责排序，Endorser只负责交易。如果要改成先排序后执行的话，peer节点就都变成了Endorser节点了，也就没有了存粹的记账节点了。无疑是增加了节点的负担，跟节点的分工和设计产生了冲突。而另外一方面排序后执行，但是执行的过程是独立的，可能还会有执行不一致的情况，所以还需要对区块进行一次共识，这就是为什么像EOS这样的第三代区块链平台，共识依然是区块确认，这使他们需要保证独立执行的正确性。</p></li><li><p>如何评价Fabric代码？</p><p>不是一个很好的设计，从两个方面来说：</p><ul><li>第一点连码设计过于抽象，fabric链码完全可以说是一个<code>K—V</code>数据库,任何业务抽象到链码都是key-value键值对的一个表达，这一点可以说是好的也可以说是不好的，就我跟人而言它是不好的，太抽象反而让人感觉不到区块链的存在，反而有为了区块链而区块链的嫌疑存在。</li><li>第二点Fabric为了能让链码独立去运行，所以它基于了Docker隔离执行环境，但是即便是很小的简单的逻辑链码，它也会被打包成一个独立的镜像，而现在一个镜像有100多兆，这种实现方式不够优雅。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链面试问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFT拜占庭容错系统</title>
      <link href="/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="BFT技术"><a href="#BFT技术" class="headerlink" title="BFT技术"></a>BFT技术</h3><p>BFT技术即拜占庭容错技术，是一类分布式计算领域的容错技术。名称拜占庭是一个泛指，它代表着计算机领域，在这个领域内会有很多问题，如硬件错误、网络拥堵或中断以及遭到恶意攻击等等，造成计算机网络可能出现的混乱。<strong>BFT技术就是为了使混乱状态达到一致性。</strong></p><a id="more"></a><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h2><p>BFT技术的由来源于一个叫拜占庭将军问题。<br>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都，由于当时拜占庭罗马帝国国土辽阔，每支军队的驻地分隔很远，将军们只能靠信使传递消息。发生战争时，将军们必须制订统一的行动计划。然而，这些将军中有叛徒，叛徒希望通过影响统一行动计划的制定与传播，破坏忠诚的将军们一致的行动计划。因此，将军们必须有一个预定的方法协议，使所有忠诚的将军能够达成一致，而且少数几个叛徒不能使忠诚的将军做出错误的计划。也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们能在一个有叛徒的非信任环境中建立对战斗计划的共识，拜占庭问题就此形成。</p><p>拜占庭将军问题（Byzantine Generals Problem），首先由Leslie Lamport与另外两人在1982年提出，很简单的故事模型，却困扰了计算机科学家们数十年。</p><p>我们将拜占庭将军问题简化一下，所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动；而形式化的要求就是，“一致性”与“正确性”。</p><ul><li><p>一致性：每个忠诚的将军必须收到相同的命令值 <strong>vi</strong>（vi是第i个将军的命令）</p></li><li><p>正确性：如果第<strong>i</strong>个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的 <strong>vi</strong> 相同。</p></li></ul><p>Lamport 对拜占庭将军的问题的研究表明，当 <strong>n &gt; 3m</strong> 时，即叛徒的个数 <strong>m</strong> 小于将军总数的 <strong>n</strong> 的 <strong>1/3</strong> 时，通过口头同步通信（假设通信是可靠的），可以构造同时满足“一致性”和“正确性”的解决方法，即将军们可以达成一致的命令。（叛徒个数=m，将军总数=n）m &lt; n * 1/3</p><h2 id="BFT理论算法"><a href="#BFT理论算法" class="headerlink" title="BFT理论算法"></a>BFT理论算法</h2><p>BFT即拜占庭容错系统，英文全称是<strong>Byzantine Fault Tolerance</strong>，是一种理论上解决拜占庭问题的方法，并非实用，不过基于BFT理论延伸出了其他共识机制。</p><p>区块链网络的记账共识和拜占庭将军的问题是相似的。参与共识记账的每一个节点相当于将军，节点之间的消息传递相当于信使，某些节点可能由于各种原因而产生错误的信息传递给其他节点。<strong>通常这些发生故障的节点被称为拜占庭节点，而正常的节点即为非拜占庭节点。</strong></p><p>假设分布式系统拥有n台节点，并假设整个系统拜占庭节点不超过m台（n ≥ 3m + 1），拜占庭容错系统需要满足如下<strong>两个条件</strong>：</p><pre><code>1. 所有非拜占庭节点使用相同的输入信息，产生同样的结果。在区块链系统中，可以理解为，随机数相同、区块算法相同、原账本相同的时候，计算结果相同。2. 如果输入的信息正确，那么所有非拜占庭节点必须接收这个消息，并计算相应的结果。在区块链系统中，可以理解为，非拜占庭节点需要对客户的请求进行计算并生成区块。</code></pre><p>另外，拜占庭容错系统需要达成如下<strong>两个指标</strong>：</p><pre><code>1. 安全性：任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。2. 活性：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。</code></pre><p>在分析拜占庭问题的时候，假设信道是可信的。拓展开来，在拜占庭容错系统，普遍采用的假设条件包括：</p><pre><code>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；节点之间的错误是不相关的；节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；节点之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和破坏信息的完整性。</code></pre><h2 id="Go语言简单实现BFT"><a href="#Go语言简单实现BFT" class="headerlink" title="Go语言简单实现BFT"></a>Go语言简单实现BFT</h2><p>模拟4个小国家攻打拜占庭，这4个国家要保证3个及以上同时攻打才能胜利。</p><p>思路：<br>1.创建4个节点，每个节点代表一个小国，我们用1代表打，0代表不打；<br>2.每个节点将自己的攻打意愿1或0分发给其他小国；<br>3.收到所有节点发送的消息后，将所有消息放在一个数组中；<br>4.每个节点遍历这个数组，如果数组中的0数量&lt;总数的1/3，那么返回一个true，表示攻打拜占庭可行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拜占庭理论的代码实现部分</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Status <span class="keyword">int</span><span class="comment">//1 代表去，０代表不去</span></span><br><span class="line">    Votes []*Node<span class="comment">//记录账本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存４个node</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">make</span>([]*Node,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNodes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A:=Node&#123;<span class="string">"A"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    B:=Node&#123;<span class="string">"B"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    C:=Node&#123;<span class="string">"C"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    D:=Node&#123;<span class="string">"D"</span>,<span class="number">0</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//不去</span></span><br><span class="line">    <span class="comment">//按照拜占庭的1/3理论，这次打仗是可行的</span></span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;A)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;B)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;C)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互相转达</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">votes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nodes);i++&#123;</span><br><span class="line">        node:=nodes[i]</span><br><span class="line">        <span class="comment">//可以将每个人的进攻状态获取出来</span></span><br><span class="line">        fmt.Println(node.Status)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此人的状态分发给其他人</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nodes);j++&#123;</span><br><span class="line">            inode := nodes[j]</span><br><span class="line">            node.Votes=<span class="built_in">append</span>(node.Votes,inode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次进攻是否可行，判断叛徒是否小于三分之一  cnt叛徒的个数小于总节点数的三分之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">//在数组中取出最后一个对象</span></span><br><span class="line">    node:=nodes[<span class="built_in">len</span>(nodes)<span class="number">-1</span>]</span><br><span class="line">    votes:=node.Votes</span><br><span class="line"></span><br><span class="line">    cnt:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,n :=<span class="keyword">range</span> votes &#123;</span><br><span class="line">        fmt.Println(n.Status)</span><br><span class="line">        <span class="keyword">if</span> n.Status == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cnt只有小于n/3的情况下，才能成功,拜占庭</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">float32</span>(cnt) &lt; <span class="keyword">float32</span>(<span class="built_in">len</span>(nodes))/<span class="keyword">float32</span>(<span class="number">3.0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    createNodes()</span><br><span class="line">    votes()</span><br><span class="line">    fmt.Println(isValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPOS股权授权证明</title>
      <link href="/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h1><h2 id="什么是-DPoS"><a href="#什么是-DPoS" class="headerlink" title="什么是 DPoS"></a>什么是 DPoS</h2><p>DPoS即股份授权证明，英文全称是<code>Delegated Proof of Stake</code>。它是PoS算法的改造版。<br>最早于2013年由比特股Bitshares提出，目的为解决PoW和PoS机制的不足。</p><a id="more"></a><h2 id="DPoS-基本原理"><a href="#DPoS-基本原理" class="headerlink" title="DPoS 基本原理"></a>DPoS 基本原理</h2><p>PoS解决了PoW的算力问题，但是依据权益结余来选择出块者，会导致首富账户的权力更大，有可能支配记账权。为改善这种中心化的负面影响，DPoS引进了代理人机制，类似于人民代表选举，被选举者就是这里的代理人。代理人是由所有持币者根据自己的意愿选出来的，他理论上能够代表大众的权益。以eos为例，它有21个超级节点，每个节点都是持币人选举出来的。</p><p>一般选举过程是这样的，首先设立一个评审委员会，全球所有节点都可以报名参加，报名的前提是交纳保证金，通过审核的最为满足条件的前N个节点将作为候选节点，进入下一轮，也就是竞选阶段。这些候选节点会将会各种演说游说其他的持币人，让他们给自己投票，这里可能场外会给投票人某些好处。<strong>最终投票总数前m名的候选节点成为公链的代理人，负责出块。每次出块时，系统会随机顺序挑选指定某个代理人出块。</strong> 每次选举出来的代理人都有任期，任期期间如果被监管发现某些作恶行为将会被追责和卸任。</p><p>代理人的职责主要有：</p><p><strong>1.提供一台服务器节点，保证节点的正常运行；</strong><br><strong>2.节点服务器收集网络里的交易；</strong><br><strong>3.节点验证交易，把交易打包到区块；</strong><br><strong>4.节点广播区块，其他节点验证后把区块添加到自己的数据库；</strong><br><strong>5.带领并促进区块链项目的发展；</strong></p><p>代理人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>普通节点不能直接参与出块，利益何在？<br>每个节点都有自己的选举权和监督权，对代理人的行为进行监视，保证链的正常运行。链稳定了，持币人在生态中的操作才能安心。同时，tps的速度快了，在链上的交易秒级可以实现，使持币人感受到了极大的方便。整个链的生态如果因为良好的运行，会吸引更多的人或应用加入，使币的价格升值，持币人当然开心。当然这些都是理想情况下，在实际中很难得以实现。</p><h3 id="DPoS的伪代码实现"><a href="#DPoS的伪代码实现" class="headerlink" title="DPoS的伪代码实现"></a>DPoS的伪代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点 授权</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure><h3 id="DPoS-运行机制"><a href="#DPoS-运行机制" class="headerlink" title="DPoS 运行机制"></a>DPoS 运行机制</h3><p>DPoS 的运作机制如下：</p><ol><li><p>所有持币者先选出代理人负责签署区块：选举过程比较类似由股东会选举出董事会（101人代表），代替股东会做出日常营运决策。授权董事会后，决策会更有效率 （相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。）</p></li><li><p>与PoW相同，DPoS的规则也是最长链胜出。其中每个受托人必须按照生产排程，轮流产生区块，拿一间工厂作为比方，假设排程排定A、Ｂ、Ｃ分别轮早、中、晚班生产，Ａ在晚上是无法刷门禁卡进入厂房生产的，同样地，C在早班时段也是无法进厂房的。</p><p><img src="http://image.chaindesk.cn/DPOS01.png/mark" alt="img"></p></li><li><p>今天有一些恶意的节点生产了分叉区块，假设Ａ、Ｃ都是诚实的节点，只有B节点是恶意的，由于B产生区块的速度（每9秒只能产生1个）慢于A、Ｃ合力产生区块的速度（每9秒产生2个），根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS2.png/mark" alt="img"></p></li><li><p>同理，因为一个节点要产生重复两个区块的速度必定慢于诚实区块产生的速度，所以根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS3.png/mark" alt="img"></p></li><li><p>如果今天A、Ｂ、Ｃ三个代理人的网络有段时间是碎片化、各自为政的呢？在短期内的确有可能三链并行，但一旦网络连结恢复，短链自然会向最长的链回归。</p><p><img src="http://image.chaindesk.cn/DPOS4.png/mark" alt="img"></p></li></ol><p><strong>因为代理可签署人数为奇数，所以两大派系势均力敌僵持不下的情况不会维持太久，最终势必会有其中一方的链更长。</strong></p><h2 id="DPoS的优缺点"><a href="#DPoS的优缺点" class="headerlink" title="DPoS的优缺点"></a>DPoS的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li><li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li><li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li><li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li></ol><h3 id="知名-DPoS-项目"><a href="#知名-DPoS-项目" class="headerlink" title="知名 DPoS 项目"></a><strong>知名 DPoS 项目</strong></h3><p>1.Bitshares</p><p>最早应用DPoS机制的项目，其DPoS机制里包含见证人(Witnesses)和代理人(Delegates)， 见证人负责区块的打包，代理人负责系统参数的修改和出块。</p><p>2.EOS</p><p>共识算法我DPoS + BFT， 有21个代理人。</p><p>3.Asch</p><p>共识算法为DPoS + PBFT， 有101个代理人。</p><h2 id="用Go实现一个简单的DPOS项目"><a href="#用Go实现一个简单的DPOS项目" class="headerlink" title="用Go实现一个简单的DPOS项目"></a>用Go实现一个简单的DPOS项目</h2><p>通过这个简易的项目，让大家对DPOS的工作加深下了解。<br>工程思路：<br>1.手动创建一个数组，将里面的元素作为代理人<br>2.每30秒将代理人的顺序随机打乱1次<br>3.乱序后的委员会将顺序出块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//DPoS原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="keyword">int</span></span><br><span class="line">    PreHash <span class="keyword">string</span></span><br><span class="line">    HashCode <span class="keyword">string</span></span><br><span class="line">    BMP <span class="keyword">int</span></span><br><span class="line">    validator <span class="keyword">string</span></span><br><span class="line">    TimeStamp <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块链</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNextBlock</span><span class="params">(oldBlock Block,BMP <span class="keyword">int</span> ,adds <span class="keyword">string</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.PreHash = oldBlock.HashCode</span><br><span class="line">    newBlock.BMP = BMP</span><br><span class="line">    newBlock.TimeStamp = time.Now().String()</span><br><span class="line">    newBlock.validator = adds</span><br><span class="line">    newBlock.HashCode = GenerateHashValue(newBlock)</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生区块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHashValue</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hashCode = block.PreHash+block.validator+block.TimeStamp+</span><br><span class="line">        strconv.Itoa(block.Index)+strconv.Itoa(block.BMP)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sha = sha256.New()</span><br><span class="line">    sha.Write([]<span class="keyword">byte</span>(hashCode))</span><br><span class="line">    hashed:=sha.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放代理人,存放delegete的地址信息</span></span><br><span class="line"><span class="keyword">var</span> delegate =[]<span class="keyword">string</span>&#123;<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"dddd"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机委托人的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandDelegate</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> r = rand.Intn(<span class="number">3</span>)</span><br><span class="line">    t:=delegate[r]</span><br><span class="line">    delegate[r]=delegate[<span class="number">3</span>]</span><br><span class="line">    delegate[<span class="number">3</span>]=t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(delegate)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创世区块</span></span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,firstBlock)</span><br><span class="line">    <span class="comment">//通过n按顺序让delegate作为矿工</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    ch1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag:&lt;-ch1</span><br><span class="line">        count:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//每间隔3秒产生新的区块，通过count记录睡眠次数</span></span><br><span class="line">            count++</span><br><span class="line">            time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">            <span class="comment">//轮到的节点进行出块</span></span><br><span class="line">            <span class="keyword">var</span> nextBlock = GenerateNextBlock(firstBlock,<span class="number">1</span>,delegate[n])</span><br><span class="line">            n++</span><br><span class="line">            n=n%<span class="built_in">len</span>(delegate)</span><br><span class="line">            firstBlock = nextBlock</span><br><span class="line">            <span class="comment">//上链</span></span><br><span class="line">            Blockchain = <span class="built_in">append</span>(Blockchain,nextBlock)</span><br><span class="line">            fmt.Println(Blockchain)</span><br><span class="line">            fmt.Println(count)</span><br><span class="line">            <span class="comment">//每30秒将代理人顺序打乱一次</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">10</span>&#123;</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">                ch2&lt;-<span class="literal">true</span></span><br><span class="line">                <span class="keyword">goto</span> flag</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; ;  &#123;</span><br><span class="line"></span><br><span class="line">        RandDelegate()</span><br><span class="line">        fmt.Println(<span class="string">"更换顺序后的代理人"</span>,delegate)</span><br><span class="line">        ch1&lt;-<span class="literal">true</span></span><br><span class="line">        &lt;-ch2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS代码实现</title>
      <link href="/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="用go语言实现一个POS共识机制"><a href="#用go语言实现一个POS共识机制" class="headerlink" title="用go语言实现一个POS共识机制"></a>用go语言实现一个POS共识机制</h1><h2 id="POS工程简述"><a href="#POS工程简述" class="headerlink" title="POS工程简述"></a>POS工程简述</h2><p>在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。</p><a id="more"></a><h2 id="实现-POS-主要功能点"><a href="#实现-POS-主要功能点" class="headerlink" title="实现 POS 主要功能点"></a>实现 POS 主要功能点</h2><ul><li>我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器</li><li>最新的区块链状态将定期广播到每个节点</li><li>每个节点都能提议建立新的区块</li><li>基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中</li></ul><h2 id="实现-POS"><a href="#实现-POS" class="headerlink" title="实现 POS"></a>实现 POS</h2><h3 id="设置-TCP-服务器的端口"><a href="#设置-TCP-服务器的端口" class="headerlink" title="设置 TCP 服务器的端口"></a>设置 TCP 服务器的端口</h3><p>新建 <code>.env</code>，添加如下内容 <code>PORT=9000</code></p><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/davecgh/<span class="keyword">go</span>-spew/spew</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> get github.com/joho/godotenv</span><br></pre></td></tr></table></figure><ul><li><code>spew</code> 在控制台中格式化输出相应的结果。</li><li><code>godotenv</code> 可以从我们项目的根目录的 <code>.env</code> 文件中读取数据。</li></ul><h3 id="引入相应的包"><a href="#引入相应的包" class="headerlink" title="引入相应的包"></a>引入相应的包</h3><p>新建 <code>main.go</code>，引入相应的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">    <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents each 'item' in the blockchain</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span></span><br><span class="line">    Timestamp <span class="keyword">string</span></span><br><span class="line">    BPM       <span class="keyword">int</span></span><br><span class="line">    Hash      <span class="keyword">string</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span></span><br><span class="line">    Validator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blockchain is a series of validated Blocks</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"><span class="keyword">var</span> tempBlocks []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// candidateBlocks handles incoming blocks for validation</span></span><br><span class="line"><span class="keyword">var</span> candidateBlocks = <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// announcements broadcasts winning validator to all nodes</span></span><br><span class="line"><span class="keyword">var</span> announcements = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validators keeps track of open validators and balances</span></span><br><span class="line"><span class="keyword">var</span> validators = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ul><li><code>Block</code> 是每个区块的内容</li><li><code>Blockchain</code> 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 <code>PrevHash</code> 与前面块的 <code>Hash</code> 相比较，以确保我们的链是正确的。 <code>tempBlocks</code> 是临时存储单元，在区块被选出来并添加到 <code>BlockChain</code> 之前，临时存储在这里</li><li><code>candidateBlocks</code> 是 <code>Block</code> 的通道，任何一个节点在提出一个新块时都将它发送到这个通道</li><li><code>announcements</code> 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链</li><li><code>mutex</code>是一个标准变量，允许我们控制读/写和防止数据竞争</li><li><code>validators</code> 是节点的存储map，同时也会保存每个节点持有的令牌数</li></ul><h3 id="生成区块"><a href="#生成区块" class="headerlink" title="生成区块"></a>生成区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateBlock</code> 是用来创建新块的。<br><code>newBlock.PrevHash</code> 存储的是上一个区块的 <code>Hash</code><br><code>newBlock.Hash</code> 是通过 <code>calculateBlockHash(newBlock)</code> 生成的 Hash 。<br><code>newBlock.Validator</code> 存储的是获取记账权的节点地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SHA256 hasing</span></span><br><span class="line"><span class="comment">// calculateHash is a simple SHA256 hashing function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculateBlockHash returns the hash of all block information</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateHash</code> 函数会接受一个 <code>string</code> ，并且返回一个<code>SHA256 hash</code> 。</p><p><code>calculateBlockHash</code> 是对一个 <code>block</code> 进行 <code>hash</code>，将一个 <code>block</code> 的所有字段连接到一起后，再调用 <code>calculateHash</code> 将字符串转为 <code>SHA256 hash</code> 。</p><h3 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h3><p>我们通过检查 <code>Index</code> 来确保它们按预期递增。我们也检查以确保我们 <code>PrevHash</code> 的确与 <code>Hash</code> 前一个区块相同。最后，我们希望通过在当前块上 <code>calculateBlockHash</code> 再次运行该函数来检查当前块的散列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isBlockValid makes sure block is valid by checking index</span></span><br><span class="line"><span class="comment">// and comparing the hash of the previous block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculateBlockHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：</p><ul><li>输入令牌的余额（之前提到过，我们不做钱包等逻辑)</li><li>接收区块链的最新广播</li><li>接收验证者赢得区块的广播信息</li><li>将自身节点添加到全局的验证者列表中（validators)</li><li>输入Block的BPM数据- BPM是每个验证者的人体脉搏值</li><li>提议创建一个新的区块</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            msg := &lt;-announcements</span><br><span class="line">            io.WriteString(conn, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 验证者地址</span></span><br><span class="line">    <span class="keyword">var</span> address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权</span></span><br><span class="line">    io.WriteString(conn, <span class="string">"Enter token balance:"</span>)</span><br><span class="line">    scanBalance := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> scanBalance.Scan() &#123;</span><br><span class="line">        <span class="comment">// 获取输入的数据，并将输入的值转为 int</span></span><br><span class="line">        balance, err := strconv.Atoi(scanBalance.Text())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"%v not a number: %v"</span>, scanBalance.Text(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        <span class="comment">// 生成验证者的地址</span></span><br><span class="line">        address = calculateHash(t.String())</span><br><span class="line">        <span class="comment">// 将验证者的地址和token 存储到 validators</span></span><br><span class="line">        validators[address] = balance</span><br><span class="line">        fmt.Println(validators)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line"></span><br><span class="line">    scanBPM := bufio.NewScanner(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// take in BPM from stdin and add it to blockchain after conducting necessary validation</span></span><br><span class="line">            <span class="keyword">for</span> scanBPM.Scan() &#123;</span><br><span class="line">                bpm, err := strconv.Atoi(scanBPM.Text())</span><br><span class="line">                <span class="comment">// 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"%v not a number: %v"</span>, scanBPM.Text(), err)</span><br><span class="line">                    <span class="built_in">delete</span>(validators, address)</span><br><span class="line">                    conn.Close()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                oldLastIndex := Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的区块，然后将其发送到 candidateBlocks 通道</span></span><br><span class="line">                newBlock, err := generateBlock(oldLastIndex, bpm, address)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Println(err)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> isBlockValid(newBlock, oldLastIndex) &#123;</span><br><span class="line">                    candidateBlocks &lt;- newBlock</span><br><span class="line">                &#125;</span><br><span class="line">                io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环会周期性的打印出最新的区块链信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Minute)</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        output, err := json.Marshal(Blockchain)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(conn, <span class="keyword">string</span>(output)+<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>io.WriteString(conn, &quot;Enter token balance:&quot;)</code>允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 <code>SHA256</code>地址，随后该验证者地址和验证者的令牌数被添加到验证者列表<code>validators</code> 中。</li><li>接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑</li><li><code>delete(validators, address)</code> 如果验证者试图提议一个被污染（例如伪造）的 <code>block</code>，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 <code>validators</code> 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</li><li>正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。</li><li>接着，我们用 <code>generateBlock</code> 函数创建一个新的 <code>block</code>，然后将其发送到 <code>candidateBlocks</code> 通道进行进一步处理。将<code>Block</code> 发送到通道使用的语法: <code>candidateBlocks &lt;- newBlock</code></li><li>最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。</li></ul><h3 id="选择获取记账权的节点"><a href="#选择获取记账权的节点" class="headerlink" title="选择获取记账权的节点"></a>选择获取记账权的节点</h3><p>下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain</span></span><br><span class="line"><span class="comment">// by random selecting from the pool, weighted by amount of tokens staked</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickWinner</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    temp := tempBlocks</span><br><span class="line">    mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    lotteryPool := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slightly modified traditional proof of stake algorithm</span></span><br><span class="line">        <span class="comment">// from all validators who submitted a block, weight them by the number of staked tokens</span></span><br><span class="line">        <span class="comment">// in traditional proof of stake, validators can participate without submitting a block to be forged</span></span><br><span class="line">    OUTER:</span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="comment">// if already in lottery pool, skip</span></span><br><span class="line">            <span class="keyword">for</span> _, node := <span class="keyword">range</span> lotteryPool &#123;</span><br><span class="line">                <span class="keyword">if</span> block.Validator == node &#123;</span><br><span class="line">                    <span class="keyword">continue</span> OUTER</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock list of validators to prevent data race</span></span><br><span class="line">            mutex.Lock()</span><br><span class="line">            setValidators := validators</span><br><span class="line">            mutex.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取验证者的tokens</span></span><br><span class="line">            k, ok := setValidators[block.Validator]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">// 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens</span></span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">                    lotteryPool = <span class="built_in">append</span>(lotteryPool, block.Validator)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过随机获得获胜节点的地址</span></span><br><span class="line">        s := rand.NewSource(time.Now().Unix())</span><br><span class="line">        r := rand.New(s)</span><br><span class="line">        lotteryWinner := lotteryPool[r.Intn(<span class="built_in">len</span>(lotteryPool))]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息</span></span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="keyword">if</span> block.Validator == lotteryWinner &#123;</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, block)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                <span class="keyword">for</span> _ = <span class="keyword">range</span> validators &#123;</span><br><span class="line">                    announcements &lt;- <span class="string">"\nwinning validator: "</span> + lotteryWinner + <span class="string">"\n"</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    tempBlocks = []Block&#123;&#125;</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个<code>lotteryPool</code>，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过<code>if len(temp) &gt; 0</code>来判断是否已经有了被提议的区块。</li><li>在<code>OUTER FOR</code>循环中，要检查暂存区域是否和 <code>lotteryPool</code> 中存在同样的验证者，如果存在，则跳过。</li><li>在以 <code>k, ok := setValidators[block.Validator]</code>开始的代码块中，我们确保了从<code>temp</code>中取出来的验证者都是合法的，即这些验证者在验证者列表<code>validators</code>已存在。若合法，则把该验证者加入到<code>lotteryPool</code>中。</li><li>那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？<ul><li>首先，用验证者的令牌填充<code>lotteryPool</code>数组，例如一个验证者有100个令牌，那么在<code>lotteryPool</code>中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。</li><li>然后，从<code>lotteryPool</code>中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。</li></ul></li><li>接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：<code>announcements &lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot;</code>。</li><li>最后，清空tempBlocks，以便下次提议的进行。</li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := godotenv.Load()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始区块</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    genesisBlock := Block&#123;&#125;</span><br><span class="line">    genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateBlockHash(genesisBlock), <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">    spew.Dump(genesisBlock)</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line"></span><br><span class="line">    httpPort := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务</span></span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+httpPort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"HTTP Server Listening on port :"</span>, httpPort)</span><br><span class="line">    <span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> candidate := <span class="keyword">range</span> candidateBlocks &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            tempBlocks = <span class="built_in">append</span>(tempBlocks, candidate)</span><br><span class="line">            mutex.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 完成 pickWinner 函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            pickWinner()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收验证者节点的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>godotenv.Load()</code> 会解析 <code>.env</code> 文件并将相应的Key/Value对都放到环境变量中，通过 <code>os.Getenv</code> 获取</li><li>然后创建一个创世区块genesisBlock，形成了区块链。</li><li>接着启动了Tcp服务，等待所有验证者的连接。</li><li>启动了一个Go协程从 <code>candidateBlocks</code> 通道中获取提议的区块，然后填充到临时缓冲区 <code>tempBlocks</code> 中，最后启动了另外一个Go协程来完成 <code>pickWinner</code> 函数。</li><li>最后的for循环，用来接收验证者节点的连接。</li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>go run main.go</code> 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">(main.Block) &#123;</span><br><span class="line"> Index: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Timestamp: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">50</span>) <span class="string">"2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793"</span>,</span><br><span class="line"> BPM: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Hash: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">64</span>) <span class="string">"96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7"</span>,</span><br><span class="line"> PrevHash: (<span class="keyword">string</span>) <span class="string">""</span>,</span><br><span class="line"> Validator: (<span class="keyword">string</span>) <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">27</span> HTTP Server Listening on port : <span class="number">9000</span></span><br></pre></td></tr></table></figure><p>打开新的终端，运行 <code>nc localhost 9000</code>，<br>输入 <code>tokens</code> , 然后输入 <code>BPM</code></p><p>可以打开多个终端，输入不同的 <code>tokens</code> ,来检验 PoS 算法</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW+POS混合公式算法</title>
      <link href="/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-POS混合共识算法"><a href="#POW-POS混合共识算法" class="headerlink" title="POW+POS混合共识算法"></a>POW+POS混合共识算法</h3><p>上一章节说过，实际运用pos是需要借助其他算法才能实现的。本章节主要学习点点币的共识算法，该算法是基于POW改进的POS算法。</p><a id="more"></a><h2 id="混合共识算法的定义"><a href="#混合共识算法的定义" class="headerlink" title="混合共识算法的定义"></a>混合共识算法的定义</h2><p>现在很多公链都是在用基于xx和xx算法的混合共识算法实现共识机制的。什么是混合共识算法呢？<br>有两种情况都可以认为是混合机制：<br>1.在某个算法的基础上，运用其他算法的技术进行改进。如点点币，它的共识机制是用pos算法对pow算法进行改进后的机制，不过大家往往认为点点币的共识机制是pos，其实严格来说是pow+pos的。<br>2.两个算法运算相互独立，但共同组成了一个共识机制。如初链，它的共识是pow和pbft两个算法组成的，然后自己给自己起了个新名字叫混合共识机制fpow。这种混合很明显，所以大家都会叫混合机制。</p><h2 id="混合共识机制POW-POS"><a href="#混合共识机制POW-POS" class="headerlink" title="混合共识机制POW+POS"></a>混合共识机制POW+POS</h2><p>点点币是第一个基于POS发行的数字货币，所以接下来我将带大家深入学习它的共识算法，加深对POS的理解。</p><p>与PoW一样，为了抢到将区块写入区块链的权利，节点同样要进行hash计算，只不过最终的解和币龄有关，计算公式：<br>proofHash &lt; coinAge * target；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coinAge是币龄，target是一个目标值，用于调整难度。coinAge * target的值越大，难度就越小，抢到区块的概率就越高。</span><br></pre></td></tr></table></figure><p>假如你的钱包里是0个币，那么你的币龄就是0, 计算一个小于0的hash值根本不可能，因此基本上抢不到区块。<br>点点币的出块时间也是10分钟左右一个。币龄之前讲过，就是持币数*持币时间；proofHash也就是pow的挖矿函数，即两次sha256 hash运算。所以重点我们要学习target的值是怎么实现的，怎么调整使出块时间在10分钟左右呢？</p><h2 id="点点币的目标值"><a href="#点点币的目标值" class="headerlink" title="点点币的目标值"></a>点点币的目标值</h2><p>点点币难度值是一个一直动态调整的，每隔2个区块就调整一次难度（目标值），使出块时间维持在10分钟左右。<br>点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。<br>计算公式如下：</p><p>　<code>当前区块目标值 = 前一个区块目标值 * (1007 * 10 * 60 + 2 * 前两个区块时间间隔) / (1009 * 10 * 60)</code><br>由公式可见，两个区块目标间隔时间即为10分钟。<br>如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。<br>反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。<br><code>点点币的挖矿难度值=创始区块目标值/当前区块目标值</code>。网页中显示的当前块难度值就是这样算出来的。</p><p>挖矿过程和pow一样，需要比较hash值与目标值大小，广播区块，验证区块，上链等等。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS权益证明</title>
      <link href="/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>通过本章节，大家一起学习单纯的pos是什么机制，以及如何工作的。它较pow有什么优缺点。</p><h2 id="POS概述"><a href="#POS概述" class="headerlink" title="POS概述"></a>POS概述</h2><p>POS即权益证明，英文全称Proof of Stake。它是由匿名极客<code>Sunny King</code>发明的。<code>Sunny King</code>很神秘，类似中本聪，他的具体信息很少有人知道。同时他也是点点币（PPCoin）和质数币（PrimeCoin）的创始人。2012年点点币问世，成为全球首次使用POS共识机制的数字货币。</p><a id="more"></a><p>基于POW的公链挖矿纯靠算力，挖矿难度越高，算力也会越来越中心化。目前比特币挖矿的算力超过70%在中国，据<code>Blockchain.info</code>2018年的统计数据显示，目前世界前十大矿池中，中国独占8家，而中国70%的算力在四川。这样完全背离了去中心化的思想，只有算力高的机构或矿场才能挖到区块，而算力低的个人几乎没有可能挖到区块。算力低的矿工要是参与挖矿，那得赔死，投入电费、场地、矿机等等，结果几乎甚至没有收益。然后他们大部分会放弃挖矿或加入其他大型矿池。而且挖矿代币价格的较大波动也会影响挖矿收益。所以POW类型的挖矿具有很大的投资风险。POW挖矿比拼的就是算力，随着挖矿难度的提高，算力会要求越来越高，导致参与挖矿的矿机数量越来越多，配置也越来越高，如此会造成多大的资源浪费啊。</p><p>针对POW的问题，POS指出了一个全新的概念-币龄，币龄 = 持有的币数 * 持有币的天数，例如钱包里有90个点点币，持有了10天，则币龄=900。决定下一个区块是由谁出，是看当前时刻谁的币龄大。出块后币龄归零，重新计时持币时间。币龄是对应账户恒定数量持币数的值，如果账户的持币数量发生变化，那么币龄也会归零，重新计时。通过币龄来决定出块，不再需要比拼算力，多么环保啊，节省了多少资源啊。</p><p>而且为了让持币人把币握住，不乱抛售，POS还使用了“利息”机制。用户的持币钱包或客户端24小时处于工作状态或后台运行状态，其实就是pos的挖矿状态，系统会在固定时间参照币龄给予持币人一定量的利息（一定量的币）。如此币的抛售将不会像传统的币那么频繁，币价相应的也会稳定。</p><p>POS出块时间可以设为恒定值，如10分钟一个块，那么每10分钟，会触发记账功能。</p><p>为了让POS出块人带有随机性，需要借助一些随机函数，币龄只是增加成为出块者可能性的筹码。如，A的币龄100，B的币龄10，那么A能够出块的概率要比B大10倍。</p><p>使用POS较POW更不容易遭受51%攻击，相比起掌握系统一半以上的算力，拥有整个系统51%的财力会更加困难。</p><p>POS解决或者缓解了POW的一些问题，但是它也有它的很大缺点：</p><pre><code>1.更容易被垄断：因为持币越多，持有的越久，币龄就越高，越容易挖到区块并得到激励，持币少的人基本上没有机会，这样整个系统的安全性实际上会被持币数量较大的一部分人（大股东们）掌握；而POW理论上则不存在这个问题，因为理论上任何人都可以购买矿机获得提高自己的算力（甚至可以联合起来），提升自己挖矿成功的概率；2.很难应对分叉的情况：当出现分叉时，PoS可以在两条链上同时挖矿并获得收益。而PoW则不存在这个问题，因为当出现分叉以后，PoW总是选择工作量大的链做为主链。</code></pre><p>但是在实际应用中，纯POS的共识机制是不可行的，通常会和POW混合一起用或者通过POS升级改进POW。这样会更好的发挥各自的优点，减小双方缺点带来的影响。</p><p>根据masternodes.online的数据显示，目前基于POS算法的币种数量已有330，但是市值在2000万美金以上的只有9种，分别是DASH、PIVX、SYS、BLOCK、XZC、SMART、XSN、PAC、DEV。其中，市值最高的为DASH，目前为21.57亿美元，POS年化收益约为7.19%；XZC市值9805万美元，POS年化收益约为27.28%。</p><h2 id="Go实现一个纯POS机制的简单挖矿"><a href="#Go实现一个纯POS机制的简单挖矿" class="headerlink" title="Go实现一个纯POS机制的简单挖矿"></a>Go实现一个纯POS机制的简单挖矿</h2><p>设计思路：<br>1.有两个挖矿节点，分别持有的币为10个和5个，持币时间为1 。所以他们的币龄也就是10和5 。<br>2.创建一个长度为15的数组，分别将两个节点的账户地址按照比例布满这个数组。<br>3.选择一个从0到14的随机数，将该随机数作为2步数组的下表，找到该下表下的挖矿地址。<br>4.挖矿地址确认后，通过方法产生区块。<br>5.将区块上链，这里的区块链我们定义了一个切片。上链过程就是append过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个块结构体</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span>  <span class="comment">//区块高度</span></span><br><span class="line">    Timestamp <span class="keyword">string</span> <span class="comment">//时间戳，也就是当前时间转换成字符串</span></span><br><span class="line">    BPM       <span class="keyword">int</span>   <span class="comment">//要保存的上链数据</span></span><br><span class="line">    Hash      <span class="keyword">string</span>  <span class="comment">//当前区块hash值</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span>  <span class="comment">//父区块hash值</span></span><br><span class="line">    Validator <span class="keyword">string</span>  <span class="comment">//当前区块出块人的账户地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个区块链，类型是切片。也就是将区块放在这个切片里面</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出块函数，也就是当随机抽中哪个账户后，该账户就会作为该区块的参数，生成一个最新区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成区块过程就是给区块的字段赋值</span></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最新区块</span></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256算法计算当前区块的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将区块字段拼接，为生成hash函数做准备</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//持币人信息</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在参与挖矿的币总数为15个，我们认为现在是平等机会的15个持币1个的矿工。</span></span><br><span class="line"><span class="comment">//声明一个数组保存15个账户地址</span></span><br><span class="line"><span class="comment">//两个节点参与挖矿</span></span><br><span class="line"><span class="keyword">var</span> N[<span class="number">15</span>] <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> p [<span class="number">2</span>] Node</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给两个挖矿节点赋值</span></span><br><span class="line">    p[<span class="number">0</span>]=Node&#123;<span class="number">10</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">    p[<span class="number">1</span>]=Node&#123;<span class="number">5</span>,<span class="string">"bcd"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下边的for循环，按照两个节点他们的持币数，分别将他们的地址赋值到之前定义好的账户地址数组中。</span></span><br><span class="line">    <span class="comment">//可以看出，前10个账户都是p[0]的；后边5个是p[1]的</span></span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;p[i].tokens;j++&#123;</span><br><span class="line"></span><br><span class="line">            N[cnt] = p[i].address</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据随机数种子产生的随机数，找到矿工的地址，然后出块  （0~14）随机数</span></span><br><span class="line">    <span class="comment">//（拥有10个币上链的概率为10/15，拥有5个币上链概率为5/15，rand.Intn(cnt)找到地址   其中有10个是拥有10个币的地址，5个事拥有5个币的地址）</span></span><br><span class="line">    <span class="keyword">var</span> b,_ = generateBlock(firstBlock,<span class="number">10</span>,N[rand.Intn(cnt)])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的区块放到区块链上。</span></span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(Blockchain)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW代码实现</title>
      <link href="/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="用go语言实现一个pow共识工程"><a href="#用go语言实现一个pow共识工程" class="headerlink" title="用go语言实现一个pow共识工程"></a>用go语言实现一个pow共识工程</h3><a id="more"></a><h2 id="1-1-项目代码结构"><a href="#1-1-项目代码结构" class="headerlink" title="1.1 项目代码结构"></a>1.1 项目代码结构</h2><p><img src="http://img.kongyixueyuan.com/0301_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png/mark" alt="img"></p><h2 id="1-2-项目运行结果"><a href="#1-2-项目运行结果" class="headerlink" title="1.2 项目运行结果"></a>1.2 项目运行结果</h2><p><img src="http://img.kongyixueyuan.com/0302_%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif/mark" alt="img"></p><h2 id="1-3-完整代码"><a href="#1-3-完整代码" class="headerlink" title="1.3 完整代码"></a>1.3 完整代码</h2><p>Block.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//1. 区块高度</span></span><br><span class="line">    Height <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//2. 上一个区块HASH</span></span><br><span class="line">    PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//3. 交易数据</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//4. 时间戳</span></span><br><span class="line">    Timestamp <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//5. Hash</span></span><br><span class="line">    Hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 6. Nonce</span></span><br><span class="line">    Nonce <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建新的区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建区块</span></span><br><span class="line">    block := &amp;Block&#123;height,prevBlockHash,[]<span class="keyword">byte</span>(data),time.Now().Unix(),<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用工作量证明的方法并且返回有效的Hash和Nonce</span></span><br><span class="line">    pow := NewProofOfWork(block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挖矿验证</span></span><br><span class="line">    hash,nonce := pow.Run()</span><br><span class="line"></span><br><span class="line">    block.Hash = hash[:]</span><br><span class="line">    block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 单独写一个方法，生成创世区块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBlock(data,<span class="number">1</span>, []<span class="keyword">byte</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlockChain.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">    Blocks []*Block  <span class="comment">// 存储有序的区块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加区块到区块链里面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blc *Blockchain)</span> <span class="title">AddBlockToBlockchain</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,preHash []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 创建新区块</span></span><br><span class="line">    newBlock := NewBlock(data,height,preHash)</span><br><span class="line">    <span class="comment">// 往链里面添加区块</span></span><br><span class="line">    blc.Blocks = <span class="built_in">append</span>(blc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建带有创世区块的区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockchainWithGenesisBlock</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建创世区块</span></span><br><span class="line">    genesisBlock := CreateGenesisBlock(<span class="string">"Genesis Data......."</span>)</span><br><span class="line">    <span class="comment">// 返回区块链对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProofOfWork.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 1001 0001 0000 .... 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 256位Hash里面前面至少要有16个零</span></span><br><span class="line"><span class="keyword">const</span> targetBit  = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash nil</span></span><br><span class="line"><span class="comment">//256位</span></span><br><span class="line"><span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 二进制表示 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 2 的 32 - 8 次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    Block *Block <span class="comment">// 当前要验证的区块</span></span><br><span class="line">    <span class="comment">// 0000 0001 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">    target *big.Int <span class="comment">// 大数据存储 2^24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面必须有8个零</span></span><br><span class="line"><span class="comment">// 0000 0000 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0001</span></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0000 0000 0000 1111 111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拼接，返回字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            pow.Block.PrevBlockHash,</span><br><span class="line">            pow.Block.Data,</span><br><span class="line">            IntToHex(pow.Block.Timestamp),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(targetBit)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(pow.Block.Height)),</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.proofOfWork.Block.Hash</span></span><br><span class="line">    <span class="comment">//2.proofOfWork.Target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int</span><br><span class="line">    <span class="comment">// []byte 转 Int</span></span><br><span class="line">    hashInt.SetBytes(proofOfWork.Block.Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">    <span class="comment">//    0 if x == y</span></span><br><span class="line">    <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">    <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>,<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 将Block的属性拼接成字节数组</span></span><br><span class="line">    <span class="comment">//2. 生成hash</span></span><br><span class="line">    <span class="comment">//3. 判断hash有效性，如果满足条件，跳出循环</span></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int <span class="comment">// 存储我们新生成的hash</span></span><br><span class="line">    <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        dataBytes := proofOfWork.prepareData(nonce)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hash</span></span><br><span class="line">        hash = sha256.Sum256(dataBytes)</span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>,hash)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将hash存储到hashInt</span></span><br><span class="line">        hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断hashInt是否小于Block里面的target</span></span><br><span class="line">        <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">        <span class="comment">//    0 if x == y</span></span><br><span class="line">        <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">        <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonce = nonce + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[:],<span class="keyword">int64</span>(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的工作量证明对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProofOfWork</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.big.Int对象 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//0000 0001</span></span><br><span class="line">    <span class="comment">// 8 - 2 = 6</span></span><br><span class="line">    <span class="comment">// 0100 0000  64</span></span><br><span class="line">    <span class="comment">// 0010 0000</span></span><br><span class="line">    <span class="comment">// 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 .... 0000</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 创建一个初始值为1的target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int Int</span></span><br><span class="line">    target := big.NewInt(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 左移256 - targetBit</span></span><br><span class="line"></span><br><span class="line">    target = target.Lsh(target,<span class="number">256</span> - targetBit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ProofOfWork&#123;block,target&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64转换为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"kongyixueyuan.com/blockchain_go_videos-master/part8-proof-of-work/BLC"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创世区块</span></span><br><span class="line">    blockchain := BLC.CreateBlockchainWithGenesisBlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新区块</span></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 100RMB To tom"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 200RMB To lily"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 300RMB To hanmeimei"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 50RMB To lucy"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(blockchain)</span><br><span class="line">    fmt.Println(blockchain.Blocks)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW挖矿及共识流程</title>
      <link href="/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="PoW-挖矿及共识流程"><a href="#PoW-挖矿及共识流程" class="headerlink" title="PoW-挖矿及共识流程"></a>PoW-挖矿及共识流程</h3><p>本章节主要是熟悉比特币pow挖矿及共识流程，和简单实现一个pow挖矿helloworld的小demo。</p><a id="more"></a><h2 id="比特币pow挖矿及共识流程"><a href="#比特币pow挖矿及共识流程" class="headerlink" title="比特币pow挖矿及共识流程"></a>比特币pow挖矿及共识流程</h2><p>比特币挖矿的过程如下：</p><ol><li>构建一个空区块，称为候选区块</li><li>从内存池中打包交易至候选区块</li><li>构造区块头，填写区块头的下述字段<br>　　1）填写版本号version字段<br>   　　2）填写父区块哈希prevhash字段<br>   　　3）用merkle树汇总全部的交易，将merkle root的哈希值填写至merkle root字段<br>   　　4）填写时间戳timestamp字段<br>   　　5）填写目标值Bits字段</li><li>开始挖矿。挖矿就是不断重复计算区块头的哈希值，修改nonce参数，直到找到一个满足条件的nonce值，也就是该nonce值下，hash函数运算出来的hash值 &lt; Bits。当挖矿节点成功求出一个解后把解填入区块头的nonce字段。</li><li>这时一个新区块就成功挖出了，然后挖矿节点会做下面这些事：<br>　　1) 按照标准清单检验新区块，检验通过后进行下面的 2)和 3)步骤<br>   　　2）立刻将这个新区块发给它的所有相邻节点，相邻节点收到这个新区块后进行验证，验证有效后会继续传播给所有相邻节点。<br>   　　3）将这个新区块连接到现有的区块链中，按照如下规则：<br>   　　　　根据新区块的prevhash字段在现有区块链中寻找这个父区块，<br>   　　　　(Ⅰ) 如果父区块是主区块链的“末梢”，则将新区块添加上去即可；<br>   　　　　(Ⅱ) 如果父区块所在的链是备用链，则节点将新区块添加到备用链，同时比较备用链与主链的工作量。如果备用链比主链积累了更多的工作量，节点将选择备用链作为其新的主链，而之前的主链则成为了备用链；<br>   　　　　(Ⅲ) 如果在现有的区块链中找不到它的父区块，那么这个区块被认为是“孤块”。孤块会被保存在孤块池中，直到它们的父区块被节点接收到。一旦收到了父区块并且将其连接到现有的区块链上，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</li></ol><p>pow工作量证明共识机制流程图如下：</p><p><img src="http://image.chaindesk.cn/pow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png/mark" alt="img"></p><p>演示挖坑过程，可链接下面网址：</p><p><a href="https://anders.com/blockchain/blockchain.html" target="_blank" rel="noopener">https://anders.com/blockchain/blockchain.html</a></p><h2 id="pow简单的例子"><a href="#pow简单的例子" class="headerlink" title="pow简单的例子"></a>pow简单的例子</h2><p>下边这个代码很糙，只是简化版的pow挖矿过程，里面的N就是挖矿Bits，我设置了一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//声明了一个挖矿难度Bits</span></span><br><span class="line"><span class="keyword">const</span> N  = <span class="number">0x00FFffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个block结构体</span></span><br><span class="line"><span class="keyword">type</span> block <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//区块数据</span></span><br><span class="line">    Data  []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//随机数</span></span><br><span class="line">    Nonce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//当前块的hash</span></span><br><span class="line">    hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//挖矿目标难度值</span></span><br><span class="line">    Bits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化一个空块</span></span><br><span class="line">    <span class="keyword">var</span> b = block&#123;[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>), <span class="number">0</span>,<span class="literal">nil</span>,N&#125;</span><br><span class="line"></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接block字段内容</span></span><br><span class="line">        dataBytes := b.PreParae(nonce)</span><br><span class="line">        <span class="comment">//矿工计算函数，我只用了一次256hash</span></span><br><span class="line">        hash := sha256.Sum256(dataBytes)</span><br><span class="line">        <span class="comment">//将hash转换成Uint64类型，将与N进行比较大小</span></span><br><span class="line">        hash1 := BytesToUint64(hash[:])</span><br><span class="line">        <span class="comment">//不断显现hash函数后的值</span></span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">        <span class="comment">//hash值与目标值进行大小比较</span></span><br><span class="line">        <span class="keyword">if</span> hash1 &lt; <span class="keyword">uint64</span>(N) &#123;</span><br><span class="line">        <span class="comment">//挖矿成功后，给b重新赋值，并跳出循环</span></span><br><span class="line">            fmt.Println()</span><br><span class="line">            b.Nonce=nonce</span><br><span class="line">            b.hash=hash[:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonce++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//block字段拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b block)</span> <span class="title">PreParae</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            b.Data,</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            b.hash,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节转换成64进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToUint64</span><span class="params">(array []<span class="keyword">byte</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">        data = data + <span class="keyword">uint64</span>(<span class="keyword">uint</span>(array[i])&lt;&lt;<span class="keyword">uint</span>(<span class="number">8</span>*i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将64进制数字转换成字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW目标值</title>
      <link href="/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
      <url>/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-目标值"><a href="#POW-目标值" class="headerlink" title="POW-目标值"></a>POW-目标值</h3><p>很多文章或解析将区块里的Bits字段解读成难度值，其实是错误的。Bits的作用是直接和区块头2次sha256（）的结果进行比较大小的。比较之前，需要先将两者的类型转换成big.Int型。起初Bits类型是Uint32；hash类型是字节数组。</p><a id="more"></a><h2 id="目标值的产生"><a href="#目标值的产生" class="headerlink" title="目标值的产生"></a>目标值的产生</h2><p>目标值是怎么产生的呢？<br>目标值是一个变量，中本聪设的初始值是0x1d00ffff。这个目标值以后会每隔2016个区块，根据过去2016个区块花费时长算出的难度值进行调整，保证正常出块的时间在10分钟左右。所有节点都会按统一公式自动调整Bits，调整公式：</p><p>新难度值=旧难度值*（过去2016个区块花费时长（分）/20160分钟）</p><p>目标值=最大目标值/难度值。</p><p>最大目标值是恒定的，即为创始区块的Bits值<code>0x1d00FFFF</code>。这个数的由来是<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>这个64位16进制数通过小端法存储得来。这个64位数字存储需要占32个字节，而Bits在区块头占大小是4个字节，所以通过小端法存储可以把后边的0都抹去，最后得到的数占4个字节。小端法英文表示little-endian，一种是将低序字节存储在起始地址的存储方法。我们经常用到的存储都是大端法，按数据字节顺序从高到低存储。</p><p><code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>来自中本聪定义的数字<code>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>使用浮点编码类型得来的。方法是为满足实现小端法存储，中本聪处理后面F的方法，具体不作分析。真正在代码中出现的最大目标值只是<code>0x1d00FFFF</code>，也就是创始区块的Bits。</p><p>每2016个区块完成后，会自动调整新的目标值Bits。从上边公式可以看出新Bits与难度值成反比。因为Bits是小端法存储，所以存储的数据越大说明实际的数字越小，那么挖矿越难；反之越简单。难度值也是个变量，最开始前2016个块数值是1，之后每隔2016个块后都会改变。在矿工挖矿过程中，都会有一个计时器，记录每个区块挖矿的时间，当累加2016次后，将会通过新难度值公式，计算出下一次挖矿的难度值，然后再通过目标值公式得到以后挖矿的目标值。</p><h2 id="还原真实目标值"><a href="#还原真实目标值" class="headerlink" title="还原真实目标值"></a>还原真实目标值</h2><p>在矿工挖矿过程中，产生的hash值与目标值进行比较大小，需要将目标值还原成真实值。目标值由指数（exponent）和系数（coefficient）两部分组成。高位一个字节为指数，低位三个字节为系数。真实目标值用target表示。</p><p>真实的目标值的大小计算方式是：target = coefficient <em>2^(8</em> (exponent – 3))</p><p>比如：<br>在区块277,316中，nBits字段的值为0x1903a30c，则0x19为指数，而 0x03a30c为系数。<br>计算难度目标的公式为：<br>target = coefficient <em>2^(8</em> (exponent – 3))</p><p>由此公式，以及难度位nBits的值 0x1903a30c，可得：</p><p>target = 0x03a30c <em>2^(0x08</em> (0x19 - 0x03))^</p><p>=&gt; <code>target = 0x03a30c * 2^(0x08 * 0x16)^</code><br>=&gt;<code>target = 0x03a30c * 2^0xB0^</code></p><p>按十进制计算为：</p><p>=&gt;<code>target = 238,348 * 2^176^</code><br>=&gt; <code>target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</code></p><p>转化回十六进制后为：</p><p>=&gt; <code>target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</code></p><p>也就是说高度为277,316的有效区块的区块头哈希值是小于这个真实目标值的。这个数字的二进制表示中必须超过60位的前导位都是0。在这个级别的难度，一个每秒可以处理1万亿次（1 tera-hash per second 或 1 TH/sec）哈希计算的矿工平均每8,496个区块，或者平均每59天，才能找到一个正确结果。</p><p>再看下比特币中创世区块(GenesisBlock)的难度值：<br>nBits字段值为：0x1d00ffff(十进制即为：486604799)，表示为十六进制的Target值为：<code>00000000ffff0000000000000000000000000000000000000000000000000000</code></p><p>综上，这个高度为277,316的有效区块的区块头的部分信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A：Bits = <span class="string">"0x1903a30c"</span></span><br><span class="line"></span><br><span class="line">B：exponent指数，exponent = <span class="number">0x19</span></span><br><span class="line"></span><br><span class="line">C：coefficient系数，coefficient = <span class="number">0x03a30c</span></span><br><span class="line"></span><br><span class="line">D：target = coefficient * Math.Pow(<span class="number">2</span>, <span class="number">8</span> * (exponent - <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">E：Bits真实值（target）：<span class="number">0x0000000000000003A30C00000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">F：本区块hash：<span class="number">00000000000000000041</span>ff1cfc5f15f929c1a45d262f88e4db83680d90658c0c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW工作量证明</title>
      <link href="/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h3><p>PoW，全称Proof of Work，即工作量证明，又称挖矿。大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。根据挖矿贡献的有效工作，来决定货币的分配。</p><p>接下来主要以pow在比特币公链上的应用展开讲解。</p><a id="more"></a><h2 id="比特币Pow"><a href="#比特币Pow" class="headerlink" title="比特币Pow"></a>比特币Pow</h2><p>比特币的出块时间是10分钟左右。每个区块内包含最多8笔交易，这些交易需要被验证和确认，才能实现账户代币的转移。每个挖矿节点做的工作就是去验证和确认这个区块，使区块内的交易得以实现。而他们用的算法就是pow。pow计算的是一个数学运算难题，矿工们首先验证要挖坑区块的合法性，如果合法，他们就开始计算本次挖矿的数学难题，谁第一个做出来并且广播出去，告诉其他矿工我做出来了，你们不用做了。其他矿工们验证你的计算结果和对应的区块，如果大部分的矿工认同你的结果，那么他们将停止挖坑并同步你的数据。区块内的所有交易也就得到认可，实现转账。你的成功挖矿会被比特币激励模块记录，并会给你发送比特币奖励金。</p><p>pow算法主要寻找一个随机数（Block里的Nonce值）作为输入，通过改变这个输入，使Block数据不重复变化，Hash函数（一般是sha256）不断计算这个改变后Block的hash值，找出一个特定格式哈希值的过程（即要求有一定数量的前导0），这里找到的值就是当前hash值 &lt; 目标值（Bits），只不过这个比较是在2进制的格式下比较运算的，也就是比较2进制后数字前面0的个数。这个过程就是pow运算过程。而要求的前导0的个数越多，代表难度越大。在将pow算法之前，先学习下区块信息。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如下图所示<br><img src="http://image.chaindesk.cn/po%20w%E5%8C%BA%E5%9D%97%E4%BF%A1%E6%81%AF.png/mark" alt="img"></p><p>从图上可知，比特币区块结构分为区块头和区块体，区块体保存交易的具体信息，由它生成的hash保存在区块头里。其中区块头细分为：<br>父区块头哈希值：前一区块的哈希值，使用SHA256(SHA256(父区块头))计算。</p><p>版本(Version)：区块版本号，表示本区块遵守的验证规则 。</p><p>时间戳(Timestamp)：该区块产生的近似时间，精确到秒的UNIX时间戳，必须严格大于前11个区块时间的中值，同时全节点也会拒绝那些超出自己2个小时时间戳的区块。</p><p>目标值(Bits)：该区块工作量证明算法的难度目标，已经使用特定算法编码。</p><p>随机数（Nonce）：为了找到满足难度目标所设定的随机数，为了解决32位随机数在算力飞升的情况下不够用的问题，规定时间戳和coinbase交易信息均可更改，以此扩展nonce的位数。</p><p>Merkle根(MerkleRoot)：该区块中交易的Merkle树根的哈希值。矿工收到计算过的区块，会跟自己的区块进行比较，其中Merkle root就是比较它们包含的交易是否一样。</p><p>区块头里的所有信息拼接成一个新的字节数组，pow函数运算的参数就是这个字节数组。函数运算是采用SHA256(SHA256())计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">var</span> genesisBlock = wire.MsgBlock&#123;</span><br><span class="line">    Header: wire.BlockHeader&#123;</span><br><span class="line">        Version:    <span class="number">1</span>,</span><br><span class="line">        PrevBlock:  chainhash.Hash&#123;&#125;,         <span class="comment">// 0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">        MerkleRoot: genesisMerkleRoot,        <span class="comment">// 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</span></span><br><span class="line">        Timestamp:  time.Unix(<span class="number">0x495fab29</span>, <span class="number">0</span>), <span class="comment">// 2009-01-03 18:15:05 +0000 UTC</span></span><br><span class="line">        Bits:       <span class="number">0x1d00ffff</span>,               <span class="comment">// 486604799 </span></span><br><span class="line">        Nonce:      <span class="number">0x7c2bac1d</span>,               <span class="comment">// 2083236893</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Transactions: []*wire.MsgTx&#123;&amp;genesisCoinbaseTx&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pow三要素"><a href="#Pow三要素" class="headerlink" title="Pow三要素"></a>Pow三要素</h2><p>1.Hash函数：在比特币中使用的是SHA256算法函数，是密码哈希函数家族中输出值为256位的哈希算法。</p><p>2.区块头 Hash函数运算需要的参数，也就是区块头的所有信息字节拼接后的字节数组。</p><p>3.目标值（Bits） 每一个区块会用一种压缩的格式（被称为“Bits”）来表示实际的16进制的目标值。通过这个值和系统中其他常量可计算出该难度值下的难度目标值。Hash函数运算出来的结果与目标值进行比较大小，如果小，则表示挖坑成功，否则继续运算。比较大小时为使运算速度快速，目标值和hash值都会转换成2进制，所以比较大小就是比较前导0的个数。比特币是每隔2016个区块后调整难度值。<br>pow挖矿的难度与目标值成反比，如果Bits的实际值增大，那么挖矿容易点；反之，挖矿难度加大。</p><p>比特币整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力，使整个网络的计算力大致每10分钟产生一个区块。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识机制</title>
      <link href="/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="共识机制概述"><a href="#共识机制概述" class="headerlink" title="共识机制概述"></a>共识机制概述</h3><p>所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。</p><a id="more"></a><p>实现共识机制的算法就是共识算法。接下来的章节我会对Pow，Pos，Pbft，Raft等共识算法进行讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Gin的Cookie和Seesion</title>
      <link href="/2019/12/19/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/03Cookie%E5%92%8CSession/"/>
      <url>/2019/12/19/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/03Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Cookie是什么"><a href="#1-Cookie是什么" class="headerlink" title="1.Cookie是什么"></a>1.Cookie是什么</h2><ul><li>HTTP是无状态协议，服务器不能记录游览器的访问状态，也就是说服务器不能区分请求是否由同一个客户端发出</li><li>Cookie就是解决HTTP协议无状态的方案之一，中文是小甜饼的意识</li><li>Cookie实际上就是服务器保存在游览器上的一段信息。游览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求。</li><li>Cookie有服务器创建，并发给浏览器，最终由服务器保存</li></ul><h2 id="2-Cookie的用途"><a href="#2-Cookie的用途" class="headerlink" title="2.Cookie的用途"></a>2.Cookie的用途</h2><ul><li>保存用户登入状态</li><li>京东购物车 </li></ul><h2 id="3-Cookie的使用"><a href="#3-Cookie的使用" class="headerlink" title="3.Cookie的使用"></a>3.Cookie的使用</h2><ul><li><p>测试服务端发送cookie给客户端，客户端请求时携带cookie</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//服务端要给客户端coookie</span></span><br><span class="line">router.GET(<span class="string">"cookie"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//获取客户端是否携带cookie</span></span><br><span class="line">cookie,err :=c.Cookie(<span class="string">"key_node"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">cookie =<span class="string">"NotSet"</span></span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line"><span class="comment">//key，value string，maxAge int 单位为秒</span></span><br><span class="line"><span class="comment">//path，cookie所在目录</span></span><br><span class="line"><span class="comment">//domain string 域名</span></span><br><span class="line"><span class="comment">//secure 是否智能通过https访问</span></span><br><span class="line"><span class="comment">//htpOnly bool是否允许别人通过js获取自己的cookie</span></span><br><span class="line">c.SetCookie(<span class="string">"key_node"</span>,<span class="string">"value_cookie"</span>,<span class="number">60</span>,</span><br><span class="line"><span class="string">"/"</span>,<span class="string">"localhost"</span>,<span class="literal">false</span>,<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"cookie :%s"</span>,cookie)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Cookie的练习"><a href="#4-Cookie的练习" class="headerlink" title="4.Cookie的练习"></a>4.Cookie的练习</h2><ul><li><p>模拟权限验证中间件</p><ul><li>有2个路由，login和home</li><li>login用于设置cookie</li><li>home是访问查看信息的请求</li><li>在请求home之前，先跑中间件代码，检验是否存在cookie</li></ul></li><li><p>访问home，会显示错误，因为权限校验未通过</p></li><li><p>然后访问登入请求，登入并设置cookie</p></li><li><p>再次访问home，访问成功</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleWare</span><span class="params">()</span><span class="title">gin</span>.<span class="title">HandlerFunc</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//获得客户端cokie并校验</span></span><br><span class="line"><span class="keyword">if</span> cookie ,err :=c.Cookie(<span class="string">"abc"</span>);err !=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">if</span> cookie== <span class="string">"abc"</span>&#123;</span><br><span class="line">c.Next()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回错误401</span></span><br><span class="line">c.JSON(http.StatusUnauthorized,gin.H&#123;<span class="string">"error"</span>:<span class="string">"err"</span>&#125;)</span><br><span class="line"><span class="comment">//若验证不通过，不再调用后继的函数处理</span></span><br><span class="line">c.Abort() </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cookie practice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//服务端要给客户端coookie</span></span><br><span class="line">router.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line">c.SetCookie(<span class="string">"abc"</span>,<span class="string">"123"</span>,<span class="number">60</span>,</span><br><span class="line"><span class="string">"/"</span>,<span class="string">"localhost"</span>,<span class="literal">false</span>,<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//返回信息</span></span><br><span class="line">c.String(<span class="number">200</span>,<span class="string">"Lofin success"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.GET(<span class="string">"/home"</span>,AuthMiddleWare(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>,gin.H&#123;<span class="string">"data"</span>:<span class="string">"home"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问/home拦截访问/login进行测试</p></li></ul><h2 id="5-Cookie的缺点"><a href="#5-Cookie的缺点" class="headerlink" title="5.Cookie的缺点"></a>5.Cookie的缺点</h2><ul><li>不安全，明文</li><li>增加带宽消耗</li><li>可以被禁用</li><li>cookie携带数据有上限</li></ul><h2 id="6-Seesion是什么"><a href="#6-Seesion是什么" class="headerlink" title="6.Seesion是什么"></a>6.Seesion是什么</h2><ul><li>session可以弥补cookie的不足，Session必须依赖于cookie才能使用，生成一个SessionId放在cookie里传给客户端就可以</li></ul><h2 id="7-Seesion的中间件开发"><a href="#7-Seesion的中间件开发" class="headerlink" title="7.Seesion的中间件开发"></a>7.Seesion的中间件开发</h2><p><img src="./image/1585748013(1).png" alt="session"></p><ul><li><p>设计一个通用的Session服务，支持内存和redis存储</p></li><li><p>session模块设计</p><ol><li>本质k-v系统，通过key进行增删改查</li><li>session可以存储在内存或者redis</li></ol></li><li><p>session接口设计</p><ul><li>Set（）</li><li>Get（）</li><li>Del（）</li><li>Save（）session存储，redis的实现延迟加载</li></ul></li><li><p>sessionMgr接口设计</p><ul><li>Init（）初始化，加载redis地址</li><li>CreateSession（）创建一个新的session</li><li>Getsession（）通过sessionId获取对应的session对象</li></ul></li><li><p>MemorySesssion设计</p><ul><li>定义MemorySession对象（字段：sessionId、存Kv的map，读写锁）</li><li>构造函数（初始化，为了获取对象）</li><li>Set（）</li><li>Get（）</li><li>Del（）</li><li>Save（）</li></ul></li><li><p>MemorySessionMgr设计</p><ul><li>定义MemorySessionMgr对象（字段：sessionId、存Kv的map，读写锁）</li><li>构造函数</li><li>Init（）初始化，加载redis地址</li><li>CreateSession（）创建一个新的session</li><li>Getsession（）通过sessionId获取对应的session对象</li></ul></li><li><p>RedisSession设计</p><ul><li>定义RedisSession对象（字段：sessionId、存Kv的map，读写锁，redis连接池，记录内存中map是否被修改的标记）</li><li>Set（）将session存到内存中的map</li><li>Get（）取数据，实现延迟加载</li><li>Del（）</li><li>Save（）将session存到redis</li></ul></li><li><p>RedisSessionMgr设计</p><ul><li>定义RedisSessionMgr对象（字段：redis地址，redis密码，读写锁，连接池）</li><li>构造函数</li><li>Init（）</li><li>CreateSession（）</li><li>Getsession（）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02Gin中间件</title>
      <link href="/2019/12/19/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/02gin%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2019/12/19/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/02gin%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h2><ul><li>gin可以构建中间件，但它只对注册过的路由函数起作用</li><li>对于分组路由，潜逃使用中间件，可以限定中间件的作用范围</li><li>中间件分为全局中间件，单个路由中间件</li><li><strong>gin中间件必须是一个gin.HandleFunc类型</strong></li></ul><h3 id="1-全局中间件"><a href="#1-全局中间件" class="headerlink" title="1.全局中间件"></a>1.全局中间件</h3><p>所有请求都经过此中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MiddleWare</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">t:=time.Now()</span><br><span class="line">fmt.Println(<span class="string">"中间件开始执行"</span>)</span><br><span class="line"><span class="comment">//设置变量Context的key中，可以通过Get（）取</span></span><br><span class="line">c.Set(<span class="string">"request"</span>,<span class="string">"中间件"</span>)</span><br><span class="line"><span class="comment">//执行中间件</span></span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要执行操作添加</span></span><br><span class="line"></span><br><span class="line">status :=c.Writer.Status()</span><br><span class="line">fmt.Println(<span class="string">"中间件执行完毕"</span>,status)</span><br><span class="line">t2 := time.Since(t)</span><br><span class="line">fmt.Println(<span class="string">"time:"</span>,t2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//注册中间件</span></span><br><span class="line">router.Use(MiddleWare())</span><br><span class="line"><span class="comment">//&#123;&#125;为了代码规范</span></span><br><span class="line">&#123;</span><br><span class="line">router.GET(<span class="string">"/middleware"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">req,_:=c.Get(<span class="string">"request"</span>)</span><br><span class="line">fmt.Println(<span class="string">"request"</span>,req)</span><br><span class="line"><span class="comment">//页面接受</span></span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"request"</span>:req&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面访问</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">localhost:</span><span class="number">8080</span>/middleware</span><br><span class="line">结果显示</span><br><span class="line">&#123;<span class="string">"request"</span>,<span class="string">"中间件"</span>&#125;</span><br></pre></td></tr></table></figure><p>控制台返回</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running <span class="keyword">in</span> <span class="string">"debug"</span> mode. Switch to <span class="string">"release"</span> mode <span class="keyword">in</span> production.</span><br><span class="line"> - using env:   <span class="built_in">export</span> GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /middleware               --&gt; main.main.func1 (4 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8000</span><br><span class="line">中间件开始执行</span><br><span class="line">request 中间件</span><br><span class="line">中间件执行完毕 200</span><br><span class="line">time: 6.0043ms</span><br><span class="line">[GIN] 2020/03/30 - 13:36:53 |?[97;42m 200 ?[0m|      6.0043ms |             ::1 |?[97;44m GET     ?[0m /middleware</span><br></pre></td></tr></table></figure><h3 id="2-Next-方法"><a href="#2-Next-方法" class="headerlink" title="2.Next()方法"></a>2.Next()方法</h3><p>源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下一步只能在中间件内部使用。</span></span><br><span class="line"><span class="comment">//它在调用处理程序内的链中执行挂起的处理程序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.index++</span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="keyword">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-局部中间件"><a href="#3-局部中间件" class="headerlink" title="3.局部中间件"></a>3.局部中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MiddleWare</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">t:=time.Now()</span><br><span class="line">fmt.Println(<span class="string">"中间件开始执行"</span>)</span><br><span class="line"><span class="comment">//设置变量Context的key中，可以通过Get（）取</span></span><br><span class="line">c.Set(<span class="string">"request"</span>,<span class="string">"中间件"</span>)</span><br><span class="line"><span class="comment">//执行中间件</span></span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要执行操作添加</span></span><br><span class="line"></span><br><span class="line">status :=c.Writer.Status()</span><br><span class="line">fmt.Println(<span class="string">"中间件执行完毕"</span>,status)</span><br><span class="line">t2 := time.Since(t)</span><br><span class="line">fmt.Println(<span class="string">"time:"</span>,t2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//注册中间件</span></span><br><span class="line">router.Use(MiddleWare())</span><br><span class="line"><span class="comment">//&#123;&#125;为了代码规范</span></span><br><span class="line">&#123;</span><br><span class="line">router.GET(<span class="string">"/middleware"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">req,_:=c.Get(<span class="string">"request"</span>)</span><br><span class="line">fmt.Println(<span class="string">"request"</span>,req)</span><br><span class="line"><span class="comment">//页面接受</span></span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"request"</span>:req&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//根路由后面定义的局部中间件</span></span><br><span class="line">router.GET(<span class="string">"/middleware2"</span>,MiddleWare(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">req,_:=c.Get(<span class="string">"request"</span>)</span><br><span class="line">fmt.Println(<span class="string">"request"</span>,req)</span><br><span class="line"><span class="comment">//页面接受</span></span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"request"</span>:req&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面访问localhost：8000/middleware2</p><p>控制台返回结果(会执行两次，会先将全局的中间件执行)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中间件开始执行</span><br><span class="line">中间件开始执行</span><br><span class="line">request 中间件</span><br><span class="line">中间件执行完毕 200</span><br><span class="line">time: 6.0102ms</span><br><span class="line">中间件执行完毕 200</span><br><span class="line">time: 11.0137ms</span><br><span class="line">[GIN] 2020/03/30 - 14:03:15 |?[97;42m 200 ?[0m|     13.0092ms |             ::1 |?[97;44m GET     ?[0m /middleware2</span><br></pre></td></tr></table></figure><h3 id="4-中间件练习"><a href="#4-中间件练习" class="headerlink" title="4.中间件练习"></a>4.中间件练习</h3><p>*定义程序计时中间件，然后定义2个路由，执行函数后应该打印统计的执行时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTime</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">start :=time.Now()</span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">//统计时间</span></span><br><span class="line">since := time.Since(start)</span><br><span class="line">fmt.Println(<span class="string">"time:"</span>,since)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//注册中间件</span></span><br><span class="line">router.Use(myTime)<span class="comment">//自动返回HandleFunc类型</span></span><br><span class="line">shoppingGroup :=router.Group(<span class="string">"/shopping"</span>)</span><br><span class="line">&#123;<span class="comment">//shopIndexHandler局部中间件</span></span><br><span class="line">shoppingGroup.GET(<span class="string">"index"</span>,shopIndexHandler)</span><br><span class="line">shoppingGroup.GET(<span class="string">"/home"</span>,shopHomeHandler)</span><br><span class="line">&#125;</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shopIndexHandler</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shopHomeHandler</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time: 5.0005598s</span><br><span class="line">[GIN] 2020/03/31 - 14:16:26 |?[97;42m 200 ?[0m|    5.0005598s |             ::1 |?[97;44m GET     ?[0m /shopping/index</span><br><span class="line">time: 3.0007355s</span><br><span class="line">[GIN] 2020/03/31 - 14:16:39 |?[97;42m 200 ?[0m|    3.0007355s |             ::1 |?[97;44m GET     ?[0m /shopping/home</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go变量和常量</title>
      <link href="/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之变量和常量"><a href="#Go语言基础之变量和常量" class="headerlink" title="Go语言基础之变量和常量"></a>Go语言基础之变量和常量</h1><p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p><a id="more"></a><h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Q1mi"</span>  <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">"Q1mi"</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span> <span class="comment">//声明并初始化变量,只能在函数内使用，不可使用在函数外</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>执行<code>go fmt main.go</code>使得程序代码格式化</p><h4 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">n <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">isOk <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">name =<span class="string">"lixiang"</span></span><br><span class="line">age =<span class="number">16</span></span><br><span class="line">n=<span class="string">"a"</span></span><br><span class="line">isOk=<span class="literal">true</span></span><br><span class="line"><span class="comment">//GO语言声明变量必须使用，不使用编译不过去</span></span><br><span class="line">fmt.Print(isOk)<span class="comment">//在终端中输出</span></span><br><span class="line">fmt.Printf(<span class="string">"name:%s"</span>,name)<span class="comment">//%s:占位符 使用name这个变量去替换占位符</span></span><br><span class="line">fmt.Println(age)<span class="comment">//打印完后会在后面加上一个换行符，同时类型推导</span></span><br><span class="line">    <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> = <span class="string">"hg"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">//类型推导</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"20"</span></span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">//简短变量声明，声明并初始化，只能在函数内部使用</span></span><br><span class="line">s3 := <span class="string">"hahah"</span></span><br><span class="line">fmt.Println(s3)</span><br><span class="line"><span class="comment">//s1 :=10 同一个作用域&#123;&#125; 中不能重复生命同样的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">"Q1mi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, _ := foo()</span><br><span class="line">_, y := foo()</span><br><span class="line">fmt.Println(<span class="string">"x="</span>, x)</span><br><span class="line">fmt.Println(<span class="string">"y="</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li><strong>函数外的每个语句都必须以关键字开始（var、const、func等）</strong></li><li><strong><code>:=</code>不能使用在函数外。</strong></li><li><strong><code>_</code>多用于占位，表示忽略值。</strong></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>同一个作用域（{}）不允许重复声明变量</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota+1)(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1 n2=iota   //iota=iota+1=1</span></span><br><span class="line">n3        <span class="comment">//2 n3=iota</span></span><br><span class="line">n4        <span class="comment">//3 n4=iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例-笔试题"><a href="#几个常见的iota示例-笔试题" class="headerlink" title="几个常见的iota示例: 笔试题"></a>几个常见的<code>iota</code>示例: 笔试题</h3><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">_</span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100    const中每新增一行常量声明将使iota计数一次(iota+1)</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//（二进制）10000000000=1024kb</span></span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//1024MB</span></span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//1024GB</span></span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2  新增一行才+1</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架的介绍和使用</title>
      <link href="/2019/12/18/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/18/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin框架介绍及使用"><a href="#Gin框架介绍及使用" class="headerlink" title="Gin框架介绍及使用"></a>Gin框架介绍及使用</h1><p><code>Gin</code>是一个用Go语言编写的web框架。它是一个类似于<code>martini</code>但拥有更好性能的API框架, 由于使用了<code>httprouter</code>，速度提高了近40倍。 如果你是性能和高效的追求者, 你会爱上<code>Gin</code>。</p><a id="more"></a><h2 id="Gin框架介绍"><a href="#Gin框架介绍" class="headerlink" title="Gin框架介绍"></a>Gin框架介绍</h2><p>Go世界里最流行的Web框架，<a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Github</a>上有<code>32K+</code>star。 基于<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>开发的Web框架。 <a href="https://gin-gonic.com/zh-cn/docs/" target="_blank" rel="noopener">中文文档</a>齐全，简单易用的轻量级框架。</p><ul><li>Gin是一个golang的为框架，封装比较优雅，API友好，源码注释比较明确，具有快速灵活容错方便特点</li><li>对于golang而言，web框架的以来要远比Python、java之类小，自身的net/http足够简单，性能也非常不错</li><li>借助框架开发，不仅可以省区很多常用的封装带来的时间，也有助于团队编码风格和形成规范</li></ul><h2 id="Gin框架安装与使用"><a href="#Gin框架安装与使用" class="headerlink" title="Gin框架安装与使用"></a>Gin框架安装与使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载并安装<code>Gin</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="第一个Gin示例："><a href="#第一个Gin示例：" class="headerlink" title="第一个Gin示例："></a>第一个Gin示例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.创建一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">    <span class="comment">//2.绑定路由规则，执行的函数，gin.Conext封装了request和response</span></span><br><span class="line"><span class="comment">// GET：请求方式；/hello：请求的路径</span></span><br><span class="line"><span class="comment">// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数</span></span><br><span class="line">r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// c.JSON：返回JSON格式的数据</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"Hello world!"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">        c.String(http.StatusOK,<span class="string">"hello world"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 启动HTTP服务，默认在0.0.0.0:8080启动服务</span></span><br><span class="line">    r.Run()<span class="comment">//8080</span></span><br><span class="line">    <span class="comment">//r.run(":8000")自己设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p><p>推荐阅读<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">阮一峰 理解RESTful架构</a></p><p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p><ul><li><code>GET</code>用来获取资源    查询</li><li><code>POST</code>用来新建资源   增加</li><li><code>PUT</code>用来更新资源     更新</li><li><code>DELETE</code>用来删除资源  删除</li></ul><p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p><p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p><table><thead><tr><th align="center">请求方法</th><th align="center">URL</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">/book</td><td align="center">查询书籍信息</td></tr><tr><td align="center">POST</td><td align="center">/create_book</td><td align="center">创建书籍记录</td></tr><tr><td align="center">POST</td><td align="center">/update_book</td><td align="center">更新书籍信息</td></tr><tr><td align="center">POST</td><td align="center">/delete_book</td><td align="center">删除书籍信息</td></tr></tbody></table><p>同样的需求我们按照RESTful API设计如下：</p><table><thead><tr><th align="center">请求方法</th><th align="center">URL</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">/book</td><td align="center">查询书籍信息</td></tr><tr><td align="center">POST</td><td align="center">/book</td><td align="center">创建书籍记录</td></tr><tr><td align="center">PUT</td><td align="center">/book</td><td align="center">更新书籍信息</td></tr><tr><td align="center">DELETE</td><td align="center">/book</td><td align="center">删除书籍信息</td></tr></tbody></table><p>Gin框架支持开发RESTful API的开发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">"/book"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"GET"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">"/book"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"POST"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.PUT(<span class="string">"/book"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"PUT"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.DELETE(<span class="string">"/book"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"DELETE"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发RESTful API的时候我们通常使用<a href="https://www.getpostman.com/" target="_blank" rel="noopener">Postman</a>来作为客户端的测试工具。</p><h2 id="Gin渲染"><a href="#Gin渲染" class="headerlink" title="Gin渲染"></a>Gin渲染</h2><h3 id="HTML渲染"><a href="#HTML渲染" class="headerlink" title="HTML渲染"></a>HTML渲染</h3><p>我们首先定义一个存放模板文件的<code>templates</code>文件夹，然后在其内部按照业务分别定义一个<code>posts</code>文件夹和一个<code>users</code>文件夹。 <code>posts/index.html</code>文件的内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define "posts/index.html"&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>posts/index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>users/index.html</code>文件的内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;define "users/index.html"&#125;&#125;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>users/index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;.title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line"><span class="comment">//r.LoadHTMLFiles("templates/posts/index.html", "templates/users/index.html")</span></span><br><span class="line">r.GET(<span class="string">"/posts/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">"posts/index.html"</span>, gin.H&#123;</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"posts/index"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"users/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">"users/index.html"</span>, gin.H&#123;</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"users/index"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义模板函数"><a href="#自定义模板函数" class="headerlink" title="自定义模板函数"></a>自定义模板函数</h3><p>定义一个不转义相应内容的<code>safe</code>模板函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.SetFuncMap(template.FuncMap&#123;</span><br><span class="line"><span class="string">"safe"</span>: <span class="function"><span class="keyword">func</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">template</span>.<span class="title">HTML</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> template.HTML(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">router.LoadHTMLFiles(<span class="string">"./index.tmpl"</span>)</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">"index.tmpl"</span>, <span class="string">"&lt;a href='https://liwenzhou.com'&gt;李文周的博客&lt;/a&gt;"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>index.tmpl</code>中使用定义好的<code>safe</code>模板函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>修改模板引擎的标识符<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; . | safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态文件处理"><a href="#静态文件处理" class="headerlink" title="静态文件处理"></a>静态文件处理</h3><p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用<code>gin.Static</code>方法即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.Static(<span class="string">"/static"</span>, <span class="string">"./static"</span>)</span><br><span class="line">r.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用模板继承"><a href="#使用模板继承" class="headerlink" title="使用模板继承"></a>使用模板继承</h3><p>Gin框架默认都是使用单模板，如果需要使用<code>block template</code>功能，可以通过<code>&quot;github.com/gin-contrib/multitemplate&quot;</code>库实现，具体示例如下：</p><p>首先，假设我们项目目录下的templates文件夹下有以下模板文件，其中<code>home.tmpl</code>和<code>index.tmpl</code>继承了<code>base.tmpl</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">templates</span><br><span class="line">├── includes</span><br><span class="line">│   ├── home.tmpl</span><br><span class="line">│   └── index.tmpl</span><br><span class="line">├── layouts</span><br><span class="line">│   └── base.tmpl</span><br><span class="line">└── scripts.tmpl</span><br></pre></td></tr></table></figure><p>然后我们定义一个<code>loadTemplates</code>函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadTemplates</span><span class="params">(templatesDir <span class="keyword">string</span>)</span> <span class="title">multitemplate</span>.<span class="title">Renderer</span></span> &#123;</span><br><span class="line">r := multitemplate.NewRenderer()</span><br><span class="line">layouts, err := filepath.Glob(templatesDir + <span class="string">"/layouts/*.tmpl"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">includes, err := filepath.Glob(templatesDir + <span class="string">"/includes/*.tmpl"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为layouts/和includes/目录生成 templates map</span></span><br><span class="line"><span class="keyword">for</span> _, include := <span class="keyword">range</span> includes &#123;</span><br><span class="line">layoutCopy := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(layouts))</span><br><span class="line"><span class="built_in">copy</span>(layoutCopy, layouts)</span><br><span class="line">files := <span class="built_in">append</span>(layoutCopy, include)</span><br><span class="line">r.AddFromFiles(filepath.Base(include), files...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<code>main</code>函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexFunc</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">"index.tmpl"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeFunc</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">"home.tmpl"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.HTMLRender = loadTemplates(<span class="string">"./templates"</span>)</span><br><span class="line">r.GET(<span class="string">"/index"</span>, indexFunc)</span><br><span class="line">r.GET(<span class="string">"/home"</span>, homeFunc)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充文件路径处理"><a href="#补充文件路径处理" class="headerlink" title="补充文件路径处理"></a>补充文件路径处理</h3><p>关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentPath</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ex, err := os.Executable(); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> filepath.Dir(ex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"./"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON渲染"><a href="#JSON渲染" class="headerlink" title="JSON渲染"></a>JSON渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">"/someJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">"message"</span>: <span class="string">"Hello world!"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">"/moreJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">Age     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">msg.Name = <span class="string">"小王子"</span></span><br><span class="line">msg.Message = <span class="string">"Hello world!"</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.JSON(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML渲染"><a href="#XML渲染" class="headerlink" title="XML渲染"></a>XML渲染</h3><p>注意需要使用具名的结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">r.GET(<span class="string">"/someXML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">c.XML(http.StatusOK, gin.H&#123;<span class="string">"message"</span>: <span class="string">"Hello world!"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">"/moreXML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 方法二：使用结构体</span></span><br><span class="line"><span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Message <span class="keyword">string</span></span><br><span class="line">Age     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> msg MessageRecord</span><br><span class="line">msg.Name = <span class="string">"小王子"</span></span><br><span class="line">msg.Message = <span class="string">"Hello world!"</span></span><br><span class="line">msg.Age = <span class="number">18</span></span><br><span class="line">c.XML(http.StatusOK, msg)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YMAL渲染"><a href="#YMAL渲染" class="headerlink" title="YMAL渲染"></a>YMAL渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/someYAML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.YAML(http.StatusOK, gin.H&#123;<span class="string">"message"</span>: <span class="string">"ok"</span>, <span class="string">"status"</span>: http.StatusOK&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="protobuf渲染"><a href="#protobuf渲染" class="headerlink" title="protobuf渲染"></a>protobuf渲染</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/someProtoBuf"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">reps := []<span class="keyword">int64</span>&#123;<span class="keyword">int64</span>(<span class="number">1</span>), <span class="keyword">int64</span>(<span class="number">2</span>)&#125;</span><br><span class="line">label := <span class="string">"test"</span></span><br><span class="line"><span class="comment">// protobuf 的具体定义写在 testdata/protoexample 文件中。</span></span><br><span class="line">data := &amp;protoexample.Test&#123;</span><br><span class="line">Label: &amp;label,</span><br><span class="line">Reps:  reps,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请注意，数据在响应中变为二进制数据</span></span><br><span class="line"><span class="comment">// 将输出被 protoexample.Test protobuf 序列化了的数据</span></span><br><span class="line">c.ProtoBuf(http.StatusOK, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><p>表单传输为post请求，http常见的传输格式为四种：</p><ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>application/xml</li><li>application/form-data</li></ul><p>表单参数可以通过PostForm（）方法获取，改方法默认解析的是x-www-form-urlencoded或form-data格式数据</p><h3 id="获取querystring参数"><a href="#获取querystring参数" class="headerlink" title="获取querystring参数"></a>获取querystring参数</h3><p><code>querystring</code>指的是URL中<code>?</code>后面携带的参数，例如：<code>/user/search?username=小王子&amp;address=沙河</code>。 获取请求的querystring参数的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">"/user/search"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.DefaultQuery(<span class="string">"username"</span>, <span class="string">"小王子"</span>)</span><br><span class="line"><span class="comment">//username := c.Query("username")</span></span><br><span class="line">address := c.Query(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取form参数"><a href="#获取form参数" class="headerlink" title="获取form参数"></a>获取form参数</h3><p>请求的数据通过form表单来提交，例如向<code>/user/search</code>发送一个POST请求，获取请求数据的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.POST(<span class="string">"/user/search"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line"><span class="comment">//username := c.DefaultPostForm("username", "小王子")</span></span><br><span class="line">username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line">address := c.PostForm(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取path参数"><a href="#获取path参数" class="headerlink" title="获取path参数"></a>获取path参数</h3><p>请求的参数通过URL路径传递，例如：<code>/user/search/小王子/沙河</code>。 获取请求URL路径中的参数的方式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">"/user/search/:username/:address"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">username := c.Param(<span class="string">"username"</span>)</span><br><span class="line">address := c.Param(<span class="string">"address"</span>)</span><br><span class="line"><span class="comment">//输出json结果给调用方</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:  <span class="string">"ok"</span>,</span><br><span class="line"><span class="string">"username"</span>: username,</span><br><span class="line"><span class="string">"address"</span>:  address,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的<code>Content-Type</code>识别请求数据类型并利用反射机制自动提取请求中<code>QueryString</code>、<code>form表单</code>、<code>JSON</code>、<code>XML</code>等参数到结构体中。 下面的示例代码演示了<code>.ShouldBind()</code>强大的功能，它能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User     <span class="keyword">string</span> <span class="string">`form:"user" json:"user" binding:"required"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`form:"password" json:"password" binding:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定JSON的示例 (&#123;"user": "q1mi", "password": "123456"&#125;)</span></span><br><span class="line">router.POST(<span class="string">"/loginJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"login info:%#v\n"</span>, login)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">router.POST(<span class="string">"/loginForm"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">router.GET(<span class="string">"/loginForm"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"user"</span>:     login.User,</span><br><span class="line"><span class="string">"password"</span>: login.Password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">"error"</span>: err.Error()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">router.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShouldBind</code>会按照下面的顺序解析请求中的数据完成绑定：</p><ol><li>如果是 <code>GET</code> 请求，只使用 <code>Form</code> 绑定引擎（<code>query</code>）。</li><li>如果是 <code>POST</code> 请求，首先检查 <code>content-type</code> 是否为 <code>JSON</code> 或 <code>XML</code>，然后再使用 <code>Form</code>（<code>form-data</code>）。</li></ol><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h3><p>文件上传前端页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端gin框架部分代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 单个文件</span></span><br><span class="line">file, err := c.FormFile(<span class="string">"f1"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: err.Error(),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">"C:/tmp/%s"</span>, file.Filename)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: fmt.Sprintf(<span class="string">"'%s' uploaded!"</span>, file.Filename),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">// 处理multipart forms提交文件时默认的内存限制是32 MiB</span></span><br><span class="line"><span class="comment">// 可以通过下面的方式修改</span></span><br><span class="line"><span class="comment">// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB</span></span><br><span class="line">router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// Multipart form</span></span><br><span class="line">form, _ := c.MultipartForm()</span><br><span class="line">files := form.File[<span class="string">"file"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">log.Println(file.Filename)</span><br><span class="line">dst := fmt.Sprintf(<span class="string">"C:/tmp/%s_%d"</span>, file.Filename, index)</span><br><span class="line"><span class="comment">// 上传文件到指定的目录</span></span><br><span class="line">c.SaveUploadedFile(file, dst)</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: fmt.Sprintf(<span class="string">"%d files uploaded!"</span>, <span class="built_in">len</span>(files)),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, <span class="string">"http://www.sogo.com/"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>路由重定向，使用<code>HandleContext</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 指定重定向的URL</span></span><br><span class="line">    c.Request.URL.Path = <span class="string">"/test2"</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">"/test2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h2><h3 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>此外，还有一个可以匹配所有请求方法的<code>Any</code>方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回<code>views/404.html</code>页面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusNotFound, <span class="string">"views/404.html"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对<code>{}</code>包裹同组的路由，这只是为了看着清晰，你用不用<code>{}</code>包裹功能上没什么区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">userGroup := r.Group(<span class="string">"/user"</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">userGroup.POST(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">"/cart"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">"/checkout"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由组也是支持嵌套的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>)</span><br><span class="line">&#123;</span><br><span class="line">shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.GET(<span class="string">"/cart"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">shopGroup.POST(<span class="string">"/checkout"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"><span class="comment">// 嵌套路由组</span></span><br><span class="line">xx := shopGroup.Group(<span class="string">"xx"</span>)</span><br><span class="line">xx.GET(<span class="string">"/oo"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h3 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h3><p>Gin框架中的路由使用的是<a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h2 id="Gin中间件"><a href="#Gin中间件" class="headerlink" title="Gin中间件"></a>Gin中间件</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><h3 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h3><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计耗时请求耗时的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatCost</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">c.Set(<span class="string">"name"</span>, <span class="string">"小王子"</span>) <span class="comment">// 可以通过c.Set在请求上下文中设置值，后续的处理函数能够取到该值</span></span><br><span class="line"><span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 不调用该请求的剩余处理程序</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line"><span class="comment">// 计算耗时</span></span><br><span class="line">cost := time.Since(start)</span><br><span class="line">log.Println(cost)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><h4 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.Use(StatCost())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">"name"</span>).(<span class="keyword">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"Hello world!"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">"/test2"</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">"name"</span>).(<span class="keyword">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"Hello world!"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。</p><p>写法1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">"/shop"</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">"/index"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h3><h4 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h4><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h4 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h4><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p><h2 id="运行多个服务"><a href="#运行多个服务" class="headerlink" title="运行多个服务"></a>运行多个服务</h2><p>我们可以在多个端口启动服务，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">g errgroup.Group</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router01</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">e := gin.New()</span><br><span class="line">e.Use(gin.Recovery())</span><br><span class="line">e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(</span><br><span class="line">http.StatusOK,</span><br><span class="line">gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>:  http.StatusOK,</span><br><span class="line"><span class="string">"error"</span>: <span class="string">"Welcome server 01"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router02</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">e := gin.New()</span><br><span class="line">e.Use(gin.Recovery())</span><br><span class="line">e.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(</span><br><span class="line">http.StatusOK,</span><br><span class="line">gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>:  http.StatusOK,</span><br><span class="line"><span class="string">"error"</span>: <span class="string">"Welcome server 02"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server01 := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":8080"</span>,</span><br><span class="line">Handler:      router01(),</span><br><span class="line">ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server02 := &amp;http.Server&#123;</span><br><span class="line">Addr:         <span class="string">":8081"</span>,</span><br><span class="line">Handler:      router02(),</span><br><span class="line">ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> server01.ListenAndServe()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> server02.ListenAndServe()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步或异步"><a href="#同步或异步" class="headerlink" title="同步或异步"></a>同步或异步</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">"/long_async"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//需要搞一个副本</span></span><br><span class="line">copyContext := c.Copy()</span><br><span class="line"><span class="comment">//异步处理</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">log.Println(<span class="string">"异步执行："</span>+copyContext.Request.URL.Path)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;)</span><br><span class="line">router.GET(<span class="string">"/long_async"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">log.Println(<span class="string">"同步执行："</span>+c.Request.URL.Path)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>测试结果</p><p>先<a href="http://localhost:8000/long_async" target="_blank" rel="noopener">http://localhost:8000/long_async</a></p><p>后<a href="http://localhost:8000/long_sync" target="_blank" rel="noopener">http://localhost:8000/long_sync</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GIN] <span class="number">2020</span>/<span class="number">03</span>/<span class="number">28</span> - <span class="number">22</span>:<span class="number">04</span>:<span class="number">41</span> |?[<span class="number">97</span>;<span class="number">42</span>m <span class="number">200</span> ?[<span class="number">0</span>m| <span class="number">0</span>s |<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> |?[<span class="number">97</span>;<span class="number">44</span>m GET     ?[<span class="number">0</span>m /long_async</span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">44</span> 异步执行：/long_async</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>/<span class="number">03</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">59</span> 同步执行：/long_sync</span><br><span class="line">[GIN] <span class="number">2020</span>/<span class="number">03</span>/<span class="number">28</span> - <span class="number">22</span>:<span class="number">04</span>:<span class="number">59</span> |?[<span class="number">97</span>;<span class="number">42</span>m <span class="number">200</span> ?[<span class="number">0</span>m|    <span class="number">3.0011444</span>s |::<span class="number">1</span> |?[<span class="number">97</span>;<span class="number">44</span>m GET ?[<span class="number">0</span>m /long_sync</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01Gin数据解析和绑定</title>
      <link href="/2019/12/18/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/01gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/"/>
      <url>/2019/12/18/Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/01gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="一、json数据解析和绑定"><a href="#一、json数据解析和绑定" class="headerlink" title="一、json数据解析和绑定"></a>一、json数据解析和绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义接受数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Json绑定</span></span><br><span class="line">router.POST(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//生命接受变量</span></span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">//将request的body中的数据，自动按照json格式解析到结构体</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;login);err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//返回错误信息，gin.H封装了生成json的工具</span></span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"error"</span>:err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断用户名和密码是否正确</span></span><br><span class="line"><span class="keyword">if</span> login.User!= <span class="string">"root"</span> || login.Password!= <span class="string">"password"</span>&#123;</span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"status"</span>:<span class="string">"304"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"status"</span>:<span class="string">"200"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"><span class="comment">//http.ListenAndServe("8000",router)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><p><img src="./image/1585401321(1).png" alt="测试结果"></p><h2 id="二、表单数据解析和绑定"><a href="#二、表单数据解析和绑定" class="headerlink" title="二、表单数据解析和绑定"></a>二、表单数据解析和绑定</h2><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义接受数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//Json绑定</span></span><br><span class="line">router.POST(<span class="string">"/loginForm"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//声明接受变量</span></span><br><span class="line"><span class="keyword">var</span> form Login</span><br><span class="line"><span class="comment">//将request的body中的数据，自动按照json格式解析到结构体</span></span><br><span class="line"><span class="keyword">if</span> err := c.Bind(&amp;form);err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//返回错误信息，gin.H封装了生成json的工具</span></span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"error"</span>:err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断用户名和密码是否正确</span></span><br><span class="line"><span class="keyword">if</span> form.User!= <span class="string">"root"</span> || form.Password!= <span class="string">"password"</span>&#123;</span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"status"</span>:<span class="string">"304"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"status"</span>:<span class="string">"200"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"><span class="comment">//http.ListenAndServe("8000",router)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8000/loginForm"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"applicaton/x-www-form-urlencoded"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><p><img src="./image/1585402117(1).png" alt="test"></p><h2 id="三、URI数据解析和绑定"><a href="#三、URI数据解析和绑定" class="headerlink" title="三、URI数据解析和绑定"></a>三、URI数据解析和绑定</h2><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义接受数据的结构体</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">User <span class="keyword">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建路由</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"><span class="comment">//Json绑定</span></span><br><span class="line">router.GET(<span class="string">"/:user/:password"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//生命接受变量</span></span><br><span class="line"><span class="keyword">var</span> login Login</span><br><span class="line"><span class="comment">//将request的body中的数据，自动按照json格式解析到结构体</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindUri(&amp;login);err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//返回错误信息，gin.H封装了生成json的工具</span></span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"error"</span>:err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断用户名和密码是否正确</span></span><br><span class="line"><span class="keyword">if</span> login.User!= <span class="string">"root"</span> || login.Password!= <span class="string">"password"</span>&#123;</span><br><span class="line">c.JSON(http.StatusBadRequest,gin.H&#123;<span class="string">"status"</span>:<span class="string">"304"</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK,gin.H&#123;<span class="string">"status"</span>:<span class="string">"200"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">router.Run(<span class="string">":8000"</span>)</span><br><span class="line"><span class="comment">//http.ListenAndServe("8000",router)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果cmd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl http://127.0.0.1:8000/root/password</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gin框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>共识算法概论</title>
      <link href="/2019/04/07/Consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/07/Consensus/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="共识算法概论"><a href="#共识算法概论" class="headerlink" title="共识算法概论"></a>共识算法概论</h3><ol><li><p>什么是共识算法</p><ul><li>分布式系统</li><li>一致性问题</li><li>FLP定理和CAP定理</li><li>拜占庭将军问题</li></ul></li><li><p>共识算法的目的和价值</p></li><li><p>常用共识算法</p><a id="more"></a></li></ol><p><img src="./images/1.png" alt="1"></p><p><img src="./images/2.png" alt="1"></p><p><img src="./images/3.png" alt="1"></p><p><img src="./images/4.png" alt="1"></p><p><img src="./images/5.png" alt="1"></p><p><img src="./images/6.png" alt="1"></p><p><img src="./images/7.png" alt="1"></p><p><img src="./images/8.png" alt="1"></p><p><img src="./images/9.png" alt="1"></p><p><img src="./images/10.png" alt="1"></p><p><img src="./images/11.png" alt="1"></p><p><img src="./images/12.png" alt="1"></p><p><img src="./images/13.png" alt="1"></p><p><img src="./images/14.png" alt="1"></p><p><img src="./images/14(1).png" alt="1"></p><p><img src="./images/15.png" alt="1"></p><p><img src="./images/16(1).png" alt="1"></p><p><img src="./images/16.png" alt="1"></p><p><img src="./images/17.png" alt="1"></p><p><img src="./images/18.png" alt="1"></p><p><img src="./images/19.png" alt="1"></p><p><img src="./images/20.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章非对称加密算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC7%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC7%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>非对称加密也叫公钥密码。<br>1976年Diffie和Hellman首次提出了一种全新的加密思想，公钥密码体制思想。在当时几乎所有的密码体制都是对称密码体制，原理都是基于替换和置换这些较简单方法。公钥密码体制完全与之不同，它是非对称的，有两个不同的密钥，分别是公钥和私钥，加密的原理也不是之前的简单置换或替换，而是一些复杂的数学函数。这些数学函数都是基于数学难题。其所依据的难题一般分为三类：大整数分解问题类、离散对数问题类、椭圆曲线类。有时也把椭圆曲线类归为离散对数类。公钥密码体制是一次革命性的变革，突破了原有的密码体制模式，它解决了传统密码体制的两个大难题：密钥分配和数字签名。</p><a id="more"></a><h2 id="1-非对称加密的概述"><a href="#1-非对称加密的概述" class="headerlink" title="1 非对称加密的概述"></a>1 非对称加密的概述</h2><p>传统密码体制用的都是一个密钥，发送方传输密钥给接收方成本很高，而且风险很大。接收方收到的密文如果在传输过程中被修改，接收方无法判断密文的真伪性。公钥体制完美地解决了上述问题。它有一对密钥，一个是公钥，完全公开，任何人都可以收到该密钥；另一个是私钥，自己保存，不需要告诉任何人。通过公开的公钥是无法计算出私钥的，所以私钥是安全的。发送方A用公钥对明文进行加密，接收方B用对应的私钥进行解密。为保证传输密文的完整性和消息来源的准确性，需要对密文进行数字签名。A对密文用自己的私钥进行再次加密，此过程叫数字签名；B接收到密文用该私钥对应的公钥进行解密，此过程叫验签。<br>所以公钥密码体制可以分为两个模型：加密解密模型和签名验签模型。两个模型可以独立使用，也可以一起混用。具体按照自己的应用场景使用，一般情况下发送的密文都是需要进行数字签名的，发送的内容包括密文和签名两部分。接受者先进行验签，验签通过后，再进行解密。<br>非对称加密的方式有很多，以下讲解RSA，DSA，ECDSA这三种加密方式。</p><h2 id="2-公钥密码体制的要求"><a href="#2-公钥密码体制的要求" class="headerlink" title="2 公钥密码体制的要求"></a>2 公钥密码体制的要求</h2><p>公钥密码体制要想实现必须满足以下要求：<br>1.产生一对密钥对，即公私钥对，在计算上是容易的；<br>2.通过公钥对明文进行加密，在计算上是容易的；<br>3.通过私钥对密文进行解密，在计算上是容易的；<br>4.已知公钥，无法计算出私钥；<br>5.已知公钥和密文，无法计算出明文；<br>6.加密和解密的顺序可以交换。</p><p>目前满足以上要求，建立公钥密码体制基于的困难问题有较多，我只分析以下两种常用的：<br>1.大整数分解问题<br>若已知两个大素数p和q，求n=pq是很容易的，但是已知n，求p和q是几乎不可能的，这就是大整数分解问题。<br>2.离散对数问题<br>先了解两个概念，阶和原根。<br>设m &gt; 1 且 (a, m) = 1, 则使得a^t ≡ 1 mod m成立的最小的正整数t称为a对模m的阶, 记为δm(a)。<br>原根，是一个数学符号。设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。里面提到的φ(m)是m质因数的个数。<br>给定一个公式a^t mod b ≡ c，其中a是b的原根，b是一个超大的素数，c是小于b大于0的正整数。问题是已知a，t，b求c很容易，但是已知a，b，c求t非常困难。这就是离散对数问题。<br>举个例子（b取个小值）：根据给定的t求 3^t mod 17很容易。t=1时，得3；t=2时，得9；t=3时，得10，等等最终的结果都是在小于17大于0的正整数。但是现在3^t mod 17≡12，求t。求解过程非常困难，而且满足条件的t不计其数。这里用的是17，如果换成很大的数，那几乎没有可能求解出来真正的t。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章对称密码RC4算法（序列密码）</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC3%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81RC4%E7%AE%97%E6%B3%95%EF%BC%88%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%EF%BC%89/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC3%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81RC4%E7%AE%97%E6%B3%95%EF%BC%88%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="对称密码RC4算法（序列密码）"><a href="#对称密码RC4算法（序列密码）" class="headerlink" title="对称密码RC4算法（序列密码）"></a>对称密码RC4算法（序列密码）</h2><p>对称加密分为<strong>序列密码</strong>和<strong>分组加密</strong>。<br><strong>序列密码，也叫流加密(stream cyphers)</strong>，<strong>依次加密明文中的每一个字节。</strong>加密是指利用用户的密钥通过某种复杂的运算（密码算法）产生大量的伪随机流，对明文流的加密。解密是指用同样的密钥和密码算法及与加密相同的伪随机流，用以还原明文流。<br><strong>分组密码，也叫块加密(block cyphers)</strong>，<strong>一次加密明文中的一个块</strong>。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。</p><a id="more"></a><h2 id="1-RC4实现过程"><a href="#1-RC4实现过程" class="headerlink" title="1. RC4实现过程"></a>1. RC4实现过程</h2><p>RC4算法的实现非常简单，使用从1到256个字节（8到2048位）可变长度密钥初始化一个256个字节的状态向量S，S的元素记为S[0]，S[1]，S[2]，…，S[255]，S先初始化为S[i]=i。以后自始至终都包含从0到255的所有8比特数，只是对它进行置换操作。每次生成的密钥字节ki由S中256个元素按一定方法选出一个元素而生成。每生成一个密钥字节，S向量中元素会进行一次置换操作。则RC4算法分为两部分：初始化S和密钥流的生成，其中密钥流的生成过程中每次产生的密钥字与对应明文的元素进行异或运算得到密文字。</p><h3 id="1-1-初始化S"><a href="#1-1-初始化S" class="headerlink" title="1.1 初始化S"></a>1.1 初始化S</h3><p>生成S的步骤如下：<br>1）声明一个长度为256的字节数组，并给S中的元素从0到255以升序的方式填充，即S[0]=0，S[1]=1，S[2]=2，…，S[255]=255。<br>2）j:=0<br>3）对于0&lt;=i&lt;=255，循环下边两个方法：<br>j = (j + S[i] + int(K[i%keylen])) % 256<br>S[i], S[j]=S[j], S[i]</p><h3 id="1-2-密钥流的生成"><a href="#1-2-密钥流的生成" class="headerlink" title="1.2 密钥流的生成"></a>1.2 密钥流的生成</h3><p>步骤如下：<br>1）i=0；j=0<br>2）i = (i + 1) % 256<br>3）j = (j + S[i]) % 256<br>4）S[i], S[j]=S[j], S[i]<br>5）输出密钥字key = S[(S[i]+S[j])%256]</p><h3 id="1-3-RC4的安全性"><a href="#1-3-RC4的安全性" class="headerlink" title="1.3 RC4的安全性"></a>1.3 RC4的安全性</h3><p>由于RC4算法加密采用的是异或方式，所以，一旦子密钥序列出现了重复，密文就有可能被破解，但是目前还没有发现密钥长度达到128位的RC4有重复的可能性，所以，RC4也是目前最安全的加密算法之一。</p><h3 id="1-4-RC4加密过程"><a href="#1-4-RC4加密过程" class="headerlink" title="1.4 RC4加密过程"></a>1.4 RC4加密过程</h3><p>简单介绍下RC4的加密过程：<br>1）利用自己的密钥，产生密钥流发生器<br>2）密钥流发生器根据明文的长度产生伪随机序列<br>3）伪随机序列每个位元素与明文对应的位元素进行异或运算，生成密文<br>示意图：<br><img src="http://img.kongyixueyuan.com/RC4%E5%8A%A0%E5%AF%86.jpg" alt="img"></p><h2 id="2-golang实现RC4加密"><a href="#2-golang实现RC4加密" class="headerlink" title="2. golang实现RC4加密"></a>2. golang实现RC4加密</h2><h3 id="2-1-golang实现RC4加密："><a href="#2-1-golang实现RC4加密：" class="headerlink" title="2.1 golang实现RC4加密："></a>2.1 golang实现RC4加密：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"helloworld"</span>);</span><br><span class="line">    output:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(data))</span><br><span class="line">    fmt.Printf(<span class="string">"明文:%s\n"</span>, data);</span><br><span class="line"></span><br><span class="line">    K := []<span class="keyword">byte</span>(<span class="string">"qwuoaknfabbalafbj"</span>);</span><br><span class="line">    keylen := <span class="built_in">len</span>(K);</span><br><span class="line">    SetKey(K, keylen);</span><br><span class="line"></span><br><span class="line">    output=Transform(output, data, <span class="built_in">len</span>(data));</span><br><span class="line">    fmt.Printf(<span class="string">"密文: %x\n"</span>, output);</span><br><span class="line"></span><br><span class="line">    SetKey(K, keylen);</span><br><span class="line">    output1:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(data))</span><br><span class="line">    output1=Transform(output1, output, <span class="built_in">len</span>(data));</span><br><span class="line">    fmt.Printf(<span class="string">"解密后明文:%s"</span>, output1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> S = [<span class="number">256</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">//初始化S盒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetKey</span><span class="params">(K []<span class="keyword">byte</span>, keylen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">256</span>; i++ &#123;</span><br><span class="line">        S[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">256</span>; i++ &#123;</span><br><span class="line">        j = (j + S[i] + <span class="keyword">int</span>(K[i%keylen])) % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        S[i], S[j]=S[j], S[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成密钥流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transform</span><span class="params">(output []<span class="keyword">byte</span>, data []<span class="keyword">byte</span>, lenth <span class="keyword">int</span>)</span>[]<span class="title">byte</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span>;</span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">    output=<span class="built_in">make</span>([]<span class="keyword">byte</span>,lenth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; lenth; k++ &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span>;</span><br><span class="line">        S[i], S[j]=S[j], S[i];</span><br><span class="line">        key := S[(S[i]+S[j])%<span class="number">256</span>];</span><br><span class="line">        <span class="comment">//按位异或操作</span></span><br><span class="line"></span><br><span class="line">        output[k] = <span class="keyword">uint8</span>(key)^data[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line">明文:helloworld</span><br><span class="line">密文: bed0b7fdabdb0be88956</span><br><span class="line">解密后明文:helloworld</span><br></pre></td></tr></table></figure><h3 id="2-2-利用goland封装好的方法实现RC4加密，但是没有解密"><a href="#2-2-利用goland封装好的方法实现RC4加密，但是没有解密" class="headerlink" title="2.2 利用goland封装好的方法实现RC4加密，但是没有解密"></a>2.2 利用goland封装好的方法实现RC4加密，但是没有解密</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/rc4"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> key []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(<span class="string">"fd6cde7c2f4913f22297c948dd530c84"</span>) <span class="comment">//初始化用于加密的KEY</span></span><br><span class="line">rc4obj, _ := rc4.NewCipher(key) <span class="comment">//返回 Cipher</span></span><br><span class="line"></span><br><span class="line">str := []<span class="keyword">byte</span>(<span class="string">"helloworld"</span>)  <span class="comment">//需要加密的字符串</span></span><br><span class="line">plaintext := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(str)) <span class="comment">//</span></span><br><span class="line">rc4obj.XORKeyStream(plaintext, str)</span><br><span class="line"><span class="comment">//XORKeyStream方法将src的数据与秘钥生成的伪随机位流取XOR并写入dst。</span></span><br><span class="line"><span class="comment">//plaintext就是你加密的返回过来的结果了，注意：plaintext为base-16 编码的字符串，每个字节使用2个字符表示 必须格式化成字符串</span></span><br><span class="line"></span><br><span class="line">stringinf := fmt.Sprintf(<span class="string">"%x\n"</span>, plaintext) <span class="comment">//转换字符串</span></span><br><span class="line">fmt.Println(stringinf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章椭圆曲线密码学</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC10%E7%AB%A0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC10%E7%AB%A0%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="椭圆曲线密码学"><a href="#椭圆曲线密码学" class="headerlink" title="椭圆曲线密码学"></a>椭圆曲线密码学</h3><h2 id="1-椭圆曲线密码学简介"><a href="#1-椭圆曲线密码学简介" class="headerlink" title="1. 椭圆曲线密码学简介"></a>1. 椭圆曲线密码学简介</h2><p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p><a id="more"></a>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上.<br>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。<br>椭圆曲线依赖的数学难题是:<br>k为正整数，G是椭圆曲线上的点（称为基点）, k*G=Q , 已知G和Q，很难计算出k</p><h2 id="2-椭圆曲线"><a href="#2-椭圆曲线" class="headerlink" title="2. 椭圆曲线"></a>2. 椭圆曲线</h2><p>一般，椭圆曲线可以用如下二元三阶方程表示：<br>　　y² = x³ + ax + b，其中a、b为系数。<br>参数a=0;b=7,得到y² = x³ +7，这个方程式产生的曲线就是secp256k1曲线。<br>曲线形状：<img src="http://img.kongyixueyuan.com/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%9B%BE.jpg" alt="img"></p><h2 id="3-椭圆曲线在密码学的应用"><a href="#3-椭圆曲线在密码学的应用" class="headerlink" title="3. 椭圆曲线在密码学的应用"></a>3. 椭圆曲线在密码学的应用</h2><p>椭圆曲线是连续的，并不适合用于加密；所以，我们必须把椭圆曲线变成离散的点，我们要把椭圆曲线定义在有限域上。<br>我们给出一个有限域Fp，Fp中有p（p为质数）个元素0,1,2,…, p-2,p-1<br>Fp的加法是a+b≡c(mod p)<br>Fp的乘法是a×b≡c(mod p)<br>Fp的除法是a÷b≡c(mod p)，即 a×b^(-1)≡c (mod p)，b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)</p><p>考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞ ），k为小于n的整数。则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。这就是椭圆曲线加密算法的数学依据。 点G称为基点（base point）k（k 小于n）为私有密钥（privte key），K为公开密钥（public key)</p><h2 id="4-椭圆曲线运算"><a href="#4-椭圆曲线运算" class="headerlink" title="4. 椭圆曲线运算"></a>4. 椭圆曲线运算</h2><p>• 加法<br>• 过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：<br><img src="http://img.kongyixueyuan.com/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97.jpg" alt="img">• 二倍运算<br>• 上述方法无法解释A + A，即两点重合的情况。因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。<br><img src="http://img.kongyixueyuan.com/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF2%E5%80%8D%E8%BF%90%E7%AE%97.jpg" alt="img">• 正负取反<br>• 将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算。如下图所示：<br><img src="http://img.kongyixueyuan.com/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E6%AD%A3%E8%B4%9F%E8%BF%90%E7%AE%97.jpg" alt="img">• 无穷远点<br>• 如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点。<br>综上，定义了A+B、2A运算，因此给定椭圆曲线的某一点G，可以求出2G、3G（即G + 2G）、4G……。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。</p><h2 id="5-有限域上的椭圆曲线运算"><a href="#5-有限域上的椭圆曲线运算" class="headerlink" title="5. 有限域上的椭圆曲线运算"></a>5. 有限域上的椭圆曲线运算</h2><p>• 椭圆曲线要形成一条光滑的曲线，要求x,y取值均为实数，即实数域上的椭圆曲线。但椭圆曲线加密算法，并非使用实数域，而是使用有限域。按数论定义，有限域GF(p)指给定某个质数p，由0、1、2……p-1共p个元素组成的整数集合中定义的加减乘除运算。<br>• 假设椭圆曲线为y² = x³ + x + 1，其在有限域GF(23)上时，写作：y² ≡ x³ + x + 1 (mod 23)<br>• 此时，椭圆曲线不再是一条光滑曲线，而是一些不连续的点。以点(1,7)为例，7² ≡ 1³ + 1 + 1 ≡ 3 (mod 23)。如此还有如下点：<br>• (0,1) (0,22)(1,7) (1,16)(3,10) (3,13)(4,0)(5,4) (5,19)(6,4) (6,19)(7,11) (7,12)(9,7) (9,16)(11,3) (11,20)等等。<br>• 另外，如果P(x,y)为椭圆曲线上的点，则-P即(x,-y)也为椭圆曲线上的点。如点P(0,1)，-P=(0,-1)=(0,22)也为椭圆曲线上的点。</p><h2 id="6-椭圆曲线加密算法原理"><a href="#6-椭圆曲线加密算法原理" class="headerlink" title="6. 椭圆曲线加密算法原理"></a>6. 椭圆曲线加密算法原理</h2><p>设私钥、公钥分别为k、K，即K = kG，其中G为G点。</p><p>公钥加密：</p><p>选择随机数r，将消息M生成密文C，该密文是一个点对，即：</p><p>C = {rG, M+rK}，其中K为公钥</p><p>私钥解密：</p><p>M + rK - k(rG) = M + r(kG) - k(rG) = M</p><p>其中k、K分别为私钥、公钥。</p><h2 id="7-椭圆曲线签名算法原理"><a href="#7-椭圆曲线签名算法原理" class="headerlink" title="7. 椭圆曲线签名算法原理"></a>7. 椭圆曲线签名算法原理</h2><p>• 椭圆曲线签名算法，即ECDSA。设私钥、公钥分别为k、K，即K = kG，其中G为G点。<br>• 私钥签名：<br>• 1、选择随机数R，计算点RG(x, y)。<br>• 2、根据随机数R、消息M的哈希h、私钥k，计算出两个*big.int类型的数r，s。<br>• 3、将r，s转换成字节切片，并拼接一起，形成签名<br>• 4、将消息M、和签名发给接收方。<br>公钥验证签名：<br>1、接收方收到消息M、以及签名。<br>2、将签名提取出r，s<br>3、根据消息求哈希h。<br>4、通过r，s产生的一个点，如果这个点在椭圆曲线上，即验签成功。</p><h2 id="8-椭圆曲线Ecc加密解密代码实现"><a href="#8-椭圆曲线Ecc加密解密代码实现" class="headerlink" title="8. 椭圆曲线Ecc加密解密代码实现"></a>8. 椭圆曲线Ecc加密解密代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">•    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"/crypto/ecies"</span></span><br><span class="line">   <span class="string">"crypto/elliptic"</span></span><br><span class="line">   <span class="string">"crypto/rand"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"encoding/hex"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   msg:=<span class="string">"hello world"</span></span><br><span class="line"><span class="comment">//调用以太坊的曲线加密包下的方法产生私钥 prv,_:=ecies.GenerateKey(rand.Reader,elliptic.P256(),nil )</span></span><br><span class="line"><span class="comment">//私钥产生公钥</span></span><br><span class="line">   pub:=prv.PublicKey</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用加密方法对明文进行加密</span></span><br><span class="line">ct,_:=ecies.Encrypt(rand.Reader,&amp;pub,[]<span class="keyword">byte</span>(msg),<span class="literal">nil</span>,<span class="literal">nil</span>)</span><br><span class="line">   scrt:=hex.EncodeToString(ct)</span><br><span class="line">   fmt.Println(scrt)</span><br><span class="line"><span class="comment">//对密文进行解密</span></span><br><span class="line">   ms,_:=prv.Decrypt(ct,<span class="literal">nil</span>,<span class="literal">nil</span>)</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(ms))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-代码实现-ECDSA-椭圆曲线的签名和验签"><a href="#9-代码实现-ECDSA-椭圆曲线的签名和验签" class="headerlink" title="9. 代码实现(ECDSA)椭圆曲线的签名和验签"></a>9. 代码实现(ECDSA)椭圆曲线的签名和验签</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"crypto/ecdsa"</span></span><br><span class="line">   <span class="string">"crypto/elliptic"</span></span><br><span class="line">   <span class="string">"crypto/rand"</span></span><br><span class="line">   <span class="string">"crypto/sha256"</span></span><br><span class="line">   <span class="string">"math/big"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//明文</span></span><br><span class="line">   message := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取私钥</span></span><br><span class="line">   key, err := NewSigningKey()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用私钥对明文进行签名</span></span><br><span class="line">   signature, err := Sign(message, key)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"签名后：%x\n"</span>, signature)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用公钥对签名进行验证，确认签名是否是对当前明文的有效</span></span><br><span class="line">   <span class="keyword">if</span> !Verify(message, signature, &amp;key.PublicKey) &#123;</span><br><span class="line">      fmt.Println(<span class="string">"验证失败！"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fmt.Println(<span class="string">"验证成功！"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSigningKey</span><span class="params">()</span> <span class="params">(*ecdsa.PrivateKey, error)</span></span> &#123;</span><br><span class="line">   key, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</span><br><span class="line">   <span class="keyword">return</span> key, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用私钥对明文进行签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(data []<span class="keyword">byte</span>, privkey *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 对明文进行sha256散列，生成一个长度为32的字节数组</span></span><br><span class="line">   digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通过椭圆曲线方法对散列后的明文进行签名，返回两个big.int类型的大数</span></span><br><span class="line">   r, s, err := ecdsa.Sign(rand.Reader, privkey, digest[:])</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将大数转换成字节数组，并拼接起来，形成签名</span></span><br><span class="line">   signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line">   <span class="keyword">return</span> signature, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过公钥验证签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verify</span><span class="params">(data, signature []<span class="keyword">byte</span>, pubkey *ecdsa.PublicKey)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="comment">// 将明文转换成字节数组</span></span><br><span class="line">   digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明两个大数r，s</span></span><br><span class="line">   r := big.Int&#123;&#125;</span><br><span class="line">   s := big.Int&#123;&#125;</span><br><span class="line">   <span class="comment">//将签名平均分割成两部分切片，并将切片转换成*big.int类型</span></span><br><span class="line">   sigLen := <span class="built_in">len</span>(signature)</span><br><span class="line">   r.SetBytes(signature[:(sigLen / <span class="number">2</span>)])</span><br><span class="line">   s.SetBytes(signature[(sigLen / <span class="number">2</span>):])</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过公钥对得到的r，s进行验证</span></span><br><span class="line">   <span class="keyword">return</span> ecdsa.Verify(pubkey, digest[:], &amp;r, &amp;s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章哈希（hash）算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC12%E7%AB%A0%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC12%E7%AB%A0%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="哈希（hash）算法"><a href="#哈希（hash）算法" class="headerlink" title="哈希（hash）算法"></a>哈希（hash）算法</h3><p>哈希函数是密码学中的一个重要分支，该函数是一类数学函数，它可以在有限的合理时间内，将任意长度的消息变换成固定长度的二进制串，且不可逆，这个输出值就是哈希值，也叫散列值或消息摘要。以hash函数为基础的hash算法，在数字签名，实现数据完整性，merkle树数据存储和检索等方面有着广泛的应用。<br>在比特币系统中使用了两个密码学hash函数，一个是SHA256,另一个是ripemd160。ripemd160主要用于生成比特币地址，SHA256是比特币链上几乎所有加密算法的hash函数。</p><h2 id="1-技术原理"><a href="#1-技术原理" class="headerlink" title="1. 技术原理"></a>1. 技术原理</h2><p>hash函数也叫散列函数，杂凑函数。它是一种单向密码机制，也就是只能加密，而不能解密。数学表达式可以为：h=H(m)，其中H是哈希函数，m是要加密的信息，h是输出的固定长度的哈希值。运算过程是设定一个初始向量，对消息补长到算法要求长度，将补长后的消息拆分成N份数据块，N份数据块与初始向量通过hash算法进行迭代循环运算，最终得到固定长度的hash值。<br>hash函数具有以下特点：</p><ol><li>压缩性：对任意长度的信息加密成固定长度的hash值；</li><li>单向性：hash函数的数学原理没有逆运算，所以不能将hash值转换成加密前的信息；</li><li>抗碰撞性：hash函数的运算过程相当复杂，包含多种数学运算和大量变量循环运算，要满足两个不同的消息产生相同的hash值几乎不可能发生；</li><li>高灵敏性：任何微小的输入都有可能对输出产生巨大的影响。<br>典型的hash函数有两类：消息摘要算法（MD5）和安全散列算法（SHA）。</li></ol><h2 id="2-hash碰撞"><a href="#2-hash碰撞" class="headerlink" title="2. hash碰撞"></a>2. hash碰撞</h2><p>理想的hash函数对于不同的输入得到两个不同的hash值。在实际中，如果存在两个不同的信息m，m’使H(m)=H(m’)，那么就称m和m’是该函数的一个碰撞。简言之，hash碰撞是指两个不同的消息在同一个哈希函数作用下，产生两个相同的哈希值。<br>为了保证数据安全性和不可篡改性，实际hash算法要足够复杂使其有很强的hash抗碰撞性。<br>hash抗碰撞性分为两种：一种是弱抗碰撞性，即指定的消息x和函数H，去求消息y，使H(x)=H(y)在计算上是不可行的；另一个是强抗碰撞性，即给定函数H，对于任意一对不同的消息x和y，使得H(x)=H(y)在计算上也是不可行的。</p><h3 id="SHA256"><a href="#SHA256" class="headerlink" title="SHA256"></a>SHA256</h3><p>SHA是一个密码散列函数家族，是英文Secure Hash Algorithm的缩写。由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布。SHA家族目前有三个系列：SHA-1，SHA-2，SHA-3。因为SHA-1已经被计算出能够被破解，所以现在几乎不再使用。SHA-3是2012年产生的算法，也叫Keccak算法，在以太坊公链中主要使用。SHA-2是当前使用最广泛的算法，尤其是比特币一代的公链。</p><a id="more"></a><p><img src="http://img.kongyixueyuan.com/sha%E7%B3%BB%E5%88%97.jpg" alt="img"></p><p>SHA算法有如下特性：1.不可以从消息摘要中复原信息；2.两个不同的消息不会产生同样的消息摘要。<br>SHA256是目前区块链加密算法中最基础也是应用最多的算法。它是SHA-2算法系列的最具代表性的加密算法。了解和熟练运用SHA256是区块链技术人才的最基本要求。</p><h2 id="1-SHA256的算法原理"><a href="#1-SHA256的算法原理" class="headerlink" title="1. SHA256的算法原理"></a>1. SHA256的算法原理</h2><p>SHA-256是指对于任意小于2^64 位长度（按bit计算）的消息，以512位的分组为单位进行处理，最终产生一个32个字节长度数据的一种加密算法。产生的数据称作消息摘要。因为消息摘要的唯一性和确定性，所以可以用来验证数据在传输过程中是否发生改变，即验证其完整性。</p><h3 id="1-1-运算单位"><a href="#1-1-运算单位" class="headerlink" title="1.1 运算单位"></a>1.1 运算单位</h3><p>SHA算法过程的处理单位是位。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串:0x616263.</p><h3 id="1-2-补位"><a href="#1-2-补位" class="headerlink" title="1.2 补位"></a>1.2 补位</h3><p>将消息转换成二进制串，在后边添加一个“1”和若干个“0”，使其长度模512余数为448。以信息“abc”为例显示补位的过程。</p><p>　　原始信息：01100001 01100010 01100011<br>　　补位第一步：0110000101100010 01100011 1<br>　　首先补一个“1”<br>　　补位第二步：0110000101100010 01100011 10…..0<br>　　然后补423个“0” 　　</p><h3 id="1-3-消息填充"><a href="#1-3-消息填充" class="headerlink" title="1.3 消息填充　"></a>1.3 消息填充　</h3><p>将补位过的信息再追加一个64位的消息长度信息，使得填充完成后的消息长度正好是512位的整数倍。追加的64位的消息长度信息是原始消息的位长，填充完成的消息会被分成512位的消息分组。 　　</p><h3 id="1-4-初始向量"><a href="#1-4-初始向量" class="headerlink" title="1.4 初始向量"></a>1.4 初始向量</h3><p>SHA256是一个Merkle-Damgard结构的迭代哈希函数，进行第一次运算的时候需要一个初始向量。该向量在整个运算过程中是一个变量。SHA256的初始变量是取自然数前8个素数（2，3，5，7，11，13，17，19）的平方根的小数部分前32bit的值。如2的平方根取小数部分是：0.414213562373095048…，转换成二进制取前32bit值是：10110111111100101010000101001010，然后将其转换成16进制的值是：0x6a09e667。同样我们也会得到其他素数的初始变量。这些初始变量存储于8个寄存器A、B、C、D、E、F、G和H中，分别是：</p><p>A= H0 = 0x6a09e667<br>B= H1 = 0xbb67ae85<br>C= H2 = 0x3c6ef372<br>D= H3 = 0xa54ff53a<br>E= H4 = 0x510e527f<br>F= H5 = 0x9b05688c<br>G= H6 = 0x1f83d9ab<br>H= H7 = 0x5be0cd19</p><h3 id="1-5-使用的64个常量"><a href="#1-5-使用的64个常量" class="headerlink" title="1.5 使用的64个常量"></a>1.5 使用的64个常量</h3><p>在SHA256算法中，用到64个常量，这些常量是对自然数中前64个素数的立方根的小数部分取前32bit而来。其作用是提供了一个64位随机串集合，用于被随机选取作为改变每次消息块运算初始向量函数的参数。这样每次消息块加密运算时，输入的初始向量都是没有任何规则的。这64个常量如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">428</span>a2f98 <span class="number">71374491</span> b5c0fbcf e9b5dba5 </span><br><span class="line"><span class="number">3956</span>c25b <span class="number">59</span>f111f1 <span class="number">923</span>f82a4 ab1c5ed5 </span><br><span class="line">d807aa98 <span class="number">12835</span>b01 <span class="number">243185</span>be <span class="number">550</span>c7dc3 </span><br><span class="line"><span class="number">72</span>be5d74 <span class="number">80</span>deb1fe <span class="number">9</span>bdc06a7 c19bf174 </span><br><span class="line">e49b69c1 efbe4786 <span class="number">0</span>fc19dc6 <span class="number">240</span>ca1cc </span><br><span class="line"><span class="number">2</span>de92c6f <span class="number">4</span>a7484aa <span class="number">5</span>cb0a9dc <span class="number">76</span>f988da </span><br><span class="line"><span class="number">983e5152</span> a831c66d b00327c8 bf597fc7 </span><br><span class="line">c6e00bf3 d5a79147 <span class="number">06</span>ca6351 <span class="number">14292967</span> </span><br><span class="line"><span class="number">27</span>b70a85 <span class="number">2e1</span>b2138 <span class="number">4</span>d2c6dfc <span class="number">53380</span>d13 </span><br><span class="line"><span class="number">650</span>a7354 <span class="number">766</span>a0abb <span class="number">81</span>c2c92e <span class="number">92722</span>c85 </span><br><span class="line">a2bfe8a1 a81a664b c24b8b70 c76c51a3 </span><br><span class="line">d192e819 d6990624 f40e3585 <span class="number">106</span>aa070 </span><br><span class="line"><span class="number">19</span>a4c116 <span class="number">1e376</span>c08 <span class="number">2748774</span>c <span class="number">34</span>b0bcb5</span><br><span class="line"><span class="number">391</span>c0cb3 <span class="number">4</span>ed8aa4a <span class="number">5</span>b9cca4f <span class="number">682e6</span>ff3 </span><br><span class="line"><span class="number">748</span>f82ee <span class="number">78</span>a5636f <span class="number">84</span>c87814 <span class="number">8</span>cc70208 </span><br><span class="line"><span class="number">90</span>befffa a4506ceb bef9a3f7 c67178f2</span><br></pre></td></tr></table></figure><h3 id="1-6-运算过程"><a href="#1-6-运算过程" class="headerlink" title="1.6 运算过程"></a>1.6 运算过程</h3><p>运算过程简单描述如下：</p><ol><li><p>创建8个变量a,b,c,d,e,f,g,h，并分别赋值初始向量对应的值；</p></li><li><p>将原始消息补位和填充后，分为N个512bit的消息块M(i)；</p></li><li><p>运算M有个大的循环，形如： For i =1 to N;</p></li><li><p>大循环里面有个64次的循环，用于改变8个变量，并将最终改变后的8个变量作为下一次大循环的参数；</p></li><li><p>大循环最后得到的a,b,c,d,e,f,g,h拼接在一起就是最后的长度为256位的消息摘要。</p><p>下边分析一下64次的循环里面的具体函数，伪代码如下：<br>For t = 0 to 63<br>T1 = （h +（∑1(e) + CH(e,f,g) + Kt + Wt）mod2^32<br>T2 = ∑0(a) + MAJ(a,b,c)mod2^32<br>h = g<br>g = f<br>f = e<br>e = (d + T1)mod2^32<br>d = c<br>c = b<br>b = a<br>a = (T1 + T2)mod2^32<br>其中∑1(e)和∑0(a)分别是e和a的位移异或函数，表达式不做展开；与异或运算函数；MAJ(a,b,c)是a，b，c之间异或运算加法运算函数，表达式不做展开，；T1和T2是每一步生成的两个临时变量；Kt是每次循环从随机串里随机选取的数值；Wt是对输入的消息块的处理函数。</p><p>消息块的处理：每个消息块分解为16个32-bit的big-endian的字，记为w[0], …, w[15]。也就是说，前16个字直接由消息的第i个块分解得到，其余的字由如下迭代公式得到，这样Wt的表达式如下表示：<br>Wt=w[t],0&lt;=t&lt;=16<br>Wt=σ1(Wt−2)+Wt−7+σ0(Wt−15)+Wt−16,16&lt;=t&lt;=63<br>最后一次循环所产生的八个字合起来即是第i个块对应到的散列字符串Hi就是sha256加密后的散列值。</p></li></ol><h2 id="2-SHA256在区块链的应用及代码实现"><a href="#2-SHA256在区块链的应用及代码实现" class="headerlink" title="2. SHA256在区块链的应用及代码实现"></a>2. SHA256在区块链的应用及代码实现</h2><p>SHA256从出现到现在，目前被证明是很安全的，其在区块链上的应用最为广泛，如比特币的挖矿算法，产生账户地址和区块产生hash，以及以太坊区块生成hash等等。<br>它的使用非常简单，golang库里已经封装好了SHA256的具体算法，所以我们在使用时直接调用方法就可以。函数hash.Sha256的参数类型是字节切片，返回值也是字节切片，在使用时需要注意。<br>Go代码实现SHA256有两种方法，原理和输出都一样，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/nebulasio/go-nebulas/crypto/hash"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    a:=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法1：一个方法直接输出</span></span><br><span class="line">    hash:=hash.Sha256([]<span class="keyword">byte</span>(a))</span><br><span class="line">    fmt.Println(hex.EncodeToString(hash))</span><br><span class="line"></span><br><span class="line">    sha256.New()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2：按步骤一步步输出</span></span><br><span class="line">    h := sha256.New() <span class="comment">//创建sha256算法</span></span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(a)) <span class="comment">//用sha256算法对参数a进行加密，得到8个变量</span></span><br><span class="line">    hash1 := h.Sum(<span class="literal">nil</span>) <span class="comment">//将8个变量相加得到最终hash</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(hex.EncodeToString(hash1))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">936</span>a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af</span><br><span class="line"><span class="number">936</span>a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章MD5算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC13%E7%AB%A0MD5%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC13%E7%AB%A0MD5%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MD5算法详解及go语言实现"><a href="#MD5算法详解及go语言实现" class="headerlink" title="MD5算法详解及go语言实现"></a>MD5算法详解及go语言实现</h3><p>MD5英文全称Message-Digest Algorithm，中文叫消息摘要算法。它是由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代被发现有安全缺陷的MD4算法。它是目前使用最广泛的密码学算法之一。</p><a id="more"></a><h2 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1 算法描述"></a>1 算法描述</h2><p>MD5算法将任意长度的消息进行函数运算，得到长度为128比特的hash值，该哈希值就是信息摘要。MD5的算法是个单向函数，无法进行逆运算。单向函数的正运算速度快，安全性高，非常实用。目前MD5被广泛应用在防篡改、数字签名、安全访问认证等方面。</p><p>算法过程是将消息进行填充，之后按512比特一组进行分组，每组信息与初始向量的缓存值进行各种逻辑运算，迭代运算和压缩函数运算，最后得到的值就是hash值。</p><p>算法流程图如下：<br><img src="http://img.kongyixueyuan.com/MD5%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.png" alt="img"></p><h3 id="1-填充消息"><a href="#1-填充消息" class="headerlink" title="1. 填充消息"></a>1. 填充消息</h3><p>填充消息使其长度与448模512同与（即长度≡448 mod 512）。也就是说，填充后的消息长度比512的某整数倍少64比特。填充的方法是：在消息后面进行填充，填充第一位为1，其余为0。注意，如果消息的长度刚好满足要求，也就是不填充消息，其长度与448模512同与。这种情况下也要进行填充操作，填充第一位为1，剩余511位都是0。</p><h3 id="2-填充消息长度"><a href="#2-填充消息长度" class="headerlink" title="2. 填充消息长度"></a>2. 填充消息长度</h3><p>完成第一步后，我们会发现如果再给消息填充64比特，那么消息的长度正好可以整除512。那好，我们就把消息的长度转换成二进制填充到经过第一步处理的消息后边。如果消息的长度过于长，长度值大于2^64 ，此时64位比特放不下这个长度值。如果这种情况，就取消息长度模2^64 的值作为填充的长度值。<br>在此步骤进行完毕后，最终消息长度就是512的整数倍。</p><h3 id="3-初始化初始向量"><a href="#3-初始化初始向量" class="headerlink" title="3. 初始化初始向量"></a>3. 初始化初始向量</h3><p>定义4个16进制的大整数（这些突然冒出来的数也叫幻数） A=67452301；B=EFCDAB89；C=98BADCFE；D=10325476。</p><p>将这四个幻数以字节数组存储，也就是我们声明4个变量去存储这四个幻数。但是存储的类型有两种：小端法(Little-Endian)存储和大端法(Big-Endian)存储。小端法就是低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端。大端法(Big-Endian)就是高位字节排放在内存的低地址端即该值的起始地址，低位字节排放在内存的高地址端。</p><p>我们现在用这两种存储方法存储A，来展示它们的区别：<br>小端法：A:=[]byte{01，23，45，67}<br>大端法：A:=[]byte{67，45，23，01}</p><p>MD5算法的逻辑函数处理字节是从最低有效字节增大顺序处理的，所以要求大整数的存储需要小端法进行存储。<br>所以，代码中我们可以直接定义4个变量，并给予赋值，分别为了存储以上4个大数，变量如下：<br>A:=[]byte{01，23，45，67}<br>B:=[]byte{89，AB，CD，EF}<br>C:=[]byte{FE，DC，BA，98}<br>D:=[]byte{76，54，32，10}</p><p>变量的长度都为4个字节，也就是32比特，加在一起是128，正好是最后hash值的长度。<br>这四个变量经过MD5函数处理后最终得到的结果拼接，就是最后的hash值。</p><h3 id="4-以512比特的分组（16个字）为单位处理消息"><a href="#4-以512比特的分组（16个字）为单位处理消息" class="headerlink" title="4. 以512比特的分组（16个字）为单位处理消息"></a>4. 以512比特的分组（16个字）为单位处理消息</h3><p>MD5算法的核心就是压缩函数H。每组消息的压缩由4轮运算完成，如图4.1所示。4轮运算结构相同，但各轮使用的逻辑函数不同，分别是H0，H1，H2，H3。每轮的输入为当前要处理的消息分组Mq和缓存区的当前A、B、C、D，前3轮输出的A、B、C、D直接替换旧的并放在缓存区，最后一轮，也就是第四轮的输出A、B、C、D需要和第一轮的输入A、B、C、D进行模2^32 加法运算之后再放到缓存区。这4轮的运算每轮都需要对缓存区ABCD进行16步迭代运算。</p><p>模加法运算很简单，其运算结果为两数相加后除以n的余数。模加法的数学符号是+。如9和8对10进行取模，结果是7。</p><p>具体的分组信息压缩过程如下图：<br><img src="http://img.kongyixueyuan.com/MD5%E5%8E%8B%E7%BC%A9%E5%88%86%E7%BB%84%E4%BF%A1%E6%81%AF%E8%BF%87%E7%A8%8B.png" alt="img"></p><h3 id="5-MD5-16步迭代运算"><a href="#5-MD5-16步迭代运算" class="headerlink" title="5. MD5 16步迭代运算"></a>5. MD5 16步迭代运算</h3><p>压缩过程的每一轮都对缓冲区的ABCD进行16步的迭代运算，每一步的运算公式结构都是一样的，只是压缩函数不一样，我现在把4轮的压缩函数定义为g，那么每轮的运算公式如下：<br>a=D<br>b=CLSs(A+g(B,C,D)+X[k]+T[i])+B<br>c=B<br>d=C<br>其中A，B，C，D是缓存区中的4个字，a，b，c，d是A，B，C，D压缩后对应的字，g是基本逻辑函数H0，H1，H2，H3的对应一个，CLSs是32比特的变量循环左移s位，s的取值如表5.1所示。X[k]=Yq[q*16+k]，即消息的第q个分组中第k个字（k=0，…，15）。T[i]为表T中的第i个字，+为模2^32 加法。</p><p>T表：</p><table><thead><tr><th align="left"></th><th align="left">T值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">0xd76aa478</td></tr><tr><td align="left">2</td><td align="left">0xe8c7b756</td></tr><tr><td align="left">3</td><td align="left">0x242070db</td></tr><tr><td align="left">4</td><td align="left">0xc1bdceee</td></tr><tr><td align="left">5</td><td align="left">0xf57c0faf</td></tr><tr><td align="left">6</td><td align="left">0x4787c62a</td></tr><tr><td align="left">7</td><td align="left">0xa8304613</td></tr><tr><td align="left">8</td><td align="left">0xfd469501</td></tr><tr><td align="left">9</td><td align="left">0x698098d8</td></tr><tr><td align="left">10</td><td align="left">0x8b44f7af</td></tr><tr><td align="left">11</td><td align="left">0xffff5bb1</td></tr><tr><td align="left">12</td><td align="left">0x895cd7be</td></tr><tr><td align="left">13</td><td align="left">0x6b901122</td></tr><tr><td align="left">14</td><td align="left">0xfd987193</td></tr><tr><td align="left">15</td><td align="left">0xa679438e</td></tr><tr><td align="left">16</td><td align="left">0x49b40821</td></tr><tr><td align="left">17</td><td align="left">0xf61e2562</td></tr><tr><td align="left">18</td><td align="left">0xc040b340</td></tr><tr><td align="left">19</td><td align="left">0x265e5a51</td></tr><tr><td align="left">20</td><td align="left">0xe9b6c7aa</td></tr><tr><td align="left">21</td><td align="left">0xd62f105d</td></tr><tr><td align="left">22</td><td align="left">0x02441453</td></tr><tr><td align="left">23</td><td align="left">0xd8a1e681</td></tr><tr><td align="left">24</td><td align="left">0xe7d3fbc8</td></tr><tr><td align="left">25</td><td align="left">0x21e1cde6</td></tr><tr><td align="left">26</td><td align="left">0xc33707d6</td></tr><tr><td align="left">27</td><td align="left">0xf4d50d87</td></tr><tr><td align="left">28</td><td align="left">0x455a14ed</td></tr><tr><td align="left">29</td><td align="left">0xa9e3e905</td></tr><tr><td align="left">30</td><td align="left">0xfcefa3f8</td></tr><tr><td align="left">31</td><td align="left">0x676f02d9</td></tr><tr><td align="left">32</td><td align="left">0x8d2a4c8a</td></tr><tr><td align="left">33</td><td align="left">0xfffa3942</td></tr><tr><td align="left">34</td><td align="left">0x8771f681</td></tr><tr><td align="left">35</td><td align="left">0x6d9d6122</td></tr><tr><td align="left">36</td><td align="left">0xfde5380c</td></tr><tr><td align="left">37</td><td align="left">0xa4beea44</td></tr><tr><td align="left">38</td><td align="left">0x4bdecfa9</td></tr><tr><td align="left">39</td><td align="left">0xf6bb4b60</td></tr><tr><td align="left">40</td><td align="left">0xbebfbc70</td></tr><tr><td align="left">41</td><td align="left">0x289b7ec6</td></tr><tr><td align="left">42</td><td align="left">0xeaa127fa</td></tr><tr><td align="left">43</td><td align="left">0xd4ef3085</td></tr><tr><td align="left">44</td><td align="left">0x04881d05</td></tr><tr><td align="left">45</td><td align="left">0xd9d4d039</td></tr><tr><td align="left">46</td><td align="left">0xe6db99e5</td></tr><tr><td align="left">47</td><td align="left">0x1fa27cf8</td></tr><tr><td align="left">48</td><td align="left">0xc4ac5665</td></tr><tr><td align="left">49</td><td align="left">0xf4292244</td></tr><tr><td align="left">50</td><td align="left">0x432aff97</td></tr><tr><td align="left">51</td><td align="left">0xab9423a7</td></tr><tr><td align="left">52</td><td align="left">0xfc93a039</td></tr><tr><td align="left">53</td><td align="left">0x655b59c3</td></tr><tr><td align="left">54</td><td align="left">0x8f0ccc92</td></tr><tr><td align="left">55</td><td align="left">0xffeff47d</td></tr><tr><td align="left">56</td><td align="left">0x85845dd1</td></tr><tr><td align="left">57</td><td align="left">0x6fa87e4f</td></tr><tr><td align="left">58</td><td align="left">0xfe2ce6e0</td></tr><tr><td align="left">59</td><td align="left">0xa3014314</td></tr><tr><td align="left">60</td><td align="left">0x4e0811a1</td></tr><tr><td align="left">61</td><td align="left">0xf7537e82</td></tr><tr><td align="left">62</td><td align="left">0xbd3af235</td></tr><tr><td align="left">63</td><td align="left">0x2ad7d2bb</td></tr><tr><td align="left">64</td><td align="left">0xeb86d391</td></tr></tbody></table><p>通过上边的公式我们得到了a，b，c，d，将他们放到缓存区A，B，C，D进入下一步运算<br>运算示意图如下：<br><img src="http://img.kongyixueyuan.com/MD5%E4%B8%80%E6%AD%A5%E8%BF%AD%E4%BB%A3%E8%BF%90%E7%AE%97.png" alt="img"></p><p>表5.1 压缩函数中每步循环左移位数表</p><table><thead><tr><th align="left"></th><th align="left">步数</th><th align="left">01</th><th align="left">02</th><th align="left">03</th><th align="left">04</th><th align="left">05</th><th align="left">06</th><th align="left">07</th><th align="left">08</th><th align="left">09</th><th align="left">10</th><th align="left">11</th><th align="left">12</th><th align="left">13</th><th align="left">14</th><th align="left">15</th><th align="left">16</th></tr></thead><tbody><tr><td align="left">轮数</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">1</td><td align="left"></td><td align="left">7</td><td align="left">12</td><td align="left">17</td><td align="left">22</td><td align="left">7</td><td align="left">12</td><td align="left">17</td><td align="left">22</td><td align="left">7</td><td align="left">12</td><td align="left">17</td><td align="left">22</td><td align="left">7</td><td align="left">12</td><td align="left">17</td><td align="left">22</td></tr><tr><td align="left">2</td><td align="left"></td><td align="left">5</td><td align="left">9</td><td align="left">14</td><td align="left">20</td><td align="left">5</td><td align="left">9</td><td align="left">14</td><td align="left">20</td><td align="left">5</td><td align="left">9</td><td align="left">14</td><td align="left">20</td><td align="left">5</td><td align="left">9</td><td align="left">14</td><td align="left">20</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">4</td><td align="left">11</td><td align="left">16</td><td align="left">23</td><td align="left">4</td><td align="left">11</td><td align="left">16</td><td align="left">23</td><td align="left">4</td><td align="left">11</td><td align="left">16</td><td align="left">23</td><td align="left">4</td><td align="left">11</td><td align="left">16</td><td align="left">23</td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">6</td><td align="left">10</td><td align="left">15</td><td align="left">21</td><td align="left">6</td><td align="left">10</td><td align="left">15</td><td align="left">21</td><td align="left">6</td><td align="left">10</td><td align="left">15</td><td align="left">21</td><td align="left">6</td><td align="left">10</td><td align="left">15</td><td align="left">21</td></tr></tbody></table><p>g逻辑函数每轮的表示：<br>第一轮：H0(B,C,D)=(B &amp; C) | ((<del>B) &amp; D)<br>第二轮：H1(B,C,D)=(B&amp;D)|(C&amp;(</del>D))<br>第三轮：H2(B,C,D)=B ^ C ^ D<br>第四轮：H3(B,C,D)=C ^ (B|~D)</p><p>上边公式里的运算符：<br>按位异或运算符” ^ “；按位或运算符”|”；按位与运算符”&amp;”；按位取反运算符”~”。</p><p>对于X[k]再做一下解释。当前要处理的512比特的分组消息保存在Y[0…15]，其元素是一个32比特的字。每轮的16步运算每一步都是对Y里的某个元素进行处理。压缩是需要4轮进行的，但是每一轮对Y处理的次序是不一样的。<br>第一轮：顺序处理，k=k++<br>第二轮：k=（1+5i）mod 16<br>第三轮：k=（5+3i）mod 16<br>第四轮：k= 7i mod 16<br>其中i是16步运算的第i步。</p><h2 id="2-用goland封装的方法使用MD5"><a href="#2-用goland封装的方法使用MD5" class="headerlink" title="2 用goland封装的方法使用MD5"></a>2 用goland封装的方法使用MD5</h2><p>使用的方法和sha256类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"hello world"</span>)</span><br><span class="line">    s := fmt.Sprintf(<span class="string">"%x"</span>, md5.Sum(data))</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用这种方式</span></span><br><span class="line">    h := md5.New()</span><br><span class="line">    h.Write(data)</span><br><span class="line">    s = hex.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Go语言实现MD5"><a href="#3-Go语言实现MD5" class="headerlink" title="3 Go语言实现MD5"></a>3 Go语言实现MD5</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Size = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    chunk = <span class="number">64</span></span><br><span class="line">    init0 = <span class="number">0x67452301</span></span><br><span class="line">    init1 = <span class="number">0xEFCDAB89</span></span><br><span class="line">    init2 = <span class="number">0x98BADCFE</span></span><br><span class="line">    init3 = <span class="number">0x10325476</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// digest represents the partial evaluation of a checksum.</span></span><br><span class="line"><span class="keyword">type</span> digest <span class="keyword">struct</span> &#123;</span><br><span class="line">    s   [<span class="number">4</span>]<span class="keyword">uint32</span></span><br><span class="line">    x   [chunk]<span class="keyword">byte</span></span><br><span class="line">    nx  <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.s[<span class="number">0</span>] = init0</span><br><span class="line">    d.s[<span class="number">1</span>] = init1</span><br><span class="line">    d.s[<span class="number">2</span>] = init2</span><br><span class="line">    d.s[<span class="number">3</span>] = init3</span><br><span class="line">    d.nx = <span class="number">0</span></span><br><span class="line">    d.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    nn = <span class="built_in">len</span>(p)</span><br><span class="line">    d.<span class="built_in">len</span> += <span class="keyword">uint64</span>(nn)</span><br><span class="line">    <span class="keyword">if</span> d.nx &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := <span class="built_in">copy</span>(d.x[d.nx:], p)</span><br><span class="line">        d.nx += n</span><br><span class="line">        <span class="keyword">if</span> d.nx == chunk &#123;</span><br><span class="line">            blockGeneric(d, d.x[:])</span><br><span class="line">            d.nx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= chunk &#123;</span><br><span class="line">        n := <span class="built_in">len</span>(p) &amp;^ (chunk - <span class="number">1</span>)</span><br><span class="line">        blockGeneric(d, p[:n])</span><br><span class="line">        p = p[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        d.nx = <span class="built_in">copy</span>(d.x[:], p)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>,d)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">checkSum</span><span class="params">()</span> [<span class="title">Size</span>]<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.</span></span><br><span class="line">    <span class="built_in">len</span> := d.<span class="built_in">len</span></span><br><span class="line">    <span class="keyword">var</span> tmp [<span class="number">64</span>]<span class="keyword">byte</span></span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="number">0x80</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>%<span class="number">64</span> &lt; <span class="number">56</span> &#123;</span><br><span class="line">        d.Write(tmp[<span class="number">0</span> : <span class="number">56</span>-<span class="built_in">len</span>%<span class="number">64</span>])</span><br><span class="line">        fmt.Printf(<span class="string">"%v"</span>,d)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d.Write(tmp[<span class="number">0</span> : <span class="number">64</span>+<span class="number">56</span>-<span class="built_in">len</span>%<span class="number">64</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Length in bits.</span></span><br><span class="line">    <span class="built_in">len</span> &lt;&lt;= <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint</span>(<span class="number">0</span>); i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        tmp[i] = <span class="keyword">byte</span>(<span class="built_in">len</span> &gt;&gt; (<span class="number">8</span> * i))</span><br><span class="line">    &#125;</span><br><span class="line">    d.Write(tmp[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d.nx != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"d.nx != 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> digest [Size]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> d.s &#123;</span><br><span class="line">        digest[i*<span class="number">4</span>] = <span class="keyword">byte</span>(s)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">1</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">8</span>)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">2</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">16</span>)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">3</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">24</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> digest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blockGeneric</span><span class="params">(dig *digest, p []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    a := dig.s[<span class="number">0</span>]</span><br><span class="line">    b := dig.s[<span class="number">1</span>]</span><br><span class="line">    c := dig.s[<span class="number">2</span>]</span><br><span class="line">    d := dig.s[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">var</span> X *[<span class="number">16</span>]<span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(p) &gt;= chunk &#123;</span><br><span class="line">        aa, bb, cc, dd := a, b, c, d</span><br><span class="line"></span><br><span class="line">        X = (*[<span class="number">16</span>]<span class="keyword">uint32</span>)(unsafe.Pointer(&amp;p[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Round 1.</span></span><br><span class="line"></span><br><span class="line">        a += (((c ^ d) &amp; b) ^ d) + X[<span class="number">0</span>] + <span class="number">3614090360</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">7</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-7</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((b ^ c) &amp; a) ^ c) + X[<span class="number">1</span>] + <span class="number">3905402710</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">12</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-12</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((a ^ b) &amp; d) ^ b) + X[<span class="number">2</span>] + <span class="number">606105819</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">17</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-17</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((d ^ a) &amp; c) ^ a) + X[<span class="number">3</span>] + <span class="number">3250441966</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">22</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-22</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((c ^ d) &amp; b) ^ d) + X[<span class="number">4</span>] + <span class="number">4118548399</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">7</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-7</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((b ^ c) &amp; a) ^ c) + X[<span class="number">5</span>] + <span class="number">1200080426</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">12</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-12</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((a ^ b) &amp; d) ^ b) + X[<span class="number">6</span>] + <span class="number">2821735955</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">17</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-17</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((d ^ a) &amp; c) ^ a) + X[<span class="number">7</span>] + <span class="number">4249261313</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">22</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-22</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((c ^ d) &amp; b) ^ d) + X[<span class="number">8</span>] + <span class="number">1770035416</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">7</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-7</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((b ^ c) &amp; a) ^ c) + X[<span class="number">9</span>] + <span class="number">2336552879</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">12</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-12</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((a ^ b) &amp; d) ^ b) + X[<span class="number">10</span>] + <span class="number">4294925233</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">17</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-17</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((d ^ a) &amp; c) ^ a) + X[<span class="number">11</span>] + <span class="number">2304563134</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">22</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-22</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((c ^ d) &amp; b) ^ d) + X[<span class="number">12</span>] + <span class="number">1804603682</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">7</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-7</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((b ^ c) &amp; a) ^ c) + X[<span class="number">13</span>] + <span class="number">4254626195</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">12</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-12</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((a ^ b) &amp; d) ^ b) + X[<span class="number">14</span>] + <span class="number">2792965006</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">17</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-17</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((d ^ a) &amp; c) ^ a) + X[<span class="number">15</span>] + <span class="number">1236535329</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">22</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-22</span>) + c</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Round 2.</span></span><br><span class="line"></span><br><span class="line">        a += (((b ^ c) &amp; d) ^ c) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">0</span>)&amp;<span class="number">15</span>] + <span class="number">4129170786</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">5</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-5</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((a ^ b) &amp; c) ^ b) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">1</span>)&amp;<span class="number">15</span>] + <span class="number">3225465664</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">9</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-9</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((d ^ a) &amp; b) ^ a) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">2</span>)&amp;<span class="number">15</span>] + <span class="number">643717713</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">14</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-14</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((c ^ d) &amp; a) ^ d) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">3</span>)&amp;<span class="number">15</span>] + <span class="number">3921069994</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">20</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-20</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((b ^ c) &amp; d) ^ c) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">4</span>)&amp;<span class="number">15</span>] + <span class="number">3593408605</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">5</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-5</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((a ^ b) &amp; c) ^ b) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">5</span>)&amp;<span class="number">15</span>] + <span class="number">38016083</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">9</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-9</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((d ^ a) &amp; b) ^ a) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">6</span>)&amp;<span class="number">15</span>] + <span class="number">3634488961</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">14</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-14</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((c ^ d) &amp; a) ^ d) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">7</span>)&amp;<span class="number">15</span>] + <span class="number">3889429448</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">20</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-20</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((b ^ c) &amp; d) ^ c) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">8</span>)&amp;<span class="number">15</span>] + <span class="number">568446438</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">5</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-5</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((a ^ b) &amp; c) ^ b) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">9</span>)&amp;<span class="number">15</span>] + <span class="number">3275163606</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">9</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-9</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((d ^ a) &amp; b) ^ a) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">10</span>)&amp;<span class="number">15</span>] + <span class="number">4107603335</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">14</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-14</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((c ^ d) &amp; a) ^ d) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">11</span>)&amp;<span class="number">15</span>] + <span class="number">1163531501</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">20</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-20</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (((b ^ c) &amp; d) ^ c) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">12</span>)&amp;<span class="number">15</span>] + <span class="number">2850285829</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">5</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-5</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (((a ^ b) &amp; c) ^ b) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">13</span>)&amp;<span class="number">15</span>] + <span class="number">4243563512</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">9</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-9</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (((d ^ a) &amp; b) ^ a) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">14</span>)&amp;<span class="number">15</span>] + <span class="number">1735328473</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">14</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-14</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (((c ^ d) &amp; a) ^ d) + X[(<span class="number">1</span>+<span class="number">5</span>*<span class="number">15</span>)&amp;<span class="number">15</span>] + <span class="number">2368359562</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">20</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-20</span>) + c</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Round 3.</span></span><br><span class="line"></span><br><span class="line">        a += (b ^ c ^ d) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">0</span>)&amp;<span class="number">15</span>] + <span class="number">4294588738</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">4</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-4</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (a ^ b ^ c) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">1</span>)&amp;<span class="number">15</span>] + <span class="number">2272392833</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">11</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-11</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (d ^ a ^ b) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">2</span>)&amp;<span class="number">15</span>] + <span class="number">1839030562</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">16</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-16</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (c ^ d ^ a) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">3</span>)&amp;<span class="number">15</span>] + <span class="number">4259657740</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">23</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-23</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (b ^ c ^ d) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">4</span>)&amp;<span class="number">15</span>] + <span class="number">2763975236</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">4</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-4</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (a ^ b ^ c) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">5</span>)&amp;<span class="number">15</span>] + <span class="number">1272893353</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">11</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-11</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (d ^ a ^ b) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">6</span>)&amp;<span class="number">15</span>] + <span class="number">4139469664</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">16</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-16</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (c ^ d ^ a) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">7</span>)&amp;<span class="number">15</span>] + <span class="number">3200236656</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">23</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-23</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (b ^ c ^ d) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">8</span>)&amp;<span class="number">15</span>] + <span class="number">681279174</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">4</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-4</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (a ^ b ^ c) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">9</span>)&amp;<span class="number">15</span>] + <span class="number">3936430074</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">11</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-11</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (d ^ a ^ b) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">10</span>)&amp;<span class="number">15</span>] + <span class="number">3572445317</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">16</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-16</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (c ^ d ^ a) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">11</span>)&amp;<span class="number">15</span>] + <span class="number">76029189</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">23</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-23</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (b ^ c ^ d) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">12</span>)&amp;<span class="number">15</span>] + <span class="number">3654602809</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">4</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-4</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (a ^ b ^ c) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">13</span>)&amp;<span class="number">15</span>] + <span class="number">3873151461</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">11</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-11</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (d ^ a ^ b) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">14</span>)&amp;<span class="number">15</span>] + <span class="number">530742520</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">16</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-16</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (c ^ d ^ a) + X[(<span class="number">5</span>+<span class="number">3</span>*<span class="number">15</span>)&amp;<span class="number">15</span>] + <span class="number">3299628645</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">23</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-23</span>) + c</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Round 4.</span></span><br><span class="line"></span><br><span class="line">        a += (c ^ (b | ^d)) + X[(<span class="number">7</span>*<span class="number">0</span>)&amp;<span class="number">15</span>] + <span class="number">4096336452</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">6</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-6</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (b ^ (a | ^c)) + X[(<span class="number">7</span>*<span class="number">1</span>)&amp;<span class="number">15</span>] + <span class="number">1126891415</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">10</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-10</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (a ^ (d | ^b)) + X[(<span class="number">7</span>*<span class="number">2</span>)&amp;<span class="number">15</span>] + <span class="number">2878612391</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">15</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-15</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (d ^ (c | ^a)) + X[(<span class="number">7</span>*<span class="number">3</span>)&amp;<span class="number">15</span>] + <span class="number">4237533241</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">21</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-21</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (c ^ (b | ^d)) + X[(<span class="number">7</span>*<span class="number">4</span>)&amp;<span class="number">15</span>] + <span class="number">1700485571</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">6</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-6</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (b ^ (a | ^c)) + X[(<span class="number">7</span>*<span class="number">5</span>)&amp;<span class="number">15</span>] + <span class="number">2399980690</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">10</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-10</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (a ^ (d | ^b)) + X[(<span class="number">7</span>*<span class="number">6</span>)&amp;<span class="number">15</span>] + <span class="number">4293915773</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">15</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-15</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (d ^ (c | ^a)) + X[(<span class="number">7</span>*<span class="number">7</span>)&amp;<span class="number">15</span>] + <span class="number">2240044497</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">21</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-21</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (c ^ (b | ^d)) + X[(<span class="number">7</span>*<span class="number">8</span>)&amp;<span class="number">15</span>] + <span class="number">1873313359</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">6</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-6</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (b ^ (a | ^c)) + X[(<span class="number">7</span>*<span class="number">9</span>)&amp;<span class="number">15</span>] + <span class="number">4264355552</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">10</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-10</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (a ^ (d | ^b)) + X[(<span class="number">7</span>*<span class="number">10</span>)&amp;<span class="number">15</span>] + <span class="number">2734768916</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">15</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-15</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (d ^ (c | ^a)) + X[(<span class="number">7</span>*<span class="number">11</span>)&amp;<span class="number">15</span>] + <span class="number">1309151649</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">21</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-21</span>) + c</span><br><span class="line"></span><br><span class="line">        a += (c ^ (b | ^d)) + X[(<span class="number">7</span>*<span class="number">12</span>)&amp;<span class="number">15</span>] + <span class="number">4149444226</span></span><br><span class="line">        a = a&lt;&lt;<span class="number">6</span> | a&gt;&gt;(<span class="number">32</span><span class="number">-6</span>) + b</span><br><span class="line"></span><br><span class="line">        d += (b ^ (a | ^c)) + X[(<span class="number">7</span>*<span class="number">13</span>)&amp;<span class="number">15</span>] + <span class="number">3174756917</span></span><br><span class="line">        d = d&lt;&lt;<span class="number">10</span> | d&gt;&gt;(<span class="number">32</span><span class="number">-10</span>) + a</span><br><span class="line"></span><br><span class="line">        c += (a ^ (d | ^b)) + X[(<span class="number">7</span>*<span class="number">14</span>)&amp;<span class="number">15</span>] + <span class="number">718787259</span></span><br><span class="line">        c = c&lt;&lt;<span class="number">15</span> | c&gt;&gt;(<span class="number">32</span><span class="number">-15</span>) + d</span><br><span class="line"></span><br><span class="line">        b += (d ^ (c | ^a)) + X[(<span class="number">7</span>*<span class="number">15</span>)&amp;<span class="number">15</span>] + <span class="number">3951481745</span></span><br><span class="line">        b = b&lt;&lt;<span class="number">21</span> | b&gt;&gt;(<span class="number">32</span><span class="number">-21</span>) + c</span><br><span class="line"></span><br><span class="line">        a += aa</span><br><span class="line">        b += bb</span><br><span class="line">        c += cc</span><br><span class="line">        d += dd</span><br><span class="line"></span><br><span class="line">        p = p[chunk:]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dig.s[<span class="number">0</span>] = a</span><br><span class="line">    dig.s[<span class="number">1</span>] = b</span><br><span class="line">    dig.s[<span class="number">2</span>] = c</span><br><span class="line">    dig.s[<span class="number">3</span>] = d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d digest</span><br><span class="line">    d.Reset()</span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">    d.Write(data)</span><br><span class="line"></span><br><span class="line">    hashnum := d.checkSum()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>,hashnum)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第14章RipeMD160算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC15%E7%AB%A0RipeMD160%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC15%E7%AB%A0RipeMD160%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="RipeMD160算法"><a href="#RipeMD160算法" class="headerlink" title="RipeMD160算法"></a>RipeMD160算法</h3><h2 id="1-RipeMD算法简述"><a href="#1-RipeMD算法简述" class="headerlink" title="1 RipeMD算法简述"></a>1 RipeMD算法简述</h2><p>RIPEMD（RACE Integrity Primitives Evaluation Message Digest），中文译为“RACE原始完整性校验消息摘要”，是比利时鲁汶大学COSIC研究小组开发的散列函数算法。RIPEMD使用MD4的设计原理，并针对MD4的算法缺陷进行改进，1996年首次发布RIPEMD-128版本，在性能上与较受欢迎的SHA-1相似。</p><a id="more"></a><p>RipeMD算法是针对MD4和MD5算法缺陷分析提出的一种升级版本算法。这些算法主要是针对摘要值的长度进行了区分，如下表：</p><table><thead><tr><th align="left">算法</th><th align="left">摘要长度</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">RipeMD128</td><td align="left">128</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">RipeMD160</td><td align="left">160</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">RipeMD256</td><td align="left">256</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">RipeMD320</td><td align="left">320</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacRipeMD128</td><td align="left">128</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacRipeMD160</td><td align="left">160</td><td align="left">BouncyCastle实现</td></tr></tbody></table><p>所以构成RIPEMD家族的四个成员分别是：RIPEMD-128、RIPEMD-160、RIPEMD-256、RIPEMD-320。但安全性最高，使用最广泛的是RIPEMD160算法。</p><h2 id="2-RipeMD160算法简介"><a href="#2-RipeMD160算法简介" class="headerlink" title="2 RipeMD160算法简介"></a>2 RipeMD160算法简介</h2><p>RIPEMD-160是基于Merkle-Damgard构造的加密散列函数。哈希值的输出值一般是16进制的字符串。而16进制字符串，每两个字符占一个字节。我们知道，一个字节=8bit.所以使用ripemd160加密函数所得到的是一个160bit的值。</p><p>Merkle-Damgard结构属于一个函数迭代运算的结构，抗hash碰撞能力强。</p><p>算法的原理几乎和MD算法的原理一样，但具体函数内容和过程不一样。RIPEMD-160的核心是一个有10个循环的压缩函数模块，其中每个循环由16个处理步骤组成。在每个循环中使用不同的原始逻辑函数，算法的处理分为两种不同的情况，在这两种情况下，分别以相反的顺序使用5个原始逻辑函数。每一个循环都以当前分组的消息字和160位的缓存值A、B、C、D、E为输入得到新的值。每个循环使用一个额外的常数，在最后一个循环结束后，两种情况的计算结果A、B、C、D、E和A′、B′、C′、D′、E′及链接变量的初始值经过一次相加运算产生最终的输出。对所有的512位的分组处理完成之后，最终产生的160位输出即为消息摘要。</p><p>在比特币系列的公链中经常用到该算法，尤其是账户地址的生成。</p><h2 id="3-RipeMD160算法过程"><a href="#3-RipeMD160算法过程" class="headerlink" title="3 RipeMD160算法过程"></a>3 RipeMD160算法过程</h2><p>RipeMD160算法过程的流程与MD5算法几乎一样，下面一步步进行分析。</p><h3 id="3-1-填充"><a href="#3-1-填充" class="headerlink" title="3.1 填充"></a>3.1 填充</h3><p>规则与MD5一模一样，使消息填充后的长度与448模512同与（即长度≡448 mod 512）。</p><h3 id="3-2-填充消息长度"><a href="#3-2-填充消息长度" class="headerlink" title="3.2 填充消息长度"></a>3.2 填充消息长度</h3><p>规则与MD5一模一样，将消息的长度填充到经过第一步填充之后的消息。最后得到的消息就是512的整数倍。</p><h3 id="3-3-设置初始向量"><a href="#3-3-设置初始向量" class="headerlink" title="3.3 设置初始向量"></a>3.3 设置初始向量</h3><p>比MD5多一个向量元素，但存储方式一样，采用小端法。<br>定义了5个16进制的大整数<br>A=67452301;<br>B=EFCDAB89;<br>C=98BADCFE;<br>D=10325476;<br>E=c3d2e1f0;</p><h3 id="3-4-以512比特的分组（16个字）为单位处理消息"><a href="#3-4-以512比特的分组（16个字）为单位处理消息" class="headerlink" title="3.4 以512比特的分组（16个字）为单位处理消息"></a>3.4 以512比特的分组（16个字）为单位处理消息</h3><p>和MD5处理分组消息的原理类似，实现过程不同。<br>先看一下流程图：<br><img src="http://img.kongyixueyuan.com/ripemd%E5%8E%8B%E7%BC%A9%E8%BF%87%E7%A8%8B.jpeg" alt="img"></p><p>图中Yq为分组后的512比特的消息；f是每个加密块用到的运算函数；Ki是常量表K中的元素,与MD5的T表一样；Xi是消息的第q个分组中第i个字（i=0，…，15）；+为模2^32 加法。<br>具体f压缩函数为：<br>f1=x ^ y ^ z<br>f2=(x&amp;y) | (<del>x&amp;z)<br>f3=(x | ~y) ^ z<br>f4=(x&amp;y) | (y&amp;</del>z)<br>f5=x ^ (y | <del>z)<br>按位异或运算符”^”；按位或运算符”|”；按位与运算符”&amp;”；按位取反运算符”</del>“。</p><p>处理分组消息的过程分为5轮，每轮分为两组，分别是Left加密块和Right加密块运算，每个加密块运算又循环16步迭代运算。最后左右两侧经过5轮运算后得到的数据，和本组运算的初始向量按照指定组合顺序，将它们三组数据进行组合。组合之后的值就是本组运算结果，该结果就是下一组消息运算的初始向量。<br>Left和Right运算的函数顺序是相反的，同时它们分别总共运行80次。</p><p>伪代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">h0:=<span class="number">67452301</span>;</span><br><span class="line">h1:=EFCDAB89;</span><br><span class="line">h2:=<span class="number">98</span>BADCFE;</span><br><span class="line">h3:=<span class="number">10325476</span>;</span><br><span class="line">h4:=c3d2e1f0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i := <span class="number">0</span> to blocks - <span class="number">1</span>) &#123;</span><br><span class="line">    aLeft := h0</span><br><span class="line">    bLeft := h1</span><br><span class="line">    cLeft := h2</span><br><span class="line">    dLeft := h3</span><br><span class="line">    eLeft := h4</span><br><span class="line"></span><br><span class="line">    aRight := h0</span><br><span class="line">    bRight := h1</span><br><span class="line">    cRight := h2</span><br><span class="line">    dRight := h3</span><br><span class="line">    eRight := h4</span><br><span class="line"><span class="comment">//每运行16步左右加密块要更换函数f</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j := <span class="number">0</span> to <span class="number">79</span>) &#123;</span><br><span class="line">        t0 := rotleft(s[j]) (aLeft + f(bLeft, cLeft, dLeft) + X[r[i]]) + eLeft</span><br><span class="line">        aLeft := eLeft;</span><br><span class="line">        eLeft := dLeft</span><br><span class="line">        dLeft := rotleft(<span class="number">10</span>) (c)</span><br><span class="line">        cLeft := bLeft</span><br><span class="line">        bLeft := t0</span><br><span class="line"></span><br><span class="line">        t1 := rotRight(s[j]) (aRight + f(bRight, cRight, dRight) + X[r[i]]) + eRight</span><br><span class="line">        aRight := eRight;</span><br><span class="line">        eRight := dRight</span><br><span class="line">        dRight := rotRight(<span class="number">10</span>) (c)</span><br><span class="line">        cRight := bRight</span><br><span class="line">        bRight := t1    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t := h1 + cLeft + dRight</span><br><span class="line">    h1 := h2 + dLeft + eRight</span><br><span class="line">    h2 := h3 + eLeft + aRight</span><br><span class="line">    h3 := h4 + aLeft + bRight</span><br><span class="line">    h4 := h0 + bLeft + cRight</span><br><span class="line">    h0 := t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-16步迭代运算"><a href="#3-5-16步迭代运算" class="headerlink" title="3.5 16步迭代运算"></a>3.5 16步迭代运算</h3><p>与MD5几乎一样，只是D是C的循环移位得到的，而MD5它们的值一样。<br>单步操作示意图：<br><img src="http://img.kongyixueyuan.com/ripemd%E5%8D%95%E6%AD%A5%E6%93%8D%E4%BD%9C.jpeg" alt="img">具体运算过程请查看MD5的运算。</p><h2 id="4-go语言封装的RipeMD160方法"><a href="#4-go语言封装的RipeMD160方法" class="headerlink" title="4 go语言封装的RipeMD160方法"></a>4 go语言封装的RipeMD160方法</h2><p>封装路径 “golang.org/x/crypto/ripemd160”</p><h3 id="4-1-pakage-ripeMD160-go代码"><a href="#4-1-pakage-ripeMD160-go代码" class="headerlink" title="4.1 pakage ripeMD160.go代码"></a>4.1 pakage ripeMD160.go代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto"</span></span><br><span class="line">    <span class="string">"hash"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    crypto.RegisterHash(crypto.RIPEMD160, New)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The size of the checksum in bytes.</span></span><br><span class="line"><span class="keyword">const</span> Size = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The block size of the hash algorithm in bytes.</span></span><br><span class="line"><span class="keyword">const</span> BlockSize = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _s0 = <span class="number">0x67452301</span></span><br><span class="line">    _s1 = <span class="number">0xefcdab89</span></span><br><span class="line">    _s2 = <span class="number">0x98badcfe</span></span><br><span class="line">    _s3 = <span class="number">0x10325476</span></span><br><span class="line">    _s4 = <span class="number">0xc3d2e1f0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// digest represents the partial evaluation of a checksum.</span></span><br><span class="line"><span class="keyword">type</span> digest <span class="keyword">struct</span> &#123;</span><br><span class="line">    s  [<span class="number">5</span>]<span class="keyword">uint32</span>       <span class="comment">// running context</span></span><br><span class="line">    x  [BlockSize]<span class="keyword">byte</span> <span class="comment">// temporary buffer</span></span><br><span class="line">    nx <span class="keyword">int</span>             <span class="comment">// index into x</span></span><br><span class="line">    tc <span class="keyword">uint64</span>          <span class="comment">// total count of bytes processed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.s[<span class="number">0</span>], d.s[<span class="number">1</span>], d.s[<span class="number">2</span>], d.s[<span class="number">3</span>], d.s[<span class="number">4</span>] = _s0, _s1, _s2, _s3, _s4</span><br><span class="line">    d.nx = <span class="number">0</span></span><br><span class="line">    d.tc = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a new hash.Hash computing the checksum.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">    result := <span class="built_in">new</span>(digest)</span><br><span class="line">    result.Reset()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> Size &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> BlockSize &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    nn = <span class="built_in">len</span>(p)</span><br><span class="line">    d.tc += <span class="keyword">uint64</span>(nn)</span><br><span class="line">    <span class="keyword">if</span> d.nx &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n := <span class="built_in">len</span>(p)</span><br><span class="line">        <span class="keyword">if</span> n &gt; BlockSize-d.nx &#123;</span><br><span class="line">            n = BlockSize - d.nx</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            d.x[d.nx+i] = p[i]</span><br><span class="line">        &#125;</span><br><span class="line">        d.nx += n</span><br><span class="line">        <span class="keyword">if</span> d.nx == BlockSize &#123;</span><br><span class="line">            _Block(d, d.x[<span class="number">0</span>:])</span><br><span class="line">            d.nx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p[n:]</span><br><span class="line">    &#125;</span><br><span class="line">    n := _Block(d, p)</span><br><span class="line">    p = p[n:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        d.nx = <span class="built_in">copy</span>(d.x[:], p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d0 *digest)</span> <span class="title">Sum</span><span class="params">(in []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// Make a copy of d0 so that caller can keep writing and summing.</span></span><br><span class="line">    d := *d0</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.</span></span><br><span class="line">    tc := d.tc</span><br><span class="line">    <span class="keyword">var</span> tmp [<span class="number">64</span>]<span class="keyword">byte</span></span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="number">0x80</span></span><br><span class="line">    <span class="keyword">if</span> tc%<span class="number">64</span> &lt; <span class="number">56</span> &#123;</span><br><span class="line">        d.Write(tmp[<span class="number">0</span> : <span class="number">56</span>-tc%<span class="number">64</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d.Write(tmp[<span class="number">0</span> : <span class="number">64</span>+<span class="number">56</span>-tc%<span class="number">64</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Length in bits.</span></span><br><span class="line">    tc &lt;&lt;= <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">uint</span>(<span class="number">0</span>); i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">        tmp[i] = <span class="keyword">byte</span>(tc &gt;&gt; (<span class="number">8</span> * i))</span><br><span class="line">    &#125;</span><br><span class="line">    d.Write(tmp[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d.nx != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"d.nx != 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> digest [Size]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> d.s &#123;</span><br><span class="line">        digest[i*<span class="number">4</span>] = <span class="keyword">byte</span>(s)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">1</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">8</span>)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">2</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">16</span>)</span><br><span class="line">        digest[i*<span class="number">4</span>+<span class="number">3</span>] = <span class="keyword">byte</span>(s &gt;&gt; <span class="number">24</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(in, digest[:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-package-ripemd160block"><a href="#4-1-package-ripemd160block" class="headerlink" title="4.1 package ripemd160block"></a>4.1 package ripemd160block</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"math/bits"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// work buffer indices and roll amounts for one line</span></span><br><span class="line"><span class="keyword">var</span> _n = [<span class="number">80</span>]<span class="keyword">uint</span>&#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">13</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _r = [<span class="number">80</span>]<span class="keyword">uint</span>&#123;</span><br><span class="line">    <span class="number">11</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">11</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same for the other parallel one</span></span><br><span class="line"><span class="keyword">var</span> n_ = [<span class="number">80</span>]<span class="keyword">uint</span>&#123;</span><br><span class="line">    <span class="number">5</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">13</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">14</span>,</span><br><span class="line">    <span class="number">12</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r_ = [<span class="number">80</span>]<span class="keyword">uint</span>&#123;</span><br><span class="line">    <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">11</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">8</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">11</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Block</span><span class="params">(md *digest, p []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> x [<span class="number">16</span>]<span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">var</span> alpha, beta <span class="keyword">uint32</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(p) &gt;= BlockSize &#123;</span><br><span class="line">        a, b, c, d, e := md.s[<span class="number">0</span>], md.s[<span class="number">1</span>], md.s[<span class="number">2</span>], md.s[<span class="number">3</span>], md.s[<span class="number">4</span>]</span><br><span class="line">        aa, bb, cc, dd, ee := a, b, c, d, e</span><br><span class="line">        j := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">            x[i] = <span class="keyword">uint32</span>(p[j]) | <span class="keyword">uint32</span>(p[j+<span class="number">1</span>])&lt;&lt;<span class="number">8</span> | <span class="keyword">uint32</span>(p[j+<span class="number">2</span>])&lt;&lt;<span class="number">16</span> | <span class="keyword">uint32</span>(p[j+<span class="number">3</span>])&lt;&lt;<span class="number">24</span></span><br><span class="line">            j += <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round 1</span></span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">16</span> &#123;</span><br><span class="line">            alpha = a + (b ^ c ^ d) + x[_n[i]]</span><br><span class="line">            s := <span class="keyword">int</span>(_r[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + e</span><br><span class="line">            beta = bits.RotateLeft32(c, <span class="number">10</span>)</span><br><span class="line">            a, b, c, d, e = e, alpha, b, beta, d</span><br><span class="line"></span><br><span class="line">            <span class="comment">// parallel line</span></span><br><span class="line">            alpha = aa + (bb ^ (cc | ^dd)) + x[n_[i]] + <span class="number">0x50a28be6</span></span><br><span class="line">            s = <span class="keyword">int</span>(r_[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + ee</span><br><span class="line">            beta = bits.RotateLeft32(cc, <span class="number">10</span>)</span><br><span class="line">            aa, bb, cc, dd, ee = ee, alpha, bb, beta, dd</span><br><span class="line"></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round 2</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">32</span> &#123;</span><br><span class="line">            alpha = a + (b&amp;c | ^b&amp;d) + x[_n[i]] + <span class="number">0x5a827999</span></span><br><span class="line">            s := <span class="keyword">int</span>(_r[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + e</span><br><span class="line">            beta = bits.RotateLeft32(c, <span class="number">10</span>)</span><br><span class="line">            a, b, c, d, e = e, alpha, b, beta, d</span><br><span class="line"></span><br><span class="line">            <span class="comment">// parallel line</span></span><br><span class="line">            alpha = aa + (bb&amp;dd | cc&amp;^dd) + x[n_[i]] + <span class="number">0x5c4dd124</span></span><br><span class="line">            s = <span class="keyword">int</span>(r_[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + ee</span><br><span class="line">            beta = bits.RotateLeft32(cc, <span class="number">10</span>)</span><br><span class="line">            aa, bb, cc, dd, ee = ee, alpha, bb, beta, dd</span><br><span class="line"></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round 3</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">48</span> &#123;</span><br><span class="line">            alpha = a + (b | ^c ^ d) + x[_n[i]] + <span class="number">0x6ed9eba1</span></span><br><span class="line">            s := <span class="keyword">int</span>(_r[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + e</span><br><span class="line">            beta = bits.RotateLeft32(c, <span class="number">10</span>)</span><br><span class="line">            a, b, c, d, e = e, alpha, b, beta, d</span><br><span class="line"></span><br><span class="line">            <span class="comment">// parallel line</span></span><br><span class="line">            alpha = aa + (bb | ^cc ^ dd) + x[n_[i]] + <span class="number">0x6d703ef3</span></span><br><span class="line">            s = <span class="keyword">int</span>(r_[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + ee</span><br><span class="line">            beta = bits.RotateLeft32(cc, <span class="number">10</span>)</span><br><span class="line">            aa, bb, cc, dd, ee = ee, alpha, bb, beta, dd</span><br><span class="line"></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round 4</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">64</span> &#123;</span><br><span class="line">            alpha = a + (b&amp;d | c&amp;^d) + x[_n[i]] + <span class="number">0x8f1bbcdc</span></span><br><span class="line">            s := <span class="keyword">int</span>(_r[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + e</span><br><span class="line">            beta = bits.RotateLeft32(c, <span class="number">10</span>)</span><br><span class="line">            a, b, c, d, e = e, alpha, b, beta, d</span><br><span class="line"></span><br><span class="line">            <span class="comment">// parallel line</span></span><br><span class="line">            alpha = aa + (bb&amp;cc | ^bb&amp;dd) + x[n_[i]] + <span class="number">0x7a6d76e9</span></span><br><span class="line">            s = <span class="keyword">int</span>(r_[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + ee</span><br><span class="line">            beta = bits.RotateLeft32(cc, <span class="number">10</span>)</span><br><span class="line">            aa, bb, cc, dd, ee = ee, alpha, bb, beta, dd</span><br><span class="line"></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// round 5</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="number">80</span> &#123;</span><br><span class="line">            alpha = a + (b ^ (c | ^d)) + x[_n[i]] + <span class="number">0xa953fd4e</span></span><br><span class="line">            s := <span class="keyword">int</span>(_r[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + e</span><br><span class="line">            beta = bits.RotateLeft32(c, <span class="number">10</span>)</span><br><span class="line">            a, b, c, d, e = e, alpha, b, beta, d</span><br><span class="line"></span><br><span class="line">            <span class="comment">// parallel line</span></span><br><span class="line">            alpha = aa + (bb ^ cc ^ dd) + x[n_[i]]</span><br><span class="line">            s = <span class="keyword">int</span>(r_[i])</span><br><span class="line">            alpha = bits.RotateLeft32(alpha, s) + ee</span><br><span class="line">            beta = bits.RotateLeft32(cc, <span class="number">10</span>)</span><br><span class="line">            aa, bb, cc, dd, ee = ee, alpha, bb, beta, dd</span><br><span class="line"></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// combine results</span></span><br><span class="line">        dd += c + md.s[<span class="number">1</span>]</span><br><span class="line">        md.s[<span class="number">1</span>] = md.s[<span class="number">2</span>] + d + ee</span><br><span class="line">        md.s[<span class="number">2</span>] = md.s[<span class="number">3</span>] + e + aa</span><br><span class="line">        md.s[<span class="number">3</span>] = md.s[<span class="number">4</span>] + a + bb</span><br><span class="line">        md.s[<span class="number">4</span>] = md.s[<span class="number">0</span>] + b + cc</span><br><span class="line">        md.s[<span class="number">0</span>] = dd</span><br><span class="line"></span><br><span class="line">        p = p[BlockSize:]</span><br><span class="line">        n += BlockSize</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-go实现RipeMD160算法应用"><a href="#5-go实现RipeMD160算法应用" class="headerlink" title="5 go实现RipeMD160算法应用"></a>5 go实现RipeMD160算法应用</h2><p>使用非常简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"golang.org/x/crypto/ripemd160"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ripemd160算法加密块</span></span><br><span class="line">    hasher := ripemd160.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将明文写入加密块</span></span><br><span class="line">    hasher.Write([]<span class="keyword">byte</span>(<span class="string">"helloword"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过加密块的方法对写入的明文进行加密，传参nil，表示没有新的信息和加密后的hash进行组合</span></span><br><span class="line">    hashBytes := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节转成字符串</span></span><br><span class="line">    hashString := fmt.Sprintf(<span class="string">"%x"</span>, hashBytes)</span><br><span class="line">    fmt.Println(hashString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">486202e6</span>b75a3b80034e2699b42ed7f4ceaf9a45</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第16章量子密码学</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC17%E7%AB%A0%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC17%E7%AB%A0%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="量子密码学"><a href="#量子密码学" class="headerlink" title="量子密码学"></a>量子密码学</h3><p>研究量子密码学的学科被称为量子密码学，是密码学的一个重要分支。它实际上是古老密码学一次一密概念和量子物理相结合的一个新产物。</p><a id="more"></a><h2 id="1-量子物理"><a href="#1-量子物理" class="headerlink" title="1 量子物理"></a>1 量子物理</h2><p>量子界的理论，都是无法进行解释的。你问为什么，没人能够回答你。现在科学家只是通过发现量子物理的一些特性对其进行应用，而无法对量子世界的理论进行论证或者解释。</p><p>量子界最著名的薛定谔的猫，大家很熟悉，关于猫的死和活完全是由观察者说着算的。在量子世界里，未打开盒子之前，猫有两种可能性，此时属于叠加状态，它是活的也是死的，但是盒子被打开后，猫的生死就定了。同时，打开盒子的人不同，结果可能也不同。这很好的说明了量子世界：什么东西都是概念性的，都是概率性的，每种可能都会被尝试。而我们处在的宏观世界，也可以叫经典世界，所有事物都具有确定性，完全与量子世界不同。</p><p>简单说一下量子物理的基本特性，具体如下：<br>1）测量塌缩性：<br>除非该量子态本身即为测量算符的本征态，否则对量子态进行测量会导致“波包塌缩”，即测量将会改变最初的量子态。<br>2）不确定性：<br>不能同时精确测量两个非对易物理量。<br>3）不可克隆性：<br>无法对一个未知的量子态进行精确的复制。<br>4）单个光子不可再分：<br>不存在半个光子</p><p>目前应用最广的量子力学是光子力学。光子具有波粒二象性：即说光子既具有一粒一粒的粒子的特性，又有像声波一样的波动性。当时间为瞬时值时，光子以粒子的形式传播；当时间为延续值时，光子以波的形式传播。光子在传导时会在某个方向上发生振荡，上、下、左、右，多数则是按照某个角度振荡，正常的太阳光是非极化的，在每一个方向都有光子振荡。当大量的光子在同一个方向振荡时，它们是极化的，极化滤波器只允许在同方向极化的光子通过，而其余方向则不能通过。光子的偏振有两个基，一是水平线和垂直线组成的基，称为线偏振光子，另一个是左对角线和右对角线组成的基，称为圆偏振光子。如果一个光子脉冲在一个给定的基上被极化后发送，而接收方在同一组基上测量，则可得到极化光度。反之，若接收方使用错误的基，则得到的是随机结果。所以光子的状态完全由观察者的测量器决定，在测量之前你永远不知道它现在处于什么状态，这个状态我们叫它量子纠缠状态。</p><h2 id="1-6-2-量子密码学"><a href="#1-6-2-量子密码学" class="headerlink" title="1.6.2 量子密码学"></a>1.6.2 量子密码学</h2><p>之前讲过一次一密这个密码概念，它具有无条件的安全性，但是一次一密乱码本的传送是最困难的，成本极其高昂，无法真正意义上的进行使用。但随着量子物理的研究，终于找到了解决了一次一密致命问题的方案，利用量子力学传输密码本。利用信息载体（例如光子等粒子）的量子特性，以量子态作为符号描述的密码称为量子密码。<br>量子密码的发展已有30多年的历史。20世纪60年代，美国人<code>Wiesner</code>以<code>量子钞票</code>的形式提出量子密码学的原始概念，并在正式发表文章中提出了更重要的共轭编码和概率信息传递的概念，正是后者称为量子密码学的原始萌芽。但是这个思想无法在当时年代接受。直到1984年，IBM公司的<code>Bennett</code>与加拿大的<code>Brasard</code>提出了量子密钥分配的新概念，以及一个量子密码分配协议–BB84协议，标志着量子密码的开始。有意思的是<code>Bennett</code>是<code>Wiesner</code>的大学同学。</p><p>量子密码体系包含了量子保密、量子认证、量子安全协议、量子密码分析等研究方向。</p><p>量子密码学基于量子物理特性，将信息隐藏在光子里，利用量子力学随机产生一个密钥并传输给接收者。密钥的形式都是以量子比特进行传输的，载体是光子。量子比特：利用量子的叠加原理，0和1叠加构成了量子态，这个量子态就叫量子比特。</p><p>举个例子说明量子密码学如何操作的：Alice是信息发送方，Bob是信息接收方，他们都有光子的圆偏振和线偏振两种检测器。</p><p>1）Alice将1，2，3，4四个光子发送给Bob，在发送之前Alice对这四个光子进行了测量，不过在测量之前Alice也不会知道结果是什么。1和2是用圆偏振；3和4是线偏振。测到的结果是1:左对角状态；2是右对角状态；3是水平状态；4是垂直状态。<br>2）Bob收到这四个被Alice测量过的光子之后，并不知道Alice是怎么顺序测量的，所以随机的用测量器对光子进行测量，他的测量顺序是1圆偏振；2是线偏振；3是圆偏振；4是线偏振。测到的结果是1:左对角状态；2是水平状态；3是右对角状态；4是垂直状态。<br>3）Bob把测量顺序和结果告诉Alice，公开信道即可。<br>4）Alice进行比较，告诉Bob哪些测量结果是对的，并且测量仪器也是对的。比如收到的1光子是左对角状态，那么通过圆偏振测量，出来的只能是左对角状态。<br>5）双方保留测量结果一致的值。规定左对角状态和水平状态用1表示，右对角状态和垂直状态用0表示。所以他们得到的比特序列是10<br>6）10就是他们进行加密的密钥</p><p>通过例子我们可以看出，量子密码属于对称密码学，双方共用一份密钥。</p><h2 id="1-6-3-量子密码学的安全性"><a href="#1-6-3-量子密码学的安全性" class="headerlink" title="1.6.3 量子密码学的安全性"></a>1.6.3 量子密码学的安全性</h2><p>量子密码的安全性不再是像其他密码分支那样去解决数学难题，而是用量子力学的物理特性来保证的。<br>接上边的例子，入侵者窃取到第4个光子，并进行了测量。他可能测量后的结果一样，也就是4光子的状态没变，此时，Bob接收到的4光子没有问题，测量结果也是对的。这种情况下Alice和Bob是察觉不到有窃听者的。但是窃听者经过测量后，光子的状态发生了改变，那么此时Bob接收到的光子也就不是Alice给发送的状态的，肯定测量结果也是不对的。这样Alice和Bob进行比对时也就发现了入侵者，然后重新进行新的光子传送。所以如果多个光子传送时，窃听者测量多个光子后，按照概率事件，肯定会被Alice和Bob发现的。而且量子是不能被复制的，所以光子在传输中不会被传输中被攻击者进行克隆复制。所以量子密码学是非常安全的。</p><p>现实中不光测量会改变光子的偏振方向，很小的干扰也会改变光子的偏振方向。在制造光子的时候，即使偏振的角度有一度的偏差，这些错误也会累积。物理学家目前只能在200公里内的范围内传输量子密钥。甚至用强光也会破坏量子探测器。互联网基础设施。</p><h2 id="1-6-4-量子密码学的发展"><a href="#1-6-4-量子密码学的发展" class="headerlink" title="1.6.4 量子密码学的发展"></a>1.6.4 量子密码学的发展</h2><p>量子技术的发展是对当前密码体系的巨大挑战，如果量子技术得到更大突破，那么整个现阶段的密码体系将会崩溃。很多数学难题，通过当前算力需要几万年的时间才能解出，但是通过量子技术可能就几个小时甚至更少时间。所以，量子密码学各国都在努力研究中。</p><p>目前已经有不少量子密码的应用出现了，但是大都是在政府，军事层面，民用还不算多。不过不久的明天，量子密码一定会代替现有的密码体系。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15章数字签名</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC16%E7%AB%A0%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC16%E7%AB%A0%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名在信息安全，包括身份认证、数据完整性、不可否认性以及匿名性有着重要应用，是现代密码学的重要分支。签名隶属于公钥密码学。签名过程：发送方用自己的私钥对发送信息进行所谓的加密运算，得到一个hash值，该hash值就是签名。使用时需要将签名和信息发给接收方。接受者用发送方公开的公钥和接收到的信息对签名进行验证，通过认证，说明接收到的信息是完整的、准确的，否则说明消息来源不对。</p><p>简单描述数字签名：私钥签名；公钥验签。</p><a id="more"></a><h2 id="1-普通签名"><a href="#1-普通签名" class="headerlink" title="1 普通签名"></a>1 普通签名</h2><p>签名只是用一把私钥，并且是发送方自己进行地签名动作，这类签名就是普通签名。常用的签名方法有较多，包括RSA数字签名、DSS数字签名、ElGamal数字签名、ECDSA数字签名等等。其中RSA和ECDSA签名已经在加密算法中有讲解。区块链项目中最常用的签名方法是ECDSA数字签名。签名和验签的原理不作讲解，感兴趣可以翻阅之前的章节。</p><p>因为ECDSA数字签名在区块链的重要性，我接下来只对它进行讲解如何应用。<br>下边代码展示简单地用ECDSA签名对数据BLOCK进行签名，上链之前需要先进行验证，验证通过之后才能上链。具体解析在代码中有说明。</p><p>过程：<br>1.通过ecdsa.GenerateKey产生一私钥；输出的私钥是指针类型；<br>2.通过私钥产生公钥；<br>3.对数据BLOCK进行hash运算，实际公链中就是挖矿过程；<br>4.为了可以给任何长度的data进行签名，我们创建自己的签名方法；<br>5.验证数据是否合法，也就是通过公钥对签名进行验证，通过后才能对数据进行上链动作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/ecdsa"</span></span><br><span class="line">    <span class="string">"crypto/elliptic"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的区块链块结构</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//1. 区块高度</span></span><br><span class="line">    Height <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//2. 上一个区块HASH</span></span><br><span class="line">    PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//3. 交易数据</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//4. 时间戳</span></span><br><span class="line">    Timestamp <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//5. 实际通过挖矿得到Hash</span></span><br><span class="line">    Hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 6. 随机数Nonce</span></span><br><span class="line">    Nonce <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用底层函数，产生私钥</span></span><br><span class="line">    prk,_:=ecdsa.GenerateKey(elliptic.P256(),rand.Reader)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成公钥</span></span><br><span class="line">    pubkey:=prk.PublicKey</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要上链的数据</span></span><br><span class="line">    data:=[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动创建一个区块信息，实际中，通过交易来触发自动创建block</span></span><br><span class="line">    block:=&amp;Block&#123;<span class="number">2</span>,<span class="literal">nil</span>,data,time.Now().Unix(),<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将block信息内容拼接成字节数组</span></span><br><span class="line">    blockbytes:=prepareData(block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对block进行hash运算，实际中是挖矿过程</span></span><br><span class="line">    blockHash:=sha256.Sum256(blockbytes)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//签名</span></span><br><span class="line">    signatrue,_:=Sign(blockHash[:],prk)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//验证，如果通过就进行上链处理，否则rollback</span></span><br><span class="line">    <span class="keyword">if</span> Verify(blockHash[:],signatrue,&amp;pubkey)&#123;</span><br><span class="line">        fmt.Println(<span class="string">"该block合法，可以上链"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"该Block不合法，rollback"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">prepareData</span><span class="params">(block *Block)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    Block:=block</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            Block.PrevBlockHash,</span><br><span class="line">            Block.Data,</span><br><span class="line">            IntToHex(Block.Timestamp),</span><br><span class="line">            Block.Data,</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(Block.Nonce)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(Block.Height)),</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64转换为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(data []<span class="keyword">byte</span>, privkey *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对要签名的信息进行sha256散列，生成一个长度为32的字节数组</span></span><br><span class="line">    digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过椭圆曲线方法对散列后的明文进行签名，返回两个big.int类型的大数</span></span><br><span class="line">    r, s, err := ecdsa.Sign(rand.Reader, privkey, digest[:])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将大数转换成字节数组，并拼接起来，形成签名</span></span><br><span class="line">    signature := <span class="built_in">append</span>(r.Bytes(), s.Bytes()...)</span><br><span class="line">    <span class="keyword">return</span> signature, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过公钥验证签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verify</span><span class="params">(data, signature []<span class="keyword">byte</span>, pubkey *ecdsa.PublicKey)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将明文转换成字节数组</span></span><br><span class="line">    digest := sha256.Sum256(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明两个大数r，s</span></span><br><span class="line">    r := big.Int&#123;&#125;</span><br><span class="line">    s := big.Int&#123;&#125;</span><br><span class="line">    <span class="comment">//将签名平均分割成两部分切片，并将切片转换成*big.int类型</span></span><br><span class="line">    sigLen := <span class="built_in">len</span>(signature)</span><br><span class="line">    r.SetBytes(signature[:(sigLen / <span class="number">2</span>)])</span><br><span class="line">    s.SetBytes(signature[(sigLen / <span class="number">2</span>):])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过公钥对得到的r，s进行验证</span></span><br><span class="line">    <span class="keyword">return</span> ecdsa.Verify(pubkey, digest[:], &amp;r, &amp;s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-群签名"><a href="#2-群签名" class="headerlink" title="2 群签名"></a>2 群签名</h2><p>1991年，<code>Chaum</code>和<code>Van Heyst</code>首次提出了群签名的概念。群签名允许一个群体中的任意一个成员以匿名的方式代表整个群体对消息进行签名。</p><p>群签名需要有一个集体，一般是公司。管理员通过认证添加群签名的成员，每个成员的签名都代表集体。利用群签名可以很好的隐藏组织结构。例如，一个公司的职员可以利用群签名方案代表公司进行签名，验证者（可能是公司顾客）只需要利用公司的群公钥进行签名的合法性验证。验证者并不知道该签名是由哪个职员所签名的。当发生争议时，群管理员可以识别出实际的签名者。当然，群签名还可以应用于电子投票、电子投标和电子现金等。</p><p>如何实现群签名呢？</p><ol><li>入群：群成员在入群之前都会向群管理进行申请入群，通过后，申请人会和群管理员达成交互式协议，该协议可生成群成员的私钥。群管理员对该密钥进行签名，并颁发给申请人，完成入群。群成员群管理员将群公钥对外公开。</li><li>签名：群成员通过自己的群密钥和群公钥对消息进行签名，得到群签名。</li><li>验证：通过输入群公钥和群签名用公开的某种验证方法进行验证，返回值只有真假，验证者无法计算得到签名者是群公钥里的具体人员，只知道该签名者属于群公钥里的，可以代表群体。</li><li>追踪：群管理员可以通过群签名得到具体是哪个群成员进行签名的。</li></ol><p>群签名是一个中心化的签名结构，该结构的算法都是群管理员定的，造成签名者的隐私没有做到真正的保障。</p><p>所以总结群签名有三点：<br>1.只有群体中的合法成员才能代表整个群体进行签名；<br>2.接收者可以用群公钥验证群签名的合法性，但不知道该群签名是群体具体哪个成员所签；、<br>3.在发生争议时，群管理员可以识别出实际的签名者。</p><h2 id="3-环签名"><a href="#3-环签名" class="headerlink" title="3 环签名"></a>3 环签名</h2><p>环签名由<code>Rivest</code>,<code>shamir</code>和<code>Tauman</code>三位密码学家在2001年首次提出。因签名中参数Ci(i=1,2,…,n)根据一定的规则首尾相接组成环状而得名。其实就是实际的签名者用其他可能签名者的公钥产生一个带有断口的环，然后用私钥将断口连成一个完整的环。</p><p>环签名可以认为是不可追踪的群签名，实际的操作过程都是自己完成的，没有群管理员。</p><p>签名者是某个群体的成员，他把其他群体的公钥拿来并加上自己的公钥组合成一个群公钥，然后用自己的私钥和群公钥对要发布的信息进行环签名。接收者接收到群公钥、签名和信息，然后对签名进行验证，如果签名来自群公钥，那么验证成功，否则消息不合法。</p><p>群公钥中签名者的公钥只是迷惑作用，并不对数据有任何操作。<br>形成的签名因为是每个其它群公钥产生的数据和自己用私钥产生的数据组成的环，自己的数据隐藏环中，攻击者很难找到签名者的公钥。所以签名者的隐私很好地被保护起来了。</p><h2 id="4-代理签名"><a href="#4-代理签名" class="headerlink" title="4 代理签名"></a>4 代理签名</h2><p>1996年，<code>Mambo</code>等人首次提出了代理签名的概念。在代理签名方案中，允许一个原始签名者把他的签名权利委托给一个称为代理签名者的人，然后代理签名者就可以代表原始签名者进行签名。代理签名者可用于需要委托权力的密码协议中，如电子现金、移动代理和移动通信等。</p><h2 id="5-盲签名"><a href="#5-盲签名" class="headerlink" title="5 盲签名"></a>5 盲签名</h2><p>1982年<code>Chaum</code>首次提出了盲签名的概念。盲签名允许使用者获得一个消息的签名，而签名者既不知道该消息的内容，也不知道该消息的签名。盲签名可用于需要提供匿名性的密码协议中，如电子投票和电子现金。</p><p>一个盲签名方案由以下部分组成。<br>1）消息盲化：使用者利用盲因子对要签名的信息进行盲化处理，然后将盲化后的消息发送给签名者。<br>2）盲消息签名：签名者对盲化后的消息进行签名，因此他并不知道真实消息的具体内容。<br>3）恢复签名：使用者除去盲因子，得到真实消息的签名。</p><h2 id="6-零知识证明"><a href="#6-零知识证明" class="headerlink" title="6 零知识证明"></a>6 零知识证明</h2><p>零知识证明：实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。简单理解，就是证明者能够在不向验证者提供任何有用信息的情况下，让验证者相信你。</p><p>举个例子：<br>小明在逛商场时，把钱包弄丢了。广播播报：有人捡到一个钱包，在前台，请失主认领。<br>问题来了，小明如何向前台证明这个钱包一定是自己的呢？不是自己冒领？<br>这个案例，就是零知识证明的完美运用。</p><p>第一：前台为了避免人冒领，不会向小明泄露有关钱包的任何信息。<br>第二：小明必须提供准确无误的信息，证明钱包是自己的。<br>比如：浅谈问小明几个问题：<br>1、钱包的大小、颜色、品牌是什么？<br>2、钱包里有多少钱？有无证件？等等<br>如果小明全答对了，小明就是失主。<br>这种信息验证的手段，就是零知识证明。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13章HMAC哈希消息认证码</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC14%E7%AB%A0HMAC%E5%93%88%E5%B8%8C%E6%B6%88%E6%81%AF%E7%A0%81%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC14%E7%AB%A0HMAC%E5%93%88%E5%B8%8C%E6%B6%88%E6%81%AF%E7%A0%81%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="HMAC算法及golang实现代码详解"><a href="#HMAC算法及golang实现代码详解" class="headerlink" title="HMAC算法及golang实现代码详解"></a>HMAC算法及golang实现代码详解</h3><h2 id="1-HMAC算法概述"><a href="#1-HMAC算法概述" class="headerlink" title="1 HMAC算法概述"></a>1 HMAC算法概述</h2><p>HMAC算法中文名称叫哈希消息认证码，英文全称是Hash-based Message Authentication Code。它的算法是基于某个哈希散列函数（主要是SHA系列和MD系列），以一个密钥和一个消息为输入，生成一个消息摘要作为输出。HMAC算法与其他哈希散列算法最大区别就是需要有密钥。它的算法函数是利用分组密码来建立的一个单向Hash函数。</p><a id="more"></a>下表显示具体的算法对应输出摘要的长度。<table><thead><tr><th align="left">算法</th><th align="left">摘要长度（位）</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">HmacMD5</td><td align="left">128</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacSHA1</td><td align="left">160（20个字节）</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacSHA256</td><td align="left">256</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacSHA384</td><td align="left">384</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacSHA512</td><td align="left">512</td><td align="left">JAVA6实现</td></tr><tr><td align="left">HmacMD2</td><td align="left">128</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacMD4</td><td align="left">128</td><td align="left">BouncyCastle实现</td></tr><tr><td align="left">HmacSHA224</td><td align="left">224</td><td align="left">BouncyCastle实现</td></tr></tbody></table><p>HMAC的密钥可以是任何长度，如果密钥的长度超过了摘要算法信息分组的长度，则首先使用摘要算法计算密钥的摘要作为新的密钥。一般不建议使用太短的密钥，因为密钥的长度与安全强度是相关的。通常选取密钥长度不小于所选用摘要算法输出的信息摘要的长度。</p><h2 id="2-HMAC算法分析"><a href="#2-HMAC算法分析" class="headerlink" title="2 HMAC算法分析"></a>2 HMAC算法分析</h2><p>HMAC的算法原理比较简单，算法公式是: HMAC(K,M)=H(K ^ opad | [H(K ^ ipad∣M)])<br>其中<br>K，M为输入参数密钥和消息；<br>H 代表所采用的HASH算法(如SHA-256);<br>opad 用16进制字0x5c重复B次;<br>ipad 用016进制字x36重复B次;<br>按位异或运算符”^”；按位或运算符”|”；</p><p>分析公式运算过程：<br>1.将密钥通过K ^ opad进行处理得到Kopad；<br>2.处理消息：K ^ ipad得到的Kipad与消息M组合，得到MK，对MK进行Hash运算得到MH<br>3.拼接处理后的Kopad和MH，得到MM<br>4.对MM进行Hash运算，得到的值就是HMAC的散列值。</p><h2 id="3-HMAC算法运算过程"><a href="#3-HMAC算法运算过程" class="headerlink" title="3 HMAC算法运算过程"></a>3 HMAC算法运算过程</h2><p>首先先看一下HMAC运算过程的流程图，然后再一步步分析它。<br><img src="http://img.kongyixueyuan.com/HMAC%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.png" alt="img"></p><p>（1）检查密钥K的长度。如果K的长度大于B，则先使用该HMAC算法内的散列算法，算出一个长度为L的新密钥。如果后K的长度小于B，则在其后面追加0来使其长度达到B。</p><p>（2）将上一步生成的B字长的密钥字符串与ipad做异或运算，得到Kipad。</p><p>（3）将需要处理的数据流M填充至第二步的结果字符串中。也就是把M append到Kipad里。</p><p>（4）使用该HMAC算法内的散列算法H计算上一步中生成的数据流的信息摘要值。</p><p>（5）将第一步生成的B字长密钥字符串与opad做异或运算。</p><p>（6）再将第四步得到的结果填充到第五步的结果之后。</p><p>（7）使用哈希函数H计算上一步中生成的数据流的信息摘要值，输出结果就是最终的HMAC值。</p><p>上边提到的B代表H中所处理的块大小，这个大小是处理块大小，而不是输出hash的大小<br>如，SHA-1和SHA-256 B = 64<br>SHA-384和SHA-512 B = 128</p><p>由上述描述过程，我们知道HMAC算法的计算过程实际是对原文做了两次类似于添加剂处理的哈希过程。</p><h2 id="4-HMAC算法golang封装的代码详细解析"><a href="#4-HMAC算法golang封装的代码详细解析" class="headerlink" title="4 HMAC算法golang封装的代码详细解析"></a>4 HMAC算法golang封装的代码详细解析</h2><p>以下对封装好的HMAC的代码进行了详细解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"hash"</span></span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 原理公式 hmac = H([key ^ opad] H([key ^ ipad] text))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个hmac的结构体</span></span><br><span class="line"><span class="keyword">type</span> hmac <span class="keyword">struct</span> &#123;</span><br><span class="line">    size         <span class="keyword">int</span> <span class="comment">//散列函数MD5的输出数据字节数</span></span><br><span class="line">    B    <span class="keyword">int</span> <span class="comment">// 加密块的长度</span></span><br><span class="line">    opad, ipad   []<span class="keyword">byte</span> <span class="comment">//分别重复16进制0x36和0x5c，使其字节长度等于blocksize</span></span><br><span class="line">    outer, inner hash.Hash <span class="comment">//hmac外部和内部压缩函数，类型是实现MD5的接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理消息的组合方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmac)</span> <span class="title">Sum</span><span class="params">(in []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    origLen := <span class="built_in">len</span>(in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现Sum这个接口的方法如下：</span></span><br><span class="line">    <span class="comment">/*func (d0 *digest) Sum(in []byte) []byte &#123;</span></span><br><span class="line"><span class="comment">    d := *d0</span></span><br><span class="line"><span class="comment">    hash := d.checkSum()</span></span><br><span class="line"><span class="comment">    return append(in, hash[:]...)</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="comment">//通过实现的方法，我们可以看出in一般传参为nil；d0就是要加密的信息；</span></span><br><span class="line">    <span class="comment">//要是in不为空，则代表需要将in后边填充已经运算过一段信息的hash值。</span></span><br><span class="line">    <span class="comment">//in就是消息第一次被hash处理的数据</span></span><br><span class="line">    in = h.inner.Sum(in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出压缩函数保证初始hash为空</span></span><br><span class="line">    h.outer.Reset()</span><br><span class="line">    <span class="comment">//将key与0x5c异或后的数据，写入</span></span><br><span class="line">    h.outer.Write(h.opad)</span><br><span class="line">    <span class="comment">//再写入in</span></span><br><span class="line">    h.outer.Write(in[origLen:])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后得到组合后的数据，进行一次MD5运算就得到HMAC的hash值。</span></span><br><span class="line">    <span class="keyword">return</span> h.outer.Sum(in[:origLen])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmac)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.inner.Write(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法返回散列函数输出数据字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmac)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> h.size &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法返回散列函数的分割数据块字长</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmac)</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> h.B &#125;<span class="comment">//方法返回blocksize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmac)</span> <span class="title">Reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h.inner.Reset()</span><br><span class="line">    h.inner.Write(h.ipad)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个hmac对象去实现hash.Hash这个接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(h <span class="keyword">func</span>()</span> <span class="title">hash</span>.<span class="title">Hash</span>, <span class="title">key</span> []<span class="title">byte</span>) <span class="title">hash</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">    hm := <span class="built_in">new</span>(hmac)</span><br><span class="line">    hm.outer = h() <span class="comment">//输出压缩函数</span></span><br><span class="line">    hm.inner = h() <span class="comment">//输入压缩函数,函数是一个，都是MD5</span></span><br><span class="line"></span><br><span class="line">    hm.size = hm.inner.Size()<span class="comment">//散列函数MD5的输出数据字节数=16</span></span><br><span class="line">    hm.B = hm.inner.BlockSize()<span class="comment">//散列函数的分割数据块字长=64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个变量，用于去接收key变化之后的结果</span></span><br><span class="line">    hm.ipad = <span class="built_in">make</span>([]<span class="keyword">byte</span>, hm.B)</span><br><span class="line">    hm.opad = <span class="built_in">make</span>([]<span class="keyword">byte</span>, hm.B)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(key) &gt; hm.B &#123;</span><br><span class="line">        <span class="comment">// 如果密码长度太大，对它进行hash运算。</span></span><br><span class="line">        hm.outer.Write(key)</span><br><span class="line">        key = hm.outer.Sum(<span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将key覆盖到创建的两个变量中</span></span><br><span class="line">    <span class="built_in">copy</span>(hm.ipad, key)</span><br><span class="line">    <span class="built_in">copy</span>(hm.opad, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy key后的两个变量，分别将他的每一个元素与0x36和0x36异或运算</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> hm.ipad &#123;</span><br><span class="line">        hm.ipad[i] ^= <span class="number">0x36</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> hm.opad &#123;</span><br><span class="line">        hm.opad[i] ^= <span class="number">0x36</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将异或后的值写入hm里。</span></span><br><span class="line">    hm.inner.Write(hm.ipad)</span><br><span class="line">    hm.outer.Write(hm.opad)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运算对象，HMAC需要两个参数：key和hash函数</span></span><br><span class="line">    hmac := New(md5.New, []<span class="keyword">byte</span>(<span class="string">"23456uikjdfgh"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将明文写入到hmac中</span></span><br><span class="line">    hmac.Write([]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hmac对象对写入数据的运算</span></span><br><span class="line">    hashBytes:=hmac.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节转换成字符串</span></span><br><span class="line">    hash:= hex.EncodeToString(hashBytes)</span><br><span class="line"></span><br><span class="line">    fmt.Println(hash)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-用golang使用HMAC算法"><a href="#5-用golang使用HMAC算法" class="headerlink" title="5 用golang使用HMAC算法"></a>5 用golang使用HMAC算法</h2><p>使用非常简单，几行代码，不做解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/hmac"</span></span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Md5</span><span class="params">(data <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    md5 := md5.New()</span><br><span class="line">    md5.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">    md5Data := md5.Sum([]<span class="keyword">byte</span>(<span class="string">""</span>))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(md5Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hmac</span><span class="params">(key, data <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    hmac := hmac.New(md5.New, []<span class="keyword">byte</span>(key))</span><br><span class="line">    hmac.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hmac.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sha1</span><span class="params">(data <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sha1 := sha1.New()</span><br><span class="line">    sha1.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(sha1.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Md5(<span class="string">"hello"</span>))</span><br><span class="line">    fmt.Println(Hmac(<span class="string">"key2"</span>, <span class="string">"hello"</span>))</span><br><span class="line">    fmt.Println(Sha1(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章对称密码AES算法（分组密码）</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC6%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81AES%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC6%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81AES%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>AES英文全称是Advanced Encryption Standard,中文是高级加密标准。它的出现就是为了替代之前的加密标准DES。1997年1月2号，美国国家标准技术研究所（National Institute of Standards and Technology: NIST）发起征集高级加密标准算法的活动，目的是重新确立一种新的分组密码代替DES，成为新的美联邦信息处理的标准。该活动得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终获胜的是由两位比利时的著名密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法。2001年11月，NIST正式公布该算法，命名为AES算法。</p><a id="more"></a><h2 id="1-AES算法原理"><a href="#1-AES算法原理" class="headerlink" title="1. AES算法原理"></a>1. AES算法原理</h2><p>AES算法采用分组密码体制，即AES加密会首先把明文切成一段一段的，而且每段数据的长度要求必须是128位16个字节，如果最后一段不够16个字节，需要用Padding来把这段数据填满16个字节，然后分组对每段数据进行加密，最后再把每段加密数据拼起来形成最终的密文。AES算法的密钥长度可以有三种，分别是128位，256位，512位。<br>AES算法的加密过程使用了四个变换：字节替换变换（SubBytes）、行移位变换（SiftRows）、列混淆变换（MixColumns）和轮密钥加变换（AddRoundKey）。解密过程用了这四个变换的逆操作，分别是逆字节替换变换（InvSubBytes）、逆行移位变换（InvShiftRows）、逆列混淆变换（InvMixColumns）和轮密钥加变换。这里说明一下，轮密钥加变换的逆运算就是它本身，所以名字就通用一个。</p><h3 id="1-1-字节替换变换"><a href="#1-1-字节替换变换" class="headerlink" title="1.1 字节替换变换"></a>1.1 字节替换变换</h3><p>字节替换变换是一个非线形变换。输入的任意字节我们看作是有限域GF(2^8 )的元素，也就是这些字节都会在这个有限域内找到。在这个有限域内任何元素通过映射运算都会找到与之对应的元素，而且他们之间映射是可逆的。根据这个映射关系，制作了一个S盒对照表。根据这个表我们会很容易的查找对应的映射元素。如果输入的字节为xy，查找S盒中的第x行盒第y列找到对应的值，将其输出替换xy输出。例如1D，替换之后就是A4。S盒的制作方法这里不做讲解。</p><p>下表就是AES的S盒：<br><img src="http://img.kongyixueyuan.com/AES%20S%E7%9B%92.png" alt="img">注：S盒中的元素都是16进制,字母大写表示。</p><h3 id="1-2-逆字节替换变换"><a href="#1-2-逆字节替换变换" class="headerlink" title="1.2 逆字节替换变换"></a>1.2 逆字节替换变换</h3><p>逆字节替换变换是字节替换变换的逆变换。字节替换变换的映射运算是可逆的，所以根据映射逆运算也制作了一张逆S盒的对照表。查找方法与字节替换变换方法一样。例如A4，替换之后就是1D。逆S盒的制作方法这里也不做讲解。<br>下表就是AES的逆S盒：<br><img src="http://img.kongyixueyuan.com/AES%20%E9%80%86S%E7%9B%92.png" alt="img">注：逆S盒中的元素都是16进制,字母大写表示。</p><h3 id="1-3-行移位变换"><a href="#1-3-行移位变换" class="headerlink" title="1.3 行移位变换"></a>1.3 行移位变换</h3><p>行移位的功能是实现一个4x4矩阵内部字节之间的置换。AES算法的明文分组要求是每组的字节长度为16，就是因为能够刚好转换成4x4矩阵。<br>行移位的过程：第一行保持不变，第二行循环左移1个字节，第三行循环左移2个字节，第四行循环左移3个字节。<br>示意图如下：<br><img src="http://img.kongyixueyuan.com/Aes%E5%B7%A6%E7%A7%BB.png" alt="img"></p><h3 id="1-4-逆行移位变换"><a href="#1-4-逆行移位变换" class="headerlink" title="1.4 逆行移位变换"></a>1.4 逆行移位变换</h3><p>逆向行移位即是相反的操作。即第一行保持不变，第二行循环右移1个字节，第三行循环右移2个字节，第四行循环右移3个字节。</p><h3 id="1-5-列混淆变换"><a href="#1-5-列混淆变换" class="headerlink" title="1.5 列混淆变换"></a>1.5 列混淆变换</h3><p>列混淆变换将状态矩阵中的每一列视为系数在GF(2^8 )上的次数小于4的多项式与同一个固定的多项式a(x)进行模多项式m(x)=x^4 +1的乘法运算。在AES中，a(x)={03}x^3 +{01}x^2 +{01}x+{02}。</p><h3 id="1-6-逆列混淆变换"><a href="#1-6-逆列混淆变换" class="headerlink" title="1.6 逆列混淆变换"></a>1.6 逆列混淆变换</h3><p>逆列混淆变换是列混淆变换的逆，它将状态矩阵中的每一列视为系数在GF(2^ 8)上的次数小于4的多项式与同一个固定的多项式a^-1 (x)进行模多项式m(x)=x^4 +1的乘法运算。a^-1 (x)={0B}x^3 +{0D}x^2 +{09}x+{0E}。</p><h3 id="1-7-轮密钥加变换"><a href="#1-7-轮密钥加变换" class="headerlink" title="1.7 轮密钥加变换"></a>1.7 轮密钥加变换</h3><p>任何数和自身的异或结果为0。加密过程中，每轮的输入与轮密钥异或一次；因此，解密时再异或上该轮的密钥即可恢复输入。</p><h3 id="1-8-密钥扩展算法"><a href="#1-8-密钥扩展算法" class="headerlink" title="1.8 密钥扩展算法"></a>1.8 密钥扩展算法</h3><p>AES加密的每一轮用到的密钥都是不一样的。AES密钥扩展算法的输入值是4个字（16字节），输出值是一个由44个字组成（176字节）的一维线性数组。</p><h2 id="2-AES加密过程"><a href="#2-AES加密过程" class="headerlink" title="2. AES加密过程"></a>2. AES加密过程</h2><p>AES的解密就是加密的逆运算，所以这里我只讲解AES加密的过程。一般AES的每组明文加密需要重复10轮加密才能完成，所有分组的明文经过10轮加密后，拼接一起就是最后的密文。下面我只讲解一轮的加密过程。<br>每一轮的加密过程：</p><ol><li><p>将明文分成N组，每组长度为128比特，也就是16个字节；</p></li><li><p>将分组明文字节输出转换成16进制（字母大写输出）；</p></li><li><p>该轮分组</p></li><li><p>将分组明文进行字节替换；</p></li><li><p>字节替换后，转换成4X4矩阵，然后进行行移位变换；</p></li><li><p>将列混淆变换后的4X4矩阵，再进行列混淆变换，输出处理后的字节数组；</p></li><li><p>轮密钥加：经过第6步后的字节数组与轮密钥进行XOR异或运算得到新的字节数组；</p></li><li><p>第7部回到第4步</p><p>整体的加解密过程如下图：<br><img src="http://img.kongyixueyuan.com/AES%E5%8A%A0%E8%A7%A3%E5%AF%86.png" alt="img"></p></li></ol><h2 id="3-AES的安全性"><a href="#3-AES的安全性" class="headerlink" title="3. AES的安全性"></a>3. AES的安全性</h2><p>AES加密算法中，每轮使用不同的常数消除了密钥的对称性；使用了非对称性的密钥扩展算法消除了相同密钥的可能性；加密和解密使用不同的变换，从而消除了弱密钥和半弱密钥存在的肯能性。经过验证，AES加密算法能有效地抵抗现有的攻击，如差分攻击、相关密钥攻击、插值攻击等。</p><h2 id="4-golang实现AES-CFB加解密"><a href="#4-golang实现AES-CFB加解密" class="headerlink" title="4. golang实现AES_CFB加解密"></a>4. golang实现AES_CFB加解密</h2><p>AES_CFB加解密代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过CFB模式，进行AES加密</span></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESEncrypt</span><span class="params">(plaintext []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">//分组密钥,key字节的长度必须是16或24，或32；密钥的长度可以使用128位、192位或256位；位只有两种形式0和1，而字节是有8个位组成的。可以表示256个状态。1字节（byte）=8位（bit）</span></span><br><span class="line">    block,_:=aes.NewCipher(key)</span><br><span class="line">    <span class="comment">//block 是个*aes.aesCipherGCMiv 类型 包含encode 和decode  这两个code类型是[]uint32, n。 n=BlockSize+28，n是新创建enc和dec的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数组，目的是存储你接下来加密的密文</span></span><br><span class="line">    ciphertext:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,aes.BlockSize+<span class="built_in">len</span>(plaintext))</span><br><span class="line">    <span class="comment">//设置内存空间可读，类似在明文前面加入一个长度16切片，用于被读取内存流</span></span><br><span class="line">    iv :=ciphertext[:aes.BlockSize]</span><br><span class="line">    <span class="comment">//[]uint8</span></span><br><span class="line">    <span class="comment">//[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">    <span class="comment">//读内存流,把rand.reader随机读取的内存流数据复制到iv里</span></span><br><span class="line">    io.ReadFull(rand.Reader,iv)<span class="comment">//n是iv的长度</span></span><br><span class="line">    <span class="comment">//iv=[127 78 10 244 97 152 178 224 62 49 156 74 239 99 211 94]每次不一样，包含时间戳应该</span></span><br><span class="line">    <span class="comment">//设置加密模式，返回一个流，也就是把iv放到block里，返回stream流</span></span><br><span class="line">    <span class="comment">//下边方法将iv的数copy到block里的next字段的字节数组里</span></span><br><span class="line">    stream :=cipher.NewCFBEncrypter(block,iv)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;&#123;0xc42007e2a0 [127 78 10 244 97 152 178 224 62 49 156 74 239 99 211 94]（输出和读出的iv一样） [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 16 false&#125;</span></span><br><span class="line">    <span class="comment">//拿着你的密文进行异或运算，加密利用ciphertext[:aes.BlockSize]与明文进行异或,overlap使部分重叠</span></span><br><span class="line"></span><br><span class="line">    stream.XORKeyStream(ciphertext[aes.BlockSize:],plaintext)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecrypt</span><span class="params">(ciphertext []<span class="keyword">byte</span>,key []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">    block,_:=aes.NewCipher(key)</span><br><span class="line">    iv:=ciphertext[:aes.BlockSize]</span><br><span class="line">    ciphertext=ciphertext[aes.BlockSize:]</span><br><span class="line">    <span class="comment">//设置解密方式</span></span><br><span class="line">    stream :=cipher.NewCFBDecrypter(block,iv)</span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    stream.XORKeyStream(ciphertext,ciphertext)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="keyword">var</span> encryptcode = AESEncrypt([]<span class="keyword">byte</span>(<span class="string">"abc"</span>),[]<span class="keyword">byte</span>(<span class="string">"123456789abcdejg"</span>))</span><br><span class="line">    <span class="keyword">var</span> decryptcode =AesDecrypt( encryptcode,[]<span class="keyword">byte</span>(<span class="string">"123456789abcdejg"</span>))</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(decryptcode))</span><br><span class="line">    fmt.Println(base64.StdEncoding.EncodeToString(encryptcode))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-golang实现AES-CTR加解密"><a href="#5-golang实现AES-CTR加解密" class="headerlink" title="5. golang实现AES_CTR加解密"></a>5. golang实现AES_CTR加解密</h2><p>AES_CTR加解密代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/aes"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    str:=[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>)</span><br><span class="line">    key:=[]<span class="keyword">byte</span>(<span class="string">"12345678qwertyui"</span>)</span><br><span class="line">    encrypt:=AesCTR_Encrypt(str,key)</span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>,encrypt)</span><br><span class="line">    decrypt:=AesCTR_Decrypt(encrypt,key)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(decrypt))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCTR_Encrypt</span><span class="params">(plainText, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">//判断用户传过来的key是否符合16字节，如果不符合16字节加以处理</span></span><br><span class="line">    keylen := <span class="built_in">len</span>(key)</span><br><span class="line">    <span class="keyword">if</span> keylen == <span class="number">0</span> &#123; <span class="comment">//如果用户传入的密钥为空那么就用默认密钥</span></span><br><span class="line">        key = []<span class="keyword">byte</span>(<span class="string">"Abskjeqiu1234567"</span>) <span class="comment">//默认密钥</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> keylen &gt; <span class="number">0</span> &amp;&amp; keylen &lt; <span class="number">16</span> &#123; <span class="comment">//如果密钥长度在0到16之间，那么用0补齐剩余的</span></span><br><span class="line">        key = <span class="built_in">append</span>(key, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, (<span class="number">16</span> - keylen))...)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> keylen &gt; <span class="number">16</span> &#123;</span><br><span class="line">        key = key[:<span class="number">16</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.指定使用的加密aes算法</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.不需要填充,直接获取ctr分组模式的stream</span></span><br><span class="line">    <span class="comment">// 返回一个计数器模式的、底层采用block生成key流的Stream接口，初始向量iv的长度必须等于block的块尺寸。</span></span><br><span class="line">    iv := []<span class="keyword">byte</span>(<span class="string">"wumansgygoaesctf"</span>)</span><br><span class="line"></span><br><span class="line">    stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.加密操作</span></span><br><span class="line">    cipherText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(plainText))</span><br><span class="line">    stream.XORKeyStream(cipherText, plainText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipherText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesCTR_Decrypt</span><span class="params">(cipherText, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">//判断用户传过来的key是否符合16字节，如果不符合16字节加以处理</span></span><br><span class="line">    keylen := <span class="built_in">len</span>(key)</span><br><span class="line">    <span class="keyword">if</span> keylen == <span class="number">0</span> &#123; <span class="comment">//如果用户传入的密钥为空那么就用默认密钥</span></span><br><span class="line">        key = []<span class="keyword">byte</span>(<span class="string">"Abskjeqiu1234567"</span>) <span class="comment">//默认密钥</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> keylen &gt; <span class="number">0</span> &amp;&amp; keylen &lt; <span class="number">16</span> &#123; <span class="comment">//如果密钥长度在0到16之间，那么用0补齐剩余的</span></span><br><span class="line">        key = <span class="built_in">append</span>(key, bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, (<span class="number">16</span> - keylen))...)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> keylen &gt; <span class="number">16</span> &#123;</span><br><span class="line">        key = key[:<span class="number">16</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.指定算法:aes</span></span><br><span class="line">    block, err := aes.NewCipher(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.返回一个计数器模式的、底层采用block生成key流的Stream接口，初始向量iv的长度必须等于block的块尺寸。</span></span><br><span class="line">    iv := []<span class="keyword">byte</span>(<span class="string">"wumansgygoaesctf"</span>)</span><br><span class="line">    stream := cipher.NewCTR(block, iv)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.解密操作</span></span><br><span class="line">    plainText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(cipherText))</span><br><span class="line">    stream.XORKeyStream(plainText, cipherText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plainText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">40</span>dbbf4ab999bb36d0d5</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章对称密码3DES算法（分组密码）</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC5%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%813DES%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC5%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%813DES%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="3DES算法"><a href="#3DES算法" class="headerlink" title="3DES算法"></a>3DES算法</h3><p>3DES，或叫3重DES，英文全称是triple-DES，是普通DES的升级改进版。在AES未出现之前，DES加密慢慢被发现存有较大的安全性，为此3DES作为过渡期的重要对称加密诞生了。1999年，NIST将3-DES指定为过渡的加密标准。<br>3DES并不是一个全新的加密算法，它可以被认为是DES系列的加密范畴。DES的密钥长度是8个字节，由于长度较短，较容易被暴力破解。增加密钥的长度成为提高DES安全性的重大突破口。密钥长度增加至2倍，也就是2DES（双重DES），但这个算法存在一种中间相遇攻击隐患，对其安全性构成了威胁，所以实际应用中，很少或不推荐双重DES。密码长度增加至3倍，也就是3DES。该算法不仅很大提高了DES的安全性，而且还可以抵抗中间相遇攻击。到目前为止，还没有相关它被暴力破解或其它安全性受到威胁的信息。尽管已经公布了高级加密标准AES，但是目前3DES还被当作一个安全有效的加密算法在使用。</p><a id="more"></a><h2 id="1-3DES算法的原理及加解密过程"><a href="#1-3DES算法的原理及加解密过程" class="headerlink" title="1. 3DES算法的原理及加解密过程"></a>1. 3DES算法的原理及加解密过程</h2><p>密钥长度为192bit（也就是24字节），加密过程是进行3次DES加密或解密的密码算法叫3DES。<br>由于当时DES算法的应用较多，所以设计3DES不得不考虑与DES的兼容问题，也就是2者之间可以混用，3DES加密，DES能够解密，DES加密，3DES能够解密。最终IBM公司设计出来了合理方案，将第2重加密过程改为解密过程，整体的加密过程是加密–&gt;解密–&gt;加密，当3DES的密钥是DES密钥的3次重复时，两者完全兼容，此时的3DES实际只有最后一重加密是有效的。如果3DES的密钥不是DES密钥的3次重复，此时两者不存在兼容，3DES的第二重解密实际上也是加密过程，只不过用的DES的解密算法而已。<br>3DES加密解密过程首先对输入的私钥平均分成3组，每组密钥对应一重DES算法，其具体实现如下：<br>设Ek()和Dk()代表DES算法的加密和解密过程，k代表DES算法使用的密钥，M代表明文，C代表密文，这样：<br>3DES加密过程为：C=Ek3(Dk2(Ek1(M)))<br>3DES解密过程为：M=Dk1(EK2(Dk3(C)))</p><p>简单加密示意图如下：<br><img src="http://img.kongyixueyuan.com/3DES%E5%8A%A0%E5%AF%86.png" alt="img"></p><p>简单解密示意图如下：<br><img src="http://img.kongyixueyuan.com/3DES%E8%A7%A3%E5%AF%86.png" alt="img"></p><h2 id="2-Golang实现3DES-CBC模式加解密"><a href="#2-Golang实现3DES-CBC模式加解密" class="headerlink" title="2. Golang实现3DES_CBC模式加解密"></a>2. Golang实现3DES_CBC模式加解密</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/des"</span></span><br><span class="line">    <span class="string">"crypto/cipher"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blocksize <span class="keyword">int</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">  <span class="comment">//求得补码的长度x</span></span><br><span class="line">    padding := blocksize-<span class="built_in">len</span>(ciphertext)%blocksize</span><br><span class="line">    <span class="comment">//将x转换成字节，并创建一个长度为x，元素都为x的切片</span></span><br><span class="line">    padtext := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;,padding)</span><br><span class="line">    <span class="comment">//返回补码后要加密的明文</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(ciphertext,padtext...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//去码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">   <span class="comment">//求得加密时补码的长度，长度就等于密文最后元素的10进制数字</span></span><br><span class="line">    length:=<span class="built_in">len</span>(origData)</span><br><span class="line">    unpadding:=<span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">    <span class="comment">//返回去码之后要进行解密的密文</span></span><br><span class="line">    <span class="keyword">return</span> origData[:(length-unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3DES加密</span></span><br><span class="line"><span class="comment">////3DES的密钥长度必须为24位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleEncrypt</span><span class="params">(origData []<span class="keyword">byte</span>,key[]<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">    <span class="comment">//通过调用3des库里方法产生分组密钥块</span></span><br><span class="line">    block,_:=des.NewTripleDESCipher(key)</span><br><span class="line">    <span class="comment">//补码</span></span><br><span class="line">    origData = PKCS5Padding(origData,block.BlockSize())</span><br><span class="line">    <span class="comment">//设置加密模式，此处用CBC模式</span></span><br><span class="line">    blockMode:=cipher.NewCBCEncrypter(block,key[:<span class="number">8</span>])</span><br><span class="line">    <span class="comment">//创建密文数组，加密</span></span><br><span class="line">    crypted:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(origData))</span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    blockMode.CryptBlocks(crypted,origData)</span><br><span class="line">    <span class="keyword">return</span> crypted</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrileDesDecrypt</span><span class="params">(crypted, key []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">  <span class="comment">//设置分组的密钥块</span></span><br><span class="line">    block,_:=des.NewTripleDESCipher(key)</span><br><span class="line">    <span class="comment">//设置解密模式</span></span><br><span class="line">    blockMode:=cipher.NewCBCDecrypter(block,key[:<span class="number">8</span>])</span><br><span class="line">    <span class="comment">//创建切片</span></span><br><span class="line">    origData :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(crypted))</span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    blockMode.CryptBlocks(origData,crypted)</span><br><span class="line">    <span class="comment">//去码得到原文</span></span><br><span class="line">    origData=PKCS5UnPadding(origData)</span><br><span class="line">    <span class="keyword">return</span> origData</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="keyword">var</span> key=[]<span class="keyword">byte</span>(<span class="string">"123456789012345678901239"</span>)</span><br><span class="line">    <span class="keyword">var</span> encirtcode =TripleEncrypt([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>),key)</span><br><span class="line">    <span class="keyword">var</span> decryptcode=TrileDesDecrypt(encirtcode,key)</span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>,encirtcode)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(decryptcode))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章对称密码DES算法（分组密码）</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81DES%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC4%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81DES%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法，英文全称是Data Encryption Standard。于1973年5月被美国采纳为联邦信息处理标准。该标准每5年审查一次。因为DES的安全性出现问题，同时AES的出现，美联邦在1994年1月取消了DES作为联邦加密标准。DES加密不断被破解，其中用时最短的时间是22小时15分钟，所以DES算法现在应用越来越少了。</p><a id="more"></a>DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组。每组64比特的明文加密得到同样长度的密文。DES的密钥长度为64位。加密运算时实际用到的密钥长度是56位，原密钥舍弃掉8位比特，分别是每隔8位的比特，即原密钥的第8位，第16位，......，第64位。而舍弃掉的这8位比特作用是校验奇偶性的。这8个比特的定义如下：若其前面7个比特中有奇数个1，则该比特为0，反之为1。<h2 id="1-DES算法加密过程"><a href="#1-DES算法加密过程" class="headerlink" title="1. DES算法加密过程"></a>1. DES算法加密过程</h2><p>DES是一个迭代分组密码，在对明文加密之前先对明文进行补长，使补长后明文的比特长度模64为0，再按照每组64比特分组。依次对分组密文进行加密，最终把加密后的结果拼接一起，得到密文。<br>每组64位的输入数据块m的加密过程如下：</p><p>1) 首先m经过初始置换IP得到m0 ；<br>2) 将m0分成左右各为32比特两部分，记为m0 = L0 R0 ；<br>3) 对L0和R0进行16轮迭代运算加密，得到L16和R16；<br>4) 再对L16R16进行初始置换IP的逆初始置换IP^-1 ，得到该分组输入块的密文。<br>DES加密总体框架如下图：<br><img src="http://img.kongyixueyuan.com/DES%E6%A1%86%E6%9E%B6.png" alt="img"></p><h3 id="1-1-初始置换IP"><a href="#1-1-初始置换IP" class="headerlink" title="1.1 初始置换IP"></a>1.1 初始置换IP</h3><p>初始置换IP是将一个64比特的消息中的各个比特进行换位，目的是让消息中的各个比特的顺序错乱。设m=m1m2…m64，根据初始置换IP表进行置换。初始置换IP表里的元素代表m的第几位。置换原则是按行依次对m的每个比特进行替换，比如m1置换后是m58，m2置换后是m50，以此类推，最后的m64置换后是m7。经过置换后的分组明文块由两部分组成，记为L0R0。</p><p>初始置换IP表：</p><table><thead><tr><th align="left">IP</th></tr></thead><tbody><tr><td align="left">58 50 42 34 26 18 10 2</td></tr><tr><td align="left">60 52 44 36 28 20 12 4</td></tr><tr><td align="left">62 54 46 38 30 22 14 6</td></tr><tr><td align="left">64 56 48 40 32 24 16 8</td></tr><tr><td align="left">57 49 41 33 25 17 9 1</td></tr><tr><td align="left">59 51 43 35 27 19 11 3</td></tr><tr><td align="left">61 53 45 37 29 21 13 5</td></tr><tr><td align="left">63 55 47 39 31 23 15 7</td></tr></tbody></table><h3 id="1-2-16轮迭代运算"><a href="#1-2-16轮迭代运算" class="headerlink" title="1.2 16轮迭代运算"></a>1.2 16轮迭代运算</h3><p>迭代运算的结构是Feistel。在Feistel结构中，加密的每个过程称为轮，全过程就是若干轮的加密运算。DES第16轮加密运算与前15轮不一样，过程分为两步：1.和前15轮一样得到L16和R16；2.将得到的L16和R16两部分整体进行互换，得到最终的L16R16。<br>每一轮的运算规则如下：<br>Li = Ri-1<br>Ri = Li-1 ⊕ f(Ri-1 , ki)<br>其中L0和R0已知；⊕表示两个比特串按位异或，f是一个非线形函数，ki是由密钥按照一定规则每一轮生成的长度均为48位的比特串。<br>具体的迭代过程如下图所示：</p><p><img src="http://img.kongyixueyuan.com/DES%E8%BF%AD%E4%BB%A3.png" alt="img"></p><p>迭代过程中最重要的内容是每轮子密钥ki的生成和非线形函数f。下面我们依次分析这两部分内容。</p><h4 id="1-2-1-子密钥ki的生成"><a href="#1-2-1-子密钥ki的生成" class="headerlink" title="1.2.1 子密钥ki的生成"></a>1.2.1 子密钥ki的生成</h4><p>子密钥的生成是随着f函数的轮数顺序产生的。生成过程如下：<br>1） 给定一个64比特的初始密钥k，利用置换PC-1（表1.2.1）得到56位密钥，然后将这56位密钥分成左右两部分，前28比特记为C0，后28比特记为D0。经过这次置换就会丢弃掉8位比特，这在DES的开始部分已经有解释。<br>2） 对于第i轮，1&lt;=i&lt;=16，首先计算<br>Ci=LSi(Ci-1)<br>Di=LSi(Di-1)<br>其中，LSi表示左循环移位，当i=1，2，9，16时，左循环移1位，当i=3，4，5，6，7，8，10，11，12，13，14，15时，左循环移位2位。<br>经过上边的左移位后，我们会得到当前i轮的Ci和Di。<br>3） 将移位后的Ci和Di利用PC-2（表1.2.2）置换，最终得到长度为48位的比特串，也就是子密钥。</p><p>具体过程的示意图如下：<br><img src="http://img.kongyixueyuan.com/DES%E5%AD%90%E5%AF%86%E9%92%A5.png" alt="img"></p><p>表1.2.1</p><table><thead><tr><th align="left">PC-1</th></tr></thead><tbody><tr><td align="left">57 49 41 33 25 17 9</td></tr><tr><td align="left">1 58 50 42 34 26 18</td></tr><tr><td align="left">10 2 59 51 43 35 27</td></tr><tr><td align="left">19 11 3 60 52 44 36</td></tr><tr><td align="left">63 55 47 39 31 23 15</td></tr><tr><td align="left">7 62 54 46 38 30 22</td></tr><tr><td align="left">14 6 61 53 45 37 29</td></tr><tr><td align="left">21 13 5 28 20 12 4</td></tr></tbody></table><p>表1.2.2</p><table><thead><tr><th align="left">PC-2</th></tr></thead><tbody><tr><td align="left">14 17 11 24 1 5</td></tr><tr><td align="left">3 28 15 6 21 10</td></tr><tr><td align="left">23 19 12 4 26 8</td></tr><tr><td align="left">16 7 27 20 13 2</td></tr><tr><td align="left">41 52 31 37 47 55</td></tr><tr><td align="left">30 40 51 45 33 48</td></tr><tr><td align="left">44 49 39 56 34 53</td></tr><tr><td align="left">46 42 50 36 29 32</td></tr></tbody></table><h4 id="1-2-2-非线形函数f"><a href="#1-2-2-非线形函数f" class="headerlink" title="1.2.2 非线形函数f"></a>1.2.2 非线形函数f</h4><p>f函数的参数有两个变量，一个是32比特的Ri-1，另一个是48比特的ki，输出的结果为32比特。具体执行如下图：<br><img src="http://img.kongyixueyuan.com/DES%E5%87%BD%E6%95%B0f.png" alt="img"></p><p>过程是：</p><p>&lt;1&gt; Ri-1是每轮迭代运算初始值的右半部分。它的长度为32位。通过扩展置换E（表1.2.3）扩展成一个48比特的串；<br>扩展置换E表里的数字都是32比特串的第几位。通过表可以看出32比特串分成8组，每组4位，然后将每组的4位前后根据表扩展，如第一组前面添加32比特串的第32位比特，后边添加32位比特串的第5位比特，其他依次类推。</p><p>&lt;2&gt; 48比特的串与长度一致的ki进行异或运算</p><p>&lt;3&gt; 将&lt;2&gt;步得到的48比特串分成8个6比特的串，即为A1A2A3A4A5A6A7A8</p><p>&lt;4&gt; 将A1，A2，A3，A4，A5，A6，A7，A8分别作为8个S盒的输入，查表（表1.2.4）得到输出B1，B2，B3，B4，B5，B6，B7，B8；<br>每个S盒都是将6比特消息映射成一个4比特的消息。设Si盒的输入位6比特串x=x1x2x3x4x5x6，将x1x6转换成10进制的0～3的某个数，它对应表中的行数，将x2x3x4x5转换成0～15的10进制的某个数，它作为表的列号，利用行号和列号查询对应S盒表得到一个整数，将该整数转换成二进制就是输出结果。例如S1盒的输入是110011，则行号是11（第3行），列号是1001（第9列），查表得到整数11，再转换成二进制为1011，这就是1盒的输出结果。</p><p>&lt;5&gt; 将8个S盒的输出拼接一起得到B1B2B3B4B5B6B7B8，再将这32比特的串使用置换运算P（表1.2.5）得到最后的结果，也就是每轮函数f的输出。<br>置换运算P：P盒置换将每一位输入位映射到输出位。任何一位都不能被映射两次，也不能被略去。映射规则是，参照置换P表，将32位的输入的第16位放在第一位，第七位放在第二位，第二十位放在第三位，以此类推。</p><p>表1.2.3<br><img src="http://img.kongyixueyuan.com/DES%E6%89%A9%E5%B1%95%E7%BD%AE%E6%8D%A2E.jpg" alt="img">备注：中间为32位，两侧为扩展位</p><p>表1.2.4：<br><img src="http://img.kongyixueyuan.com/DES%20S%E7%9B%92.gif" alt="img"></p><p>表1.2.5：</p><table><thead><tr><th align="left">置换P</th></tr></thead><tbody><tr><td align="left">16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10</td></tr><tr><td align="left">2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25</td></tr></tbody></table><h3 id="1-3-逆初始置换IP-1"><a href="#1-3-逆初始置换IP-1" class="headerlink" title="1.3 逆初始置换IP^-1"></a>1.3 逆初始置换IP^-1</h3><p>逆置换是初始置换的逆运算。参照表1.2.6，从初始置换规则中可以看到，原始数据的第1位置换到了第40位，第2位置换到了第8位。则逆置换就是将第40位置换到第1位，第8位置换到第2位。以此类推，逆置换规则如下。</p><p>表1.2.6：</p><table><thead><tr><th align="left">逆初始置换IP^-1</th></tr></thead><tbody><tr><td align="left">40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31</td></tr><tr><td align="left">38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29</td></tr><tr><td align="left">36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27</td></tr><tr><td align="left">34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25</td></tr></tbody></table><h2 id="2-DES算法解密过程"><a href="#2-DES算法解密过程" class="headerlink" title="2 DES算法解密过程"></a>2 DES算法解密过程</h2><p>加密和解密使用相同的算法。加密和解密唯一不同的是秘钥的次序是相反的。就是说如果每一轮的加密秘钥分别是K1、K2、K3…K16，那么解密秘钥就是K16、K15、K14…K1。为每一轮产生秘钥的算法也是循环的。加密是秘钥循环左移，解密是秘钥循环右移。解密秘钥每次移动的位数是：0、1、2、2、2、2、2、2、1、2、2、2、2、2、2、1。具体不做讲解。但是要注意一点，解密的结果并不一定是我们原来的加密数据，可能还含有你补得位，一定要把补位去掉才是你的原来的数据。</p><h2 id="3-DES算法特点"><a href="#3-DES算法特点" class="headerlink" title="3 DES算法特点"></a>3 DES算法特点</h2><p>1、分组加密算法：<br>以64位为分组。64位明文输入，64位密文输出。</p><p>2、对称算法：<br>加密和解密使用同一秘钥</p><p>3、有效密钥长度为56位<br>秘钥通常表示为64位数，但每个第8位用作奇偶校验，可以忽略。</p><p>4、代替和置换<br>DES算法是两种加密技术的组合：混乱和扩散。先替代后置换。</p><p>5、易于实现<br>DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64 位，因此用70年代末期的硬件技术很容易实现</p><h2 id="4-golang实现DES-CBC模式加解密"><a href="#4-golang实现DES-CBC模式加解密" class="headerlink" title="4 golang实现DES_CBC模式加解密"></a>4 golang实现DES_CBC模式加解密</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/cipher"</span><span class="comment">//密码</span></span><br><span class="line">    <span class="string">"crypto/des"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span><span class="comment">//将对象转换成字符串</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//DES加密的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyDesEncrypt</span><span class="params">(origData,key[]<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">  <span class="comment">//生成加密块</span></span><br><span class="line">    block,_:=des.NewCipher(key)</span><br><span class="line">    <span class="comment">//按照blocksize的长度padding</span></span><br><span class="line">    origData =PKCS5Padding(origData,des.BlockSize)</span><br><span class="line">    <span class="comment">//设置加密方式</span></span><br><span class="line">    blockMode:=cipher.NewCBCEncrypter(block,key)</span><br><span class="line">    <span class="comment">//创建明文长度的字节数组</span></span><br><span class="line">    crypted :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(origData))</span><br><span class="line">    <span class="comment">//加密明文</span></span><br><span class="line">    blockMode.CryptBlocks(crypted,origData)</span><br><span class="line">    <span class="comment">//将字节数组转换成字符串</span></span><br><span class="line">    fmt.Println(base64.StdEncoding.EncodeToString(crypted))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//明文补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>,blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    padding:=blockSize-<span class="built_in">len</span>(ciphertext)%blockSize</span><br><span class="line"></span><br><span class="line">    padtext := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;,padding)<span class="comment">//补码过程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(ciphertext,padtext...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现去补码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>  &#123;</span><br><span class="line">    length:=<span class="built_in">len</span>(origData)</span><br><span class="line">    unpadding:=<span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> origData[:(length-unpadding)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DES解密方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyDESDecrypt</span><span class="params">(data <span class="keyword">string</span>,key []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//将字符串转换成字节数组</span></span><br><span class="line">     crypted,_:=base64.StdEncoding.DecodeString(data)</span><br><span class="line">     <span class="comment">//将字节密钥转换成block块</span></span><br><span class="line">     block,_:=des.NewCipher(key)</span><br><span class="line">     <span class="comment">//设置解密方式</span></span><br><span class="line">     blockMode:=cipher.NewCBCDecrypter(block,key)</span><br><span class="line">     <span class="comment">//创建秘文大小的数组变量</span></span><br><span class="line">     origData:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="built_in">len</span>(crypted))</span><br><span class="line">     <span class="comment">//解密秘文到数组origData中</span></span><br><span class="line">     blockMode.CryptBlocks(origData,crypted)</span><br><span class="line">     origData=PKCS5UnPadding(origData)</span><br><span class="line">     fmt.Println(<span class="keyword">string</span>((origData)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="comment">//声明一个密钥,利用此密钥实现明文的加密和解密</span></span><br><span class="line">    key :=[]<span class="keyword">byte</span>(<span class="string">"12345698"</span>)</span><br><span class="line">    MyDesEncrypt([]<span class="keyword">byte</span>(<span class="string">"hello world "</span> ),key)</span><br><span class="line">    MyDESDecrypt(<span class="string">"NIJWb9F1DO11q08fSnB/HA=="</span>,key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章非对称密码RSA算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC8%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81RSA%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC8%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81RSA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>RSA是目前使用最广泛的公钥密码体制之一。它是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。</p><a id="more"></a>RSA算法的安全性基于RSA问题的困难性，也就是基于大整数因子分解的困难性上。但是RSA问题不会比因子分解问题更加困难，也就是说，在没有解决因子分解问题的情况下可能解决RSA问题，因此RSA算法并不是完全基于大整数因子分解的困难性上的。<h2 id="1-RSA算法描述"><a href="#1-RSA算法描述" class="headerlink" title="1. RSA算法描述"></a>1. RSA算法描述</h2><h3 id="1-1-RSA产生公私钥对"><a href="#1-1-RSA产生公私钥对" class="headerlink" title="1.1 RSA产生公私钥对"></a>1.1 RSA产生公私钥对</h3><p>具体实例讲解如何生成密钥对<br>1.随机选择两个不相等的质数p和q。<br>alice选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p><p>2.计算p和q的乘积n。<br>n = 61×53 = 3233<br>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><p>3.计算n的欧拉函数φ(n)。称作L<br>根据公式φ(n) = (p-1)(q-1)<br>alice算出φ(3233)等于60×52，即3120。</p><p>4.随机选择一个整数e，也就是公钥当中用来加密的那个数字<br>条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。<br>alice就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><p>5.计算e对于φ(n)的模反元素d。也就是密钥当中用来解密的那个数字<br>所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。ed ≡ 1 (mod φ(n))<br>alice找到了2753，即17*2753 mode 3120 = 1</p><p>6.将n和e封装成公钥，n和d封装成私钥。<br>在alice的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p><h3 id="1-2-RSA加密"><a href="#1-2-RSA加密" class="headerlink" title="1.2 RSA加密"></a>1.2 RSA加密</h3><p>首先对明文进行比特串分组，使得每个分组对应的十进制数小于n，然后依次对每个分组m做一次加密，所有分组的密文构成的序列就是原始消息的加密结果，即m满足0&lt;=m&lt;n，则加密算法为：<br>c≡ m^e mod n; c为密文，且0&lt;=c&lt;n。</p><h3 id="1-3-RSA解密"><a href="#1-3-RSA解密" class="headerlink" title="1.3 RSA解密"></a>1.3 RSA解密</h3><p>对于密文0&lt;=c&lt;n，解密算法为：<br>m≡ c^d mod n;</p><h3 id="1-4-RSA签名验证"><a href="#1-4-RSA签名验证" class="headerlink" title="1.4 RSA签名验证"></a>1.4 RSA签名验证</h3><p>RSA密码体制既可以用于加密又可以用于数字签名。下面介绍RSA数字签名的功能。<br>已知公钥（e，n），私钥d<br>1.对于消息m签名为：sign ≡ m ^d mod n<br>2.验证：对于消息签名对（m，sign），如果m ≡ sign ^e mod n，则sign是m的有效签名</p><h2 id="2-已知公私钥，golang实现RSA加解密"><a href="#2-已知公私钥，golang实现RSA加解密" class="headerlink" title="2. 已知公私钥，golang实现RSA加解密"></a>2. 已知公私钥，golang实现RSA加解密</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/x509"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">    <span class="string">"encoding/pem"</span></span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可通过openssl产生</span></span><br><span class="line"><span class="comment">//openssl genrsa -out rsa_private_key.pem 1024</span></span><br><span class="line"><span class="keyword">var</span> privateKey = []<span class="keyword">byte</span>(<span class="string">`  </span></span><br><span class="line"><span class="string">-----BEGIN RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="string">MIICXQIBAAKBgQDfw1/P15GQzGGYvNwVmXIGGxea8Pb2wJcF7ZW7tmFdLSjOItn9</span></span><br><span class="line"><span class="string">kvUsbQgS5yxx+f2sAv1ocxbPTsFdRc6yUTJdeQolDOkEzNP0B8XKm+Lxy4giwwR5</span></span><br><span class="line"><span class="string">LJQTANkqe4w/d9u129bRhTu/SUzSUIr65zZ/s6TUGQD6QzKY1Y8xS+FoQQIDAQAB</span></span><br><span class="line"><span class="string">AoGAbSNg7wHomORm0dWDzvEpwTqjl8nh2tZyksyf1I+PC6BEH8613k04UfPYFUg1</span></span><br><span class="line"><span class="string">0F2rUaOfr7s6q+BwxaqPtz+NPUotMjeVrEmmYM4rrYkrnd0lRiAxmkQUBlLrCBiF</span></span><br><span class="line"><span class="string">u+bluDkHXF7+TUfJm4AZAvbtR2wO5DUAOZ244FfJueYyZHECQQD+V5/WrgKkBlYy</span></span><br><span class="line"><span class="string">XhioQBXff7TLCrmMlUziJcQ295kIn8n1GaKzunJkhreoMbiRe0hpIIgPYb9E57tT</span></span><br><span class="line"><span class="string">/mP/MoYtAkEA4Ti6XiOXgxzV5gcB+fhJyb8PJCVkgP2wg0OQp2DKPp+5xsmRuUXv</span></span><br><span class="line"><span class="string">720oExv92jv6X65x631VGjDmfJNb99wq5QJBAMSHUKrBqqizfMdOjh7z5fLc6wY5</span></span><br><span class="line"><span class="string">M0a91rqoFAWlLErNrXAGbwIRf3LN5fvA76z6ZelViczY6sKDjOxKFVqL38ECQG0S</span></span><br><span class="line"><span class="string">pxdOT2M9BM45GJjxyPJ+qBuOTGU391Mq1pRpCKlZe4QtPHioyTGAAMd4Z/FX2MKb</span></span><br><span class="line"><span class="string">3in48c0UX5t3VjPsmY0CQQCc1jmEoB83JmTHYByvDpc8kzsD8+GmiPVrausrjj4p</span></span><br><span class="line"><span class="string">y2DQpGmUic2zqCxl6qXMpBGtFEhrUbKhOiVOJbRNGvWW</span></span><br><span class="line"><span class="string">-----END RSA PRIVATE KEY-----</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//openssl</span></span><br><span class="line"><span class="comment">//openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span></span><br><span class="line"><span class="keyword">var</span> publicKey = []<span class="keyword">byte</span>(<span class="string">`  </span></span><br><span class="line"><span class="string">-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDfw1/P15GQzGGYvNwVmXIGGxea</span></span><br><span class="line"><span class="string">8Pb2wJcF7ZW7tmFdLSjOItn9kvUsbQgS5yxx+f2sAv1ocxbPTsFdRc6yUTJdeQol</span></span><br><span class="line"><span class="string">DOkEzNP0B8XKm+Lxy4giwwR5LJQTANkqe4w/d9u129bRhTu/SUzSUIr65zZ/s6TU</span></span><br><span class="line"><span class="string">GQD6QzKY1Y8xS+FoQQIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----    </span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaEncrypt</span><span class="params">(origData []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//解码pem格式的公钥，得到公钥的载体block</span></span><br><span class="line">    block, _ := pem.Decode(publicKey)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"public key error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析得到公钥</span></span><br><span class="line">    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接口类型断言</span></span><br><span class="line">    pub := pubInterface.(*rsa.PublicKey)</span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    <span class="keyword">return</span> rsa.EncryptPKCS1v15(rand.Reader, pub, origData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaDecrypt</span><span class="params">(ciphertext []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//解码pem格式的私钥，得到公钥的载体block</span></span><br><span class="line">    block, _ := pem.Decode(privateKey)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"private key error!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析得到PKCS1格式的私钥</span></span><br><span class="line">    priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="keyword">return</span> rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data, _ := RsaEncrypt([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">    fmt.Println(base64.StdEncoding.EncodeToString(data))</span><br><span class="line">    origData, _ := RsaDecrypt(data)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(origData))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-golang实现RSA生成公私钥并加解密"><a href="#3-golang实现RSA生成公私钥并加解密" class="headerlink" title="3. golang实现RSA生成公私钥并加解密"></a>3. golang实现RSA生成公私钥并加解密</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"encoding/base64"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过RSA实现加密和解密</span></span><br><span class="line"><span class="comment">//利用RSA的方法生成私钥对</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//RSA首先生成的是私钥，然后根据私钥生成公钥</span></span><br><span class="line">    <span class="comment">//生成1024位私钥</span></span><br><span class="line">    pri,_:=rsa.GenerateKey(rand.Reader,<span class="number">2048</span>)</span><br><span class="line">    <span class="comment">//根据私钥产生公钥</span></span><br><span class="line">    pub:=&amp;pri.PublicKey</span><br><span class="line">    <span class="comment">//fmt.Println("私钥",pri)</span></span><br><span class="line">    <span class="comment">//fmt.Println("公钥",pub)</span></span><br><span class="line">    <span class="comment">//定义明文</span></span><br><span class="line">    plaintext:=[]<span class="keyword">byte</span>(<span class="string">"hello china"</span>)</span><br><span class="line">    <span class="comment">//加密成密文,OAEP补码</span></span><br><span class="line">    ciphertext,_:=rsa.EncryptOAEP(md5.New(),rand.Reader,pub,plaintext,<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(base64.StdEncoding.EncodeToString(ciphertext))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    plaintext,_=rsa.DecryptOAEP(md5.New(),rand.Reader,pri,ciphertext,<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(plaintext))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-golang实现RSA签名和验签"><a href="#4-golang实现RSA签名和验签" class="headerlink" title="4. golang实现RSA签名和验签"></a>4. golang实现RSA签名和验签</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/rsa"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"crypto"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//RSA实现签名和验签</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//生成私钥</span></span><br><span class="line">    priv,_:=rsa.GenerateKey(rand.Reader,<span class="number">1024</span>)</span><br><span class="line">    <span class="comment">//产生公钥</span></span><br><span class="line">    pub:=&amp;priv.PublicKey</span><br><span class="line">    <span class="comment">//设置明文</span></span><br><span class="line">    plaintext:=[]<span class="keyword">byte</span>(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="comment">//给明文做哈希散列</span></span><br><span class="line">    h:=md5.New()</span><br><span class="line">    h.Write(plaintext)</span><br><span class="line">    hashed:=h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">//签名</span></span><br><span class="line">    opts:=&amp;rsa.PSSOptions&#123;SaltLength:rsa.PSSSaltLengthAuto,Hash:crypto.MD5&#125;</span><br><span class="line">    sign,_:=rsa.SignPSS(rand.Reader,priv,crypto.MD5,hashed,opts)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    e:=rsa.VerifyPSS(pub,crypto.MD5,hashed,sign,opts,)</span><br><span class="line">    <span class="keyword">if</span> e==<span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"验证成功"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"验证失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章非对称密码DSA算法</title>
      <link href="/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC9%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81DSA%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/17/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC9%E7%AB%A0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81DSA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="DSA算法"><a href="#DSA算法" class="headerlink" title="DSA算法"></a>DSA算法</h3><p>DSA（Digital Signature Algorithm）是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。</p><a id="more"></a>DSA加密算法主要依赖于整数有限域离散对数难题，素数P必须足够大，且p-1至少包含一个大素数因子以抵抗Pohlig &Hellman算法的攻击。M一般都应采用信息的HASH值。DSA加密算法的安全性主要依赖于p和g，若选取不当则签名容易伪造，应保证g对于p-1的大素数因子不可约。其安全性与RSA相比差不多。<p>DSA 一般用于数字签名和认证。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.</p><h2 id="1-DSA签名及验证"><a href="#1-DSA签名及验证" class="headerlink" title="1. DSA签名及验证"></a>1. DSA签名及验证</h2><p>DSA算法中应用了下述参数：</p><p>p：L bits长的素数。L是64的倍数，范围是512到1024；</p><p>q：p – 1的160bits的素因子；</p><p>g：g = h^((p-1)/q) mod p，h满足h &lt; p – 1, h^((p-1)/q) mod p &gt; 1；</p><p>x：x &lt; q，x为私钥 ；</p><p>y：y = g^x mod p ，( p, q, g, y )为公钥；</p><p>H( x )：One-Way Hash函数。DSS中选用SHA( Secure Hash Algorithm )。</p><p>p, q, g可由一组用户共享，但在实际应用中，使用公共模数可能会带来一定的威胁。</p><p>签名及验证协议：<br>1.P产生随机数k，k &lt; q；<br>2.P计算 r = ( g^k mod p ) mod q<br>s = ( k^(-1) (H(m) xr)) mod q<br>签名结果是( m, r, s )。<br>3.验证时计算 w = s^(-1)mod q<br>u1 = ( H( m ) <em>w ) mod q<br>u2 = ( r</em> w ) mod q<br>v = (( g^u1 * y^u2 ) mod p ) mod q<br>若v = r，则认为签名有效。</p><h2 id="2-golang实现DSA签名及验证"><a href="#2-golang实现DSA签名及验证" class="headerlink" title="2. golang实现DSA签名及验证"></a>2. golang实现DSA签名及验证</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/dsa"</span></span><br><span class="line">    <span class="string">"crypto/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="comment">//作用1 确保传递数据的完整性 2 确保数据的来源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//DSA专业做签名和验签</span></span><br><span class="line">    <span class="keyword">var</span> param dsa.Parameters<span class="comment">//结构体里有三个很大很大的数bigInt</span></span><br><span class="line">    <span class="comment">//结构体实例化</span></span><br><span class="line">    dsa.GenerateParameters(&amp;param,rand.Reader,dsa.L1024N160)<span class="comment">//L是1024，N是160，这里的L是私钥，N是公钥初始参数</span></span><br><span class="line">    <span class="comment">//通过上边参数生成param结构体，里面有三个很大很大的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成私钥</span></span><br><span class="line">    <span class="keyword">var</span> priv dsa.PrivateKey<span class="comment">//privatekey是个结构体，里面有publickey结构体，该结构体里有Parameters字段</span></span><br><span class="line">    priv.Parameters=param</span><br><span class="line">    <span class="comment">//通过随机读数与param一些关系生成私钥</span></span><br><span class="line">    dsa.GenerateKey(&amp;priv,rand.Reader)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过私钥生成公钥</span></span><br><span class="line">    pub:=priv.PublicKey</span><br><span class="line">    message:=[]<span class="keyword">byte</span>(<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="comment">//r,s是两个整数,通过私钥给message签名,得到两个随机整数r，s</span></span><br><span class="line">    r,s,_:=dsa.Sign(rand.Reader,&amp;priv,message)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用公钥验签，验证r，s</span></span><br><span class="line">    b:= dsa.Verify(&amp;pub,message,r,s)</span><br><span class="line">    <span class="keyword">if</span> b==<span class="literal">true</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"验签成功"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"验证失败"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章对称加密</title>
      <link href="/2019/03/16/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC2%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/03/16/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC2%E7%AB%A0%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密算法是应用较早的加密算法，技术成熟。</p><a id="more"></a><h2 id="1-对称加密的使用过程"><a href="#1-对称加密的使用过程" class="headerlink" title="1 对称加密的使用过程"></a>1 对称加密的使用过程</h2><p>在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。</p><h2 id="2-对称加密的特点"><a href="#2-对称加密的特点" class="headerlink" title="2 对称加密的特点"></a>2 对称加密的特点</h2><p>对称加密算法的<strong>特点</strong>是<strong>算法公开、计算量小、加密速度快、加密效率高</strong>。<strong>不足</strong>之处是，<strong>交易双方都使用同样钥匙，安全性得不到保证。</strong>此外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法的安全性取决于加密密钥的保存情况。<br>对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。而与公开密钥加密算法也就是非对称加密算法比起来，对称加密算法能够提供加密和认证，却缺乏了签名功能，使得使用范围有所缩小。</p><h2 id="3-对称加密的划分"><a href="#3-对称加密的划分" class="headerlink" title="3 对称加密的划分"></a>3 对称加密的划分</h2><p>对称加密分为<strong>序列密码</strong>和<strong>分组加密</strong>。<br><strong>序列密码，也叫流加密(stream cyphers)</strong>，<strong>依次加密明文中的每一个字节。</strong>加密是指利用用户的密钥通过某种复杂的运算（密码算法）产生大量的伪随机流，对明文流的加密。解密是指用同样的密钥和密码算法及与加密相同的伪随机流，用以还原明文流。<br><strong>分组密码，也叫块加密(block cyphers)</strong>，<strong>一次加密明文中的一个块</strong>。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。</p><h3 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h3><p>序列密码，也叫流密码，是利用种子密钥通过密钥流生成器产生与明文长度一致的伪随机序列，该随机序列与明文进行某种算法相结合产生的密文的一种密码算法。</p><p>使用序列密码对某一消息m执行加密操作时，都是按<strong>字</strong>进行加密的，一般是先将m分成连续的字符，m=m1m2m3…;然后使用密钥流k=k1k2k3…中的第i个字符ki对明文消息的第i字符mi执行加密变换，i=1,2,3…；所有的加密输出连接在一起就构成了对m执行加密后的密文。解密需要和加密同步进行，所以使用序列密码，发送方和接收方需要对明文或密文在信息的同一位置进行操作。<br>加解密过程示意图如下：<br><img src="http://img.kongyixueyuan.com/%E5%8A%A0%E8%A7%A3%E5%AF%86.png" alt="img" style="zoom:120%;" /></p><p><strong>序列密码</strong>具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点，但是因为这类密码主要运用在军事，政治机密机构上，因此它的研究成果较少有公开。目前可以公开在其他领域应用的算法有<strong>RC4</strong>，SEAL，A5等。</p><h4 id="1-一次一密密码"><a href="#1-一次一密密码" class="headerlink" title="1 . 一次一密密码"></a>1 . 一次一密密码</h4><p>一次一密加密是1917年Mauborgne和Vernam联合提出的一种理想加密方案，它要求对明文消息逐字符加密，每个字符加密都是独立的，加密的密钥是与明文长度一致的毫无规则随机的密钥序列，这个密钥序列就是一次一密乱码本。在使用时，密文发送方和接收方手里头都拥有一个一模一样的乱码本，该乱码本是由双方协商确定的一个足够长的随机密钥序列。发送方对明文进行加密时，用到的密钥序列是来自乱码本发送消息长度的最前面的一段，加密完后，立马对用过的密钥序列进行销毁。接收方收到密文后，用乱码本的密钥序列依次对密文进行解密，得到明，同时也要把用过的密钥序列进行销毁，不再使用。</p><p>一次一密的乱码本被认为是无条件安全的密码体制，即是一种不可攻破的密码体制。窃听者得到密文信息，根本没有可能对其进行解密，因为加密的密钥是完全随机的，毫无规律，攻击者没有任何信息对它进行密文分析。但前提是一次一密乱码本不能泄漏。<br>一次一密概念的提出对序列密码的产生提供了方向。正是基于这个概念，越来越多的序列密码算法不断产生。</p><h4 id="2-序列密码的结构"><a href="#2-序列密码的结构" class="headerlink" title="2. 序列密码的结构"></a>2. 序列密码的结构</h4><p><strong>序列密码的结构</strong>可细分为<strong>同步流密码和自同步流密码</strong>。</p><p>（1）同步流密码指它的<strong>密钥流的产生与明文无关</strong>，而是通过某种独立的随机方法产生的伪随机数字流。</p><p>（2）自同步流密码也叫异步流密码，它与同步流密码相反，<strong>密钥流的产生与明文有关</strong>，具体是后一个密钥字的产生与前一个明文加密后的字有关。自同步密码这个特性，使得它非常难以研究，所以大部分序列密码的研究都集中在同步密码上。</p><h5 id="2-1-同步流密码"><a href="#2-1-同步流密码" class="headerlink" title="2.1 同步流密码"></a>2.1 同步流密码</h5><p>同步流密码产生密码流的过程分为两部分，一个是密钥流产生器，另一个是加密变换器。<br>加密过程表达式是：ci=E(ki,mi)，参数都是字节数组的单个元素。解密过程和加密过程必须同步，表达式是一个。因为密钥流的产生每次都是不一样的。所以加密时，每次产生的密钥流元素先缓存到寄存器中，等解密用完这个元素以后再继续进行加密。整个过程有点类似tcp协议。目前最为常用的流密码体制是有限域GF(2)上的二元加法流密码，其加密变换可表示为ci=ki⊕mi。<br>特点：<br>1）<strong>同步要求</strong><br>在同步流密码中，发送方和接收方必须是同步的，即双方使用同样的密钥，对同一位置进行操作。一旦密文字符在传输中出现丢失，损坏或者删除，那么解密将失败<br>2）<strong>无错误传播</strong><br>密文字符在传输过程中被修改，只是对该字符产生影响，并不影响其他密文字符的解密。<br>3）<strong>主动攻击性破坏同步性</strong><br>作为同步要求的结果，主动攻击者对传输中的密文字符进行重放，插入，删除等破坏操作，直接会造成加解密过程的同步性。所以在使用时，需要借助其他密码学技术对传输的密文进行认证和完整性的验证操作。</p><h5 id="2-2-自同步流密码"><a href="#2-2-自同步流密码" class="headerlink" title="2.2 自同步流密码"></a>2.2 自同步流密码</h5><p>自同步密码的密钥流的产生不独立于明文流和密文流，通常第i个密钥字的产生不仅与主密钥有关，而且与前面已经产生的若干个密文字有关。<br>特点：<br>1）<strong>自同步</strong><br>发送方在传输密文流过程中，某些密文字符被攻击，接收方的解密只是在这些被攻击过的密文与发送方不同步，而其他密文流解密同步不会有问题。<br>2）<strong>有限的错误传播</strong><br>接收方的解密只是对攻击过的i个密文字符有影响，而对其他密文流不会有问题。所以产生的明文至多有i个错误。<br>3）<strong>主动攻击破坏当前的同步性</strong><br>4）<strong>明文统计扩算</strong><br>每个明文字符都会影响其后的整个密文，即明文的统计学特性扩散到了密文中。因此，自同步流密码在抵抗利用明文冗余而发起的攻击方面要强于同步流密码。</p><h5 id="2-3-密钥流生成器"><a href="#2-3-密钥流生成器" class="headerlink" title="2.3 密钥流生成器"></a>2.3 密钥流生成器</h5><p>流密钥的重要部分是密钥流生成器。理想的密钥流生成器是生成完全随机的密钥流，但实际中因为它是根据用户的私钥通过一定的算法产生的，不可能做到真正的随机，所以产生的密钥流是伪随机序列。<br>一个密钥流生成器通常由一个线形反馈移位寄存器（LFSR）和一个非线形组合部分构成。线形反馈移位寄存器可以称为驱动部分。其工作原理是将驱动部分在j时刻的状态变量x作为输入，输入到非线形组合部分f，将f（x）作为当前时刻的kj。驱动部分负责提供非线形组合部分使用的序列，而非线形部分以各时刻移位寄存器的状态组合出密钥序列j时刻的值kj。通俗讲就是驱动部分内部的变量是不断变化的，在每个不同时刻的值都是不一样的，它不断向非线形组合部分输入变量x的不同时刻的值，非线形组合部分接收到此时刻的x，通过函数f产生当前的密钥流字节。</p><h5 id="2-4-反馈移位寄存器"><a href="#2-4-反馈移位寄存器" class="headerlink" title="2.4 反馈移位寄存器"></a>2.4 反馈移位寄存器</h5><p>反馈移位寄存器是流密码产生密钥流的一个重要组成部分，GF(2)上一个n级反馈移位寄存器由n个二元存储器和一个反馈函数f(a1,a2,a3,a4,…,an)组成，n级反馈移位寄存器如下图所示。<br><img src="http://img.kongyixueyuan.com/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="img">)每一存储器称为移位寄存器的一级，在任一时刻，这些级的内容构成反馈位移寄存器的状态，在每一状态对应GF(2)上一个维向量，总共有2^n 种可能的状态。每一时刻的状态可用长为n的序列a1，a2，a3，…，an或者n维向量（a1，a2，a3，…，an）表示，其中ai是当前时刻第i级存储器的内容。初始状态由用户确定，当第i个移位时钟脉冲到来时，每一级存储器ai都将其内容向下一级ai-1传递，反馈函数f(a1,a2,a3,a4,…,an)根据寄存器当前的状态计算出下一时刻的an。反馈函数是一个n元布尔函数，即n个变量a1，a2，a3，…，an可以分别独立地取0和1两个可能的值，函数中的运算有逻辑与、逻辑或、逻辑补等运算，最后的函数值为0或1.</p><h3 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h3><p><strong>分组密码，也叫块加密，</strong>英文Block Cyper，一般先对明文m进行填充得到一个长度是固定分组长度s的整数倍明文串M；然后将M划分成一个个长度为s的分组；最后对每个分组使用同一个密钥执行加密变换。比较常见的算法有<strong>AES;DES;3DES。</strong></p><p>分组密码中，无论是明文块还是密文块，块与块之间都有一些逻辑运算关系，这些关系即为运算的模式。<br>比较常见的分组密码运算的五种模式：</p><ul><li>Electronic Code Book(ECB)电子密码本模式</li><li>Cipher Block Chaining(CBC)密码分组链接模式</li><li>Cipher Feedback Mode(CFB)加密反馈模式</li><li>Output Feedback Mode(OFB)输出反馈模式</li><li>Counter mode（CTR）计数器模式<br>目前推荐使用的是CBC模式和CTR模式，其它模式较少使用或不推荐使用。</li></ul><h4 id="1-Electronic-Code-Book-ECB-电子密码本模式"><a href="#1-Electronic-Code-Book-ECB-电子密码本模式" class="headerlink" title="1.Electronic Code Book(ECB)电子密码本模式"></a>1.Electronic Code Book(ECB)电子密码本模式</h4><p>ECB又称电子密码本模式，英文全称是Electronic codebook，是最基本的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，如果最后一块不足128位，使用填充(具体看算法，默认是0x00)，之后将每个块使用相同的密钥单独加密得到密文块，然后将密文块连在一起就得到密文了。解密同理。<br>下图展示ECB模式加解密的过程：<br>加密过程：<br><img src="http://img.kongyixueyuan.com/ECB%E5%8A%A0%E5%AF%86.jpg" alt="img"></p><p>解密过程：<br><img src="http://img.kongyixueyuan.com/ECB%E8%A7%A3%E5%AF%86.jpg" alt="img"></p><p>由此得知相同的明文内容将永远加密成相同的密文，而且密文的格式和明文也相同。这是很不安全的，尤其是传输图片或明文内容重复很多的情况下。由于所有分组的加密方式一致，明文中的重复内容会在密文中有所体现，因此难以抵抗统计分析攻击。还有因为明文和密文的内容顺序一致，攻击者很容易破坏密文。攻击者在密文传输过程中截获，并对密文内容次序打乱，接收密文信息者得到的密文就不可能解密成原本的明文信息了。这也是ECB模式很少使用的原因。</p><p>特点：<br>1.操作简单，易于实现，有利于并行计算，误差不会被传送；<br>2.不能隐藏明文的模式；<br>3.可能对明文进行主动攻击；</p><h4 id="2-Cipher-Block-Chaining-CBC-密码分组链接模式"><a href="#2-Cipher-Block-Chaining-CBC-密码分组链接模式" class="headerlink" title="2. Cipher Block Chaining(CBC)密码分组链接模式"></a>2. Cipher Block Chaining(CBC)密码分组链接模式</h4><p>CBC又称密文分组链接模式，英文全称是Cipher Block Chaining，之所以叫这个名字，是因为<strong>密文分组像链条一样相互连接在一起。</strong></p><p>在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。<br>若第一个块的下标为1，则CBC模式的加密过程为：<br>Ci = Ek (P ⊕ Ci-1), C0 = IV.<br>而其解密过程则为：<br>Pi = Dk (Ci) ⊕Ci-1, C0 = IV.</p><p>CBC模式运算过程示意图：<br><img src="http://img.kongyixueyuan.com/CBC%E5%8A%A0%E5%AF%86.jpg" alt="img"></p><p><img src="http://img.kongyixueyuan.com/CBC%E8%A7%A3%E5%AF%86.png" alt="img"></p><p>CBC算法优点：</p><ol><li><p>明文的重复排列不会反映在密文中</p></li><li><p>支持并行计算（仅解密）</p></li><li><p>能够解密任意密文分组</p><p>CBC算法缺点：</p></li><li><p>对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错</p></li><li><p>加密不支持并行计算</p></li></ol><h4 id="3-Cipher-Feedback-Mode-CFB-加密反馈模式"><a href="#3-Cipher-Feedback-Mode-CFB-加密反馈模式" class="headerlink" title="3. Cipher Feedback Mode(CFB)加密反馈模式"></a>3. Cipher Feedback Mode(CFB)加密反馈模式</h4><p>CFB又称密文反馈，英文全称为Cipher feedback。模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似。需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高x位与平文的x进行异或，以产生密文的x位。下一步将生成的x位密文移入寄存器中，并对下面的x位平文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位平文，再将密文的下面x位移入寄存器。<br>与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。</p><p>CFB模式运算过程示意图：<br>加密过程：<br><img src="http://img.kongyixueyuan.com/CFB%E5%8A%A0%E5%AF%86.png" alt="img">解密过程：<br><img src="http://img.kongyixueyuan.com/CFB%E8%A7%A3%E5%AF%86.png" alt="img"></p><p>CFB模式的优点：</p><ol><li>不需要填充（padding）</li><li>支持并行计算（仅解密）</li><li>能够解密任意密文分组</li></ol><p>CFB模式的缺点：</p><ol><li>加密不支持并行计算</li><li>对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错</li><li>不能抵御重放攻击</li></ol><h4 id="4-Output-Feedback-Mode-OFB-输出反馈模式"><a href="#4-Output-Feedback-Mode-OFB-输出反馈模式" class="headerlink" title="4. Output Feedback Mode(OFB)输出反馈模式"></a>4. Output Feedback Mode(OFB)输出反馈模式</h4><p>OFB：将分组密码作为同步序列密码运行，和CFB相似，不过OFB用的是前一个n位密文输出分组反馈回移位寄存器，OFB没有错误扩散问题。<br>输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。<br>每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于平文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将平文或密文进行并行的异或处理。<br>可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。</p><p>加密过程：<br><img src="http://img.kongyixueyuan.com/OFB%E5%8A%A0%E5%AF%86.png" alt="img"></p><p>解密过程：<br><img src="http://img.kongyixueyuan.com/OFB%E8%A7%A3%E5%AF%86.png" alt="img"></p><p>OFB模式的优点：</p><ol><li>不需要填充（padding）</li><li>可事先进行加密、解密的准备</li><li>加密、解密使用相同结构</li><li>对包含某些错误比特的密文进行解密时，只有铭文中相应的比特会出错</li></ol><p>OFB模式的缺点：</p><ol><li>不支持并行运算</li><li>主动攻击这反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</li></ol><h4 id="5-Counter-mode（CTR）计数器模式"><a href="#5-Counter-mode（CTR）计数器模式" class="headerlink" title="5. Counter mode（CTR）计数器模式"></a>5. Counter mode（CTR）计数器模式</h4><p>计数模式（CTR模式）加密是对一系列输入数据块(称为计数)进行加密，产生一系列的流密码，流密码与明文异或得到密文，同样解密就是流密码与密文异或得到明文。<br>数据块是加密之前通过将逐次累加的计数器产生不同的比特序列，它是由nonce和counter（分组序号）构成的。CTR计数器，长度是128比特(16字节)。前8个字节是叫做nonce的初始值，这个值每次加密都不相同。后8个字节则是分组序号，也就是不断+1得到的值。nonce的作用是让数据块内容复杂化。如果没有nonce，只有counter，数据块过于单一。Golang里封装的计数器实现与这里讲的有些许不同，首先初始化一个长度为BLOCK.SIZE()的初始向量iv，然后iv最后一个字节通过计数器逐组递增，同样也会产生分组加密之前不同的数据块。<br>加密的过程就是生成一个初始的计数器。假设有8个分组，就通过初始计数器不断+1得到8个计数器值，每个计数器值再加密得到密钥流，每个密钥流和对应分组明文异或得到密文。所以它的加密过程相当于一次一密。<br>CTR模式中可以以任意顺序对分组进行加密和解密，因为在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。<br>下图展示CTR模式的加解密的过程：<br>加密过程：<br><img src="http://img.kongyixueyuan.com/CTR%E5%8A%A0%E5%AF%86.png" alt="img">解密过程：<br><img src="http://img.kongyixueyuan.com/CTR%E8%A7%A3%E5%AF%86.png" alt="img"></p><p>CTR模式的优点：</p><ol><li>不需要填充（padding）</li><li>可事先进行加密、解密的准备</li><li>加密、解密使用相同的结构</li><li>对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错</li><li>支持并行计算（加密、解密）<br>CTR模式的缺点：</li><li>主动攻击者反转密文分组中的某些比特时，明文分组中对应的比特也会被反转</li><li>没有错误传播，不适合用于数据完整性认证。</li></ol><h4 id="6-分组密码模式比较"><a href="#6-分组密码模式比较" class="headerlink" title="6. 分组密码模式比较"></a>6. 分组密码模式比较</h4><table><thead><tr><th align="left">模式</th><th align="left">优点</th><th align="left">缺点</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">ECB模式</td><td align="left">简单 快速 支持并行运算</td><td align="left">明文中的重复排列反映在密文中 通过删除、替换密文分组可以对明文进行操作 对包含某些比特错误的密文进行解密时对应的分组会出错 不能抵御重放攻击</td><td align="left">不应使用</td></tr><tr><td align="left">CBC模式</td><td align="left">明文的重复排列不会反映在密文中 支持并行运算（仅解密） 能够解密任意密文分组</td><td align="left">对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错 加密不支持并行运算</td><td align="left">CRYPRTREC推荐 《应用密码学》推荐</td></tr><tr><td align="left">CFB模式</td><td align="left">不需要填充 支持并行计算（仅解密） 能够解密任意密文分组</td><td align="left">加密不支持并行计算 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错 不能抵御重放攻击</td><td align="left">CRYPRTREC推荐</td></tr><tr><td align="left">OFB模式</td><td align="left">不需要填充 可事先进行加密、解密的准备 加密、解密使用相同结构 对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错</td><td align="left">不支持并行计算 主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</td><td align="left">CRYPRTREC推荐</td></tr><tr><td align="left">CTR模式</td><td align="left">不需要填充 可事先进行加密、解密的准备 加密、解密使用相同结构 对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错 支持并行计算（加密、解密）</td><td align="left">主动攻击者反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转</td><td align="left">CRYPRTREC推荐 《应用密码学》推荐</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章密码学的发展及在区块链中的应用</title>
      <link href="/2019/03/16/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC1%E7%AB%A0%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%8A%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/03/16/%E5%AE%8C%E6%95%B4%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC1%E7%AB%A0%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%8A%E5%9C%A8%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="密码学的发展及在区块链中的应用"><a href="#密码学的发展及在区块链中的应用" class="headerlink" title="密码学的发展及在区块链中的应用"></a>密码学的发展及在区块链中的应用</h3><p>密码学的历史悠久，古时候主要应用于军事机密的传送，如“口令”，“暗号”等。在1970年之前，密码学的应用范畴大部分还是在政府层面，直到标准加密系统-数据加密标准和非对称加密算法的发明，密码学才逐步被深入应用在各个领域。</p><a id="more"></a><h2 id="1-密码学的发展历程"><a href="#1-密码学的发展历程" class="headerlink" title="1 密码学的发展历程"></a>1 密码学的发展历程</h2><p>密码学的发展大致可以分为三个阶段：古典密码学-&gt;现代密码学-&gt;公钥密码学<br>1.古典密码学：这阶段的核心密码学思想主要为代替和置换。代替就是将明文每个字符替换成另外一种字符产生密文，接收者根据对应的字符替换密文就得到明文了。置换就是将明文的字符顺序按照某种规则打乱。<br>2.现代密码学：这阶段的发展主要是对称加密算法。对称加密是发送方使用某种公开的算法使用密钥对明文进行加密，接收方使用之前发送方给予的密钥对密文进行解密得到明文。<br>3.公匙密码学：这个阶段的发展主要是非对称加密算法。非对称加密的原理是公钥加密，私钥解密。它的实现过程是A通过某种算法产生一对密钥，分别是公钥和私钥，然后将公钥公开。B想发送信息给A，就使用A的公钥对明文进行加密产生密文并发送给A。A接收到密文后，用自己的私钥对密文进行解密，得到明文。<br>对称加密解密的示意图如下：<br><img src="http://img.kongyixueyuan.com/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="img">非对称加密解密的示意图如下：<br><img src="http://img.kongyixueyuan.com/%E9%9D%9E%E5%AF%B9%E7%A7%B0.png" alt="img"></p><h2 id="2-密码学在区块链的应用"><a href="#2-密码学在区块链的应用" class="headerlink" title="2 密码学在区块链的应用"></a>2 密码学在区块链的应用</h2><p>密码学在区块链的应用非常广泛，可分为3类：对称加密算法、非对称加密算法和哈希散列算法。常见的方法有： Merkle tree 哈希树算法，椭圆曲线算法，SHA-256算法，Base58编码。作用有：通过hash算法快速查找；对明文进行加解密；对信息进行签名以及验证；产生数字证书；生成账户地址等。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
