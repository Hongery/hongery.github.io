<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kafka软件配置</title>
      <link href="/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/03/kafka%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h3><a id="more"></a><h4 id="第一步：安装java-JDK"><a href="#第一步：安装java-JDK" class="headerlink" title="第一步：安装java JDK"></a>第一步：安装java JDK</h4><h5 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h5><p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-jdk13-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk13-downloads.html</a></p><h5 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h5><p>双击下一步</p><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>在系统中新建</p><p>JAVA_HOME :C:\Program Files\Java\jdk-13.0.2</p><p>在PATH后面加上<code>;%JAVA_HOME%\bin</code></p><h5 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h5><p>打开cmd，输入javac，回车，</p><h5 id="第二步：安装zookeerper-java-jdk-kafka自带，可以跳过"><a href="#第二步：安装zookeerper-java-jdk-kafka自带，可以跳过" class="headerlink" title="第二步：安装zookeerper(java jdk  kafka自带，可以跳过)"></a>第二步：安装zookeerper(java jdk  kafka自带，可以跳过)</h5><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>下载地址<a href="http://apache.fayea.com/zookeerper" target="_blank" rel="noopener">http://apache.fayea.com/zookeerper</a></p><h5 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><p>将下载好的压缩包解压到本地即可</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1.将conf\zoo_sample.cfg复制一份，并重命名为zoo.cfg</p><p>2.打开上一步得到的zoo.cfg文件，修改dataDir=E:\zookeerper3.5.5\data(文件路径)</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>在zookeerper目录中执行bin\zkServer.cmd</p><h4 id="第三步：安装kafka"><a href="#第三步：安装kafka" class="headerlink" title="第三步：安装kafka"></a>第三步：安装kafka</h4><h5 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h5><p>下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a>,下载kafka_2.12-2.3.0.tgz.</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>将下好的压缩在本地就可以</p><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><p>1.打开config目录下的server.properties文件</p><p>2.修改log.dirs=E:\kafkalogs</p><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><p>执行bin\windows\kafka-server-start.bat config\server.properties</p>]]></content>
      
      
      <categories>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库context</title>
      <link href="/2020/03/02/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93context/"/>
      <url>/2020/03/02/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93context/</url>
      
        <content type="html"><![CDATA[<h1 id="Go标准库Context"><a href="#Go标准库Context" class="headerlink" title="Go标准库Context"></a>Go标准库Context</h1><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><a id="more"></a><h2 id="为什么需要Context"><a href="#为什么需要Context" class="headerlink" title="为什么需要Context"></a>为什么需要Context</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何接收外部命令实现退出</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker()</span><br><span class="line"><span class="comment">// 如何优雅的实现结束子goroutine</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量方式"><a href="#全局变量方式" class="headerlink" title="全局变量方式"></a>全局变量方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> exit <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量方式存在的问题：</span></span><br><span class="line"><span class="comment">// 1. 使用全局变量在跨包调用时不容易统一</span></span><br><span class="line"><span class="comment">// 2. 如果worker中再启动goroutine，就不太好控制了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> exit &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker()</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// sleep3秒以免程序过快退出</span></span><br><span class="line">exit = <span class="literal">true</span>                 <span class="comment">// 修改全局变量实现子goroutine的退出</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道方式存在的问题：</span></span><br><span class="line"><span class="comment">// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channel</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(exitChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-exitChan: <span class="comment">// 等待接收上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> exitChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(exitChan)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// sleep3秒以免程序过快退出</span></span><br><span class="line">exitChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;      <span class="comment">// 给子goroutine发送退出信号</span></span><br><span class="line"><span class="built_in">close</span>(exitChan)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方版的方案"><a href="#官方版的方案" class="headerlink" title="官方版的方案"></a>官方版的方案</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> worker2(ctx)</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"worker2"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 等待上级通知</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context初识"><a href="#Context初识" class="headerlink" title="Context初识"></a>Context初识</h2><p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel返回取消的函数</code>、<code>WithDeadline返回截至的时间</code>、<code>WithTimeout超时</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><h2 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h2><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>Deadline</code>方法需要返回当前<code>Context</code>被取消的时间，也就是完成工作的截止时间（deadline）；</p></li><li><p><code>Done</code>方法需要返回一个<code>Channel</code>，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用<code>Done</code>方法会返回同一个Channel；</p></li><li><pre><code>Err<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方法会返回当前</span><br></pre></td></tr></table></figure>Context<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结束的原因，它只会在</span><br></pre></td></tr></table></figure>Done<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  返回的Channel被关闭时才会返回非空的值；</span><br><span class="line"></span><br><span class="line">  - 如果当前`Context`被取消就会返回`Canceled`错误；</span><br><span class="line">  - 如果当前`Context`超时就会返回`DeadlineExceeded`错误；</span><br><span class="line"></span><br><span class="line">- `Value`方法会从`Context`中返回键对应的值，对于同一个上下文来说，多次调用`Value` 并传入相同的`Key`会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</span><br><span class="line"></span><br><span class="line">### Background()和TODO()</span><br><span class="line"></span><br><span class="line">Go内置两个函数：`Background()`和`TODO()`，这两个函数分别返回一个实现了`Context`接口的`background`和`todo`。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的`partent context`，衍生出更多的子上下文对象。</span><br><span class="line"></span><br><span class="line">`Background()`主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</span><br><span class="line"></span><br><span class="line">`TODO()`，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</span><br><span class="line"></span><br><span class="line">`background`和`todo`本质上都是`emptyCtx`结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</span><br><span class="line"></span><br><span class="line">## With系列函数</span><br><span class="line"></span><br><span class="line">此外，`context`包中还定义了四个With系列函数。</span><br><span class="line"></span><br><span class="line">### WithCancel</span><br><span class="line"></span><br><span class="line">`WithCancel`的函数签名如下：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>WithCancel</code>返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// return结束该goroutine，防止泄露</span></span><br><span class="line"><span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//context.Background根节点造子节点ctx</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 当我们取完需要的整数后调用cancel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p><h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><p><code>WithDeadline</code>的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span></span><br><span class="line"><span class="comment">// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"overslept"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以<code>ctx.Done()</code>会先接收到值，上面的代码会打印ctx.Err()取消原因。</p><h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h3><p><code>WithTimeout</code>的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p><code>WithTimeout</code>返回<code>WithDeadline(parent, time.Now().Add(timeout))</code>。</p><p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"db connecting ..."</span>)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"worker done!"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p><p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p><p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.WithValue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TraceCode <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">key := TraceCode(<span class="string">"TRACE_CODE"</span>)</span><br><span class="line">traceCode, ok := ctx.Value(key).(<span class="keyword">string</span>) <span class="comment">// 在子goroutine中获取trace code</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"invalid trace code"</span>)</span><br><span class="line">&#125;</span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"worker, trace code:%s\n"</span>, traceCode)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// 假设正常连接数据库耗时10毫秒</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 50毫秒后自动调用</span></span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"worker done!"</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置一个50毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">50</span>)</span><br><span class="line"><span class="comment">// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合</span></span><br><span class="line">ctx = context.WithValue(ctx, TraceCode(<span class="string">"TRACE_CODE"</span>), <span class="string">"12512312234"</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> worker(ctx)</span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">cancel() <span class="comment">// 通知子goroutine结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Context的注意事项"><a href="#使用Context的注意事项" class="headerlink" title="使用Context的注意事项"></a>使用Context的注意事项</h2><ul><li>推荐以参数的方式显示传递Context</li><li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li><li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li><li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li><li>Context是线程安全的，可以放心的在多个goroutine中传递</li></ul><h2 id="客户端超时取消示例"><a href="#客户端超时取消示例" class="headerlink" title="客户端超时取消示例"></a>客户端超时取消示例</h2><p>调用服务端API时如何在客户端实现超时控制？</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/server/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server端，随机出现慢响应</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">number := rand.Intn(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> number == <span class="number">0</span> &#123;</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>) <span class="comment">// 耗时10秒的慢响应</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">"slow response"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprint(w, <span class="string">"quick response"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, indexHandler)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context_timeout/client/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> respData <span class="keyword">struct</span> &#123;</span><br><span class="line">resp *http.Response</span><br><span class="line">err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCall</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">transport := http.Transport&#123;</span><br><span class="line">   <span class="comment">// 请求频繁可定义全局的client对象并启用长链接</span></span><br><span class="line">   <span class="comment">// 请求不频繁使用短链接</span></span><br><span class="line">   DisableKeepAlives: <span class="literal">true</span>, &#125;</span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Transport: &amp;transport,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">respChan := <span class="built_in">make</span>(<span class="keyword">chan</span> *respData, <span class="number">1</span>)</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://127.0.0.1:8000/"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"new requestg failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">req = req.WithContext(ctx) <span class="comment">// 使用带超时的ctx创建一个新的client request</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> wg.Wait()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line">fmt.Printf(<span class="string">"client.do resp:%v, err:%v\n"</span>, resp, err)</span><br><span class="line">rd := &amp;respData&#123;</span><br><span class="line">resp: resp,</span><br><span class="line">err:  err,</span><br><span class="line">&#125;</span><br><span class="line">respChan &lt;- rd</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//transport.CancelRequest(req)</span></span><br><span class="line">fmt.Println(<span class="string">"call api timeout"</span>)</span><br><span class="line"><span class="keyword">case</span> result := &lt;-respChan:</span><br><span class="line">fmt.Println(<span class="string">"call server api success"</span>)</span><br><span class="line"><span class="keyword">if</span> result.err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"call server api failed, err:%v\n"</span>, result.err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> result.resp.Body.Close()</span><br><span class="line">data, _ := ioutil.ReadAll(result.resp.Body)</span><br><span class="line">fmt.Printf(<span class="string">"resp:%v\n"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个100毫秒的超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class="number">100</span>)</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 调用cancel释放子goroutine资源</span></span><br><span class="line">doCall(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用go module导入本地</title>
      <link href="/2020/03/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go-module%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/"/>
      <url>/2020/03/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8go-module%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用go-module导入本地包"><a href="#如何使用go-module导入本地包" class="headerlink" title="如何使用go module导入本地包"></a>如何使用go module导入本地包</h1><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从<code>Go1.13</code>版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。到今天<code>Go1.14</code>版本推出之后<code>Go modules</code> 功能已经被正式推荐在生产环境下使用了。</p><p>这几天已经有很多教程讲解如何使用<code>go module</code>，以及如何使用<code>go module</code>导入gitlab私有仓库，我这里就不再啰嗦了。但是最近我发现很多小伙伴在群里问如何使用<code>go module</code>导入本地包，作为初学者大家刚开始接触package的时候肯定都是先在本地创建一个包，然后本地调用一下，然后就被卡住了。。。</p><p>这里就详细介绍下如何使用<code>go module</code>导入本地包。</p><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>假设我们现在有<code>moduledemo</code>和<code>mypackage</code>两个包，其中<code>moduledemo</code>包中会导入<code>mypackage</code>包并使用它的<code>New</code>方法。</p><p><code>mypackage/mypackage.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"mypackage.New"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在分两种情况讨论：</p><h2 id="在同一个项目下"><a href="#在同一个项目下" class="headerlink" title="在同一个项目下"></a>在同一个项目下</h2><p><strong>注意</strong>：在一个项目（project）下我们是可以定义多个包（package）的。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>现在的情况是，我们在<code>moduledemo/main.go</code>中调用了<code>mypackage</code>这个包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">moduledemo</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>这个时候，我们需要在<code>moduledemo/go.mod</code>中按如下定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后在<code>moduledemo/main.go</code>中按如下方式导入<code>mypackage</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"moduledemo/mypackage"</span>  <span class="comment">// 导入同一项目下的mypackage包</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>举一反三，假设我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── bubble</span><br><span class="line">    ├── dao</span><br><span class="line">    │   └── mysql.go</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── main.go</span><br></pre></td></tr></table></figure><p>其中<code>bubble/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/bubble</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>bubble/dao/mysql.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dao</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"mypackage.New"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bubble/main.go</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/q1mi/bubble/dao"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dao.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不在同一个项目下"><a href="#不在同一个项目下" class="headerlink" title="不在同一个项目下"></a>不在同一个项目下</h2><h3 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── moduledemo</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── mypackage</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── mypackage.go</span><br></pre></td></tr></table></figure><h3 id="导入包-1"><a href="#导入包-1" class="headerlink" title="导入包"></a>导入包</h3><p>这个时候，<code>mypackage</code>也需要进行module初始化，即拥有一个属于自己的<code>go.mod</code>文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module mypackage</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后我们在<code>moduledemo/main.go</code>中按如下方式导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"mypackage"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mypackage.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这两个包不在同一个项目路径下，你想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候我们就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p><p>在调用方也就是<code>packagedemo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>mypackage</code>这个包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module moduledemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">"mypackage"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"mypackage"</span> =&gt; <span class="string">"../mypackage"</span></span><br></pre></td></tr></table></figure><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><p>最后我们再举个例子巩固下上面的内容。</p><p>我们现在有文件目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── p1</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── main.go</span><br><span class="line">└── p2</span><br><span class="line">    ├── go.mod</span><br><span class="line">    └── p2.go</span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中想要导入<code>p2.go</code>中定义的函数。</p><p><code>p2/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module liwenzhou.com/q1mi/p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p><code>p1/main.go</code>中按如下方式导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"liwenzhou.com/q1mi/p2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p2.New()</span><br><span class="line">fmt.Println(<span class="string">"main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我并没有把<code>liwenzhou.com/q1mi/p2</code>这个包上传到<code>liwenzhou.com</code>这个网站，我们只是想导入本地的包，这个时候就需要用到<code>replace</code>这个指令了。</p><p><code>p1/go.mod</code>内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module github.com/q1mi/p1</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">require <span class="string">"liwenzhou.com/q1mi/p2"</span> v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line">replace <span class="string">"liwenzhou.com/q1mi/p2"</span> =&gt; <span class="string">"../p2"</span></span><br></pre></td></tr></table></figure><p>此时，我们就可以正常编译<code>p1</code>这个项目了。</p><p>说再多也没用，自己动手试试吧。</p>]]></content>
      
      
      <categories>
          
          <category> GO进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO依赖管理GO Module的使用</title>
      <link href="/2020/03/02/GO%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86GO-Module%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/02/GO%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86GO-Module%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言之依赖管理"><a href="#Go语言之依赖管理" class="headerlink" title="Go语言之依赖管理"></a>Go语言之依赖管理</h1><p>Go语言的依赖管理随着版本的更迭正逐渐完善起来。</p><a id="more"></a><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="为什么需要依赖管理"><a href="#为什么需要依赖管理" class="headerlink" title="为什么需要依赖管理"></a>为什么需要依赖管理</h2><p>最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？</p><h2 id="godep"><a href="#godep" class="headerlink" title="godep"></a>godep</h2><p>Go语言从v1.5开始开始引入<code>vendor</code>模式，如果项目目录下有vendor目录，那么go工具链会优先使用<code>vendor</code>内的包进行编译、测试等。</p><p><code>godep</code>是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具<code>dep</code>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行以下命令安装<code>godep</code>工具。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/tools/godep</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>安装好godep之后，在终端输入<code>godep</code>查看支持的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">godep save     将依赖项输出并复制到Godeps.json文件中</span><br><span class="line">godep go       使用保存的依赖项运行go工具</span><br><span class="line">godep get      下载并安装具有指定依赖项的包</span><br><span class="line">godep path     打印依赖的GOPATH路径</span><br><span class="line">godep restore  在GOPATH中拉取依赖的版本</span><br><span class="line">godep update   更新选定的包或go版本</span><br><span class="line">godep diff     显示当前和以前保存的依赖项集之间的差异</span><br><span class="line">godep version  查看版本信息</span><br></pre></td></tr></table></figure><p>使用<code>godep help [command]</code>可以看看具体命令的帮助信息。</p><h3 id="使用godep"><a href="#使用godep" class="headerlink" title="使用godep"></a>使用godep</h3><p>在项目目录下执行<code>godep save</code>命令，会在当前项目中创建<code>Godeps</code>和<code>vender</code>两个文件夹。</p><p>其中<code>Godeps</code>文件夹下有一个<code>Godeps.json</code>的文件，里面记录了项目所依赖的包信息。 <code>vender</code>文件夹下是项目依赖的包的源代码文件。</p><h3 id="vender机制"><a href="#vender机制" class="headerlink" title="vender机制"></a>vender机制</h3><p>Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。</p><p>例如查找项目的某个依赖包，首先会在项目根目录下的<code>vender</code>文件夹中查找，如果没有找到就会去<code>$GOAPTH/src</code>目录下查找。</p><h3 id="godep开发流程"><a href="#godep开发流程" class="headerlink" title="godep开发流程"></a>godep开发流程</h3><ol><li>保证程序能够正常编译</li><li>执行<code>godep save</code>保存当前项目的所有第三方依赖的版本信息和代码</li><li>提交Godeps目录和vender目录到代码库。</li><li>如果要更新依赖的版本，可以直接修改<code>Godeps.json</code>文件中的对应项</li></ol><h2 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h2><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p><ol><li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li><li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li><li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li></ol><p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p><p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>Go1.11之后设置GOPROXY命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn  //mac</span><br><span class="line"><span class="built_in">set</span> GOPROXY=https://goproxy.cn  //window</span><br></pre></td></tr></table></figure><p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用<a href="https://studygolang.com/topics/10014" target="_blank" rel="noopener">goproxy.cn</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>常用的<code>go mod</code>命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> download    下载依赖的module到本地cache（默认为$GOPATH/pkg/<span class="keyword">mod</span>目录）</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> <span class="keyword">edit</span>        编辑<span class="keyword">go</span>.<span class="keyword">mod</span>文件</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> graph       打印模块依赖图</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> init        初始化当前文件夹, 创建<span class="keyword">go</span>.<span class="keyword">mod</span>文件</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> tidy        增加缺少的module，删除无用的module</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> vendor      将依赖复制到vendor下</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> verify      校验依赖</span><br><span class="line"><span class="keyword">go</span> <span class="keyword">mod</span> why         解释为什么需要依赖</span><br></pre></td></tr></table></figure><h3 id="go-sum-pkg文件下"><a href="#go-sum-pkg文件下" class="headerlink" title="go  sum  pkg文件下"></a>go  sum  pkg文件下</h3><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>go.mod文件记录了项目所有的依赖信息和版本信息，其结构大致如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Q1mi/studygo/blogger</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586</span><br><span class="line">github.com/gin-gonic/gin v1.4.0</span><br><span class="line">github.com/go-sql-driver/mysql v1.4.1</span><br><span class="line">github.com/jmoiron/sqlx v1.2.0</span><br><span class="line">github.com/satori/go.uuid v1.2.0</span><br><span class="line">google.golang.org/appengine v1.6.1 // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>module</code>用来定义包名</li><li><code>require</code>用来定义依赖包及版本</li><li><code>indirect</code>表示间接引用</li></ul><h4 id="依赖的版本"><a href="#依赖的版本" class="headerlink" title="依赖的版本"></a>依赖的版本</h4><p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gopkg.in/tomb.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20141024135613</span>-dd632973f1e7</span><br><span class="line">gopkg.in/vmihailenco/msgpack.v2 v2<span class="number">.9</span><span class="number">.1</span></span><br><span class="line">gopkg.in/yaml.v2 &lt;=v2<span class="number">.2</span><span class="number">.1</span></span><br><span class="line">github.com/tatsushid/<span class="keyword">go</span>-fastping v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20160109021039</span>-d7bb493dee3e</span><br><span class="line">latest</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180820150726</span><span class="number">-614</span>d502a4dac</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180821023952</span><span class="number">-922</span>f4815f713 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180826012351</span><span class="number">-8</span>a410e7b638d</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p><ol><li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li><li>运行<code>go get package@version</code>将会升级到指定的版本号version</li></ol><p>如果下载所有依赖可以使用<code>go mod download</code>命令。</p><h3 id="整理依赖"><a href="#整理依赖" class="headerlink" title="整理依赖"></a>整理依赖</h3><p>我们在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下我们可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p><h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><h4 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -require=golang.org/x/text</span><br></pre></td></tr></table></figure><h4 id="移除依赖项"><a href="#移除依赖项" class="headerlink" title="移除依赖项"></a>移除依赖项</h4><p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -droprequire=golang.org/x/text</span><br></pre></td></tr></table></figure><p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p><h2 id="在项目中使用go-module"><a href="#在项目中使用go-module" class="headerlink" title="在项目中使用go module"></a>在项目中使用go module</h2><h3 id="既有项目"><a href="#既有项目" class="headerlink" title="既有项目"></a>既有项目</h3><p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p><ol><li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li><li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录<strong>每个依赖库的版本和哈希值。</strong></li></ol><h3 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h3><p>对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作：</p><ol><li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li><li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库time</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93time/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93time/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之time包"><a href="#Go语言基础之time包" class="headerlink" title="Go语言基础之time包"></a>Go语言基础之time包</h1><p>时间和日期是我们编程中经常会用到的，本文主要介绍了Go语言内置的time包的基本用法。</p><a id="more"></a><h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p>time包提供了时间的显示和测量用的函数。日历的计算采用的是公历。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p><code>time.Time</code>类型表示时间。我们可以通过<code>time.Now()</code>函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">fmt.Printf(<span class="string">"current time:%v\n"</span>, now)</span><br><span class="line"></span><br><span class="line">year := now.Year()     <span class="comment">//年</span></span><br><span class="line">month := now.Month()   <span class="comment">//月</span></span><br><span class="line">day := now.Day()       <span class="comment">//日</span></span><br><span class="line">hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := now.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。</p><p>基于时间对象获取时间戳的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()            <span class="comment">//获取当前时间</span></span><br><span class="line">timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">fmt.Printf(<span class="string">"current timestamp1:%v\n"</span>, timestamp1)</span><br><span class="line">fmt.Printf(<span class="string">"current timestamp2:%v\n"</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>time.Unix()</code>函数可以将时间戳转为时间格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo2</span><span class="params">(timestamp <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p><p>time包中定义的时间间隔类型的常量如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure><p>举个例子，求一个小时之后的时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">later := now.Add(time.Hour) <span class="comment">// 当前时间加1小时后的时间</span></span><br><span class="line">fmt.Println(later)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>求两个时间之间的差值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure><p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p><h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之前，返回真；否则返回假。</p><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之后，返回真；否则返回假。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>时间类型有一个自带的方法<code>Format</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。也许这就是技术人员的浪漫吧。</p><p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line"><span class="comment">// 24小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 15:04:05.000 Mon Jan"</span>))</span><br><span class="line"><span class="comment">// 12小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006-01-02 03:04:05.000 PM Mon Jan"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006/01/02 15:04"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"15:04 2006/01/02"</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">"2006/01/02"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">"Asia/Shanghai"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">"2006/01/02 15:04:05"</span>, <span class="string">"2019/08/04 14:15:20"</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure><p>练习题：</p><ol><li>获取当前时间，格式化输出为2017/06/19 20:30:05`格式。</li><li>编写程序统计一段代码的执行耗时时间，单位精确到微秒。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库strconv</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93strconv/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93strconv/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言内置包之strconv"><a href="#Go语言内置包之strconv" class="headerlink" title="Go语言内置包之strconv"></a>Go语言内置包之strconv</h1><p>Go语言中<code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p><a id="more"></a><h1 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h1><p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： <code>Atoi()</code>、<code>Itia()</code>、parse系列、format系列、append系列。</p><p>更多函数请查看<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="string与int类型转换"><a href="#string与int类型转换" class="headerlink" title="string与int类型转换"></a>string与int类型转换</h2><p>这一组函数是我们平时编程中用的最多的。</p><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(i <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"100"</span></span><br><span class="line">i1, err := strconv.Atoi(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"can't convert to int"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, i1, i1) <span class="comment">//type:int value:100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i2 := <span class="number">200</span></span><br><span class="line">s2 := strconv.Itoa(i2)</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%#v\n"</span>, s2, s2) <span class="comment">//type:string value:"200"</span></span><br></pre></td></tr></table></figure><h3 id="a的典故"><a href="#a的典故" class="headerlink" title="a的典故"></a>a的典故</h3><p>【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以<code>Itoa</code>对很多C系的程序员很好理解。</p><h2 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h2><p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p><h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p><h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>返回字符串表示的整数值，接受正负号。</p><p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p><p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p><p>返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p><h3 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(n <span class="keyword">uint64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p><h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>解析一个表示浮点数的字符串并返回其值。</p><p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。</p><p>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；</p><p>返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b, err := strconv.ParseBool(<span class="string">"true"</span>)</span><br><span class="line">f, err := strconv.ParseFloat(<span class="string">"3.1415"</span>, <span class="number">64</span>)</span><br><span class="line">i, err := strconv.ParseInt(<span class="string">"-2"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">u, err := strconv.ParseUint(<span class="string">"2"</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p><h2 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h2><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p><h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>根据b的值返回”true”或”false”。</p><h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p><h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>是FormatInt的无符号整数版本。</p><h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>函数将浮点数表示为字符串并返回。</p><p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p><p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p><p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := strconv.FormatBool(<span class="literal">true</span>)</span><br><span class="line">s2 := strconv.FormatFloat(<span class="number">3.1415</span>, <span class="string">'E'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">s3 := strconv.FormatInt(<span class="number">-2</span>, <span class="number">16</span>)</span><br><span class="line">s4 := strconv.FormatUint(<span class="number">2</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="isPrint"><a href="#isPrint" class="headerlink" title="isPrint()"></a>isPrint()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>返回一个字符是否是可打印的，和<code>unicode.IsPrint</code>一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p><h3 id="CanBackquote"><a href="#CanBackquote" class="headerlink" title="CanBackquote()"></a>CanBackquote()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanBackquote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>除上文列出的函数外，<code>strconv</code>包中还有Append系列、Quote系列等函数。具体用法可查看<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库log</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93log/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93log/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库log介绍"><a href="#Go语言标准库log介绍" class="headerlink" title="Go语言标准库log介绍"></a>Go语言标准库log介绍</h1><p>无论是软件开发的调试阶段还是软件上线之后的运行阶段，日志一直都是非常重要的一个环节，我们也应该养成在程序中记录日志的好习惯。</p><a id="more"></a><h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p><h2 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h2><p>log包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”logger，可以通过调用函数<code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和<code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个logger对象更容易使用。</p><p>例如，我们可以像下面的代码一样直接通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">v := <span class="string">"很普通的"</span></span><br><span class="line">log.Printf(<span class="string">"这是一条%s日志。\n"</span>, v)</span><br><span class="line">log.Fatalln(<span class="string">"这是一条会触发fatal的日志。"</span>)</span><br><span class="line">log.Panicln(<span class="string">"这是一条会触发panic的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行上面的代码会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017/06/19 14:04:17 这是一条很普通的日志。</span><br><span class="line">2017/06/19 14:04:17 这是一条很普通的日志。</span><br><span class="line">2017/06/19 14:04:17 这是一条会触发fatal的日志。</span><br></pre></td></tr></table></figure><p>logger会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。</p><h2 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h2><h3 id="标准logger的配置"><a href="#标准logger的配置" class="headerlink" title="标准logger的配置"></a>标准logger的配置</h3><p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p><p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><h3 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h3><p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 控制输出日志信息的细节，不能控制输出的顺序和格式。</span></span><br><span class="line">    <span class="comment">// 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</span></span><br><span class="line">    Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 日期：2009/01/23</span></span><br><span class="line">    Ltime                         <span class="comment">// 时间：01:23:23</span></span><br><span class="line">    Lmicroseconds                 <span class="comment">// 微秒级别的时间：01:23:23.123123（用于增强Ltime位）</span></span><br><span class="line">    Llongfile                     <span class="comment">// 文件全路径名+行号： /a/b/c/d.go:23</span></span><br><span class="line">    Lshortfile                    <span class="comment">// 文件名+行号：d.go:23（会覆盖掉Llongfile）</span></span><br><span class="line">    LUTC                          <span class="comment">// 使用UTC时间</span></span><br><span class="line">    LstdFlags     = Ldate | Ltime <span class="comment">// 标准logger的初始值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面我们在记录日志之前先设置一下标准logger的输出选项如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后得到的输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">17.494943</span> .../log_demo/main.<span class="keyword">go</span>:<span class="number">11</span>: 这是一条很普通的日志。</span><br></pre></td></tr></table></figure><h3 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h3><p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prefix</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPrefix</span><span class="params">(prefix <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">log.SetPrefix(<span class="string">"[小王子]"</span>)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[小王子]2017/06/19 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。</span><br></pre></td></tr></table></figure><p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p><h3 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure><p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p><p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFile, err := os.OpenFile(<span class="string">"./xx.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open log file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">log.SetPrefix(<span class="string">"[小王子]"</span>)</span><br><span class="line">log.Println(<span class="string">"这是一条很普通的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">logFile, err := os.OpenFile(<span class="string">"./xx.log"</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open log file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建logger"><a href="#创建logger" class="headerlink" title="创建logger"></a>创建logger</h2><p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。<code>New</code>函数的签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span></span><br></pre></td></tr></table></figure><p>New创建一个Logger对象。其中，参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger := log.New(os.Stdout, <span class="string">"&lt;New&gt;"</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">logger.Println(<span class="string">"这是自定义的logger记录的日志。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译执行之后，得到结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的logger记录的日志。</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如<a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a>、<a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a>等。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言基础之标准库flag</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93flag/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93flag/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库flag基本使用"><a href="#Go语言标准库flag基本使用" class="headerlink" title="Go语言标准库flag基本使用"></a>Go语言标准库flag基本使用</h1><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><a id="more"></a><h1 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h1><p>如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//os.Args demo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">"args[%d]=%v\n"</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./args_demo a b c d</span><br><span class="line">args[0]=./args_demo</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=b</span><br><span class="line">args[3]=c</span><br><span class="line">args[4]=d</span><br></pre></td></tr></table></figure><p><strong><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</strong></p><h1 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a><strong>flag包基本使用</strong></h1><p>本文介绍了flag包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="导入flag包"><a href="#导入flag包" class="headerlink" title="导入flag包"></a>导入flag包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flag</span><br></pre></td></tr></table></figure><h2 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><table><thead><tr><th align="center">flag参数</th><th align="center">有效值</th></tr></thead><tbody><tr><td align="center">字符串flag</td><td align="center">合法字符串</td></tr><tr><td align="center">整数flag</td><td align="center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td align="center">浮点数flag</td><td align="center">合法浮点数</td></tr><tr><td align="center">bool类型flag</td><td align="center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td align="center">时间段flag</td><td align="center">任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td></tr></tbody></table><h2 id="定义命令行flag参数"><a href="#定义命令行flag参数" class="headerlink" title="定义命令行flag参数"></a>定义命令行flag参数</h2><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h3><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">age := flag.Int(<span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">married := flag.Bool(<span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"时间间隔"</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h3><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"时间间隔"</span>)</span><br></pre></td></tr></table></figure><h2 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h2><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p><h2 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">////返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">//返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义命令行参数方式1</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">"name"</span>, <span class="string">"张三"</span>, <span class="string">"姓名"</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">"age"</span>, <span class="number">18</span>, <span class="string">"年龄"</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">"married"</span>, <span class="literal">false</span>, <span class="string">"婚否"</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">"d"</span>, <span class="number">0</span>, <span class="string">"延迟的时间间隔"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析命令行参数</span></span><br><span class="line">flag.Parse()<span class="comment">//解析传入命令参数，传递给对应变量</span></span><br><span class="line">fmt.Println(name, age, married, delay)</span><br><span class="line"><span class="comment">//返回命令行参数后的其他参数</span></span><br><span class="line">fmt.Println(flag.Args())</span><br><span class="line"><span class="comment">//返回命令行参数后的其他参数个数</span></span><br><span class="line">fmt.Println(flag.NArg())</span><br><span class="line"><span class="comment">//返回使用的命令行参数个数</span></span><br><span class="line">fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>命令行参数使用提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -<span class="built_in">help</span></span><br><span class="line">Usage of ./flag_demo:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -married</span><br><span class="line">        婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default <span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure><p>正常使用命令行flag参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo -name 沙河娜扎 --age 28 -married=<span class="literal">false</span> -d=1h30m</span><br><span class="line">沙河娜扎 28 <span class="literal">false</span> 1h30m0s</span><br><span class="line">[]</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>使用非flag命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./flag_demo a b c</span><br><span class="line">张三 18 <span class="literal">false</span> 0s</span><br><span class="line">[a b c]</span><br><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言标准库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言性能优化</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Go性能调优"><a href="#Go性能调优" class="headerlink" title="Go性能调优"></a>Go性能调优</h1><p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库，这篇文章就要讲解怎么在 golang 中做 profiling。</p><a id="more"></a><h1 id="Go性能优化"><a href="#Go性能优化" class="headerlink" title="Go性能优化"></a>Go性能优化</h1><p>Go语言项目中的性能优化主要有以下几个方面：</p><ul><li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li><li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li><li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li><li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li></ul><h2 id="采集性能数据"><a href="#采集性能数据" class="headerlink" title="采集性能数据"></a>采集性能数据</h2><p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p><ul><li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li><li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li></ul><p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取格格函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p><p>注意，我们只应该在性能测试的时候才在代码中引入pprof。</p><h2 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h2><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime/pprof"</span></span><br></pre></td></tr></table></figure><h3 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h3><p>开启CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>停止CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用<code>go tool pprof</code>工具进行CPU性能分析。</p><h3 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h3><p>记录程序的堆栈信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>得到采样数据之后，使用<code>go tool pprof</code>工具进行内存性能分析。</p><p><code>go tool pprof</code>默认是使用<code>-inuse_space</code>进行统计，还可以使用<code>-inuse-objects</code>查看分配对象的数量。</p><h2 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h2><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p><p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure><p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/trace"</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>如果你使用的是gin框架，那么推荐使用<code>&quot;github.com/DeanThompson/ginpprof&quot;</code>。</p><p>不管哪种方式，你的 HTTP 服务都会多出<code>/debug/pprof</code> endpoint，访问它会得到类似下面的内容：<img src="https://www.liwenzhou.com/images/Go/performance_optimisation/pprof2.png" alt="debug/pprof">这个路径下还有几个子页面：</p><ul><li>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载</li><li>/debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</li><li>/debug/pprof/block：block Profiling 的路径</li><li>/debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系</li></ul><h2 id="go-tool-pprof命令"><a href="#go-tool-pprof命令" class="headerlink" title="go tool pprof命令"></a>go tool pprof命令</h2><p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code>命令行工具。</p><p><code>go tool pprof</code>最简单的使用方式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>binary 是应用的二进制文件，用来解析各种符号；</li><li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li></ul><p><strong>注意事项：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>首先我们来写一段有问题的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime_pprof/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"runtime/pprof"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段有问题的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">fmt.Printf(<span class="string">"recv from chan, value:%v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> isCPUPprof <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> isMemPprof <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;isCPUPprof, <span class="string">"cpu"</span>, <span class="literal">false</span>, <span class="string">"turn cpu pprof on"</span>)</span><br><span class="line">flag.BoolVar(&amp;isMemPprof, <span class="string">"mem"</span>, <span class="literal">false</span>, <span class="string">"turn mem pprof on"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isCPUPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">"./cpu.pprof"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"create cpu pprof failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.StartCPUProfile(file)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> logicCode()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> isMemPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">"./mem.pprof"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"create mem pprof failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.WriteHeapProfile(file)</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过flag我们可以在命令行控制是否开启CPU和Mem的性能分析。 将上面的代码保存并编译成<code>runtime_pprof</code>可执行文件，执行时加上<code>-cpu</code>命令行参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./runtime_pprof -cpu</span><br></pre></td></tr></table></figure><p>等待30秒后会在当前目录下生成一个<code>cpu.pprof</code>文件。</p><h3 id="命令行交互界面"><a href="#命令行交互界面" class="headerlink" title="命令行交互界面"></a>命令行交互界面</h3><p>我们使用go工具链里的<code>pprof</code>来分析一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof cpu.pprof</span><br></pre></td></tr></table></figure><p>执行上面的代码会进入交互界面如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtime_pprof $ go tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Jun 28, 2019 at 11:28am (CST)</span><br><span class="line">Duration: 20.13s, Total samples = 1.91mins (568.60%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>我们可以在交互界面输入<code>top 3</code>来查看程序中占用CPU前3位的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top 3</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> 100.37s, 87.68% of 114.47s total</span><br><span class="line">Dropped 17 nodes (cum &lt;= 0.57s)</span><br><span class="line">Showing top 3 nodes out of 4</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    42.52s 37.15% 37.15%     91.73s 80.13%  runtime.selectnbrecv</span><br><span class="line">    35.21s 30.76% 67.90%     39.49s 34.50%  runtime.chanrecv</span><br><span class="line">    22.64s 19.78% 87.68%    114.37s 99.91%  main.logicCode</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>flat：当前函数占用CPU的耗时</li><li>flat：:当前函数占用CPU的耗时百分比</li><li>sun%：函数占用CPU的耗时累计百分比</li><li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li><li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li><li>最后一列：函数名称</li></ul><p>在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p><p>我们还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list logicCode</code>查看我们编写的函数的详细分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list logicCode</span><br><span class="line">Total: 1.91mins</span><br><span class="line">ROUTINE ================ main.logicCode <span class="keyword">in</span> .../runtime_pprof/main.go</span><br><span class="line">    22.64s   1.91mins (flat, cum) 99.91% of Total</span><br><span class="line">         .          .     12:func <span class="function"><span class="title">logicCode</span></span>() &#123;</span><br><span class="line">         .          .     13:   var c chan int</span><br><span class="line">         .          .     14:   <span class="keyword">for</span> &#123;</span><br><span class="line">         .          .     15:           select &#123;</span><br><span class="line">         .          .     16:           <span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">    22.64s   1.91mins     17:                   fmt.Printf(<span class="string">"recv from chan, value:%v\n"</span>, v)</span><br><span class="line">         .          .     18:           default:</span><br><span class="line">         .          .     19:</span><br><span class="line">         .          .     20:           &#125;</span><br><span class="line">         .          .     21:   &#125;</span><br><span class="line">         .          .     22:&#125;</span><br></pre></td></tr></table></figure><p>通过分析发现大部分CPU资源被17行占用，我们分析出select语句中的default没有内容会导致上面的<code>case v:=&lt;-c:</code>一直执行。我们在default分支添加一行<code>time.Sleep(time.Second)</code>即可。</p><h3 id="图形化"><a href="#图形化" class="headerlink" title="图形化"></a>图形化</h3><p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。 想要查看图形化的界面首先需要安装<a href="https://graphviz.gitlab.io/" target="_blank" rel="noopener">graphviz</a>图形化工具。</p><p>Mac：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>Windows: 下载<a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html" target="_blank" rel="noopener">graphviz</a> 将<code>graphviz</code>安装目录下的bin文件夹添加到Path环境变量中。 在终端输入<code>dot -version</code>查看是否安装成功。</p><p><img src="https://www.liwenzhou.com/images/Go/performance_optimisation/cpu_pprof.png" alt="CPU占比图">关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。 线条上的数字表示函数调用的次数。 方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p><h2 id="go-torch和火焰图"><a href="#go-torch和火焰图" class="headerlink" title="go-torch和火焰图"></a>go-torch和火焰图</h2><p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling 结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：<code>go-torch</code>。这是 uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。</p><h3 id="安装go-touch"><a href="#安装go-touch" class="headerlink" title="安装go-touch"></a>安装go-touch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -v github.com/uber/go-torch</span><br></pre></td></tr></table></figure><p>火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in 分析它上面的内容。</p><p>火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用 CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p><p>go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从<code>http://localhost:8080/debug/pprof/profile</code>获取 profiling 数据。它有三个常用的参数可以调整：</p><ul><li>-u –url：要访问的 URL，这里只是主机和端口部分</li><li>-s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile</li><li>–seconds：要执行 profiling 的时间长度，默认为 30s</li></ul><h3 id="安装-FlameGraph"><a href="#安装-FlameGraph" class="headerlink" title="安装 FlameGraph"></a>安装 FlameGraph</h3><p>要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。</p><ol><li>下载安装perl：<a href="https://www.perl.org/get.html" target="_blank" rel="noopener">https://www.perl.org/get.html</a></li><li>下载FlameGraph：<code>git clone https://github.com/brendangregg/FlameGraph.git</code></li><li>将<code>FlameGraph</code>目录加入到操作系统的环境变量中。</li><li>Windows平台的同学，需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code>按如下方式修改，然后在<code>go-torch</code>目录下执行<code>go install</code>即可。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) &#123;</span></span><br><span class="line">flameGraph := findInPath(flameGraphScripts)</span><br><span class="line"><span class="keyword">if</span> flameGraph == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errNoPerlScript</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> runScript(<span class="string">"perl"</span>, <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;flameGraph&#125;, args...), graphInput)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> runScript(flameGraph, args, graphInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h3><p>推荐使用<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">https://github.com/wg/wrk</a> 或 <a href="https://github.com/adjust/go-wrk" target="_blank" rel="noopener">https://github.com/adjust/go-wrk</a></p><h3 id="使用go-torch"><a href="#使用go-torch" class="headerlink" title="使用go-torch"></a>使用go-torch</h3><p>使用wrk进行压测:<code>go-wrk -n 50000 http://127.0.0.1:8080/book/list</code> 在上面压测进行的同时，打开另一个终端执行<code>go-torch -u http://127.0.0.1:8080 -t 30</code>，30秒之后终端会初夏如下提示：<code>Writing svg to torch.svg</code></p><p>然后我们使用浏览器打开<code>torch.svg</code>就能看到如下火焰图了。<img src="https://www.liwenzhou.com/images/Go/performance_optimisation/pprof3.png" alt="火焰图">火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p><h2 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h2><p><code>go test</code>命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p><ul><li>-cpuprofile：cpu profiling 数据要保存的文件地址</li><li>-memprofile：memory profiling 数据要报文的文件地址</li></ul><p>我们还可以选择将pprof与性能测试相结合，比如：</p><p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.prof</span><br></pre></td></tr></table></figure><p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -memprofile=./mem.prof</span><br></pre></td></tr></table></figure><p>需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下 Profiling 才有意义。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用gin框架编写一个接口，使用<code>go-wrk</code>进行压测，使用性能调优工具采集数据绘制出调用图和火焰图。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言操作Mysql</title>
      <link href="/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMysql/"/>
      <url>/2020/02/27/GO%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言操作MySQL"><a href="#Go语言操作MySQL" class="headerlink" title="Go语言操作MySQL"></a>Go语言操作MySQL</h1><p>MySQL是常用的关系型数据库，本文介绍了Go语言如何操作MySQL数据库。</p><a id="more"></a><h1 id="Go操作MySQL"><a href="#Go操作MySQL" class="headerlink" title="Go操作MySQL"></a>Go操作MySQL</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>Go语言中的<code>database/sql</code>包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用<code>database/sql</code>包时必须注入（至少）一个数据库驱动。</p><p>我们常用的数据库基本上都有完整的第三方实现。例如：<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">MySQL驱动</a></p><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure><h3 id="使用MySQL驱动"><a href="#使用MySQL驱动" class="headerlink" title="使用MySQL驱动"></a>使用MySQL驱动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span></span><br></pre></td></tr></table></figure><p>Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般包至少括数据库文件名和（可能的）连接信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/dbname"</span></span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()  <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题</strong>： 为什么上面代码中的<code>defer db.Close()</code>语句不应该写在<code>if err != nil</code>的前面呢？</p><h3 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h3><p>Open函数可能只是验证其参数，而不创建与数据库的连接。如果要检查数据源的名称是否合法，应调用返回值的Ping方法。</p><p>返回的DB可以安全的被多个goroutine同时使用，并会维护自身的闲置连接池。这样一来，Open函数只需调用一次。很少需要关闭DB。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span></span><br><span class="line"><span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line"><span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">db, err = sql.Open(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"init db failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>sql.DB</code>是一个数据库（操作）句柄，代表一个具有零到多个底层连接的连接池。它可以安全的被多个go程同时使用。<code>database/sql</code>包会自动创建和释放连接；它也会维护一个闲置连接的连接池。</p><h3 id="SetMaxOpenConns"><a href="#SetMaxOpenConns" class="headerlink" title="SetMaxOpenConns"></a>SetMaxOpenConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxOpenConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>SetMaxOpenConns</code>设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会限制最大开启连接数，默认为0（无限制）。</p><h3 id="SetMaxIdleConns"><a href="#SetMaxIdleConns" class="headerlink" title="SetMaxIdleConns"></a>SetMaxIdleConns</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">SetMaxIdleConns</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure><p>SetMaxIdleConns设置连接池中的最大闲置连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会保留闲置连接。</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h3><p>我们先在MySQL中创建一个名为<code>sql_test</code>的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sql_test;</span><br></pre></td></tr></table></figure><p>进入该数据库:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> sql_test;</span><br></pre></td></tr></table></figure><p>执行以下命令创建一张用于测试的数据表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`age`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="单行查询"><a href="#单行查询" class="headerlink" title="单行查询"></a>单行查询</h4><p>单行查询<code>db.QueryRow()</code>执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">QueryRow</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Row</span></span></span><br></pre></td></tr></table></figure><p>具体示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id=?"</span></span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line"><span class="comment">// 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放</span></span><br><span class="line">err := db.QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多行查询"><a href="#多行查询" class="headerlink" title="多行查询"></a>多行查询</h4><p>多行查询<code>db.Query()</code>执行一次查询，返回多行结果（即Rows），一般用于执行select命令。参数args表示query中的占位参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(*Rows, error)</span></span></span><br></pre></td></tr></table></figure><p>具体示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询多条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line">rows, err := db.Query(sqlStr, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非常重要：关闭rows释放持有的数据库链接</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取结果集中的数据</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入、更新和删除操作都使用*[Math Processing Error]*方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Exec</span><span class="params">(query <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(Result, error)</span></span></span><br></pre></td></tr></table></figure><p>Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。</p><p>具体插入数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="string">"王五"</span>, <span class="number">38</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get lastinsert ID failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"insert success, the id is %d.\n"</span>, theID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>具体更新数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"update user set age=? where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"update failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"update success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>具体删除数据的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"delete from user where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"delete failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"delete success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySQL预处理"><a href="#MySQL预处理" class="headerlink" title="MySQL预处理"></a>MySQL预处理</h2><h3 id="什么是预处理？"><a href="#什么是预处理？" class="headerlink" title="什么是预处理？"></a>什么是预处理？</h3><p>普通SQL语句执行过程：</p><ol><li>客户端对SQL语句进行占位符替换得到完整的SQL语句。</li><li>客户端发送完整SQL语句到MySQL服务端</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><p>预处理执行过程：</p><ol><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><h3 id="为什么要预处理？"><a href="#为什么要预处理？" class="headerlink" title="为什么要预处理？"></a>为什么要预处理？</h3><ol><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。</li><li>避免SQL注入问题。</li></ol><h3 id="Go实现MySQL预处理"><a href="#Go实现MySQL预处理" class="headerlink" title="Go实现MySQL预处理"></a>Go实现MySQL预处理</h3><p>Go中的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Prepare</span><span class="params">(query <span class="keyword">string</span>)</span> <span class="params">(*Stmt, error)</span></span></span><br></pre></td></tr></table></figure><p><code>Prepare</code>方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p><p>查询操作的预处理示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理查询示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareQueryDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prepare failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">rows, err := stmt.Query(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="comment">// 循环读取结果集中的数据</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"scan failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入、更新和删除操作的预处理十分类似，这里以插入操作的预处理为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理插入示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareInsertDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">stmt, err := db.Prepare(sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prepare failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line">_, err = stmt.Exec(<span class="string">"小王子"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = stmt.Exec(<span class="string">"沙河娜扎"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"insert success."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go实现MySQL事务"><a href="#Go实现MySQL事务" class="headerlink" title="Go实现MySQL事务"></a>Go实现MySQL事务</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。</p><p>在MySQL中只有使用了<code>Innodb</code>数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><h3 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h3><p>通常事务必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><table><thead><tr><th align="center">条件</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">原子性</td><td align="center">一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</td></tr><tr><td align="center">一致性</td><td align="center">在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</td></tr><tr><td align="center">隔离性</td><td align="center">数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</td></tr><tr><td align="center">持久性</td><td align="center">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td></tr></tbody></table><h3 id="事务相关方法"><a href="#事务相关方法" class="headerlink" title="事务相关方法"></a>事务相关方法</h3><p>Go语言中使用以下三个方法实现MySQL中的事务操作。 开始事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Begin</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span></span><br></pre></td></tr></table></figure><p>提交事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>回滚事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><h3 id="事务示例"><a href="#事务示例" class="headerlink" title="事务示例"></a>事务示例</h3><p>下面的代码演示了一个简单的事务操作，该事物操作能够确保两次更新操作要么同时成功要么同时失败，不会存在中间状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务操作示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx, err := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"begin trans failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr1 := <span class="string">"Update user set age=30 where id=?"</span></span><br><span class="line">_, err = tx.Exec(sqlStr1, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"exec sql1 failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr2 := <span class="string">"Update user set age=40 where id=?"</span></span><br><span class="line">_, err = tx.Exec(sqlStr2, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"exec sql2 failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"commit failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"exec trans success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sqlx使用"><a href="#sqlx使用" class="headerlink" title="sqlx使用"></a>sqlx使用</h1><p>第三方库<code>sqlx</code>能够简化操作，提高开发效率。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/jmoiron/sqlx</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">dsn := <span class="string">"user:password@tcp(127.0.0.1:3306)/test"</span></span><br><span class="line"><span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">db, err = sqlx.Connect(<span class="string">"mysql"</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"connect DB failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>查询单行数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id=?"</span></span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := db.Get(&amp;u, sqlStr, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"id:%d name:%s age:%d\n"</span>, u.ID, u.Name, u.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询多行数据示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询多条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"select id, name, age from user where id &gt; ?"</span></span><br><span class="line"><span class="keyword">var</span> users []user</span><br><span class="line">err := db.Select(&amp;users, sqlStr, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"query failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"users:%#v\n"</span>, users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入、更新和删除"><a href="#插入、更新和删除" class="headerlink" title="插入、更新和删除"></a>插入、更新和删除</h3><p>sqlx中的exec方法与原生sql中的exec使用基本一致：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"insert into user(name, age) values (?,?)"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="string">"沙河小王子"</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"insert failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get lastinsert ID failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"insert success, the id is %d.\n"</span>, theID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"update user set age=? where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">39</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"update failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"update success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">"delete from user where id = ?"</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"delete failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get RowsAffected failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"delete success, affected rows:%d\n"</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>对于事务操作，我们可以使用<code>sqlx</code>中提供的<code>db.Beginx()</code>和<code>tx.MustExec()</code>方法来简化错误处理过程。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx, err := db.Beginx() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"begin trans failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr1 := <span class="string">"Update user set age=40 where id=?"</span></span><br><span class="line">tx.MustExec(sqlStr1, <span class="number">2</span>)</span><br><span class="line">sqlStr2 := <span class="string">"Update user set age=50 where id=?"</span></span><br><span class="line">tx.MustExec(sqlStr2, <span class="number">4</span>)</span><br><span class="line">err = tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">"commit failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"exec trans success!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="SQL中的占位符"><a href="#SQL中的占位符" class="headerlink" title="SQL中的占位符"></a>SQL中的占位符</h2><p>不同的数据库中，SQL语句使用的占位符语法不尽相同。</p><table><thead><tr><th align="center">数据库</th><th align="center">占位符语法</th></tr></thead><tbody><tr><td align="center">MySQL</td><td align="center"><code>?</code></td></tr><tr><td align="center">PostgreSQL</td><td align="center"><code>$1</code>, <code>$2</code>等</td></tr><tr><td align="center">SQLite</td><td align="center"><code>?</code> 和<code>$1</code></td></tr><tr><td align="center">Oracle</td><td align="center"><code>:name</code></td></tr></tbody></table><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p><strong>我们任何时候都不应该自己拼接SQL语句！</strong></p><p>这里我们演示一个自行拼接SQL语句的示例，编写一个根据name字段查询user表的函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql注入示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlInjectDemo</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">sqlStr := fmt.Sprintf(<span class="string">"select id, name, age from user where name='%s'"</span>, name)</span><br><span class="line">fmt.Printf(<span class="string">"SQL:%s\n"</span>, sqlStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> users []user</span><br><span class="line">err := db.Select(&amp;users, sqlStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"exec failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%#v\n"</span>, u)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时以下输入字符串都可以引发SQL注入问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlInjectDemo(<span class="string">"xxx' or 1=1#"</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">"xxx' union select * from user #"</span>)</span><br><span class="line">sqlInjectDemo(<span class="string">"xxx' and (select count(*) from user) &lt;10 #"</span>)</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>结合<code>net/http</code>和<code>sqlx</code>包实现一个注册及登陆的web程序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18GO语言基础之单元测试</title>
      <link href="/2020/02/27/18GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/02/27/18GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之单元测试"><a href="#Go语言基础之单元测试" class="headerlink" title="Go语言基础之单元测试"></a>Go语言基础之单元测试</h1><p>不写测试的开发不是好程序员。我个人非常崇尚TDD（Test Driven Development）的，然而可惜的是国内的程序员都不太关注测试这一部分。 这篇文章主要介绍下在Go语言中如何做单元测试和基准测试。</p><a id="more"></a><h1 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a>go test工具</h1><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th align="center">类型</th><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">测试函数</td><td align="center">函数名前缀为Test</td><td align="center">测试程序的一些逻辑行为是否正确</td></tr><tr><td align="center">基准函数</td><td align="center">函数名前缀为Benchmark</td><td align="center">测试函数的性能</td></tr><tr><td align="center">示例函数</td><td align="center">函数名前缀为Example</td><td align="center">为文档提供示例文档</td></tr></tbody></table><p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><h1 id="1-测试函数"><a href="#1-测试函数" class="headerlink" title="1.测试函数"></a>1.测试函数</h1><h2 id="测试函数的格式"><a href="#测试函数的格式" class="headerlink" title="测试函数的格式"></a>测试函数的格式</h2><p>每个测试函数必须导入<code>testing</code>包，测试函数的基本格式（签名）如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数的名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>其中参数<code>t</code>用于报告测试失败和附加的日志信息。 <code>testing.T</code>的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Parallel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h2 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a>测试函数示例</h2><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。</p><p>接下来，我们定义一个<code>split</code>的包，包中定义了一个<code>Split</code>函数，具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="number">1</span>:]</span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下，我们创建一个<code>split_test.go</code>的测试文件，并定义一个测试函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">got := Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能比较直接，借助反射包中的方法比较</span></span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>split</code>这个包中的文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ ls -l</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 liwenzhou  staff  408  4 29 15:50 split.go</span><br><span class="line">-rw-r--r--  1 liwenzhou  staff  466  4 29 16:04 split_test.go</span><br></pre></td></tr></table></figure><p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以看到输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在<code>split_test.go</code>中添加如下测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMoreSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got := Split(<span class="string">"abcd"</span>, <span class="string">"bc"</span>)</span><br><span class="line">want := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行<code>go test</code>命令，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span></span><br><span class="line">--- FAIL: TestMultiSplit (0.00s)</span><br><span class="line">    split_test.go:20: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这一次，我们的测试失败了。<strong>我们可以为<code>go test</code>命令添加<code>-v</code>参数，查看测试函数名称和运行时间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- FAIL: TestMoreSplit (0.00s)</span><br><span class="line">    split_test.go:21: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>这一次我们能清楚的看到是<code>TestMoreSplit</code>这个测试没有成功。 <strong>还可以在<code>go test</code>命令后添加<code>-run</code>参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被<code>go test</code>命令执行。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v -run=<span class="string">"More"</span></span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- FAIL: TestMoreSplit (0.00s)</span><br><span class="line">    split_test.go:21: excepted:[a d], got:[a <span class="built_in">cd</span>]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>现在我们回过头来解决我们程序中的问题。很显然我们最初的<code>split</code>函数并没有考虑到sep为多个字符的情况，我们来修复下这个Bug：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次我们再来测试一下，我们的程序。注意，当我们修改了我们的代码之后不要仅仅执行那些失败的测试函数，我们应该完整的运行所有的测试，保证不会因为修改代码而引入了新的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">=== RUN   TestMoreSplit</span><br><span class="line">--- PASS: TestMoreSplit (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这一次我们的测试都通过了。</p><h2 id="2-测试组"><a href="#2-测试组" class="headerlink" title="2.测试组"></a>2.测试组</h2><p>我们现在还想要测试一下<code>split</code>函数对中文字符串的支持，这个时候我们可以再编写一个<code>TestChineseSplit</code>测试函数，但是我们也可以使用如下更友好的一种方式来添加更多的测试用例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">tests := []test&#123;</span><br><span class="line">&#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line">&#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%v, got:%v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过上面的代码把多个测试用例合到一起，再次执行<code>go test</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:42: excepted:[河有 又有河], got:[ 河有 又有河]</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>我们的测试出现了问题，仔细看打印的测试失败提示信息：<code>excepted:[河有 又有河], got:[ 河有 又有河]</code>，你会发现<code>[ 河有 又有河]</code>中有个不明显的空串，这种情况下十分推荐使用<code>%#v</code>的格式化方式。</p><p>我们修改下测试用例的格式化输出错误提示部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行<code>go test</code>命令后就能看到比较明显的提示信息了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    split_test.go:42: excepted:[]string&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;, got:[]string&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><h2 id="3-子测试"><a href="#3-子测试" class="headerlink" title="3.子测试"></a>3.子测试</h2><p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"name:%s excepted:%#v, got:%#v"</span>, name, tc.want, got) <span class="comment">// 将测试用例的name格式化输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做法是能够解决问题的。同时Go1.7+中新增了子测试，我们可以按照如下方式使用<code>t.Run</code>执行子测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再执行<code>go test</code>命令就能够看到更清晰的输出内容了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">=== RUN   TestSplit/leading_sep</span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">--- FAIL: TestSplit (0.00s)</span><br><span class="line">    --- FAIL: TestSplit/leading_sep (0.00s)</span><br><span class="line">        split_test.go:83: excepted:[]string&#123;<span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;, got:[]string&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;</span><br><span class="line">    --- PASS: TestSplit/simple (0.00s)</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (0.00s)</span><br><span class="line">    --- PASS: TestSplit/more_sep (0.00s)</span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL    github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><p>这个时候我们要把测试用例中的错误修改回来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道可以通过<code>-run=RegExp</code>来指定运行的测试用例，还可以通过<code>/</code>来指定要运行的子测试用例，例如：<code>go test -v -run=Split/simple</code>只会运行<code>simple</code>对应的子测试用例。</p><h2 id="4-测试覆盖率"><a href="#4-测试覆盖率" class="headerlink" title="4.测试覆盖率"></a>4.测试覆盖率</h2><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p><p>Go提供内置功能来检查你的代码覆盖率。<strong>我们可以使用<code>go test -cover</code>来查看测试覆盖率。</strong>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>从上面的结果可以看到我们的测试用例覆盖了100%的代码。</p><p>Go还提供了一个额外的<code>-coverprofile</code>参数，用来将覆盖率相关的记录信息输出到一个文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -cover -coverprofile=c.out</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s</span><br></pre></td></tr></table></figure><p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的<code>c.out</code>文件中，<strong>然后我们执行<code>go tool cover -html=c.out</code>，使用<code>cover</code>工具来处理生成的记录信息</strong>，该命令会打开本地的浏览器窗口生成一个HTML报告。<img src="https://www.liwenzhou.com/images/Go/unit_test/cover.png" alt="Go test cover">上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。</p><h1 id="5-基准测试"><a href="#5-基准测试" class="headerlink" title="5.基准测试"></a>5.基准测试</h1><h2 id="基准测试函数格式"><a href="#基准测试函数格式" class="headerlink" title="基准测试函数格式"></a>基准测试函数格式</h2><p><strong>基准测试就是在一定的工作负载之下检测程序性能的一种方法</strong>。基准测试的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基准测试以<code>Benchmark</code>为前缀</strong>，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code>拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ReportAllocs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ResetTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(b *B)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">RunParallel</span><span class="params">(body <span class="keyword">func</span>(*PB)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetBytes</span><span class="params">(n <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetParallelism</span><span class="params">(p <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StartTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StopTimer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a>基准测试示例</h2><p>我们为split包中的<code>Split_test.go</code>函数编写基准测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试并不会默认执行，需要增加<code>-bench</code>参数，所以我们通过执行<code>go test -bench=Split</code>命令执行基准测试，输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split   //(BenchmarkName  后缀的Name Split)</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8//(8核)        10000000//(次数)               203 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s</span><br></pre></td></tr></table></figure><p>其中<code>BenchmarkSplit-8</code>表示对Split函数进行基准测试，数字<code>8</code>表示<code>GOMAXPROCS</code>（最大线程数）的值，这个对于并发基准测试很重要。<code>10000000</code>和<code>203ns/op</code>表示每次调用<code>Split</code>函数耗时<code>203ns</code>，这个结果是<code>10000000</code>次调用的平均值。</p><p><strong>我们还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000 //次数              215 ns/op //每次操作执行时间    112 B/op//每次操作耗费内存       </span><br><span class="line">3 allocs/op //申请多少次内存</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s</span><br></pre></td></tr></table></figure><p>其中，<code>112 B/op</code>表示每次操作内存分配了112字节，<code>3 allocs/op</code>则表示每次操作进行了3次内存分配。 我们将我们的<code>Split</code>函数优化如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">result = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line">i := strings.Index(s, sep)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">i = strings.Index(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, s)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Split -benchmem</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8        10000000               127 ns/op              48 B/op          1 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       1.423s</span><br></pre></td></tr></table></figure><p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p><h2 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a>性能比较函数</h2><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p><p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="keyword">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure><p>例如我们编写了一个计算斐波那契数列的函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写的性能比较函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Fib(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure><p>运行基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns/op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns/op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns/op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns/op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns/op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 12.944s</span><br></pre></td></tr></table></figure><p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p><p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用<code>-benchtime</code>标志增加最小基准时间，以产生更准确的结果。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=Fib40 -benchtime=20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s</span><br></pre></td></tr></table></figure><p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p><p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">Fib(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a>重置时间</h2><p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line">b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code>数量的默认值为<code>GOMAXPROCS</code>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/Q1mi/studygo/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure><p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p><h1 id="Setup与TearDown"><a href="#Setup与TearDown" class="headerlink" title="Setup与TearDown"></a>Setup与TearDown</h1><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p><h2 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a>TestMain</h2><p>通过在<code>*_test.go</code>文件中定义<code>TestMain</code>函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p><p>如果测试文件包含函数:<code>func TestMain(m *testing.M)</code>那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。<code>TestMain</code>运行在主<code>goroutine</code>中, 可以在调用 <code>m.Run</code>前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用<code>m.Run</code>的返回值作为参数调用<code>os.Exit</code>。</p><p>一个使用<code>TestMain</code>来设置Setup和TearDown的示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write setup code here..."</span>) <span class="comment">// 测试之前的做一些设置</span></span><br><span class="line"><span class="comment">// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()</span></span><br><span class="line">retCode := m.Run()                         <span class="comment">// 执行测试</span></span><br><span class="line">fmt.Println(<span class="string">"write teardown code here..."</span>) <span class="comment">// 测试之后做一些拆卸工作</span></span><br><span class="line">os.Exit(retCode)                           <span class="comment">// 退出测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：在调用<code>TestMain</code>时, <code>flag.Parse</code>并没有被调用。所以如果<code>TestMain</code> 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用<code>flag.Parse</code>。</p><h2 id="子测试的Setup与Teardown"><a href="#子测试的Setup与Teardown" class="headerlink" title="子测试的Setup与Teardown"></a>子测试的Setup与Teardown</h2><p>有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试集的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupTestCase</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:测试之前的setup"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:测试之后的teardown"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子测试的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubTest</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:子测试之前的setup"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">"如有需要在此执行:子测试之后的teardown"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">input <span class="keyword">string</span></span><br><span class="line">sep   <span class="keyword">string</span></span><br><span class="line">want  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line"><span class="string">"simple"</span>:      &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">":"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"wrong sep"</span>:   &#123;input: <span class="string">"a:b:c"</span>, sep: <span class="string">","</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a:b:c"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"more sep"</span>:    &#123;input: <span class="string">"abcd"</span>, sep: <span class="string">"bc"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"d"</span>&#125;&#125;,</span><br><span class="line"><span class="string">"leading sep"</span>: &#123;input: <span class="string">"沙河有沙又有河"</span>, sep: <span class="string">"沙"</span>, want: []<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">"河有"</span>, <span class="string">"又有河"</span>&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">teardownTestCase := setupTestCase(t) <span class="comment">// 测试之前执行setup操作</span></span><br><span class="line"><span class="keyword">defer</span> teardownTestCase(t)            <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">teardownSubTest := setupSubTest(t) <span class="comment">// 子测试之前执行setup操作</span></span><br><span class="line"><span class="keyword">defer</span> teardownSubTest(t)           <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line">got := Split(tc.input, tc.sep)</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">"excepted:%#v, got:%#v"</span>, tc.want, got)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">=== RUN   TestSplit/leading_sep</span><br><span class="line">--- PASS: TestSplit (0.00s)</span><br><span class="line">    split_test.go:71: 如有需要在此执行:测试之前的setup</span><br><span class="line">    --- PASS: TestSplit/simple (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/more_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    --- PASS: TestSplit/leading_sep (0.00s)</span><br><span class="line">        split_test.go:79: 如有需要在此执行:子测试之前的setup</span><br><span class="line">        split_test.go:81: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">    split_test.go:73: 如有需要在此执行:测试之后的teardown</span><br><span class="line">=== RUN   ExampleSplit</span><br><span class="line">--- PASS: ExampleSplit (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure><h1 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h1><h2 id="示例函数的格式"><a href="#示例函数的格式" class="headerlink" title="示例函数的格式"></a>示例函数的格式</h2><p>被<code>go test</code>特殊对待的第三种函数就是示例函数，它们的函数名以<code>Example</code>为前缀。它们既没有参数也没有返回值。标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a>示例函数示例</h2><p>下面的代码是我们为<code>Split</code>函数编写的一个示例函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSplit</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split.Split(<span class="string">"a:b:c"</span>, <span class="string">":"</span>))</span><br><span class="line">fmt.Println(split.Split(<span class="string">"沙河有沙又有河"</span>, <span class="string">"沙"</span>))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [a b c]</span></span><br><span class="line"><span class="comment">// [ 河有 又有河]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为你的代码编写示例代码有如下三个用处：</p><ol><li><p>示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。</p></li><li><p>示例函数只要包含了<code>// Output:</code>也是可以通过<code>go test</code>运行的可执行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">split $ go <span class="built_in">test</span> -run Example</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s</span><br></pre></td></tr></table></figure></li><li><p>示例函数提供了可以直接运行的示例代码，可以直接在<code>golang.org</code>的<code>godoc</code>文档服务器上使用<code>Go Playground</code>运行示例代码。下图为<code>strings.ToUpper</code>函数在Playground的示例函数效果。<img src="https://www.liwenzhou.com/images/Go/unit_test/example.png" alt="Go Playground"></p></li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写一个回文检测函数，并为其编写单元测试和基准测试，根据测试的结果逐步对其进行优化。（回文：一个字符串正序和逆序一样，如“Madam,I’mAdam”、“油灯少灯油”等。）</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17GO语言基础之net/http</title>
      <link href="/2020/02/27/17GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bnet-http/"/>
      <url>/2020/02/27/17GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bnet-http/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之net-http"><a href="#Go语言基础之net-http" class="headerlink" title="Go语言基础之net/http"></a>Go语言基础之net/http</h1><p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p><a id="more"></a><h2 id="net-http介绍"><a href="#net-http介绍" class="headerlink" title="net/http介绍"></a>net/http介绍</h2><p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><h3 id="基本的HTTP-HTTPS请求"><a href="#基本的HTTP-HTTPS请求" class="headerlink" title="基本的HTTP/HTTPS请求"></a>基本的HTTP/HTTPS请求</h3><p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">"http://example.com/upload"</span>, <span class="string">"image/jpeg"</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">"http://example.com/form"</span>,</span><br><span class="line">url.Values&#123;<span class="string">"key"</span>: &#123;<span class="string">"Value"</span>&#125;, <span class="string">"id"</span>: &#123;<span class="string">"123"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>程序在使用完response后必须关闭回复的主体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="GET请求示例"><a href="#GET请求示例" class="headerlink" title="GET请求示例"></a>GET请求示例</h3><p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"https://www.liwenzhou.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from resp.Body failed,err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>liwenzhou.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p><h3 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h3><p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">apiUrl := <span class="string">"http://127.0.0.1:9090/get"</span></span><br><span class="line"><span class="comment">// URL param</span></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">"name"</span>, <span class="string">"小王子"</span>)</span><br><span class="line">data.Set(<span class="string">"age"</span>, <span class="string">"18"</span>)</span><br><span class="line">u, err := url.ParseRequestURI(apiUrl)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"parse url requestUrl failed,err:%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">u.RawQuery = data.Encode() <span class="comment">// URL encode</span></span><br><span class="line">fmt.Println(u.String())</span><br><span class="line">resp, err := http.Get(u.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">data := r.URL.Query()</span><br><span class="line">fmt.Println(data.Get(<span class="string">"name"</span>))</span><br><span class="line">fmt.Println(data.Get(<span class="string">"age"</span>))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post请求示例"><a href="#Post请求示例" class="headerlink" title="Post请求示例"></a>Post请求示例</h3><p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http post demo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := <span class="string">"http://127.0.0.1:9090/post"</span></span><br><span class="line"><span class="comment">// 表单数据</span></span><br><span class="line"><span class="comment">//contentType := "application/x-www-form-urlencoded"</span></span><br><span class="line"><span class="comment">//data := "name=小王子&amp;age=18"</span></span><br><span class="line"><span class="comment">// json</span></span><br><span class="line">contentType := <span class="string">"application/json"</span></span><br><span class="line">data := <span class="string">`&#123;"name":"小王子","age":18&#125;`</span></span><br><span class="line">resp, err := http.Post(url, contentType, strings.NewReader(data))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"post failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"get resp failed,err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的Server端HandlerFunc如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line"><span class="comment">// 1. 请求类型是application/x-www-form-urlencoded时解析form数据</span></span><br><span class="line">r.ParseForm()</span><br><span class="line">fmt.Println(r.PostForm) <span class="comment">// 打印form数据</span></span><br><span class="line">fmt.Println(r.PostForm.Get(<span class="string">"name"</span>), r.PostForm.Get(<span class="string">"age"</span>))</span><br><span class="line"><span class="comment">// 2. 请求类型是application/json时从r.Body读取数据</span></span><br><span class="line">b, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read request.Body failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">answer := <span class="string">`&#123;"status": "ok"&#125;`</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(answer))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Client"><a href="#自定义Client" class="headerlink" title="自定义Client"></a>自定义Client</h3><p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"http://example.com"</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">req.Header.Add(<span class="string">"If-None-Match"</span>, <span class="string">`W/"wyzzy"`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="自定义Transport"><a href="#自定义Transport" class="headerlink" title="自定义Transport"></a>自定义Transport</h3><p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;http.Transport&#123;</span><br><span class="line">TLSClientConfig:    &amp;tls.Config&#123;RootCAs: pool&#125;,</span><br><span class="line">DisableCompression: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure><p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="默认的Server"><a href="#默认的Server" class="headerlink" title="默认的Server"></a>默认的Server</h3><p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p><p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><h3 id="默认的Server示例"><a href="#默认的Server示例" class="headerlink" title="默认的Server示例"></a>默认的Server示例</h3><p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http server</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">"Hello 沙河！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"http server failed, err:%v\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="https://www.liwenzhou.com/images/Go/socket/hello.png" alt="hello页面"></p><h3 id="自定义Server"><a href="#自定义Server" class="headerlink" title="自定义Server"></a>自定义Server</h3><p>要管理服务端的行为，可以创建一个自定义的Server：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;http.Server&#123;</span><br><span class="line">Addr:           <span class="string">":8080"</span>,</span><br><span class="line">Handler:        myHandler,</span><br><span class="line">ReadTimeout:    <span class="number">10</span> * time.Second,</span><br><span class="line">WriteTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16GO语言基础之网络编程</title>
      <link href="/2020/02/27/16GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/02/27/16GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之网络编程"><a href="#Go语言基础之网络编程" class="headerlink" title="Go语言基础之网络编程"></a>Go语言基础之网络编程</h1><p>现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。</p><a id="more"></a><h1 id="互联网协议介绍"><a href="#互联网协议介绍" class="headerlink" title="互联网协议介绍"></a>互联网协议介绍</h1><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。</p><h2 id="互联网分层模型"><a href="#互联网分层模型" class="headerlink" title="互联网分层模型"></a>互联网分层模型</h2><p>互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。<img src="https://www.liwenzhou.com/images/Go/socket/osi.png" alt="osi七层模型">如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。</p><p>接下来我们一层一层的自底向上介绍一下每一层。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用<strong>双绞线、光纤、无线电波</strong>等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些<strong>电气特性</strong>，作用是负责传送0和1的电信号。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：<strong>多少个电信号算一组？每个信号位有何意义？</strong>这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，<strong>一组电信号构成一个数据包，叫做”帧”（Frame）。</strong>每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是<strong>数据包的发送地址和接收地址，这叫做MAC地址</strong>。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。</p><p>因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。</p><p>我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。</p><p>如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/httptcpip.png" alt="HTTP数据传输图解"></p><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h2 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a>socket图解</h2><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/socket.png" alt="socket图解"></p><h2 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a>Go语言实现TCP通信</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即<strong>传输控制协议/网间协议</strong>，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p><strong>TCP服务端</strong>程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp/server/main.go</span></span><br><span class="line"><span class="comment">// TCP server端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">n, err := reader.Read(buf[:]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from client failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">recvStr := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">fmt.Println(<span class="string">"收到client端发来的数据："</span>, recvStr)</span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(recvStr)) <span class="comment">// 发送数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:20000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept() <span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn) <span class="comment">// 启动一个goroutine处理连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>一个<strong>TCP客户端</strong>进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp/client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:20000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"err :"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close() <span class="comment">// 关闭连接</span></span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">input, _ := inputReader.ReadString(<span class="string">'\n'</span>) <span class="comment">// 读取用户输入</span></span><br><span class="line">inputInfo := strings.Trim(input, <span class="string">"\r\n"</span>)</span><br><span class="line"><span class="keyword">if</span> strings.ToUpper(inputInfo) == <span class="string">"Q"</span> &#123; <span class="comment">// 如果输入q就退出</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">_, err = conn.Write([]<span class="keyword">byte</span>(inputInfo)) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">buf := [<span class="number">512</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">n, err := conn.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recv failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h2 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h2><h3 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a>黏包示例</h3><p>服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := reader.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read from client failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">recvStr := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">fmt.Println(<span class="string">"收到client发来的数据："</span>, recvStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/client/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"dial failed, err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">msg := <span class="string">`Hello, Hello. How are you?`</span></span><br><span class="line">conn.Write([]<span class="keyword">byte</span>(msg))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br></pre></td></tr></table></figure><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/proto/proto.go</span></span><br><span class="line"><span class="keyword">package</span> proto</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode 将消息编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取消息的长度，转换成int32类型（占4个字节）</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="keyword">int32</span>(<span class="built_in">len</span>(message))</span><br><span class="line"><span class="keyword">var</span> pkg = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"><span class="comment">// 写入消息头</span></span><br><span class="line">err := binary.Write(pkg, binary.LittleEndian, length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入消息实体</span></span><br><span class="line">err = binary.Write(pkg, binary.LittleEndian, []<span class="keyword">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pkg.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decode 解码消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(reader *bufio.Reader)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 读取消息的长度</span></span><br><span class="line">lengthByte, _ := reader.Peek(<span class="number">4</span>) <span class="comment">// 读取前4个字节的数据</span></span><br><span class="line">lengthBuff := bytes.NewBuffer(lengthByte)</span><br><span class="line"><span class="keyword">var</span> length <span class="keyword">int32</span></span><br><span class="line">err := binary.Read(lengthBuff, binary.LittleEndian, &amp;length)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Buffered返回缓冲中现有的可读取的字节数。</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int32</span>(reader.Buffered()) &lt; length+<span class="number">4</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取真正的消息数据</span></span><br><span class="line">pack := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="keyword">int</span>(<span class="number">4</span>+length))</span><br><span class="line">_, err = reader.Read(pack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(pack[<span class="number">4</span>:]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/server2/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">reader := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := proto.Decode(reader)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"decode msg failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"收到client发来的数据："</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket_stick/client2/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:30000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"dial failed, err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">msg := <span class="string">`Hello, Hello. How are you?`</span></span><br><span class="line">data, err := proto.Encode(msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"encode msg failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Write(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a>Go语言实现UDP通信</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h3 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h3><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP/server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP server端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">"udp"</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">Port: <span class="number">30000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> data [<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(data[:]) <span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read udp failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"data:%v addr:%v count:%v\n"</span>, <span class="keyword">string</span>(data[:n]), addr, n)</span><br><span class="line">_, err = listen.WriteToUDP(data[:n], addr) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write to udp failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">socket, err := net.DialUDP(<span class="string">"udp"</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">Port: <span class="number">30000</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"连接服务端失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> socket.Close()</span><br><span class="line">sendData := []<span class="keyword">byte</span>(<span class="string">"Hello server"</span>)</span><br><span class="line">_, err = socket.Write(sendData) <span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"发送数据失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line">n, remoteAddr, err := socket.ReadFromUDP(data) <span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"接收数据失败，err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"recv:%v addr:%v count:%v\n"</span>, <span class="keyword">string</span>(data[:n]), remoteAddr, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15GO语言基础之并发</title>
      <link href="/2020/02/27/15GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
      <url>/2020/02/27/15GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之并发"><a href="#Go语言基础之并发" class="headerlink" title="Go语言基础之并发"></a>Go语言基础之并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。<a href="http://blog.sina.com.cn/s/blog_5a2bbc860101gedc.html" target="_blank" rel="noopener">进程与线程区别和处理器调度</a></p><a id="more"></a><h1 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hello()</span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p><strong>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</strong></p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line"><span class="keyword">go</span> hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。G（线程）P（管理G）M(G在M上运行)M相当于CPU</p><ul><li><p><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</p></li><li><p><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</p></li><li><p><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</p><p><strong>M：N：把m个goroutine分配给n个操作系统线程去执行。</strong></p></li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html" target="_blank" rel="noopener">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p><strong>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。</strong>默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//gomaxprocs 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span>  wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"A:%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"B:%d\n"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">6</span>)<span class="comment">//设置多少个线程同时执行程序 默认CPU逻辑核心数是6，默认跑满整个cpu</span></span><br><span class="line">fmt.Println(runtime.NumCPU()) <span class="comment">//最大线程数是4，我的电脑</span></span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">wg.Wait() <span class="comment">//等待线程数为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</strong></p><p>创建channel的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ret := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发panic，从该通道里接收的值一直都是类型零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel 练习</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 开启goroutine将0~100的数发送到ch1中</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">ch1 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i, ok := &lt;-ch1 <span class="comment">// 通道关闭后再取值ok=false</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 在主goroutine中从ch2中接收值打印</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123; <span class="comment">// 通道关闭后会退出for range循环</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">out &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">out &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> counter(ch1)</span><br><span class="line"><span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h2 id="worker-pool（goroutine池）（面试手写）"><a href="#worker-pool（goroutine池）（面试手写）" class="headerlink" title="worker pool（goroutine池）（面试手写）"></a>worker pool（goroutine池）（面试手写）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">fmt.Printf(<span class="string">"worker:%d start job:%d\n"</span>, id, j)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">"worker:%d end job:%d\n"</span>, id, j)</span><br><span class="line">results &lt;- j * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 开启3个goroutine</span></span><br><span class="line"><span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5个任务</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(jobs)</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">    个                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个小例子来演示下<code>select</code>的使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><strong>互斥锁是一种常用的控制共享资源访问的方法，</strong>它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，<strong>当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的</strong>，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x      <span class="keyword">int64</span></span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">lock   sync.Mutex</span><br><span class="line">rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line"><span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">(wg * WaitGroup) Add(delta int)</td><td align="center">计数器+delta</td></tr><tr><td align="center">(wg *WaitGroup) Done()</td><td align="center">计数器-1</td></tr><tr><td align="center">(wg *WaitGroup) Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine done!"</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们<strong>需要确保某些操作在高并发的场景下只执行一次</strong>，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line"><span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line"><span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line"><span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">icons[<span class="string">"left"</span>] = loadIcon(<span class="string">"left.png"</span>)</span><br><span class="line">icons[<span class="string">"up"</span>] = loadIcon(<span class="string">"up.png"</span>)</span><br><span class="line">icons[<span class="string">"right"</span>] = loadIcon(<span class="string">"right.png"</span>)</span><br><span class="line">icons[<span class="string">"down"</span>] = loadIcon(<span class="string">"down.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">"left"</span>:  loadIcon(<span class="string">"left.png"</span>),</span><br><span class="line"><span class="string">"up"</span>:    loadIcon(<span class="string">"up.png"</span>),</span><br><span class="line"><span class="string">"right"</span>: loadIcon(<span class="string">"right.png"</span>),</span><br><span class="line"><span class="string">"down"</span>:  loadIcon(<span class="string">"down.png"</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">set(key, n)</span><br><span class="line">fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, get(key))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//concurrent map writes 并发映射写</span></span><br></pre></td></tr></table></figure><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)</span><br><span class="line">value, _ := m.Load(key)</span><br><span class="line">fmt.Printf(<span class="string">"k=:%v,v:=%v\n"</span>, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td align="center">读取操作</td></tr><tr><td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td align="center">写入操作</td></tr><tr><td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td align="center">修改操作</td></tr><tr><td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td align="center">交换操作</td></tr><tr><td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td align="center">比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">test(c1) <span class="comment">//0  499.7µs</span></span><br><span class="line">c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">test(&amp;c2)<span class="comment">//1000 500.1µs</span></span><br><span class="line">c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">test(&amp;c3) <span class="comment">//1000 0s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">goroutine</span></span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">channel</span></span><br></pre></td></tr></table></figure><p>实现一个计算int64随机数各位数和的程序。</p><ol><li><p>开启一个<code>goroutine</code>循环生成int64类型的随机数，发送到<code>jobChan</code></p></li><li><p>开启24个<code>goroutine</code>从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code></p></li><li><p>主<code>goroutine</code>从<code>resultChan</code>取出结果并打印到终端输出</p><p>代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/*实现一个计算int64随机数各位数和的程序。</span></span><br><span class="line"><span class="comment">1. 开启一个`goroutine`循环生成int64类型的随机数，发送到`jobChan`</span></span><br><span class="line"><span class="comment">2. 开启24个`goroutine`从`jobChan`中取出随机数计算各位数的和，将结果发送到`resultChan`</span></span><br><span class="line"><span class="comment">3. 主`goroutine`从`resultChan`取出结果并打印到终端输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> job <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">job*job</span><br><span class="line">sum <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobChan =<span class="built_in">make</span>(<span class="keyword">chan</span> *job,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> resultChan =<span class="built_in">make</span>(<span class="keyword">chan</span> *result,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rom</span><span class="params">(z1 <span class="keyword">chan</span>&lt;- *job)</span></span>&#123;</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="comment">//1.循环生成int64类型的随机数，发送到`jobChan`</span></span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"> x := rand.Int63()</span><br><span class="line">newJob := &amp;job&#123;</span><br><span class="line">x,</span><br><span class="line">&#125;</span><br><span class="line">z1 &lt;- newJob</span><br><span class="line">time.Sleep(time.Millisecond*<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(z1 &lt;-<span class="keyword">chan</span> *job,resultChan <span class="keyword">chan</span>&lt;- *result)</span></span>&#123;</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="comment">//2.从`jobChan`中取出随机数计算各位数的和，将结果发送到`resultChan`</span></span><br><span class="line"><span class="keyword">for</span>   &#123;</span><br><span class="line">job := &lt;- z1</span><br><span class="line">sum := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">n :=job.value</span><br><span class="line"><span class="keyword">for</span> n&gt;<span class="number">0</span> &#123;</span><br><span class="line">sum += n%<span class="number">10</span></span><br><span class="line">n=n/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">newResult := &amp;result&#123;</span><br><span class="line">job,</span><br><span class="line">sum,</span><br><span class="line">&#125;</span><br><span class="line">resultChan&lt;-newResult</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> rom(jobChan)</span><br><span class="line">wg.Add(<span class="number">24</span>)</span><br><span class="line"><span class="comment">//开启24个goroutine执行get方法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="number">24</span>;i++&#123;</span><br><span class="line"><span class="keyword">go</span> get(jobChan,resultChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.从`resultChan`取出结果并打印到终端输出</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> resultChan&#123;</span><br><span class="line">fmt.Printf(<span class="string">"value:%d  sum:%d\n"</span>,result.job.value,result.sum)</span><br><span class="line">        <span class="comment">//value:2610529275472644968  sum:89</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。</p><p>业务代码记日志先存放到通道中，然后起一个后台goroutine专门从通道中取日志往文件里写。</p><p>1.日志库中channel怎么用？</p><p>2.什么时候起后台的goroutine去写日志到文件中</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14GO语言基础之反射</title>
      <link href="/2020/02/27/14GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/02/27/14GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之反射"><a href="#Go语言基础之反射" class="headerlink" title="Go语言基础之反射"></a>Go语言基础之反射</h1><p>本文介绍了Go语言反射的意义和基本使用。</p><a id="more"></a><h1 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h1><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p><h1 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h1><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h2 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h2><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">"type:%v\n"</span>, v) <span class="comment">//type</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line">reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a>type name和type kind</h3><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">"type:%v kind:%v\n"</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">"沙河小王子"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">"《跟小王子学Go语言》"</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h2><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Interface() interface {}</td><td align="center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td align="center">Int() int64</td><td align="center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td align="center">Uint() uint64</td><td align="center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td align="center">Float() float64</td><td align="center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td align="center">Bool() bool</td><td align="center">将值以 bool 类型返回</td></tr><tr><td align="center">Bytes() []bytes</td><td align="center">将值以字节数组 []bytes 类型返回</td></tr><tr><td align="center">String() string</td><td align="center">将值以字符串类型返回</td></tr></tbody></table><h3 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is int64, value is %d\n"</span>, <span class="keyword">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is float32, value is %f\n"</span>, <span class="keyword">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">"type is float64, value is %f\n"</span>, <span class="keyword">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"><span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">"type c :%T\n"</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h3><h4 id="isNil"><a href="#isNil" class="headerlink" title="isNil()"></a>isNil()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><h4 id="isValid"><a href="#isValid" class="headerlink" title="isValid()"></a>isValid()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// *int类型空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">"var a *int IsNil:"</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line"><span class="comment">// nil值</span></span><br><span class="line">fmt.Println(<span class="string">"nil IsValid:"</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从结构体中查找"abc"字段</span></span><br><span class="line">fmt.Println(<span class="string">"不存在的结构体成员:"</span>, reflect.ValueOf(b).FieldByName(<span class="string">"abc"</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找"abc"方法</span></span><br><span class="line">fmt.Println(<span class="string">"不存在的结构体方法:"</span>, reflect.ValueOf(b).MethodByName(<span class="string">"abc"</span>).IsValid())</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">"map中不存在的键："</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">"娜扎"</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h1><h2 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h2><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Field(i int) StructField</td><td align="center">根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td align="center">NumField() int</td><td align="center">返回结构体成员字段数量。</td></tr><tr><td align="center">FieldByName(name string) (StructField, bool)</td><td align="center">根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td align="center">FieldByIndex(index []int) StructField</td><td align="center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td align="center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td align="center">根据传入的匹配函数匹配需要的字段。</td></tr><tr><td align="center">NumMethod() int</td><td align="center">返回该类型的方法集中方法的数目</td></tr><tr><td align="center">Method(int) Method</td><td align="center">返回该类型方法集中的第i个方法</td></tr><tr><td align="center">MethodByName(string)(Method, bool)</td><td align="center">根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h2 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h2><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为""。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    PkgPath <span class="keyword">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="keyword">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="keyword">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="keyword">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h2><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">Score <span class="keyword">int</span>    <span class="string">`json:"score"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  <span class="string">"小王子"</span>,</span><br><span class="line">Score: <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line"><span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">"name:%s index:%d type:%v json tag:%v\n"</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line"><span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">"Score"</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"name:%s index:%d type:%v json tag:%v\n"</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Study</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">"好好学习，天天向上。"</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Sleep</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">"好好睡觉，快快长大。"</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType := v.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">"method name:%s\n"</span>, t.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">"method:%s\n"</span>, methodType)</span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h1><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>编写代码利用反射实现一个ini文件的解析器程序。</p><p><code>conf.ini</code></p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#mysql config []节点  下面是子孩子</span><br><span class="line">[mysql]</span><br><span class="line">address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line"></span><br><span class="line">#redis config</span><br><span class="line">[redis]</span><br><span class="line">host=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">port=<span class="number">6379</span></span><br><span class="line">password=root</span><br><span class="line">database=<span class="number">0</span></span><br><span class="line">test=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ini配置文件解析器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mysqlConfig MYSQL配置结构体</span></span><br><span class="line"><span class="keyword">type</span> MysqlConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Address <span class="keyword">string</span> <span class="string">`ini:"address"`</span></span><br><span class="line">Port <span class="keyword">int</span><span class="string">`ini:"port"`</span></span><br><span class="line">Username<span class="keyword">string</span><span class="string">`ini:"username"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`ini:"password"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//redisconfig</span></span><br><span class="line"><span class="keyword">type</span> RedisConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Host  <span class="keyword">string</span><span class="string">`ini:"host"`</span></span><br><span class="line">Port  <span class="keyword">int</span><span class="string">`ini:"port"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`ini:"password"`</span></span><br><span class="line">Database <span class="keyword">int</span> <span class="string">`ini:"database"`</span></span><br><span class="line">Test <span class="keyword">bool</span><span class="string">`ini:"test"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Config</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">MysqlConfig <span class="string">`ini:"mysql"`</span></span><br><span class="line">RedisConfig<span class="string">`ini:"redis"`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIni</span><span class="params">(fileName <span class="keyword">string</span>,data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line"><span class="comment">//0.参数的校验</span></span><br><span class="line"><span class="comment">//0.1传来的data参数必须是指针类型（因为需要在函数中对其赋值）</span></span><br><span class="line">t :=reflect.TypeOf(data)</span><br><span class="line">fmt.Println(t.Kind())</span><br><span class="line"><span class="keyword">if</span> t.Kind() !=reflect.Ptr&#123; <span class="comment">//ptr指针类型</span></span><br><span class="line">err =errors.New(<span class="string">"data param should be a pointer"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0.2传进来的data参数必须是结构体类型指针（以为配置文件中各种键值对需要赋值给结构体字段）</span></span><br><span class="line"><span class="keyword">if</span> t.Elem().Kind() !=reflect.Struct&#123;</span><br><span class="line">err =errors.New(<span class="string">"data param should be a struct"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.读文件得到字节类型数据</span></span><br><span class="line">b,err :=ioutil.ReadFile(fileName)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string(b) 将字节类型转换为字符串</span></span><br><span class="line">lineSlice :=strings.Split(<span class="keyword">string</span>(b),<span class="string">"\r\n"</span>)</span><br><span class="line"><span class="comment">//fmt.Println(lineSlice)</span></span><br><span class="line"><span class="comment">//2.一行一行的读数据</span></span><br><span class="line"><span class="keyword">var</span> structName <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> idx,line := <span class="keyword">range</span> lineSlice&#123;</span><br><span class="line"><span class="comment">//去掉字符串首尾的空格</span></span><br><span class="line">line =strings.TrimSpace(line)</span><br><span class="line"><span class="comment">//如果是空格就跳过</span></span><br><span class="line"><span class="keyword">if</span>  <span class="built_in">len</span>(line) == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.1如果是注释就跳过</span></span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(line,<span class="string">";"</span>) || strings.HasPrefix(line,<span class="string">"#"</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.2如果是[开头的就表示是节（section）</span></span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(line,<span class="string">"["</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> line[<span class="number">0</span>] !=<span class="string">'['</span> || line[<span class="built_in">len</span>(line)<span class="number">-1</span>] != <span class="string">']'</span>&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把这一行首尾的[]去掉，取到中间的内容把首尾的空格去掉拿到内容</span></span><br><span class="line">sectionName :=strings.TrimSpace(line[<span class="number">1</span>:<span class="built_in">len</span>(line)<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sectionName)==<span class="number">0</span>&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据sectionName去掉data里面根据反射找到对应的结构体</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t.Elem().NumField();i++&#123;</span><br><span class="line">filed :=t.Elem().Field(i)</span><br><span class="line"><span class="keyword">if</span> sectionName == filed.Tag.Get(<span class="string">"ini"</span>)&#123;</span><br><span class="line"><span class="comment">//说明找到了对应的嵌套结构体，吧字段名记下来</span></span><br><span class="line">structName =filed.Name</span><br><span class="line">fmt.Printf(<span class="string">"找到%s对应的潜逃结构体%s\n"</span>,sectionName,structName)<span class="comment">//mysql  MysqlConfig</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//2.3如果不是[开头就是=分割键值对</span></span><br><span class="line"><span class="comment">//1.以等号分割这一行，等号左边是key，等号右边是value</span></span><br><span class="line"><span class="keyword">if</span> strings.Index(line,<span class="string">"="</span>) == <span class="number">-1</span> || strings.HasPrefix(line,<span class="string">"="</span>)&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d syntax errot"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">index :=strings.Index(line,<span class="string">"="</span>)</span><br><span class="line">key :=strings.TrimSpace(line[:index])</span><br><span class="line">value :=strings.TrimSpace(line[index+<span class="number">1</span>:]) <span class="comment">//自动去除空格</span></span><br><span class="line"><span class="comment">//2.根据structName去data里面把对应的嵌套结构体给取出来</span></span><br><span class="line">v:=reflect.ValueOf(data)</span><br><span class="line">sValue :=v.Elem().FieldByName(structName)</span><br><span class="line">sType :=sValue.Type()</span><br><span class="line"><span class="keyword">if</span> sValue.Kind() != reflect.Struct&#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"data中的%s字段应该是一个结构体"</span>,structName)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fieldName <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> fileType reflect.StructField</span><br><span class="line"><span class="comment">//3.遍历嵌套结构体的每一个字段，判断tag是不是等于key</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt;sValue.NumField();i++&#123;</span><br><span class="line">filed :=sType.Field(i)</span><br><span class="line">fileType =filed</span><br><span class="line"><span class="keyword">if</span> filed.Tag.Get(<span class="string">"ini"</span>) ==key&#123;</span><br><span class="line"><span class="comment">//找到相应的字段</span></span><br><span class="line">fieldName= filed.Name</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.如果key=tag ，给这个字段赋值</span></span><br><span class="line"><span class="comment">//4.1根据fieldName去取出这个字段</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fieldName) == <span class="number">0</span> &#123; <span class="comment">//value长度为0</span></span><br><span class="line"><span class="comment">//在结构体中找不到对应的字符</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj :=sValue.FieldByName(fieldName)</span><br><span class="line"><span class="comment">//4.2对其赋值</span></span><br><span class="line">fmt.Println(fieldName,fileType.Type.Kind())<span class="comment">//address string</span></span><br><span class="line"><span class="keyword">switch</span> fileType.Type.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.String:</span><br><span class="line">fileObj.SetString(value)</span><br><span class="line"><span class="keyword">case</span> reflect.Int,reflect.Int8,reflect.Int16,reflect.Int32,reflect.Int64:</span><br><span class="line"><span class="keyword">var</span> valueInt <span class="keyword">int64</span></span><br><span class="line">valueInt,err = strconv.ParseInt(value,<span class="number">10</span>,<span class="number">64</span>)<span class="comment">//10进制，64位</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"ling:%d value type error "</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetInt(valueInt)</span><br><span class="line"><span class="keyword">case</span> reflect.Bool:</span><br><span class="line"><span class="keyword">var</span> valueBool <span class="keyword">bool</span></span><br><span class="line">valueBool,err = strconv.ParseBool(value)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d value type error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetBool(valueBool)</span><br><span class="line"><span class="keyword">case</span> reflect.Float32,reflect.Float64:</span><br><span class="line"><span class="keyword">var</span> valueFloat <span class="keyword">float64</span></span><br><span class="line">valueFloat,err = strconv.ParseFloat(value,<span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err =fmt.Errorf(<span class="string">"line:%d value type error"</span>,idx+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fileObj.SetFloat(valueFloat)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> cfg Config</span><br><span class="line">err :=loadIni(<span class="string">"./conf.ini"</span>,&amp;cfg)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"load ini failed,err %v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>,cfg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">ptr</span><br><span class="line">找到mysql对应的潜逃结构体MysqlConfig</span><br><span class="line">Address <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">Username <span class="keyword">string</span></span><br><span class="line">Password <span class="keyword">string</span></span><br><span class="line">找到redis对应的潜逃结构体RedisConfig</span><br><span class="line">Host <span class="keyword">string</span></span><br><span class="line">Port <span class="keyword">int</span></span><br><span class="line">Password <span class="keyword">string</span></span><br><span class="line">Database <span class="keyword">int</span></span><br><span class="line">Test <span class="keyword">bool</span></span><br><span class="line">main.Config&#123;MysqlConfig:main.MysqlConfig&#123;Address:<span class="string">"127.0.0.1"</span>, Port:<span class="number">3306</span>, Username:<span class="string">"root"</span>, Password:<span class="string">"root"</span>&#125;, RedisConfig:main.RedisConfig&#123;Host:<span class="string">"127.0.0.1"</span>, Port:<span class="number">6379</span>, Password:<span class="string">"root"</span>, Database:<span class="number">0</span>, Test:<span class="literal">false</span>&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13Go语言基础之文件操作</title>
      <link href="/2020/01/28/13Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/01/28/13Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言文件操作"><a href="#Go语言文件操作" class="headerlink" title="Go语言文件操作"></a>Go语言文件操作</h1><p>主要介绍了Go语言中文件读写的相关操作。</p><p>文件是什么？</p><p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p><a id="more"></a><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 使用Read方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"读取了%d字节数据\n"</span>, n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">"./xx.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">line, err := reader.ReadString(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h2><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString区别"><a href="#Write和WriteString区别" class="headerlink" title="Write和WriteString区别"></a>Write和WriteString区别</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">file.Write([]<span class="keyword">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">"hello 小王子"</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writer.WriteString(<span class="string">"hello沙河\n"</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"./xx.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h2><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyFile 拷贝文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 以读方式打开源文件</span></span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, srcName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> src.Close()</span><br><span class="line"><span class="comment">// 以写|创建的方式打开目标文件</span></span><br><span class="line">dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, dstName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line"><span class="keyword">return</span> io.Copy(dst, src) <span class="comment">//调用io.Copy()拷贝内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := CopyFile(<span class="string">"dst.txt"</span>, <span class="string">"src.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"copy file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"copy done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h2><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat命令实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf, err := r.ReadBytes(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line"><span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有参数默认从标准输入读取内容</span></span><br><span class="line">cat(bufio.NewReader(os.Stdin))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次读取每个指定文件的内容并打印到终端</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">f, err := os.Open(flag.Arg(i))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"reading from %s failed, err:%v\n"</span>, flag.Arg(i), err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cat(bufio.NewReader(f))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12Go语言基础之包</title>
      <link href="/2020/01/25/12Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/"/>
      <url>/2020/01/25/12Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之包"><a href="#Go语言基础之包" class="headerlink" title="Go语言基础之包"></a>Go语言基础之包</h1><p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。</p><a id="more"></a><h1 id="Go语言的包（package）"><a href="#Go语言的包（package）" class="headerlink" title="Go语言的包（package）"></a>Go语言的包（package）</h1><p>1.包的路径从<code>GOPATH/src</code>后面的路径开始写起，路径分隔符用<code>/</code></p><p>2.想被别的宝地啊用的标识符都要首字母大写</p><p>3.单行导入和多行导入</p><p>4.导入包的时候可以制定别名</p><p>5.导入包不想使用包内部的标识符，需要使用匿名导入</p><p>6.每个包导入的时候会自动执行一个名为<code>init()</code>的函数，它没有参数也没有返回值</p><p>7.多个包中都定义了<code>init()</code>函数，执行顺序如下</p><h2 id="包介绍"><a href="#包介绍" class="headerlink" title="包介绍"></a>包介绍</h2><p><code>包（package）</code>是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p>我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个文件夹下面直接包含的文件只能归属一个<code>package</code>，同样一个<code>package</code>的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 <code>-</code> 符号。</li><li>包名为<code>main</code>的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含<code>main</code>包的源代码则不会得到可执行文件。</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。</p><p>举个例子， 我们定义一个包名为<code>pkg2</code>的包，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包变量可见性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="keyword">const</span> Mode = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首字母大写，外部包可见，可在其他包中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">age</span><span class="params">()</span></span> &#123; <span class="comment">// 首字母小写，外部包不可见，只能在当前包内使用</span></span><br><span class="line"><span class="keyword">var</span> Age = <span class="number">18</span> <span class="comment">// 函数局部变量，外部包不可见，只能在当前函数内使用</span></span><br><span class="line">fmt.Println(Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="comment">//可在包外访问的方法</span></span><br><span class="line">class <span class="keyword">string</span> <span class="comment">//仅限包内访问的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Payer <span class="keyword">interface</span> &#123;</span><br><span class="line">init() <span class="comment">//仅限包内访问的方法</span></span><br><span class="line">Pay()  <span class="comment">//可在包外访问的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h2><p>要在代码中引用其他包的内容，需要使用<code>import</code>关键字导入使用的包。具体语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>import导入语句通常放在文件开头包声明语句的下面。</li><li>导入的包名需要使用双引号包裹起来。</li><li>包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔。</li><li>Go语言中禁止循环导入包。</li></ul><h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><p>单行导入的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"包2"</span></span><br></pre></td></tr></table></figure><h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><p>多行导入的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"包1"</span></span><br><span class="line">    <span class="string">"包2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a>自定义包名</h2><p>在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 别名 <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>单行导入方式定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> m <span class="string">"github.com/Q1mi/studygo/pkg_test"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m.Add(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行导入方式定义别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    m <span class="string">"github.com/Q1mi/studygo/pkg_test"</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m.Add(<span class="number">100</span>, <span class="number">200</span>))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h2><p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"包的路径"</span></span><br></pre></td></tr></table></figure><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><h2 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h2><h3 id="init-函数介绍"><a href="#init-函数介绍" class="headerlink" title="init()函数介绍"></a>init()函数介绍</h3><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。</p><p>包初始化执行的顺序如下图所示：<img src="https://www.liwenzhou.com/images/Go/package/init01.png" alt="包中的init()执行时机"></p><h3 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init()函数执行顺序"></a>init()函数执行顺序</h3><p>Go语言包会从<code>main</code>包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p><p>在运行时，被最后导入的包会最先初始化并调用其<code>init()</code>函数， 如下图示：<img src="https://www.liwenzhou.com/images/Go/package/init02.png" alt="包之间的init()执行顺序"></p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写一个<code>clac</code>包实现加减乘除四个功能函数，在<code>snow</code>这个包中导入并使用加减乘除四个函数实现数学运算。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11Go语言基础之接口</title>
      <link href="/2020/01/25/11Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/01/25/11Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之接口"><a href="#Go语言基础之接口" class="headerlink" title="Go语言基础之接口"></a>Go语言基础之接口</h1><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><a id="more"></a><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p><p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p><h2 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"喵喵喵"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"汪汪汪"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := Cat&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"猫:"</span>, c.Say())</span><br><span class="line">d := Dog&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"狗:"</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？</p><p>像类似的例子在我们编程过程中会经常遇到：</p><p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p><p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p><p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</p><p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p><h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>Go语言提倡面向接口编程。</p><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p><h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。</p><p>我们来定义一个<code>Sayer</code>接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>dog</code>和<code>cat</code>两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Sayer</code>接口里只有一个<code>say</code>方法，所以我们只需要给<code>dog</code>和<code>cat</code>分别实现<code>say</code>方法就可以实现<code>Sayer</code>接口了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"汪汪汪"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"喵喵喵"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p><h2 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h2><p>那实现了接口有什么用呢？</p><p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，<code>Sayer</code>类型的变量能够存储<code>dog</code>和<code>cat</code>类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是<code>dog</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针<em>dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值`</em>fugui`。</p><h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*dog</code>类型，所以不能给<code>x</code>传入<code>dog</code>类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>注意：</strong>这是一道你需要回答“能”或者“不能”的题！</p><p>首先请观察下面的这段代码，然后请回答这段代码能不能通过编译？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> think == <span class="string">"sb"</span> &#123;</span><br><span class="line">talk = <span class="string">"你是个大帅比"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">talk = <span class="string">"您好"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">think := <span class="string">"bitch"</span></span><br><span class="line">fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： <code>Mover</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dog既可以实现Sayer接口，也可以实现Mover接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会叫汪汪汪\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Sayer</span><br><span class="line"><span class="keyword">var</span> y Mover</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line">x = a</span><br><span class="line">y = a</span><br><span class="line">x.say()</span><br><span class="line">y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个<code>Mover</code>接口，它要求必须由一个<code>move</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会跑\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// car类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s速度70迈\n"</span>, c.brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的<code>move</code>方法就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> a = dog&#123;name: <span class="string">"旺财"</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = car&#123;brand: <span class="string">"保时捷"</span>&#125;</span><br><span class="line">x = a</span><br><span class="line">x.move()</span><br><span class="line">x = b</span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度<span class="number">70</span>迈</span><br></pre></td></tr></table></figure><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"甩一甩"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"洗刷刷"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Sayer</span><br><span class="line">Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"喵喵喵"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"猫会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x animal</span><br><span class="line">x = cat&#123;name: <span class="string">"花花"</span>&#125;</span><br><span class="line">x.move()</span><br><span class="line">x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个空接口x</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">s := <span class="string">"Hello 沙河"</span></span><br><span class="line">x = s</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">x = i</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">b := <span class="literal">true</span></span><br><span class="line">x = b</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">"name"</span>] = <span class="string">"沙河娜扎"</span></span><br><span class="line">studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>一个接口的值（简称接口值）是由<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的。这两部分分别称为接口的<code>动态类型</code>和<code>动态值</code>。</p><p>我们来看一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>请看下图分解：<img src="https://www.liwenzhou.com/images/Go/interface/interface.png" alt="接口值图解"></p><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示类型为<code>interface{}</code>的变量</li><li>T：表示断言<code>x</code>可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">"Hello 沙河"</span></span><br><span class="line">v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中如果要断言多次就需要写多个<code>if</code>判断，这个时候我们可以使用<code>switch</code>语句来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a string，value is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a int is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a bool is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"unsupport type！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p><p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10Go语言基础之结构体</title>
      <link href="/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2020/01/17/10Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之结构体"><a href="#Go语言基础之结构体" class="headerlink" title="Go语言基础之结构体"></a>Go语言基础之结构体</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><a id="more"></a><h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过<code>Type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type（<span class="keyword">int</span>，<span class="keyword">string</span>，<span class="keyword">byte</span>。。。）</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">name, city <span class="keyword">string</span></span><br><span class="line">age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">"沙河娜扎"</span></span><br><span class="line">p1.city = <span class="string">"北京"</span></span><br><span class="line">p1.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person&#123;name:"沙河娜扎", city:"北京", age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//匿名结构体</span></span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">"小王子"</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">"小王子"</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">"上海"</span></span><br><span class="line">fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:"小王子", city:"上海", age:28&#125;</span></span><br></pre></td></tr></table></figure><h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。（new &amp;make申请内存空间）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person（自定义类型）</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">"七米"</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">"成都"</span></span><br><span class="line">fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:"七米", city:"成都", age:30&#125;</span></span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">city <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p4 person</span><br><span class="line">fmt.Printf(<span class="string">"p4=%#v\n"</span>, p4) <span class="comment">//p4=main.person&#123;name:"", city:"", age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">name: <span class="string">"小王子"</span>,</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p6=%#v\n"</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:"小王子", city:"北京", age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">city: <span class="string">"北京"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:"", city:"北京", age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line"><span class="string">"沙河娜扎"</span>,</span><br><span class="line"><span class="string">"北京"</span>,</span><br><span class="line"><span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"p8=%#v\n"</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:"沙河娜扎", city:"北京", age:28&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int8</span></span><br><span class="line">b <span class="keyword">int8</span></span><br><span class="line">c <span class="keyword">int8</span></span><br><span class="line">d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"n.a %p\n"</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">"n.b %p\n"</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">"n.c %p\n"</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">"n.d %p\n"</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com" target="_blank" rel="noopener">在 Go 中恰到好处的内存对齐</a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>请问下面代码的执行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">stus := []student&#123;</span><br><span class="line">&#123;name: <span class="string">"小王子"</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"娜扎"</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"大王八"</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">m[stu.name] = &amp;stu</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">"=&gt;"</span>, v.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数：约定成俗new开头</span></span><br><span class="line"><span class="comment">//返回的是结构体还是结构体指针</span></span><br><span class="line"><span class="comment">//当结构体比较大的时候尽量使用结构体指针，减少程序的内存开销</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">"张三"</span>, <span class="string">"沙河"</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p9) <span class="comment">//&amp;main.person&#123;name:"张三", city:"沙河", age:90&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法作用于特定类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;<span class="comment">//只用dog才能使用</span></span><br><span class="line">fucn(d *dog)wang()&#123;</span><br><span class="line">    fmt.Println(<span class="string">"汪汪汪"</span>，d.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s的梦想是学好Go语言！\n"</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者：传内存地址进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge(<span class="number">30</span>)</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者 ：传拷贝进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := NewPerson(<span class="string">"小王子"</span>, <span class="number">25</span>)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, 我是一个int。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v  %T\n"</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">    <span class="comment">//不能再定义string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">"小王子"</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person&#123;string:"北京", int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address Address  <span class="comment">//如果换成Address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">"小王子"</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">"山东"</span>,</span><br><span class="line">City:     <span class="string">"威海"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(user1.Address.city)  <span class="comment">//如果上面换成匿名Address ，user1.city 就可以直接访问</span></span><br><span class="line">    fmt.Println(user1.city)<span class="comment">//现在自己的结构体里面找，找不到就去匿名嵌套的结构体里面找</span></span><br><span class="line">    fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)<span class="comment">//user1=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a>嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.Name = <span class="string">"小王子"</span></span><br><span class="line">user2.Gender = <span class="string">"男"</span></span><br><span class="line">user2.Address.Province = <span class="string">"山东"</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">user2.City = <span class="string">"威海"</span> <span class="comment">//（user2.Address.city）               //直接访问匿名结构体的字段名</span></span><br><span class="line">fmt.Printf(<span class="string">"user2=%#v\n"</span>, user2) <span class="comment">//user2=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province   <span class="keyword">string</span></span><br><span class="line">City       <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">Account    <span class="keyword">string</span></span><br><span class="line">CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user3 User</span><br><span class="line">user3.Name = <span class="string">"沙河娜扎"</span></span><br><span class="line">user3.Gender = <span class="string">"男"</span></span><br><span class="line"><span class="comment">// user3.CreateTime = "2019" //ambiguous selector user3.CreateTime</span></span><br><span class="line">user3.Address.CreateTime = <span class="string">"2000"</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">user3.Email.CreateTime = <span class="string">"2000"</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动！\n"</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="keyword">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会汪汪汪~\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">"乐乐"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体字段的可见性（-）"><a href="#结构体字段的可见性（-）" class="headerlink" title="结构体字段的可见性（**）"></a>结构体字段的可见性（**）</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span></span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">"101"</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;"Title":"101","Students":[&#123;"ID":0,"Gender":"男","Name":"stu00"&#125;,&#123;"ID":1,"Gender":"男","Name":"stu01"&#125;,&#123;"ID":2,"Gender":"男","Name":"stu02"&#125;,&#123;"ID":3,"Gender":"男","Name":"stu03"&#125;,&#123;"ID":4,"Gender":"男","Name":"stu04"&#125;,&#123;"ID":5,"Gender":"男","Name":"stu05"&#125;,&#123;"ID":6,"Gender":"男","Name":"stu06"&#125;,&#123;"ID":7,"Gender":"男","Name":"stu07"&#125;,&#123;"ID":8,"Gender":"男","Name":"stu08"&#125;,&#123;"ID":9,"Gender":"男","Name":"stu09"&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">"value1"</span> key2:<span class="string">"value2"</span>`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 <strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key </span></span><br><span class="line">name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := Student&#123;</span><br><span class="line">ID:     <span class="number">1</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">name:   <span class="string">"沙河娜扎"</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(s1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json str:%s\n"</span>, data) <span class="comment">//json str:&#123;"id":1,"Gender":"男"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体中遇到的问题"><a href="#结构体中遇到的问题" class="headerlink" title="结构体中遇到的问题"></a>结构体中遇到的问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个int类型的变量，它的值是10//1</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">x =<span class="number">10</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span>=<span class="number">10</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">x :=<span class="keyword">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="keyword">var</span> myInt <span class="keyword">int</span> <span class="comment">//自定义类型</span></span><br><span class="line">m :=myInt(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>问题2结构体初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pserson <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span> </span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法1，声明一个person类型的变量p</span></span><br><span class="line">    <span class="keyword">var</span> p person</span><br><span class="line">    p.name=<span class="string">"hg"</span></span><br><span class="line">    p.age=<span class="number">19</span></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    <span class="comment">//方法2，键值对初始化</span></span><br><span class="line">    <span class="keyword">var</span> p2=person&#123;</span><br><span class="line">        name :<span class="string">"hg"</span>,</span><br><span class="line">        age : <span class="number">19</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p2)</span><br><span class="line">    <span class="comment">//方法3，zhi值列表初始化</span></span><br><span class="line">    <span class="keyword">var</span> p3 = person&#123;</span><br><span class="line">        <span class="string">"理想"</span>，</span><br><span class="line">        <span class="number">12</span>，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题3：为什么要用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(x <span class="keyword">string</span>,y <span class="keyword">int</span>)</span> <span class="title">person</span></span>&#123;      <span class="comment">//返回*person</span></span><br><span class="line">    <span class="comment">//别人调用，我能给他一个person类型的变量 </span></span><br><span class="line">    <span class="keyword">return</span> person&#123;<span class="comment">//return &amp;person</span></span><br><span class="line">        name:x,</span><br><span class="line">        age :y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>使用“面向对象”的思维方式编写一个学生信息管理系统。<ol><li>学生有id、姓名、年龄、分数等信息</li><li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数版学生管理系统，</span></span><br><span class="line"><span class="comment">写一个系统能够产看，新增学生，删除学生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">allStudent <span class="keyword">map</span>[<span class="keyword">int64</span>]*student <span class="comment">//变量声明</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newStudnet</span><span class="params">(id <span class="keyword">int64</span>,name <span class="keyword">string</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">id : id ,</span><br><span class="line">name : name,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示所有学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showallStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k,v :=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line">fmt.Printf(<span class="string">"学号：%d 姓名：%s\n"</span>,k,v.name,)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加学生</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建一个学生</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">id <span class="keyword">int64</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生学号："</span>)</span><br><span class="line">fmt.Scanln(&amp;id)</span><br><span class="line">fmt.Println(<span class="string">"请输入学生姓名："</span>)</span><br><span class="line">fmt.Scanln(&amp;name)</span><br><span class="line">newStu :=newStudnet(id,name)</span><br><span class="line"><span class="comment">//2追加到allstudent这个map中</span></span><br><span class="line">allStudent[id]=newStu</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteStudent</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//1.请输入删除学生的学号</span></span><br><span class="line"><span class="keyword">var</span> deleteId  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"请输入你要删除学生的学号:"</span>)</span><br><span class="line">fmt.Scanln(&amp;deleteId)</span><br><span class="line"><span class="comment">//2.去allStudent这个map中根据学号删除对应的键值对</span></span><br><span class="line"><span class="keyword">for</span> k,_:=<span class="keyword">range</span> allStudent&#123;</span><br><span class="line"><span class="keyword">if</span> k==deleteId&#123;</span><br><span class="line"><span class="built_in">delete</span>(allStudent,deleteId)</span><br><span class="line">fmt.Println(<span class="string">"删除成功"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">allStudent =<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*student,<span class="number">48</span>) <span class="comment">//初始化（开辟内存空间）</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//1.打印菜单</span></span><br><span class="line">fmt.Println(<span class="string">"欢迎学生管理系统"</span>)</span><br><span class="line">fmt.Println(<span class="string">`</span></span><br><span class="line"><span class="string">1.查看所用学生</span></span><br><span class="line"><span class="string">2.新增学生</span></span><br><span class="line"><span class="string">3.删除学生</span></span><br><span class="line"><span class="string">4.退出</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line">fmt.Println(<span class="string">"请输入你要干啥:"</span>)</span><br><span class="line"><span class="comment">//2.等待用户选择要做什么</span></span><br><span class="line"><span class="keyword">var</span> choice <span class="keyword">int</span></span><br><span class="line">fmt.Scanln(&amp;choice)</span><br><span class="line">fmt.Printf(<span class="string">"你选择了%d这个选项\n"</span>, choice)</span><br><span class="line"><span class="comment">//3.执行对应的函数</span></span><br><span class="line"><span class="keyword">switch</span> choice &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">showallStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">addStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">deleteStudent()</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"gun~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09Go语言基础之函数</title>
      <link href="/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
      <url>/2020/01/17/09Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之函数"><a href="#Go语言基础之函数" class="headerlink" title="Go语言基础之函数"></a>Go语言基础之函数</h1><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello 沙河"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret := intSum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h3><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名的函数值就相当于在函数中声明一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x,y <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int</span>)</span></span>&#123;  <span class="comment">//若func f(x,y int) int()&#123; return x+y&#125;</span></span><br><span class="line">res =x+y</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//命名的返回值可以不写res</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//可变长参数，必须放在函数的最后</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s</span><span class="params">(s <span class="keyword">string</span>,y... <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(y)  <span class="comment">//y的类型是切片slice</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go函数没有默认参数这个概念</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">r :=f(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s(<span class="string">"hg"</span>)   <span class="comment">//hg []</span></span><br><span class="line">s(<span class="string">"huang"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)<span class="comment">//huang [1 2 3 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum2</span><span class="params">(x ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x) <span class="comment">//x是一个切片       </span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 := intSum2()</span><br><span class="line">ret2 := intSum2(<span class="number">10</span>)</span><br><span class="line">ret3 := intSum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret4 := intSum2(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) <span class="comment">//0 10 30 60</span></span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum := x</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">sum = sum + v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 := intSum3(<span class="number">100</span>)</span><br><span class="line">ret6 := intSum3(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">ret7 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">ret8 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) <span class="comment">//100 110 130 160</span></span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言中通过<code>return</code>关键字向外输出返回值。</p><h3 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h3><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h3><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGlobalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">//函数中可以访问全局变量num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testGlobalVar() <span class="comment">//num=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//定义一个函数局部变量x,仅在该函数内生效</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"x=%d\n"</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) <span class="comment">// 此时无法使用变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNum</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">"num=%d\n"</span>, num) <span class="comment">// 函数中优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testNum() <span class="comment">// num=100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar2</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x, y) <span class="comment">//函数的参数也是只在本函数中生效</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">z := <span class="number">100</span> <span class="comment">//变量z只在if语句块生效</span></span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(z)//此处无法使用变量z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testLocalVar3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i) <span class="comment">//变量i只在当前for语句块中生效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(i) //此处无法使用变量i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h2><h3 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h3><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line">c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用声明calculation也可以直接函数赋值</span></span><br><span class="line">f := add                        <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line">fmt.Printf(<span class="string">"type of f:%T\n"</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line">fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><p>函数可以作为参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="keyword">int</span>, op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>函数也可以作为返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> add, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> sub, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err := errors.New(<span class="string">"无法识别的操作符"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。 首先我们来看一个例子：  (闭包是一个函数，函数是可以成为返回值，这个函数包含了他外部作用域的一个变量)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = adder()   <span class="comment">//func f(y int) int&#123; x+=y  return x&#125;</span></span><br><span class="line"> fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line"></span><br><span class="line">f1 := adder()</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = adder2(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//70</span></span><br><span class="line"></span><br><span class="line">f1 := adder2(<span class="number">20</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//60</span></span><br><span class="line">fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">jpgFunc := makeSuffixFunc(<span class="string">".jpg"</span>)</span><br><span class="line">txtFunc := makeSuffixFunc(<span class="string">".txt"</span>)</span><br><span class="line">fmt.Println(jpgFunc(<span class="string">"test"</span>)) <span class="comment">//test.jpg</span></span><br><span class="line">fmt.Println(txtFunc(<span class="string">"test"</span>)) <span class="comment">//test.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"start"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h3 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h3><p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：第一步：返回值赋值。第二部：真正的return返回；</p><p>函数中如果存在defer。那么defer执行的时机是在第一步和第二步之间</p><p><img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p><h3 id="defer经典案例-面试题"><a href="#defer经典案例-面试题" class="headerlink" title="defer经典案例(面试题)"></a>defer经典案例(面试题)</h3><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">int</span></span> &#123;   <span class="comment">//f1()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//x=6</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x   <span class="comment">//x =5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f2()=6  定义了返回值</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>   <span class="comment">//返回值=x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(y <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//f3()=5</span></span><br><span class="line">x := <span class="number">5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x++   <span class="comment">//修改的是x的值</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x  <span class="comment">//返回值y=x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span> <span class="params">(x <span class="keyword">int</span>)</span></span> &#123;   <span class="comment">//f4()=5</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x++  <span class="comment">//改变函数中的副本</span></span><br><span class="line">&#125;(x)<span class="comment">//外部穿的参数，属于局部变量，不是返回值x传进去的参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span> <span class="comment">//返回值x=5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">fmt.Println(f3())</span><br><span class="line">fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="keyword">string</span>, a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"AA"</span>, x, calc(<span class="string">"A"</span>, x, y))</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">"BB"</span>, x, calc(<span class="string">"B"</span>, x, y))</span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A 1 2 3</span></span><br><span class="line"><span class="comment">B 0 2 2</span></span><br><span class="line"><span class="comment">BB 0 2 2</span></span><br><span class="line"><span class="comment">AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 x=1 y=2     defer 是压栈，先进后出</span></span><br><span class="line"><span class="comment">//2 defer calc("AA",x,calc("A", x, y))  压栈的时候将x存进去</span></span><br><span class="line"><span class="comment">//3 calc("A", x, y) //"A" 1 2 3</span></span><br><span class="line"><span class="comment">//4 defer calc("AA",x,3)  （x =1）</span></span><br><span class="line"><span class="comment">//5 x=0</span></span><br><span class="line"><span class="comment">//6 defer calc("BB",x,calc("B", x, y))</span></span><br><span class="line"><span class="comment">//7 calc("B", x, y) //"B" 0 2 2    </span></span><br><span class="line"><span class="comment">//8 defer calc("BB",x,2)</span></span><br><span class="line"><span class="comment">//9 y=1 （有点混淆，没有被引用过）</span></span><br><span class="line"><span class="comment">//10 calc("BB",x,2) //"BB" 0 2 2  出栈  </span></span><br><span class="line"><span class="comment">//calc("AA",x,3) //"AA" 1 3 4   这里有点特别  （x=1 为原先的）</span></span><br></pre></td></tr></table></figure><p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p><h1 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h1><table><thead><tr><th align="center">内置函数</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">close</td><td align="center">主要用来关闭channel</td></tr><tr><td align="center">len</td><td align="center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td align="center">new</td><td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td align="center">make</td><td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td align="center">append</td><td align="center">用来追加元素到数组、slice中</td></tr><tr><td align="center">panic和recover</td><td align="center">用来做错误处理</td></tr></tbody></table><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h3><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic <span class="keyword">in</span> B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        .../code/func/main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        .../code/func/main.go:20 +0x98</span><br></pre></td></tr></table></figure><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recover in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"panic in B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>分金币</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span></span><br><span class="line"><span class="comment">分配规则如下：</span></span><br><span class="line"><span class="comment">a. 名字中每包含1个'e'或'E'分1枚金币</span></span><br><span class="line"><span class="comment">b. 名字中每包含1个'i'或'I'分2枚金币</span></span><br><span class="line"><span class="comment">c. 名字中每包含1个'o'或'O'分3枚金币</span></span><br><span class="line"><span class="comment">d: 名字中每包含1个'u'或'U'分4枚金币</span></span><br><span class="line"><span class="comment">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span></span><br><span class="line"><span class="comment">程序结构如下，请实现 ‘dispatchCoin’ 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">coins = <span class="number">50</span></span><br><span class="line">users = []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Matthew"</span>, <span class="string">"Sarah"</span>, <span class="string">"Augustus"</span>, <span class="string">"Heidi"</span>, <span class="string">"Emilie"</span>, <span class="string">"Peter"</span>, <span class="string">"Giana"</span>, <span class="string">"Adriano"</span>, <span class="string">"Aaron"</span>, <span class="string">"Elizabeth"</span>,</span><br><span class="line">&#125;</span><br><span class="line">distribution = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">left := dispatchCoin()</span><br><span class="line">fmt.Println(<span class="string">"剩下："</span>, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08Go语言基础之Map</title>
      <link href="/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/"/>
      <url>/2020/01/17/08Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8BMap/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之map"><a href="#Go语言基础之map" class="headerlink" title="Go语言基础之map"></a>Go语言基础之map</h1><p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p><a id="more"></a><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>Go语言中 <code>map</code>的定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[<span class="string">"小明"</span>])</span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line"><span class="built_in">type</span> of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"username"</span>: <span class="string">"沙河小王子"</span>,</span><br><span class="line"><span class="string">"password"</span>: <span class="string">"123456"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//开辟内存空间，要估值好map容量，避免在程序运行期间再动态扩容</span></span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">v, ok := scoreMap[<span class="string">"张三"</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"查无此人"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;  <span class="comment">//默认获得key值</span></span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> _,value:=<span class="keyword">range</span> scoreMap&#123; <span class="comment">//获取value值</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line"><span class="built_in">delete</span>(scoreMap, <span class="string">"小明"</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按照指定顺序遍历map（map本身是无序的）"><a href="#按照指定顺序遍历map（map本身是无序的）" class="headerlink" title="按照指定顺序遍历map（map本身是无序的）"></a>按照指定顺序遍历map（map本身是无序的）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"stu%02d"</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">scoreMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">//按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//元素类型为map的切片</span></span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"name"</span>] = <span class="string">"小王子"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"password"</span>] = <span class="string">"123456"</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">"address"</span>] = <span class="string">"沙河"</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d value:%v\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">"after init"</span>)</span><br><span class="line">key := <span class="string">"中国"</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">"北京"</span>, <span class="string">"上海"</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li></ol><h4 id="看文档"><a href="#看文档" class="headerlink" title="看文档"></a>看文档</h4><p> go doc builtin.delete(delete代表方法)</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07Go语言基础之指针</title>
      <link href="/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/"/>
      <url>/2020/01/17/07Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之指针"><a href="#Go语言基础之指针" class="headerlink" title="Go语言基础之指针"></a>Go语言基础之指针</h1><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><a id="more"></a><h1 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h1><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h2 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h2><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为<code>T</code></li><li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a:%d ptr:%p\n"</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">fmt.Printf(<span class="string">"b:%p type:%T\n"</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">    </span><br><span class="line">    n :=<span class="number">18</span></span><br><span class="line">p :=&amp;n</span><br><span class="line">fmt.Println(&amp;n)<span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,p) <span class="comment">//*int</span></span><br><span class="line">fmt.Println(p) <span class="comment">//0xc04200e0a0</span></span><br><span class="line">fmt.Println(*p)<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">m :=*p</span><br><span class="line">fmt.Println(m) <span class="comment">//18</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,m)<span class="comment">//int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：<img src="https://www.liwenzhou.com/images/Go/pointer/ptr.png" alt="取变量地址图示"></p><h2 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a>指针取值</h2><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//指针取值</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">b := &amp;a <span class="comment">// 取变量a的地址，将指针保存到b中</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b)</span><br><span class="line">c := *b <span class="comment">// 指针取值（根据指针去内存取值）</span></span><br><span class="line">fmt.Printf(<span class="string">"type of c:%T\n"</span>, c)</span><br><span class="line">fmt.Printf(<span class="string">"value of c:%v\n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of b:*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> of c:<span class="keyword">int</span></span><br><span class="line">value of c:<span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p><strong>指针传值示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// var a *int //nil pointer</span></span><br><span class="line"><span class="comment">// *a =100</span></span><br><span class="line"><span class="comment">// fmt.Println(*a)//报错无效内存地址和空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 *<span class="keyword">int</span>  </span><br><span class="line">fmt.Println(a1)  <span class="comment">//nil</span></span><br><span class="line"><span class="keyword">var</span> a2=<span class="built_in">new</span>(<span class="keyword">int</span>)  <span class="comment">//new函数申请一个内存地址</span></span><br><span class="line">fmt.Println(a2) <span class="comment">//0xc04204a0e0</span></span><br><span class="line">*a2 =<span class="number">100</span></span><br><span class="line">fmt.Println(*a2) <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h2><p>我们先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">100</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><h5 id="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："><a href="#make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：" class="headerlink" title="make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下："></a>make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">b[<span class="string">"沙河娜扎"</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new与make的区别（面试题）"><a href="#new与make的区别（面试题）" class="headerlink" title="new与make的区别（面试题）"></a>new与make的区别（面试题）</h3><ol><li>二者都是用来做（申请）内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型（int string …）的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06Go语言基础之切片</title>
      <link href="/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/"/>
      <url>/2020/01/17/06Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之切片"><a href="#Go语言基础之切片" class="headerlink" title="Go语言基础之切片"></a>Go语言基础之切片</h1><p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [3]<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">        sum = sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明切片类型</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="keyword">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。</p><h3 id="基于数组定义切片"><a href="#基于数组定义切片" class="headerlink" title="基于数组定义切片"></a>基于数组定义切片</h3><p>由于切片的底层就是一个数组，所以我们可以基于数组定义切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于数组定义切片</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">4</span>]                     <span class="comment">//基于数组a创建切片，前包后不包，包括元素a[1],a[2],a[3]</span></span><br><span class="line">fmt.Println(b)                  <span class="comment">//[56 57 58]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:[]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还支持如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := a[<span class="number">1</span>:] <span class="comment">//[56 57 58 59]</span></span><br><span class="line">d := a[:<span class="number">4</span>] <span class="comment">//[55 56 57 58]</span></span><br><span class="line">e := a[:]  <span class="comment">//[55 56 57 58 59]</span></span><br></pre></td></tr></table></figure><h3 id="切片再切片"><a href="#切片再切片" class="headerlink" title="切片再切片"></a>切片再切片</h3><p>除了基于数组得到切片，我们还可以通过切片来得到切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//切片再切片</span></span><br><span class="line">a := [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>, <span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"a:%v type:%T len:%d  cap:%d\n"</span>, a, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))<span class="comment">//6 6</span></span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"b:%v type:%T len:%d  cap:%d\n"</span>, b, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))<span class="comment">//2 5</span></span><br><span class="line">c := b[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"c:%v type:%T len:%d  cap:%d\n"</span>, c, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c)) <span class="comment">//4  4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:[北京 上海 广州 深圳 成都 重庆] <span class="built_in">type</span>:[6]string len:6  <span class="built_in">cap</span>:6</span><br><span class="line">b:[上海 广州] <span class="built_in">type</span>:[]string len:2  <span class="built_in">cap</span>:5</span><br><span class="line">c:[广州 深圳 成都 重庆] <span class="built_in">type</span>:[]string len:4  <span class="built_in">cap</span>:4</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 对切片进行再切片时，索引不能超过原数组的长度，否则会出现索引越界的错误。</p><p>​            切片指向一个底层数组</p><p>​            切片的长度就是它元素的个数</p><p>​            切片的容量，是最底层数组从切片的第一个元素到最后一个元素的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s6 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s7 :=s6[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//len (2 3 4)   cap(2 3 4 5 6 7)   </span></span><br><span class="line">fmt.Printf(<span class="string">"len(s7)%d   cap(s7)%d"</span>,<span class="built_in">len</span>(s7),<span class="built_in">cap</span>(s7)) <span class="comment">//3 ,6</span></span><br></pre></td></tr></table></figure><p>1.切片不保存具体的值</p><p>2.切片对应一个底层数组</p><p>3.底层数组都是占用一块连续的内存</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a1 :=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">a2 := a1  <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">// var a3 []int //这样定义a3为nil  没办法进行copy</span></span><br><span class="line"><span class="keyword">var</span> a3 =<span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">copy</span>(a3,a1)  <span class="comment">//a1复制到a3</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[1 3 5] [1 3 5] [1 3 5]</span></span><br><span class="line">a1[<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line">fmt.Println(a1,a2,a3)<span class="comment">//[100 3 5] [100 3 5] [1 3 5]  由于切片是引用类型a1给a2赋值，都指向同一块内存地址</span></span><br><span class="line"></span><br><span class="line">x1 :=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//数组</span></span><br><span class="line">s1 :=x1[:]<span class="comment">//切片</span></span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 2 3] 3 3 </span></span><br><span class="line">s1=<span class="built_in">append</span>(s1[:<span class="number">1</span>],s1[<span class="number">2</span>:]...)</span><br><span class="line">fmt.Println(s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[1 3] 2 3 删除一个元素</span></span><br><span class="line">fmt.Println(x1) <span class="comment">//[1 3 3]  //修改了底层数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a =<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0]</span></span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">a =<span class="built_in">append</span>(a,i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)<span class="comment">//[0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//20扩容 面试题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 =[...]<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>&#125;</span><br><span class="line">sort.Ints(b1[:]) <span class="comment">//对切片进行排序</span></span><br><span class="line">fmt.Println(b1)<span class="comment">//1，2，4，9</span></span><br></pre></td></tr></table></figure><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">10</span>)  <span class="comment">//创建切片</span></span><br><span class="line">fmt.Println(a)      <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(a)) <span class="comment">//2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(a)) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质（引用类型）"><a href="#切片的本质（引用类型）" class="headerlink" title="切片的本质（引用类型）"></a>切片的本质（引用类型）</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。（切片就是一个框，框住了一块连续的内存，切片属于引用类型，真正的数据都保存在底层数组里的）</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><h5 id="切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："><a href="#切片之间是不能比较的，我们不能使用-操作符来判断两个切片是否含有全部相等元素。-切片唯一合法的比较操作是和nil比较。-一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：" class="headerlink" title="切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例："></a>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]   切片是引用类型</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s1) <span class="comment">//[100 0 0]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">//[100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 每个切片会指向一个底层数组，这个数组能容纳一定数量的元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">"%v  len:%d  cap:%d  ptr:%p\n"</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> citySlice []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 追加一个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"北京"</span>)</span><br><span class="line"><span class="comment">// 追加多个元素</span></span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, <span class="string">"上海"</span>, <span class="string">"广州"</span>, <span class="string">"深圳"</span>)</span><br><span class="line"><span class="comment">// 追加切片</span></span><br><span class="line">a := []<span class="keyword">string</span>&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;</span><br><span class="line">citySlice = <span class="built_in">append</span>(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) <span class="comment">//[北京 上海 广州 深圳 成都 重庆]</span></span><br></pre></td></tr></table></figure><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"><a href="#由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。" class="headerlink" title="由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。"></a>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</h5><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(c, a)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片c</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">fmt.Println(c) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1.请写出下面代码的输出结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">a = <span class="built_in">append</span>(a, fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int{3, 7, 8, 9, 1}</code>进行排序。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go语言中不存在指针操作，只需要记住两个符号</p><p>1.<code>&amp;</code>：取地址操作</p><p>2 <code>*</code>：根据地址取值</p>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05Go语言基础之数组</title>
      <link href="/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
      <url>/2020/01/17/05Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之数组"><a href="#Go语言基础之数组" class="headerlink" title="Go语言基础之数组"></a>Go语言基础之数组</h1><p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><a id="more"></a><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个长度为3元素类型为int的数组a</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line">a = b <span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"><span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;                 <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"><span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line">fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line">fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> numArray = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> cityArray = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line">fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line">fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of numArray:%T\n"</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line">fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of cityArray:%T\n"</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line">fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"深圳"</span>&#125;</span><br><span class="line"><span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：for range遍历</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line">fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t"</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持的写法</span></span><br><span class="line">a := [...][<span class="number">2</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不支持多维数组的内层使用...</span></span><br><span class="line">b := [<span class="number">3</span>][...]<span class="keyword">string</span>&#123;</span><br><span class="line">&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"广州"</span>, <span class="string">"深圳"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"成都"</span>, <span class="string">"重庆"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line">fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">b := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line">fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>求数组<code>[1, 3, 5, 7, 8]</code>所有元素的和</li><li>找出数组中和为指定值的两个元素的下标，比如从数组<code>[1, 3, 5, 7, 8]</code>中找出和为8的两个元素的下标分别为<code>(0,3)</code>和<code>(1,2)</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04Go语言基础之流程控制</title>
      <link href="/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/01/17/04Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之流程控制"><a href="#Go语言基础之流程控制" class="headerlink" title="Go语言基础之流程控制"></a>Go语言基础之流程控制</h1><p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><a id="more"></a><h2 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h2><h3 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h3><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域  全局变量</span></span><br><span class="line">score := <span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h3><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//作用域    局部变量</span></span><br><span class="line"><span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考题：</strong> 上下两种写法的区别在哪里？</p><p>score 的作用域不一样</p><h2 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h2><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p><h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h2><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">finger := <span class="number">3</span></span><br><span class="line"><span class="keyword">switch</span> finger &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">"大拇指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">"食指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"中指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">fmt.Println(<span class="string">"无名指"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">fmt.Println(<span class="string">"小拇指"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"无效的输入！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">"奇数"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">"偶数"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好学习吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好工作吧"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">"好好享受吧"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"活着真好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"a"</span>:</span><br><span class="line">fmt.Println(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"b"</span>:</span><br><span class="line">fmt.Println(<span class="string">"b"</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">"c"</span>:</span><br><span class="line">fmt.Println(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h2><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;                             <span class="comment">//跳出多层循环，经常使用</span></span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">"结束for循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h2><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h2><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码打印9*9乘法表。</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03Go语言基础之运算符</title>
      <link href="/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/01/17/03Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之运算符"><a href="#Go语言基础之运算符" class="headerlink" title="Go语言基础之运算符"></a>Go语言基础之运算符</h1><p>运算符用于在程序运行时执行数学或逻辑运算。</p><a id="more"></a><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++ <span class="comment">//单独的语句，不能放在=号的右边赋值</span></span><br><span class="line">a-- <span class="comment">//单独语句，不能放在=的右边赋值</span></span><br></pre></td></tr></table></figure><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="center">!=</td><td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;</td><td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&gt;=</td><td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="center">&lt;=</td><td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td align="center">||</td><td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td align="center">!</td><td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+=</td><td align="center">相加后再赋值</td></tr><tr><td align="center">-=</td><td align="center">相减后再赋值</td></tr><tr><td align="center">*=</td><td align="center">相乘后再赋值</td></tr><tr><td align="center">/=</td><td align="center">相除后再赋值</td></tr><tr><td align="center">%=</td><td align="center">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;=</td><td align="center">左移后赋值</td></tr><tr><td align="center">&gt;&gt;=</td><td align="center">右移后赋值</td></tr><tr><td align="center">&amp;=</td><td align="center">按位与后赋值</td></tr><tr><td align="center">|=</td><td align="center">按位或后赋值</td></tr><tr><td align="center">^=</td><td align="center">按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02基本数据类型</title>
      <link href="/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/17/02%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之基本数据类型"><a href="#Go语言基础之基本数据类型" class="headerlink" title="Go语言基础之基本数据类型"></a>Go语言基础之基本数据类型</h1><p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><a id="more"></a><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h3><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint</td><td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td></tr><tr><td align="center">int</td><td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td></tr><tr><td align="center">uintptr</td><td align="center">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p><p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p><h3 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h3><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说：</p><p>v := 123_456 等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 八进制  以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p><p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为<code>false</code>。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"你好"</span></span><br><span class="line">s3 :=<span class="string">'2'</span> <span class="comment">//单独字母，汉字，符号，表示一个字符，</span></span><br><span class="line"><span class="comment">//字节：1个字节=8bit（8个二进制位2^8=156）</span></span><br><span class="line"><span class="comment">//一个字符'A'=1个字节</span></span><br><span class="line"><span class="comment">//1个utf8编码汉子‘啥’=一般占3个字节</span></span><br></pre></td></tr></table></figure><h3 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h3><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th align="center">转义符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>\r</code></td><td align="center">回车符（返回行首）</td></tr><tr><td align="center"><code>\n</code></td><td align="center">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="center"><code>\t</code></td><td align="center">制表符</td></tr><tr><td align="center"><code>\&#39;</code></td><td align="center">单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td align="center">双引号</td></tr><tr><td align="center"><code>\\</code></td><td align="center">反斜杠</td></tr></tbody></table><p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Code\\lesson1\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h3 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h3><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">+或fmt.Sprintf</td><td align="center">拼接字符串</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr><tr><td align="center">strings.Join(a[]string, sep string)</td><td align="center">join操作</td></tr></tbody></table><h2 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h2><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li><li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li></ol><p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"hello沙河"</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河)</span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">"big"</span>    <span class="comment">//字符串不能直接修改，，不能修改的变量</span></span><br><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line">byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">s2 := <span class="string">"白萝卜"</span></span><br><span class="line">runeS2 := []<span class="keyword">rune</span>(s2)<span class="comment">//吧字符强制转换成rune一个切片</span></span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">    </span><br><span class="line">    c1 :=<span class="string">"红"</span></span><br><span class="line">    c2 :=<span class="string">'红'</span></span><br><span class="line">    fmt.Printf(<span class="string">"c1:%T  c2%T"</span>,c1 ,c2)<span class="comment">//c1:string  c2:int32  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"><span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li>编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用<code>fmt.Printf()</code>搭配<code>%T</code>分别打印出上述变量的值和类型。</li><li>编写代码统计出字符串<code>&quot;hello沙河小王子&quot;</code>中汉字的数量</li></ol>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ripple支付开源协议</title>
      <link href="/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/01/10/Ripple%E6%94%AF%E4%BB%98%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="Ripple共识算法"><a href="#Ripple共识算法" class="headerlink" title="Ripple共识算法"></a>Ripple共识算法</h3><p>Ripple（瑞波）是一种基于互联网的开源支付协议，可以实现去中心化的货币兑换、支付与清算功能。在Ripple的网络中，交易由客户端发起，经过追踪节点（tracking node）或验证节点（validating node）把交易广播到整个网络中。追踪节点的主要功能是分发交易信息以及相应客户端的账本请求。验证节点除了包含追踪节点的所有功能外，还能通过共识协议，在账本中增加新的账本实例数据。</p><a id="more"></a><p>下面我用在图形中分析具体的共识过程：</p><p><img src="http://image.chaindesk.cn/Ripple1.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple2.png/mark" alt="img">)<img src="http://image.chaindesk.cn/Ripple4.png/mark" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOS共识机制</title>
      <link href="/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/EOS%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="EOS共识机制"><a href="#EOS共识机制" class="headerlink" title="EOS共识机制"></a>EOS共识机制</h3><p>EOS在第一版白皮书中使用的DPOS共识机制，而在新一版的白书中，对共识机制进行了改进，使用BFT+DPOS混合共识机制。使出块速度从原来的3秒变为0.5秒，tps显著提高，达到测试3590次/秒。</p><a id="more"></a><h2 id="EOS第一版共识机制DPOS"><a href="#EOS第一版共识机制DPOS" class="headerlink" title="EOS第一版共识机制DPOS"></a>EOS第一版共识机制DPOS</h2><p>EOS现在系统运行的链用的共识机制是第一版白皮书的，也就是纯DPOS共识机制。<br>DPOS即授权权益证明共识机制。相比于比特币的POW机制，DPOS不用浪费算力资源去争夺记账权，而是通过赋予EOS通证持有人的投票选举，选出21个超级节点担任记账人的角色，保证整个网络的正常运行。值得一提的是，人们的投票所占的比重取决于他们持有多少token。这意味着拥有更多token的人将比拥有极少token的人更多地影响网络。这其实很好理解，因为持有网络的运行的好坏会对持有更多token的人的利益产生更大的影响，这使得他们的投票更谨慎。<br>21个超级节点轮流负责记账。<strong>每轮都会随机打乱他们的出块顺序，</strong>每个超级节点作为出块节点时，只负责出一个块。每一个区块产生后会按照顺序传递给下一个超级节点中。第二个超级节点要负责打包新的区块，同时还要确认上一个区块的内容。当某一个区块被超过2/3的超级节点确认后，则该区块将成为不可逆转区块，即上链区块。</p><p>该算法有些地方明显需要改良。比如容易出现漏块现象。21个超级节点分布世界各地，如果随机打乱顺序，导致总是依次顺序的节点相距地理位置很远，如中国和美国，这两国的网络传输单向时间是300毫秒，一来一回总共600毫秒。那么中国这边出块，然后经过其他20个节点确认后返回，假设时间总共是4秒；而接下来美国出块，反馈回来的时间是3秒，比中国快1秒，肯定是先上链的，结果中国出的块就被丢弃掉了。当前目前设的出块时间是3秒，理论上能够解决这种漏块现象，但想提高eos的性能，这块肯定是要改进的。</p><h2 id="EOS最新版共识机制BFT-DPOS"><a href="#EOS最新版共识机制BFT-DPOS" class="headerlink" title="EOS最新版共识机制BFT-DPOS"></a>EOS最新版共识机制BFT-DPOS</h2><p>BFT即拜占庭容错算法。EOS引入这个算法，主要是赋予出块节点更大的权力，加快出块速度，解决节点出的块都被漏掉的问题。</p><p>EOS共识算法的升级，势必需要超级节点们更新代码，使用新的程序，然后在当前链上继续运行。但如果超过1/3的节点拒绝更新代码，可能会出现硬分叉问题。所以如何很好地做好过渡是EOS最大难题。</p><p>我们一起分析下改进后的共识机制是如何工作的。</p><p>EOS使用BFT+DPOS共识机制后，不再按照出块顺序让超级节点一个个验证区块内容，而是让出块节点成为主节点。出块后，同时向其他20个超级节点进行广播该区块，并获得他们的验证。如果超过2/3的节点验证通过后，则该区块将成为不可逆转区块。</p><p>BFT可以使EOS出块速度显著增加。目前使用BFT+DPOS共识机制的EOS，可以实现0.5秒的出块速度，1秒实现区块的不可逆转。为避免因出块速度过快而漏块，EOS的超级节点按照其他的地理位置依次轮流成为主节点，尽可能减少超级节点的网络延迟。比如超级节点有中国、美国、加拿大、日本，那么成为主节点的顺序是中国&gt;日本&gt;美国&gt;加拿大或者反过来，总之保证相邻最近的超级节点要依次交接主节点角色。</p><p>同时规定每个主节点连续生产6个区块，至少保证6个区块的前几个能确认完成，不存在整个超级节点被跳过的现象。可以看出每轮记账节点的出块总时间还是3秒钟，在这3秒里，因为他对他自己出的块是信任的，所以可以持续出块。一边出块一边广播，3秒之内率先广播的区块肯定能够得到确认，在网络通畅的情况下，6个区块都会可能得到确认。</p><p>EOS共识处理分叉问题非常简单，和比特币一样，节点只会认可最长的链作为合法链。假如某个节点开始作恶，自己出块并生成自己的链，也就是每次轮到它就产生6个块。但是超级节点总共21个，每轮产生理论126个块。根据选择最长链作为主链原则，肯定作恶的链得不到认可。所以EOS不会发生分叉问题。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBFT实用拜占庭容错系统</title>
      <link href="/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/PBFT%E5%AE%9E%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><p>PBFT即<strong>实用拜占庭容错系统</strong>，英文全称<strong>Practical Byzantine Fault Tolerance</strong>。它是第一个基于BFT理论并结合实际产生的新的共识算法。但应用场景是私有链和联盟链，如果用于公链，需要和其他共识算法进行灵活的混用。</p><a id="more"></a><h2 id="PBFT算法原理"><a href="#PBFT算法原理" class="headerlink" title="PBFT算法原理"></a>PBFT算法原理</h2><p>PBFT是一类<strong>状态机拜占庭系统</strong>，要求共同维护一个状态，所有节点采用的行动一致。为此，需要运行三类基本协议，包括一致性协议（Agreement）、验证确认协议（Validity）和视图更换协议（Viewchange）。</p><h5 id="1-一致性协议："><a href="#1-一致性协议：" class="headerlink" title="1.一致性协议："></a>1.一致性协议：</h5><p>在PBFT系统中，节点分为两类：主节点（Lead）和从节点（Follow）。主节点就一个，其他剩余节点都是从节点。在实现PBFT系统功能之前，所有节点都是从节点，经过选举，产生一个主节点。每个节点都有被选举权和选举权，选举过程每个节点的概率都是平等的。</p><p>一致性协议包含若干个阶段：请求（Request）&gt;序列分配（Pre-prepare）&gt;相互交互（Prepare） &gt;确认（Commit） &gt;响应（Reply）。过程如下图：</p><p><img src="http://image.chaindesk.cn/pbft.jpg/mark" alt="img"></p><p>注：C为客户端或叫请求节点；0为当前视图下的主节点；1，2，3是从节点，其中3为宕机节点。<br>该视图满足拜占庭容错，即系统节点总数4 &gt;故障节点个数1x3             1&lt; 4 * (1/3)</p><p>1）Request阶段<br>也就是Lead生成请求阶段。</p><p>客户端发送请求到主节点，或者主节点主动从某数据源获取数据作为请求</p><p>2）Pre-prepare阶段<br>也就是Lead给其他所有Follow发送请求阶段。</p><p>主节点将收到的请求进行处理，给请求赋值一个序列号n，形成一个带序号的副本，然后分发给其从节点。其中序号n必须在水线（watermark）上下限h和H之间。水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间。发送副本的格式是 <code>&lt;,m&gt;</code>，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要，n是序号。</p><p>3）Prepare阶段<br>也就是Follow收到请求，但不知道其他节点请求是什么，就给收到的<strong>请求签名</strong>发给其他所有节点，告诉他们我收到了这样一个请求。</p><p>从节点接收到副本后，对副本进行校验和确认。检查副本中请求是否签名合法；检查d与m的摘要是否一致；检查当前视图编号是是否与副本v一致。满足这些条件后，从节点将副本存入消息日志中，然后对副本进行签名并转发给其他的所有节点（包括主节点）。如果不满足，则该验证节点就会进入View change阶段。</p><p>4）Commit阶段<br>也就是每个节点收到其他所有节点的签名请求，把这个合法请求跟自己之前保存的请求进行比较，如果超过有2f个请求一样，那么这个请求他会认为是大家共识的请求。然后对这个请求进行处理。</p><p>当前阶段所有节点，包括主节点，<strong>对接收到的签名副本进行签名验证和确认</strong>。签名验证通过后的副本与自己保存的副本进行比较，设和自己一样的副本个数记为 s，满足(自己+收到的副本) s+1&gt;= 2f，故障节点的个数为f，则该节点将会对这个请求进行响应，给予运算结果，并做签名。 2+1&gt;=2*1</p><p>5）Reply阶段<br>也就是将处理结果发送给客户端，客户端收到 f+1(=2)个一样结果，那么客户端会认为该结果正确。</p><p>每个收到请求的节点都会对请求进行响应处理，将结果广播给客户端。当客户端接收到 f+1的响应相同时，则会认为该响应就是请求的结果。</p><h5 id="2-验证确认协议："><a href="#2-验证确认协议：" class="headerlink" title="2.验证确认协议："></a>2.验证确认协议：</h5><p>在一致性协议使用时都用到了这个协议。在PBFT系统中，时刻保证数据的准确性，要进行数据校验和签名确认。对Lead的任何行为要进行监视，如果Lead有做越权或错误的事件，其他节点可以对其进行举报。</p><h5 id="3-视图更换协议：-更换主节点"><a href="#3-视图更换协议：-更换主节点" class="headerlink" title="3.视图更换协议：(更换主节点)"></a>3.视图更换协议：(更换主节点)</h5><p>此阶段主要是用户在设计PBFT系统时，<strong>对Lead节点权限的设定</strong>。</p><p>比如定时多长时间，正常更换Lead，其他Follow节点都有机会成为新的Lead。在Lead任期时期，如果超过2/3的节点反映它有问题，那么也会触发view change。还有Lead在运行中突然挂掉，也会触发view change。我们需要确保在新的view中如何来延续上一个view最终的状态，（比如给这时来的新请求的编号，还有如何处理上一个view还没来得及完全处理好的请求。）</p><h2 id="PBFT算法在公链中的应用"><a href="#PBFT算法在公链中的应用" class="headerlink" title="PBFT算法在公链中的应用"></a>PBFT算法在公链中的应用</h2><p>PBFT机制不需要挖矿，也不需要权益计算，所以通过它达成共识的时间会很快，为了提高公链的tps(每秒事务处理量(TransactionPerSecond))，将PBFT灵活改进并引入公链，和pow算法或pos相结合形成一套新的混合机制，非常明智。目前这样应用的公链比较多，我下边主要讲解初链（TrueChain）是怎么实现的。</p><p><strong>初链</strong>使用双链结构，即快链和慢链。运用PBFT和POW混合共识算法，前者生成快链，后者生成慢链。交易确认和挖矿是分开的。交易被打包后，通过PBFT委员会确认，生成fastBlock，此时交易已经得到确认；慢链将快链里的fastBlock打包成为一个snailBlock，经过矿工挖矿确认，实现上链。通过这种混合共识算法，tps得到很大的提升，达到3000左右，而且使用POW挖矿，实现了去中心化的思想。PBFT委员会每两天换届一次，候选委员都是POW挖矿成功后的矿工，保证了公平公正的原则。</p><p>虽然PBFT算法的设计初期是服务于私有链和公有链的，但是随着人们对它的不断改进和灵活使用，未来公链它将在共识机制中处于重要地位。</p><h2 id="Go语言实现一个网络交互的PBFT工程"><a href="#Go语言实现一个网络交互的PBFT工程" class="headerlink" title="Go语言实现一个网络交互的PBFT工程"></a>Go语言实现一个网络交互的PBFT工程</h2><p>工程思路：<br>1.开启4个终端，分别代表4个小国，开启http监听，监听路径有4个，分别是”/req”，”/prePrepare”, “/prepare”, “/commit”。<br>2.任意一个节点通过http网页发起请求；<br>3.该被请求节点会将数据写入自己的数组，然后并通过”/prePrepare”路径向其他节点广播该请求数据；<br>4.其他节点通过节点监听接收到请求数据，将请求数据写入自己的数组，并通过”/Prepare”路径向其他节点广播该请求数据；<br>5.所有节点将收到的数据进行校验，如果当前数组的长度大于所有节点个数的2/3，则输出OK，并将OK数据通过路径”/commit”广播给其他所有节点；<br>6.当节点收到OK数量达到所有节点个数的1/3，则就是最后的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明nodeInfo节点，代表各个小国家</span></span><br><span class="line"><span class="keyword">type</span> nodeInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//节点名称</span></span><br><span class="line">    id <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//节点路径</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    <span class="comment">//http响应</span></span><br><span class="line">    writer http.ResponseWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map，存储各个国家的ip地址,也就是url</span></span><br><span class="line"><span class="keyword">var</span> nodeTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当http服务器，接收到网络请求并且/req 则回调request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">request</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">//该命令允许request请求参数</span></span><br><span class="line">    request.ParseForm()<span class="comment">//解析完毕，打包返回。所以该方法不需要返回值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.writer = writer</span><br><span class="line">        fmt.Println(<span class="string">"主节点接收到的参数信息为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment">//fmt.Println(request.Form["warTime"])打印出来是个数组，如果warTime=1111&amp;2222等等，等号后边的是数组，warTime是map的key</span></span><br><span class="line">        <span class="comment">//激活主节点后，向其他的节点发送广播</span></span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prePrepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点发送广播的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">broadcast</span><span class="params">(msg <span class="keyword">string</span>, path <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"广播"</span>, path)</span><br><span class="line">    <span class="comment">//遍历所有的节点</span></span><br><span class="line">    <span class="keyword">for</span> nodeId, url := <span class="keyword">range</span> nodeTable &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeId == node.id &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使当前节点以外的节点做响应</span></span><br><span class="line">        http.Get(<span class="string">"http://"</span> + url + path + <span class="string">"?warTime="</span> + msg + <span class="string">"&amp;nodeId="</span> + node.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理广播后接收到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prePrepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    fmt.Println(<span class="string">"接收到的广播为"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/prepare"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收子节点的广播</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">prepare</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    request.ParseForm()</span><br><span class="line">    <span class="comment">//打印消息</span></span><br><span class="line">    fmt.Println(<span class="string">"接收到的子节点的广播"</span>, request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"warTime"</span>]) &gt; <span class="number">2</span>/<span class="number">3</span>*<span class="built_in">len</span>(nodeTable) &#123;</span><br><span class="line">        node.authentication(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authenticationNodeMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> authenticationSuceess = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//校验拜占庭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">authentication</span><span class="params">(request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !authenticationSuceess &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(request.Form[<span class="string">"nodeId"</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            authenticationNodeMap[request.Form[<span class="string">"nodeId"</span>][<span class="number">0</span>]] = <span class="string">"OK"</span></span><br><span class="line">            <span class="comment">//如果有两个国家节点正确的返回了结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(authenticationNodeMap) &gt; <span class="built_in">len</span>(nodeTable)/<span class="number">3</span> &#123;</span><br><span class="line">                authenticationSuceess = <span class="literal">true</span></span><br><span class="line">                node.broadcast(request.Form[<span class="string">"warTime"</span>][<span class="number">0</span>], <span class="string">"/commit"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回成功响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *nodeInfo)</span> <span class="title">commit</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> writer != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"拜占庭校验成功"</span>)</span><br><span class="line">        <span class="comment">//在网页上显示ok</span></span><br><span class="line">        io.WriteString(node.writer, <span class="string">"ok"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//接受终端参数</span></span><br><span class="line">    userId := os.Args[<span class="number">1</span>]</span><br><span class="line">    fmt.Println(userId)</span><br><span class="line">    <span class="comment">//存储4个国家的IP地址</span></span><br><span class="line">    nodeTable = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"Apple"</span>:  <span class="string">"localhost:1111"</span>,</span><br><span class="line">        <span class="string">"MS"</span>:     <span class="string">"localhost:1112"</span>,</span><br><span class="line">        <span class="string">"Google"</span>: <span class="string">"localhost:1113"</span>,</span><br><span class="line">        <span class="string">"IBM"</span>:    <span class="string">"localhost:1114"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建国家对象</span></span><br><span class="line">    node := nodeInfo&#123;id: userId, path: nodeTable[userId]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//http协议的回调函数</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/req"</span>, node.request)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prePrepare"</span>, node.prePrepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/prepare"</span>, node.prepare)</span><br><span class="line">    http.HandleFunc(<span class="string">"/commit"</span>, node.commit)</span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(node.path, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFT拜占庭容错系统</title>
      <link href="/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/01/10/BFT%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="BFT技术"><a href="#BFT技术" class="headerlink" title="BFT技术"></a>BFT技术</h3><p>BFT技术即拜占庭容错技术，是一类分布式计算领域的容错技术。名称拜占庭是一个泛指，它代表着计算机领域，在这个领域内会有很多问题，如硬件错误、网络拥堵或中断以及遭到恶意攻击等等，造成计算机网络可能出现的混乱。<strong>BFT技术就是为了使混乱状态达到一致性。</strong></p><a id="more"></a><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a><strong>拜占庭将军问题</strong></h2><p>BFT技术的由来源于一个叫拜占庭将军问题。<br>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都，由于当时拜占庭罗马帝国国土辽阔，每支军队的驻地分隔很远，将军们只能靠信使传递消息。发生战争时，将军们必须制订统一的行动计划。然而，这些将军中有叛徒，叛徒希望通过影响统一行动计划的制定与传播，破坏忠诚的将军们一致的行动计划。因此，将军们必须有一个预定的方法协议，使所有忠诚的将军能够达成一致，而且少数几个叛徒不能使忠诚的将军做出错误的计划。也就是说，拜占庭将军问题的实质就是要寻找一个方法，使得将军们能在一个有叛徒的非信任环境中建立对战斗计划的共识，拜占庭问题就此形成。</p><p>拜占庭将军问题（Byzantine Generals Problem），首先由Leslie Lamport与另外两人在1982年提出，很简单的故事模型，却困扰了计算机科学家们数十年。</p><p>我们将拜占庭将军问题简化一下，所有忠诚的将军都能够让别的将军接收到自己的真实意图，并最终一致行动；而形式化的要求就是，“一致性”与“正确性”。</p><p>一致性：每个忠诚的将军必须收到相同的命令值 <strong>vi</strong>（vi是第i个将军的命令）</p><p>正确性：如果第<strong>i</strong>个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的 <strong>vi</strong> 相同。</p><p>Lamport 对拜占庭将军的问题的研究表明，当 <strong>n &gt; 3m</strong> 时，即叛徒的个数 <strong>m</strong> 小于将军总数的 <strong>n</strong> 的 <strong>1/3</strong> 时，通过口头同步通信（假设通信是可靠的），可以构造同时满足“一致性”和“正确性”的解决方法，即将军们可以达成一致的命令。（叛徒个数=m，将军总数=n）m &lt; n * 1/3</p><h2 id="BFT理论算法"><a href="#BFT理论算法" class="headerlink" title="BFT理论算法"></a>BFT理论算法</h2><p>BFT即拜占庭容错系统，英文全称是<strong>Byzantine Fault Tolerance</strong>，是一种理论上解决拜占庭问题的方法，并非实用，不过基于BFT理论延伸出了其他共识机制。</p><p>区块链网络的记账共识和拜占庭将军的问题是相似的。参与共识记账的每一个节点相当于将军，节点之间的消息传递相当于信使，某些节点可能由于各种原因而产生错误的信息传递给其他节点。<strong>通常这些发生故障的节点被称为拜占庭节点，而正常的节点即为非拜占庭节点。</strong></p><p>假设分布式系统拥有n台节点，并假设整个系统拜占庭节点不超过m台（n ≥ 3m + 1），拜占庭容错系统需要满足如下<strong>两个条件</strong>：</p><pre><code>1. 所有非拜占庭节点使用相同的输入信息，产生同样的结果。在区块链系统中，可以理解为，随机数相同、区块算法相同、原账本相同的时候，计算结果相同。2. 如果输入的信息正确，那么所有非拜占庭节点必须接收这个消息，并计算相应的结果。在区块链系统中，可以理解为，非拜占庭节点需要对客户的请求进行计算并生成区块。</code></pre><p>另外，拜占庭容错系统需要达成如下<strong>两个指标</strong>：</p><pre><code>1. 安全性：任何已经完成的请求都不会被更改，它可以在以后请求看到。在区块链系统中，可以理解为，已经生成的账本不可篡改，并且可以被节点随时查看。2. 活性：可以接受并且执行非拜占庭客户端的请求，不会被任何因素影响而导致非拜占庭客户端的请求不能执行。在区块链系统中，可以理解为，系统需要持续生成区块，为用户记账，这主要靠挖矿的激励机制来保证。</code></pre><p>在分析拜占庭问题的时候，假设信道是可信的。拓展开来，在拜占庭容错系统，普遍采用的假设条件包括：</p><pre><code>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；节点之间的错误是不相关的；节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；节点之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和破坏信息的完整性。</code></pre><h2 id="Go语言简单实现BFT"><a href="#Go语言简单实现BFT" class="headerlink" title="Go语言简单实现BFT"></a>Go语言简单实现BFT</h2><p>模拟4个小国家攻打拜占庭，这4个国家要保证3个及以上同时攻打才能胜利。</p><p>思路：<br>1.创建4个节点，每个节点代表一个小国，我们用1代表打，0代表不打；<br>2.每个节点将自己的攻打意愿1或0分发给其他小国；<br>3.收到所有节点发送的消息后，将所有消息放在一个数组中；<br>4.每个节点遍历这个数组，如果数组中的0数量&lt;总数的1/3，那么返回一个true，表示攻打拜占庭可行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拜占庭理论的代码实现部分</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Status <span class="keyword">int</span><span class="comment">//1 代表去，０代表不去</span></span><br><span class="line">    Votes []*Node<span class="comment">//记录账本</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存４个node</span></span><br><span class="line"><span class="keyword">var</span> nodes = <span class="built_in">make</span>([]*Node,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNodes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A:=Node&#123;<span class="string">"A"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    B:=Node&#123;<span class="string">"B"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    C:=Node&#123;<span class="string">"C"</span>,<span class="number">1</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//去</span></span><br><span class="line">    D:=Node&#123;<span class="string">"D"</span>,<span class="number">0</span>,<span class="built_in">make</span>([]*Node,<span class="number">0</span>)&#125;<span class="comment">//不去</span></span><br><span class="line">    <span class="comment">//按照拜占庭的1/3理论，这次打仗是可行的</span></span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;A)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;B)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;C)</span><br><span class="line">    nodes=<span class="built_in">append</span>(nodes,&amp;D)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//互相转达</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">votes</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nodes);i++&#123;</span><br><span class="line">        node:=nodes[i]</span><br><span class="line">        <span class="comment">//可以将每个人的进攻状态获取出来</span></span><br><span class="line">        fmt.Println(node.Status)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此人的状态分发给其他人</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nodes);j++&#123;</span><br><span class="line">            inode := nodes[j]</span><br><span class="line">            node.Votes=<span class="built_in">append</span>(node.Votes,inode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断本次进攻是否可行，判断叛徒是否小于三分之一  cnt叛徒的个数小于总节点数的三分之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">()</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">//在数组中取出最后一个对象</span></span><br><span class="line">    node:=nodes[<span class="built_in">len</span>(nodes)<span class="number">-1</span>]</span><br><span class="line">    votes:=node.Votes</span><br><span class="line"></span><br><span class="line">    cnt:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,n :=<span class="keyword">range</span> votes &#123;</span><br><span class="line">        fmt.Println(n.Status)</span><br><span class="line">        <span class="keyword">if</span> n.Status == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cnt只有小于n/3的情况下，才能成功,拜占庭</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">float32</span>(cnt) &lt; <span class="keyword">float32</span>(<span class="built_in">len</span>(nodes))/<span class="keyword">float32</span>(<span class="number">3.0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    createNodes()</span><br><span class="line">    votes()</span><br><span class="line">    fmt.Println(isValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPOS股权授权证明</title>
      <link href="/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/DPOS%E8%82%A1%E6%9D%83%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h1><h2 id="什么是-DPoS"><a href="#什么是-DPoS" class="headerlink" title="什么是 DPoS"></a>什么是 DPoS</h2><p>DPoS即股份授权证明，英文全称是<code>Delegated Proof of Stake</code>。它是PoS算法的改造版。<br>最早于2013年由比特股Bitshares提出，目的为解决PoW和PoS机制的不足。</p><a id="more"></a><h2 id="DPoS-基本原理"><a href="#DPoS-基本原理" class="headerlink" title="DPoS 基本原理"></a>DPoS 基本原理</h2><p>PoS解决了PoW的算力问题，但是依据权益结余来选择出块者，会导致首富账户的权力更大，有可能支配记账权。为改善这种中心化的负面影响，DPoS引进了代理人机制，类似于人民代表选举，被选举者就是这里的代理人。代理人是由所有持币者根据自己的意愿选出来的，他理论上能够代表大众的权益。以eos为例，它有21个超级节点，每个节点都是持币人选举出来的。</p><p>一般选举过程是这样的，首先设立一个评审委员会，全球所有节点都可以报名参加，报名的前提是交纳保证金，通过审核的最为满足条件的前N个节点将作为候选节点，进入下一轮，也就是竞选阶段。这些候选节点会将会各种演说游说其他的持币人，让他们给自己投票，这里可能场外会给投票人某些好处。<strong>最终投票总数前m名的候选节点成为公链的代理人，负责出块。每次出块时，系统会随机顺序挑选指定某个代理人出块。</strong> 每次选举出来的代理人都有任期，任期期间如果被监管发现某些作恶行为将会被追责和卸任。</p><p>代理人的职责主要有：</p><p><strong>1.提供一台服务器节点，保证节点的正常运行；</strong><br><strong>2.节点服务器收集网络里的交易；</strong><br><strong>3.节点验证交易，把交易打包到区块；</strong><br><strong>4.节点广播区块，其他节点验证后把区块添加到自己的数据库；</strong><br><strong>5.带领并促进区块链项目的发展；</strong></p><p>代理人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>普通节点不能直接参与出块，利益何在？<br>每个节点都有自己的选举权和监督权，对代理人的行为进行监视，保证链的正常运行。链稳定了，持币人在生态中的操作才能安心。同时，tps的速度快了，在链上的交易秒级可以实现，使持币人感受到了极大的方便。整个链的生态如果因为良好的运行，会吸引更多的人或应用加入，使币的价格升值，持币人当然开心。当然这些都是理想情况下，在实际中很难得以实现。</p><h3 id="DPoS的伪代码实现"><a href="#DPoS的伪代码实现" class="headerlink" title="DPoS的伪代码实现"></a>DPoS的伪代码实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">//分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">//根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">//随机改变顺序</span></span><br><span class="line">   loop <span class="comment">//round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in this node <span class="comment">//delegate在这个节点 授权</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">//产生block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure><h3 id="DPoS-运行机制"><a href="#DPoS-运行机制" class="headerlink" title="DPoS 运行机制"></a>DPoS 运行机制</h3><p>DPoS 的运作机制如下：</p><ol><li><p>所有持币者先选出代理人负责签署区块：选举过程比较类似由股东会选举出董事会（101人代表），代替股东会做出日常营运决策。授权董事会后，决策会更有效率 （相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。）</p></li><li><p>与PoW相同，DPoS的规则也是最长链胜出。其中每个受托人必须按照生产排程，轮流产生区块，拿一间工厂作为比方，假设排程排定A、Ｂ、Ｃ分别轮早、中、晚班生产，Ａ在晚上是无法刷门禁卡进入厂房生产的，同样地，C在早班时段也是无法进厂房的。</p><p><img src="http://image.chaindesk.cn/DPOS01.png/mark" alt="img"></p></li><li><p>今天有一些恶意的节点生产了分叉区块，假设Ａ、Ｃ都是诚实的节点，只有B节点是恶意的，由于B产生区块的速度（每9秒只能产生1个）慢于A、Ｃ合力产生区块的速度（每9秒产生2个），根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS2.png/mark" alt="img"></p></li><li><p>同理，因为一个节点要产生重复两个区块的速度必定慢于诚实区块产生的速度，所以根据最长链胜出的规则，诚实的节点还是会胜出。</p><p><img src="http://image.chaindesk.cn/DPOS3.png/mark" alt="img"></p></li><li><p>如果今天A、Ｂ、Ｃ三个代理人的网络有段时间是碎片化、各自为政的呢？在短期内的确有可能三链并行，但一旦网络连结恢复，短链自然会向最长的链回归。</p><p><img src="http://image.chaindesk.cn/DPOS4.png/mark" alt="img"></p></li></ol><p><strong>因为代理可签署人数为奇数，所以两大派系势均力敌僵持不下的情况不会维持太久，最终势必会有其中一方的链更长。</strong></p><h2 id="DPoS的优缺点"><a href="#DPoS的优缺点" class="headerlink" title="DPoS的优缺点"></a>DPoS的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>能耗更低。DPoS机制将节点数量进一步减少到101个，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本最低。</li><li>更加去中心化。目前，对于比特币而言，个人挖矿已经不现实了，比特币的算力都集中在几个大的矿池手里，每个矿池都是中心化的，就像DPoS的一个受托人，因此DPoS机制的加密货币更加去中心化。PoS机制的加密货币（比如未来币），要求用户开着客户端，事实上用户并不会天天开着电脑，因此真正的网络节点是由几个股东保持的，去中心化程度也不能与DPoS机制的加密货币相比。</li><li>更快的确认速度。每个块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的101个块的周期大概仅仅需要16分钟。而比特币（PoW机制）产生一个区块需要10分钟，一笔交易完成（6个区块确认后）需要1个小时。点点币（PoS机制）确认一笔交易大概也需要1小时。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>投票的积极性并不高。绝大多数持股人（90％+）从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的。</li><li>对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患。</li></ol><h3 id="知名-DPoS-项目"><a href="#知名-DPoS-项目" class="headerlink" title="知名 DPoS 项目"></a><strong>知名 DPoS 项目</strong></h3><p>1.Bitshares</p><p>最早应用DPoS机制的项目，其DPoS机制里包含见证人(Witnesses)和代理人(Delegates)， 见证人负责区块的打包，代理人负责系统参数的修改和出块。</p><p>2.EOS</p><p>共识算法我DPoS + BFT， 有21个代理人。</p><p>3.Asch</p><p>共识算法为DPoS + PBFT， 有101个代理人。</p><h2 id="用Go实现一个简单的DPOS项目"><a href="#用Go实现一个简单的DPOS项目" class="headerlink" title="用Go实现一个简单的DPOS项目"></a>用Go实现一个简单的DPOS项目</h2><p>通过这个简易的项目，让大家对DPOS的工作加深下了解。<br>工程思路：<br>1.手动创建一个数组，将里面的元素作为代理人<br>2.每30秒将代理人的顺序随机打乱1次<br>3.乱序后的委员会将顺序出块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//DPoS原理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建区块</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index <span class="keyword">int</span></span><br><span class="line">    PreHash <span class="keyword">string</span></span><br><span class="line">    HashCode <span class="keyword">string</span></span><br><span class="line">    BMP <span class="keyword">int</span></span><br><span class="line">    validator <span class="keyword">string</span></span><br><span class="line">    TimeStamp <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区块链</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNextBlock</span><span class="params">(oldBlock Block,BMP <span class="keyword">int</span> ,adds <span class="keyword">string</span>)</span> <span class="title">Block</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.PreHash = oldBlock.HashCode</span><br><span class="line">    newBlock.BMP = BMP</span><br><span class="line">    newBlock.TimeStamp = time.Now().String()</span><br><span class="line">    newBlock.validator = adds</span><br><span class="line">    newBlock.HashCode = GenerateHashValue(newBlock)</span><br><span class="line">    <span class="keyword">return</span> newBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生区块的hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHashValue</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hashCode = block.PreHash+block.validator+block.TimeStamp+</span><br><span class="line">        strconv.Itoa(block.Index)+strconv.Itoa(block.BMP)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sha = sha256.New()</span><br><span class="line">    sha.Write([]<span class="keyword">byte</span>(hashCode))</span><br><span class="line">    hashed:=sha.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放代理人,存放delegete的地址信息</span></span><br><span class="line"><span class="keyword">var</span> delegate =[]<span class="keyword">string</span>&#123;<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,<span class="string">"dddd"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机委托人的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandDelegate</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> r = rand.Intn(<span class="number">3</span>)</span><br><span class="line">    t:=delegate[r]</span><br><span class="line">    delegate[r]=delegate[<span class="number">3</span>]</span><br><span class="line">    delegate[<span class="number">3</span>]=t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(delegate)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创世区块</span></span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,firstBlock)</span><br><span class="line">    <span class="comment">//通过n按顺序让delegate作为矿工</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    ch1:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag:&lt;-ch1</span><br><span class="line">        count:=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">//每间隔3秒产生新的区块，通过count记录睡眠次数</span></span><br><span class="line">            count++</span><br><span class="line">            time.Sleep(time.Second*<span class="number">3</span>)</span><br><span class="line">            <span class="comment">//轮到的节点进行出块</span></span><br><span class="line">            <span class="keyword">var</span> nextBlock = GenerateNextBlock(firstBlock,<span class="number">1</span>,delegate[n])</span><br><span class="line">            n++</span><br><span class="line">            n=n%<span class="built_in">len</span>(delegate)</span><br><span class="line">            firstBlock = nextBlock</span><br><span class="line">            <span class="comment">//上链</span></span><br><span class="line">            Blockchain = <span class="built_in">append</span>(Blockchain,nextBlock)</span><br><span class="line">            fmt.Println(Blockchain)</span><br><span class="line">            fmt.Println(count)</span><br><span class="line">            <span class="comment">//每30秒将代理人顺序打乱一次</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">10</span>&#123;</span><br><span class="line">                count=<span class="number">0</span></span><br><span class="line">                ch2&lt;-<span class="literal">true</span></span><br><span class="line">                <span class="keyword">goto</span> flag</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; ;  &#123;</span><br><span class="line"></span><br><span class="line">        RandDelegate()</span><br><span class="line">        fmt.Println(<span class="string">"更换顺序后的代理人"</span>,delegate)</span><br><span class="line">        ch1&lt;-<span class="literal">true</span></span><br><span class="line">        &lt;-ch2</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>  &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS代码实现</title>
      <link href="/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POS%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="用go语言实现一个POS共识机制"><a href="#用go语言实现一个POS共识机制" class="headerlink" title="用go语言实现一个POS共识机制"></a>用go语言实现一个POS共识机制</h1><h2 id="POS工程简述"><a href="#POS工程简述" class="headerlink" title="POS工程简述"></a>POS工程简述</h2><p>在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。</p><a id="more"></a><h2 id="实现-POS-主要功能点"><a href="#实现-POS-主要功能点" class="headerlink" title="实现 POS 主要功能点"></a>实现 POS 主要功能点</h2><ul><li>我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器</li><li>最新的区块链状态将定期广播到每个节点</li><li>每个节点都能提议建立新的区块</li><li>基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中</li></ul><h2 id="实现-POS"><a href="#实现-POS" class="headerlink" title="实现 POS"></a>实现 POS</h2><h3 id="设置-TCP-服务器的端口"><a href="#设置-TCP-服务器的端口" class="headerlink" title="设置 TCP 服务器的端口"></a>设置 TCP 服务器的端口</h3><p>新建 <code>.env</code>，添加如下内容 <code>PORT=9000</code></p><h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/davecgh/<span class="keyword">go</span>-spew/spew</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> get github.com/joho/godotenv</span><br></pre></td></tr></table></figure><ul><li><code>spew</code> 在控制台中格式化输出相应的结果。</li><li><code>godotenv</code> 可以从我们项目的根目录的 <code>.env</code> 文件中读取数据。</li></ul><h3 id="引入相应的包"><a href="#引入相应的包" class="headerlink" title="引入相应的包"></a>引入相应的包</h3><p>新建 <code>main.go</code>，引入相应的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/davecgh/go-spew/spew"</span></span><br><span class="line">    <span class="string">"github.com/joho/godotenv"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents each 'item' in the blockchain</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span></span><br><span class="line">    Timestamp <span class="keyword">string</span></span><br><span class="line">    BPM       <span class="keyword">int</span></span><br><span class="line">    Hash      <span class="keyword">string</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span></span><br><span class="line">    Validator <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Blockchain is a series of validated Blocks</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"><span class="keyword">var</span> tempBlocks []Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// candidateBlocks handles incoming blocks for validation</span></span><br><span class="line"><span class="keyword">var</span> candidateBlocks = <span class="built_in">make</span>(<span class="keyword">chan</span> Block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// announcements broadcasts winning validator to all nodes</span></span><br><span class="line"><span class="keyword">var</span> announcements = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validators keeps track of open validators and balances</span></span><br><span class="line"><span class="keyword">var</span> validators = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><ul><li><code>Block</code> 是每个区块的内容</li><li><code>Blockchain</code> 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 <code>PrevHash</code> 与前面块的 <code>Hash</code> 相比较，以确保我们的链是正确的。 <code>tempBlocks</code> 是临时存储单元，在区块被选出来并添加到 <code>BlockChain</code> 之前，临时存储在这里</li><li><code>candidateBlocks</code> 是 <code>Block</code> 的通道，任何一个节点在提出一个新块时都将它发送到这个通道</li><li><code>announcements</code> 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链</li><li><code>mutex</code>是一个标准变量，允许我们控制读/写和防止数据竞争</li><li><code>validators</code> 是节点的存储map，同时也会保存每个节点持有的令牌数</li></ul><h3 id="生成区块"><a href="#生成区块" class="headerlink" title="生成区块"></a>生成区块</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateBlock</code> 是用来创建新块的。<br><code>newBlock.PrevHash</code> 存储的是上一个区块的 <code>Hash</code><br><code>newBlock.Hash</code> 是通过 <code>calculateBlockHash(newBlock)</code> 生成的 Hash 。<br><code>newBlock.Validator</code> 存储的是获取记账权的节点地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SHA256 hasing</span></span><br><span class="line"><span class="comment">// calculateHash is a simple SHA256 hashing function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//calculateBlockHash returns the hash of all block information</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculateHash</code> 函数会接受一个 <code>string</code> ，并且返回一个<code>SHA256 hash</code> 。</p><p><code>calculateBlockHash</code> 是对一个 <code>block</code> 进行 <code>hash</code>，将一个 <code>block</code> 的所有字段连接到一起后，再调用 <code>calculateHash</code> 将字符串转为 <code>SHA256 hash</code> 。</p><h3 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h3><p>我们通过检查 <code>Index</code> 来确保它们按预期递增。我们也检查以确保我们 <code>PrevHash</code> 的确与 <code>Hash</code> 前一个区块相同。最后，我们希望通过在当前块上 <code>calculateBlockHash</code> 再次运行该函数来检查当前块的散列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isBlockValid makes sure block is valid by checking index</span></span><br><span class="line"><span class="comment">// and comparing the hash of the previous block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBlockValid</span><span class="params">(newBlock, oldBlock Block)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> oldBlock.Index+<span class="number">1</span> != newBlock.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calculateBlockHash(newBlock) != newBlock.Hash &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证者"><a href="#验证者" class="headerlink" title="验证者"></a>验证者</h3><p>当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：</p><ul><li>输入令牌的余额（之前提到过，我们不做钱包等逻辑)</li><li>接收区块链的最新广播</li><li>接收验证者赢得区块的广播信息</li><li>将自身节点添加到全局的验证者列表中（validators)</li><li>输入Block的BPM数据- BPM是每个验证者的人体脉搏值</li><li>提议创建一个新的区块</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            msg := &lt;-announcements</span><br><span class="line">            io.WriteString(conn, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 验证者地址</span></span><br><span class="line">    <span class="keyword">var</span> address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权</span></span><br><span class="line">    io.WriteString(conn, <span class="string">"Enter token balance:"</span>)</span><br><span class="line">    scanBalance := bufio.NewScanner(conn)</span><br><span class="line">    <span class="keyword">for</span> scanBalance.Scan() &#123;</span><br><span class="line">        <span class="comment">// 获取输入的数据，并将输入的值转为 int</span></span><br><span class="line">        balance, err := strconv.Atoi(scanBalance.Text())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"%v not a number: %v"</span>, scanBalance.Text(), err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        t := time.Now()</span><br><span class="line">        <span class="comment">// 生成验证者的地址</span></span><br><span class="line">        address = calculateHash(t.String())</span><br><span class="line">        <span class="comment">// 将验证者的地址和token 存储到 validators</span></span><br><span class="line">        validators[address] = balance</span><br><span class="line">        fmt.Println(validators)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line"></span><br><span class="line">    scanBPM := bufio.NewScanner(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// take in BPM from stdin and add it to blockchain after conducting necessary validation</span></span><br><span class="line">            <span class="keyword">for</span> scanBPM.Scan() &#123;</span><br><span class="line">                bpm, err := strconv.Atoi(scanBPM.Text())</span><br><span class="line">                <span class="comment">// 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Printf(<span class="string">"%v not a number: %v"</span>, scanBPM.Text(), err)</span><br><span class="line">                    <span class="built_in">delete</span>(validators, address)</span><br><span class="line">                    conn.Close()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mutex.Lock()</span><br><span class="line">                oldLastIndex := Blockchain[<span class="built_in">len</span>(Blockchain)<span class="number">-1</span>]</span><br><span class="line">                mutex.Unlock()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的区块，然后将其发送到 candidateBlocks 通道</span></span><br><span class="line">                newBlock, err := generateBlock(oldLastIndex, bpm, address)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Println(err)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> isBlockValid(newBlock, oldLastIndex) &#123;</span><br><span class="line">                    candidateBlocks &lt;- newBlock</span><br><span class="line">                &#125;</span><br><span class="line">                io.WriteString(conn, <span class="string">"\nEnter a new BPM:"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环会周期性的打印出最新的区块链信息</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Minute)</span><br><span class="line">        mutex.Lock()</span><br><span class="line">        output, err := json.Marshal(Blockchain)</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        io.WriteString(conn, <span class="keyword">string</span>(output)+<span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>io.WriteString(conn, &quot;Enter token balance:&quot;)</code>允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 <code>SHA256</code>地址，随后该验证者地址和验证者的令牌数被添加到验证者列表<code>validators</code> 中。</li><li>接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑</li><li><code>delete(validators, address)</code> 如果验证者试图提议一个被污染（例如伪造）的 <code>block</code>，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 <code>validators</code> 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</li><li>正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。</li><li>接着，我们用 <code>generateBlock</code> 函数创建一个新的 <code>block</code>，然后将其发送到 <code>candidateBlocks</code> 通道进行进一步处理。将<code>Block</code> 发送到通道使用的语法: <code>candidateBlocks &lt;- newBlock</code></li><li>最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。</li></ul><h3 id="选择获取记账权的节点"><a href="#选择获取记账权的节点" class="headerlink" title="选择获取记账权的节点"></a>选择获取记账权的节点</h3><p>下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain</span></span><br><span class="line"><span class="comment">// by random selecting from the pool, weighted by amount of tokens staked</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pickWinner</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    temp := tempBlocks</span><br><span class="line">    mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    lotteryPool := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// slightly modified traditional proof of stake algorithm</span></span><br><span class="line">        <span class="comment">// from all validators who submitted a block, weight them by the number of staked tokens</span></span><br><span class="line">        <span class="comment">// in traditional proof of stake, validators can participate without submitting a block to be forged</span></span><br><span class="line">    OUTER:</span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="comment">// if already in lottery pool, skip</span></span><br><span class="line">            <span class="keyword">for</span> _, node := <span class="keyword">range</span> lotteryPool &#123;</span><br><span class="line">                <span class="keyword">if</span> block.Validator == node &#123;</span><br><span class="line">                    <span class="keyword">continue</span> OUTER</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock list of validators to prevent data race</span></span><br><span class="line">            mutex.Lock()</span><br><span class="line">            setValidators := validators</span><br><span class="line">            mutex.Unlock()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取验证者的tokens</span></span><br><span class="line">            k, ok := setValidators[block.Validator]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">// 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens</span></span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">                    lotteryPool = <span class="built_in">append</span>(lotteryPool, block.Validator)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过随机获得获胜节点的地址</span></span><br><span class="line">        s := rand.NewSource(time.Now().Unix())</span><br><span class="line">        r := rand.New(s)</span><br><span class="line">        lotteryWinner := lotteryPool[r.Intn(<span class="built_in">len</span>(lotteryPool))]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息</span></span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            <span class="keyword">if</span> block.Validator == lotteryWinner &#123;</span><br><span class="line">                mutex.Lock()</span><br><span class="line">                Blockchain = <span class="built_in">append</span>(Blockchain, block)</span><br><span class="line">                mutex.Unlock()</span><br><span class="line">                <span class="keyword">for</span> _ = <span class="keyword">range</span> validators &#123;</span><br><span class="line">                    announcements &lt;- <span class="string">"\nwinning validator: "</span> + lotteryWinner + <span class="string">"\n"</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    tempBlocks = []Block&#123;&#125;</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个<code>lotteryPool</code>，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过<code>if len(temp) &gt; 0</code>来判断是否已经有了被提议的区块。</li><li>在<code>OUTER FOR</code>循环中，要检查暂存区域是否和 <code>lotteryPool</code> 中存在同样的验证者，如果存在，则跳过。</li><li>在以 <code>k, ok := setValidators[block.Validator]</code>开始的代码块中，我们确保了从<code>temp</code>中取出来的验证者都是合法的，即这些验证者在验证者列表<code>validators</code>已存在。若合法，则把该验证者加入到<code>lotteryPool</code>中。</li><li>那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？<ul><li>首先，用验证者的令牌填充<code>lotteryPool</code>数组，例如一个验证者有100个令牌，那么在<code>lotteryPool</code>中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。</li><li>然后，从<code>lotteryPool</code>中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。</li></ul></li><li>接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：<code>announcements &lt;- &quot;\nwinning validator: &quot; + lotteryWinner + &quot;\n&quot;</code>。</li><li>最后，清空tempBlocks，以便下次提议的进行。</li></ul><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := godotenv.Load()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建初始区块</span></span><br><span class="line">    t := time.Now()</span><br><span class="line">    genesisBlock := Block&#123;&#125;</span><br><span class="line">    genesisBlock = Block&#123;<span class="number">0</span>, t.String(), <span class="number">0</span>, calculateBlockHash(genesisBlock), <span class="string">""</span>, <span class="string">""</span>&#125;</span><br><span class="line">    spew.Dump(genesisBlock)</span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</span><br><span class="line"></span><br><span class="line">    httpPort := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 TCP 服务</span></span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":"</span>+httpPort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"HTTP Server Listening on port :"</span>, httpPort)</span><br><span class="line">    <span class="keyword">defer</span> server.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> candidate := <span class="keyword">range</span> candidateBlocks &#123;</span><br><span class="line">            mutex.Lock()</span><br><span class="line">            tempBlocks = <span class="built_in">append</span>(tempBlocks, candidate)</span><br><span class="line">            mutex.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动了一个Go routine 完成 pickWinner 函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            pickWinner()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收验证者节点的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>godotenv.Load()</code> 会解析 <code>.env</code> 文件并将相应的Key/Value对都放到环境变量中，通过 <code>os.Getenv</code> 获取</li><li>然后创建一个创世区块genesisBlock，形成了区块链。</li><li>接着启动了Tcp服务，等待所有验证者的连接。</li><li>启动了一个Go协程从 <code>candidateBlocks</code> 通道中获取提议的区块，然后填充到临时缓冲区 <code>tempBlocks</code> 中，最后启动了另外一个Go协程来完成 <code>pickWinner</code> 函数。</li><li>最后的for循环，用来接收验证者节点的连接。</li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><code>go run main.go</code> 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">(main.Block) &#123;</span><br><span class="line"> Index: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Timestamp: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">50</span>) <span class="string">"2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793"</span>,</span><br><span class="line"> BPM: (<span class="keyword">int</span>) <span class="number">0</span>,</span><br><span class="line"> Hash: (<span class="keyword">string</span>) (<span class="built_in">len</span>=<span class="number">64</span>) <span class="string">"96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7"</span>,</span><br><span class="line"> PrevHash: (<span class="keyword">string</span>) <span class="string">""</span>,</span><br><span class="line"> Validator: (<span class="keyword">string</span>) <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span>/<span class="number">05</span>/<span class="number">08</span> <span class="number">16</span>:<span class="number">45</span>:<span class="number">27</span> HTTP Server Listening on port : <span class="number">9000</span></span><br></pre></td></tr></table></figure><p>打开新的终端，运行 <code>nc localhost 9000</code>，<br>输入 <code>tokens</code> , 然后输入 <code>BPM</code></p><p>可以打开多个终端，输入不同的 <code>tokens</code> ,来检验 PoS 算法</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW+POS混合公式算法</title>
      <link href="/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/10/POW-POS%E6%B7%B7%E5%90%88%E5%85%AC%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-POS混合共识算法"><a href="#POW-POS混合共识算法" class="headerlink" title="POW+POS混合共识算法"></a>POW+POS混合共识算法</h3><p>上一章节说过，实际运用pos是需要借助其他算法才能实现的。本章节主要学习点点币的共识算法，该算法是基于POW改进的POS算法。</p><a id="more"></a><h2 id="混合共识算法的定义"><a href="#混合共识算法的定义" class="headerlink" title="混合共识算法的定义"></a>混合共识算法的定义</h2><p>现在很多公链都是在用基于xx和xx算法的混合共识算法实现共识机制的。什么是混合共识算法呢？<br>有两种情况都可以认为是混合机制：<br>1.在某个算法的基础上，运用其他算法的技术进行改进。如点点币，它的共识机制是用pos算法对pow算法进行改进后的机制，不过大家往往认为点点币的共识机制是pos，其实严格来说是pow+pos的。<br>2.两个算法运算相互独立，但共同组成了一个共识机制。如初链，它的共识是pow和pbft两个算法组成的，然后自己给自己起了个新名字叫混合共识机制fpow。这种混合很明显，所以大家都会叫混合机制。</p><h2 id="混合共识机制POW-POS"><a href="#混合共识机制POW-POS" class="headerlink" title="混合共识机制POW+POS"></a>混合共识机制POW+POS</h2><p>点点币是第一个基于POS发行的数字货币，所以接下来我将带大家深入学习它的共识算法，加深对POS的理解。</p><p>与PoW一样，为了抢到将区块写入区块链的权利，节点同样要进行hash计算，只不过最终的解和币龄有关，计算公式：<br>proofHash &lt; coinAge * target；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coinAge是币龄，target是一个目标值，用于调整难度。coinAge * target的值越大，难度就越小，抢到区块的概率就越高。</span><br></pre></td></tr></table></figure><p>假如你的钱包里是0个币，那么你的币龄就是0, 计算一个小于0的hash值根本不可能，因此基本上抢不到区块。<br>点点币的出块时间也是10分钟左右一个。币龄之前讲过，就是持币数*持币时间；proofHash也就是pow的挖矿函数，即两次sha256 hash运算。所以重点我们要学习target的值是怎么实现的，怎么调整使出块时间在10分钟左右呢？</p><h2 id="点点币的目标值"><a href="#点点币的目标值" class="headerlink" title="点点币的目标值"></a>点点币的目标值</h2><p>点点币难度值是一个一直动态调整的，每隔2个区块就调整一次难度（目标值），使出块时间维持在10分钟左右。<br>点点币使用目标值来衡量挖矿难度，目标值与难度成反比，目标值越大、难度越小；反之亦然。当前区块的目标值与前一个区块目标值、前两个区块的时间间隔有关。<br>计算公式如下：</p><p>　<code>当前区块目标值 = 前一个区块目标值 * (1007 * 10 * 60 + 2 * 前两个区块时间间隔) / (1009 * 10 * 60)</code><br>由公式可见，两个区块目标间隔时间即为10分钟。<br>如果前两个区块时间间隔大于10分钟，目标值会提高，即当前区块难度会降低。<br>反之，如果前两个区块时间间隔小于10分钟，目标值会降低，即当前区块难度会提高。<br><code>点点币的挖矿难度值=创始区块目标值/当前区块目标值</code>。网页中显示的当前块难度值就是这样算出来的。</p><p>挖矿过程和pow一样，需要比较hash值与目标值大小，广播区块，验证区块，上链等等。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POS权益证明</title>
      <link href="/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POS%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>通过本章节，大家一起学习单纯的pos是什么机制，以及如何工作的。它较pow有什么优缺点。</p><h2 id="POS概述"><a href="#POS概述" class="headerlink" title="POS概述"></a>POS概述</h2><p>POS即权益证明，英文全称Proof of Stake。它是由匿名极客<code>Sunny King</code>发明的。<code>Sunny King</code>很神秘，类似中本聪，他的具体信息很少有人知道。同时他也是点点币（PPCoin）和质数币（PrimeCoin）的创始人。2012年点点币问世，成为全球首次使用POS共识机制的数字货币。</p><a id="more"></a><p>基于POW的公链挖矿纯靠算力，挖矿难度越高，算力也会越来越中心化。目前比特币挖矿的算力超过70%在中国，据<code>Blockchain.info</code>2018年的统计数据显示，目前世界前十大矿池中，中国独占8家，而中国70%的算力在四川。这样完全背离了去中心化的思想，只有算力高的机构或矿场才能挖到区块，而算力低的个人几乎没有可能挖到区块。算力低的矿工要是参与挖矿，那得赔死，投入电费、场地、矿机等等，结果几乎甚至没有收益。然后他们大部分会放弃挖矿或加入其他大型矿池。而且挖矿代币价格的较大波动也会影响挖矿收益。所以POW类型的挖矿具有很大的投资风险。POW挖矿比拼的就是算力，随着挖矿难度的提高，算力会要求越来越高，导致参与挖矿的矿机数量越来越多，配置也越来越高，如此会造成多大的资源浪费啊。</p><p>针对POW的问题，POS指出了一个全新的概念-币龄，币龄 = 持有的币数 * 持有币的天数，例如钱包里有90个点点币，持有了10天，则币龄=900。决定下一个区块是由谁出，是看当前时刻谁的币龄大。出块后币龄归零，重新计时持币时间。币龄是对应账户恒定数量持币数的值，如果账户的持币数量发生变化，那么币龄也会归零，重新计时。通过币龄来决定出块，不再需要比拼算力，多么环保啊，节省了多少资源啊。</p><p>而且为了让持币人把币握住，不乱抛售，POS还使用了“利息”机制。用户的持币钱包或客户端24小时处于工作状态或后台运行状态，其实就是pos的挖矿状态，系统会在固定时间参照币龄给予持币人一定量的利息（一定量的币）。如此币的抛售将不会像传统的币那么频繁，币价相应的也会稳定。</p><p>POS出块时间可以设为恒定值，如10分钟一个块，那么每10分钟，会触发记账功能。</p><p>为了让POS出块人带有随机性，需要借助一些随机函数，币龄只是增加成为出块者可能性的筹码。如，A的币龄100，B的币龄10，那么A能够出块的概率要比B大10倍。</p><p>使用POS较POW更不容易遭受51%攻击，相比起掌握系统一半以上的算力，拥有整个系统51%的财力会更加困难。</p><p>POS解决或者缓解了POW的一些问题，但是它也有它的很大缺点：</p><pre><code>1.更容易被垄断：因为持币越多，持有的越久，币龄就越高，越容易挖到区块并得到激励，持币少的人基本上没有机会，这样整个系统的安全性实际上会被持币数量较大的一部分人（大股东们）掌握；而POW理论上则不存在这个问题，因为理论上任何人都可以购买矿机获得提高自己的算力（甚至可以联合起来），提升自己挖矿成功的概率；2.很难应对分叉的情况：当出现分叉时，PoS可以在两条链上同时挖矿并获得收益。而PoW则不存在这个问题，因为当出现分叉以后，PoW总是选择工作量大的链做为主链。</code></pre><p>但是在实际应用中，纯POS的共识机制是不可行的，通常会和POW混合一起用或者通过POS升级改进POW。这样会更好的发挥各自的优点，减小双方缺点带来的影响。</p><p>根据masternodes.online的数据显示，目前基于POS算法的币种数量已有330，但是市值在2000万美金以上的只有9种，分别是DASH、PIVX、SYS、BLOCK、XZC、SMART、XSN、PAC、DEV。其中，市值最高的为DASH，目前为21.57亿美元，POS年化收益约为7.19%；XZC市值9805万美元，POS年化收益约为27.28%。</p><h2 id="Go实现一个纯POS机制的简单挖矿"><a href="#Go实现一个纯POS机制的简单挖矿" class="headerlink" title="Go实现一个纯POS机制的简单挖矿"></a>Go实现一个纯POS机制的简单挖矿</h2><p>设计思路：<br>1.有两个挖矿节点，分别持有的币为10个和5个，持币时间为1 。所以他们的币龄也就是10和5 。<br>2.创建一个长度为15的数组，分别将两个节点的账户地址按照比例布满这个数组。<br>3.选择一个从0到14的随机数，将该随机数作为2步数组的下表，找到该下表下的挖矿地址。<br>4.挖矿地址确认后，通过方法产生区块。<br>5.将区块上链，这里的区块链我们定义了一个切片。上链过程就是append过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个块结构体</span></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Index     <span class="keyword">int</span>  <span class="comment">//区块高度</span></span><br><span class="line">    Timestamp <span class="keyword">string</span> <span class="comment">//时间戳，也就是当前时间转换成字符串</span></span><br><span class="line">    BPM       <span class="keyword">int</span>   <span class="comment">//要保存的上链数据</span></span><br><span class="line">    Hash      <span class="keyword">string</span>  <span class="comment">//当前区块hash值</span></span><br><span class="line">    PrevHash  <span class="keyword">string</span>  <span class="comment">//父区块hash值</span></span><br><span class="line">    Validator <span class="keyword">string</span>  <span class="comment">//当前区块出块人的账户地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个区块链，类型是切片。也就是将区块放在这个切片里面</span></span><br><span class="line"><span class="keyword">var</span> Blockchain []Block</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出块函数，也就是当随机抽中哪个账户后，该账户就会作为该区块的参数，生成一个最新区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateBlock</span><span class="params">(oldBlock Block, BPM <span class="keyword">int</span>, address <span class="keyword">string</span>)</span> <span class="params">(Block, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newBlock Block</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成区块过程就是给区块的字段赋值</span></span><br><span class="line">    newBlock.Index = oldBlock.Index + <span class="number">1</span></span><br><span class="line">    newBlock.Timestamp = t.String()</span><br><span class="line">    newBlock.BPM = BPM</span><br><span class="line">    newBlock.PrevHash = oldBlock.Hash</span><br><span class="line">    newBlock.Hash = calculateBlockHash(newBlock)</span><br><span class="line">    newBlock.Validator = address</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最新区块</span></span><br><span class="line">    <span class="keyword">return</span> newBlock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHA256算法计算当前区块的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    h := sha256.New()</span><br><span class="line">    h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">    hashed := h.Sum(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将区块字段拼接，为生成hash函数做准备</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBlockHash</span><span class="params">(block Block)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    record := <span class="keyword">string</span>(block.Index) + block.Timestamp + <span class="keyword">string</span>(block.BPM) + block.PrevHash</span><br><span class="line">    <span class="keyword">return</span> calculateHash(record)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//持币人信息</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    tokens <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在参与挖矿的币总数为15个，我们认为现在是平等机会的15个持币1个的矿工。</span></span><br><span class="line"><span class="comment">//声明一个数组保存15个账户地址</span></span><br><span class="line"><span class="comment">//两个节点参与挖矿</span></span><br><span class="line"><span class="keyword">var</span> N[<span class="number">15</span>] <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> p [<span class="number">2</span>] Node</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给两个挖矿节点赋值</span></span><br><span class="line">    p[<span class="number">0</span>]=Node&#123;<span class="number">10</span>,<span class="string">"abc"</span>&#125;</span><br><span class="line">    p[<span class="number">1</span>]=Node&#123;<span class="number">5</span>,<span class="string">"bcd"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过下边的for循环，按照两个节点他们的持币数，分别将他们的地址赋值到之前定义好的账户地址数组中。</span></span><br><span class="line">    <span class="comment">//可以看出，前10个账户都是p[0]的；后边5个是p[1]的</span></span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;p[i].tokens;j++&#123;</span><br><span class="line"></span><br><span class="line">            N[cnt] = p[i].address</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">    <span class="keyword">var</span> firstBlock Block</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据随机数种子产生的随机数，找到矿工的地址，然后出块  （0~14）随机数</span></span><br><span class="line">    <span class="comment">//（拥有10个币上链的概率为10/15，拥有5个币上链概率为5/15，rand.Intn(cnt)找到地址   其中有10个是拥有10个币的地址，5个事拥有5个币的地址）</span></span><br><span class="line">    <span class="keyword">var</span> b,_ = generateBlock(firstBlock,<span class="number">10</span>,N[rand.Intn(cnt)])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的区块放到区块链上。</span></span><br><span class="line">    Blockchain = <span class="built_in">append</span>(Blockchain,b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(Blockchain)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW代码实现</title>
      <link href="/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/01/10/POW%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="用go语言实现一个pow共识工程"><a href="#用go语言实现一个pow共识工程" class="headerlink" title="用go语言实现一个pow共识工程"></a>用go语言实现一个pow共识工程</h3><a id="more"></a><h2 id="1-1-项目代码结构"><a href="#1-1-项目代码结构" class="headerlink" title="1.1 项目代码结构"></a>1.1 项目代码结构</h2><p><img src="http://img.kongyixueyuan.com/0301_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png/mark" alt="img"></p><h2 id="1-2-项目运行结果"><a href="#1-2-项目运行结果" class="headerlink" title="1.2 项目运行结果"></a>1.2 项目运行结果</h2><p><img src="http://img.kongyixueyuan.com/0302_%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif/mark" alt="img"></p><h2 id="1-3-完整代码"><a href="#1-3-完整代码" class="headerlink" title="1.3 完整代码"></a>1.3 完整代码</h2><p>Block.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//1. 区块高度</span></span><br><span class="line">    Height <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//2. 上一个区块HASH</span></span><br><span class="line">    PrevBlockHash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//3. 交易数据</span></span><br><span class="line">    Data []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//4. 时间戳</span></span><br><span class="line">    Timestamp <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">//5. Hash</span></span><br><span class="line">    Hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 6. Nonce</span></span><br><span class="line">    Nonce <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建新的区块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建区块</span></span><br><span class="line">    block := &amp;Block&#123;height,prevBlockHash,[]<span class="keyword">byte</span>(data),time.Now().Unix(),<span class="literal">nil</span>,<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用工作量证明的方法并且返回有效的Hash和Nonce</span></span><br><span class="line">    pow := NewProofOfWork(block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挖矿验证</span></span><br><span class="line">    hash,nonce := pow.Run()</span><br><span class="line"></span><br><span class="line">    block.Hash = hash[:]</span><br><span class="line">    block.Nonce = nonce</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 单独写一个方法，生成创世区块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewBlock(data,<span class="number">1</span>, []<span class="keyword">byte</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlockChain.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</span><br><span class="line">    Blocks []*Block  <span class="comment">// 存储有序的区块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加区块到区块链里面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(blc *Blockchain)</span> <span class="title">AddBlockToBlockchain</span><span class="params">(data <span class="keyword">string</span>,height <span class="keyword">int64</span>,preHash []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 创建新区块</span></span><br><span class="line">    newBlock := NewBlock(data,height,preHash)</span><br><span class="line">    <span class="comment">// 往链里面添加区块</span></span><br><span class="line">    blc.Blocks = <span class="built_in">append</span>(blc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建带有创世区块的区块链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockchainWithGenesisBlock</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建创世区块</span></span><br><span class="line">    genesisBlock := CreateGenesisBlock(<span class="string">"Genesis Data......."</span>)</span><br><span class="line">    <span class="comment">// 返回区块链对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;genesisBlock&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProofOfWork.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"math/big"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//0000 0000 0000 0000 1001 0001 0000 .... 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 256位Hash里面前面至少要有16个零</span></span><br><span class="line"><span class="keyword">const</span> targetBit  = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash nil</span></span><br><span class="line"><span class="comment">//256位</span></span><br><span class="line"><span class="comment">// 32</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 二进制表示 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 2 的 32 - 8 次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProofOfWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    Block *Block <span class="comment">// 当前要验证的区块</span></span><br><span class="line">    <span class="comment">// 0000 0001 0000 0000 0000 0000 0000 0000</span></span><br><span class="line">    target *big.Int <span class="comment">// 大数据存储 2^24</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面必须有8个零</span></span><br><span class="line"><span class="comment">// 0000 0000 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0001</span></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0001 0000</span></span><br><span class="line"><span class="comment">// 0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0000 0000 0000 0000 1111 111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据拼接，返回字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pow *ProofOfWork)</span> <span class="title">prepareData</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            pow.Block.PrevBlockHash,</span><br><span class="line">            pow.Block.Data,</span><br><span class="line">            IntToHex(pow.Block.Timestamp),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(targetBit)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(pow.Block.Height)),</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.proofOfWork.Block.Hash</span></span><br><span class="line">    <span class="comment">//2.proofOfWork.Target</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int</span><br><span class="line">    <span class="comment">// []byte 转 Int</span></span><br><span class="line">    hashInt.SetBytes(proofOfWork.Block.Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">    <span class="comment">//    0 if x == y</span></span><br><span class="line">    <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">    <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(proofOfWork *ProofOfWork)</span> <span class="title">Run</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>,<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1. 将Block的属性拼接成字节数组</span></span><br><span class="line">    <span class="comment">//2. 生成hash</span></span><br><span class="line">    <span class="comment">//3. 判断hash有效性，如果满足条件，跳出循环</span></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> hashInt big.Int <span class="comment">// 存储我们新生成的hash</span></span><br><span class="line">    <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        dataBytes := proofOfWork.prepareData(nonce)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成hash</span></span><br><span class="line">        hash = sha256.Sum256(dataBytes)</span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>,hash)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将hash存储到hashInt</span></span><br><span class="line">        hashInt.SetBytes(hash[:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断hashInt是否小于Block里面的target</span></span><br><span class="line">        <span class="comment">// Cmp compares x and y and returns:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   -1 if x &lt;  y</span></span><br><span class="line">        <span class="comment">//    0 if x == y</span></span><br><span class="line">        <span class="comment">//   +1 if x &gt;  y</span></span><br><span class="line">        <span class="keyword">if</span> proofOfWork.target.Cmp(&amp;hashInt) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonce = nonce + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash[:],<span class="keyword">int64</span>(nonce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的工作量证明对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProofOfWork</span><span class="params">(block *Block)</span> *<span class="title">ProofOfWork</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.big.Int对象 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//0000 0001</span></span><br><span class="line">    <span class="comment">// 8 - 2 = 6</span></span><br><span class="line">    <span class="comment">// 0100 0000  64</span></span><br><span class="line">    <span class="comment">// 0010 0000</span></span><br><span class="line">    <span class="comment">// 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 .... 0000</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//1. 创建一个初始值为1的target</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int Int</span></span><br><span class="line">    target := big.NewInt(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 左移256 - targetBit</span></span><br><span class="line"></span><br><span class="line">    target = target.Lsh(target,<span class="number">256</span> - targetBit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ProofOfWork&#123;block,target&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BLC</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int64转换为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"kongyixueyuan.com/blockchain_go_videos-master/part8-proof-of-work/BLC"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创世区块</span></span><br><span class="line">    blockchain := BLC.CreateBlockchainWithGenesisBlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新区块</span></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 100RMB To tom"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 200RMB To lily"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 300RMB To hanmeimei"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line">    blockchain.AddBlockToBlockchain(<span class="string">"Send 50RMB To lucy"</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Height + <span class="number">1</span>,blockchain.Blocks[<span class="built_in">len</span>(blockchain.Blocks) - <span class="number">1</span>].Hash)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(blockchain)</span><br><span class="line">    fmt.Println(blockchain.Blocks)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW挖矿及共识流程</title>
      <link href="/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/01/10/POW%E6%8C%96%E7%9F%BF%E5%8F%8A%E5%85%B1%E8%AF%86%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="PoW-挖矿及共识流程"><a href="#PoW-挖矿及共识流程" class="headerlink" title="PoW-挖矿及共识流程"></a>PoW-挖矿及共识流程</h3><p>本章节主要是熟悉比特币pow挖矿及共识流程，和简单实现一个pow挖矿helloworld的小demo。</p><a id="more"></a><h2 id="比特币pow挖矿及共识流程"><a href="#比特币pow挖矿及共识流程" class="headerlink" title="比特币pow挖矿及共识流程"></a>比特币pow挖矿及共识流程</h2><p>比特币挖矿的过程如下：</p><ol><li>构建一个空区块，称为候选区块</li><li>从内存池中打包交易至候选区块</li><li>构造区块头，填写区块头的下述字段<br>　　1）填写版本号version字段<br>   　　2）填写父区块哈希prevhash字段<br>   　　3）用merkle树汇总全部的交易，将merkle root的哈希值填写至merkle root字段<br>   　　4）填写时间戳timestamp字段<br>   　　5）填写目标值Bits字段</li><li>开始挖矿。挖矿就是不断重复计算区块头的哈希值，修改nonce参数，直到找到一个满足条件的nonce值，也就是该nonce值下，hash函数运算出来的hash值 &lt; Bits。当挖矿节点成功求出一个解后把解填入区块头的nonce字段。</li><li>这时一个新区块就成功挖出了，然后挖矿节点会做下面这些事：<br>　　1) 按照标准清单检验新区块，检验通过后进行下面的 2)和 3)步骤<br>   　　2）立刻将这个新区块发给它的所有相邻节点，相邻节点收到这个新区块后进行验证，验证有效后会继续传播给所有相邻节点。<br>   　　3）将这个新区块连接到现有的区块链中，按照如下规则：<br>   　　　　根据新区块的prevhash字段在现有区块链中寻找这个父区块，<br>   　　　　(Ⅰ) 如果父区块是主区块链的“末梢”，则将新区块添加上去即可；<br>   　　　　(Ⅱ) 如果父区块所在的链是备用链，则节点将新区块添加到备用链，同时比较备用链与主链的工作量。如果备用链比主链积累了更多的工作量，节点将选择备用链作为其新的主链，而之前的主链则成为了备用链；<br>   　　　　(Ⅲ) 如果在现有的区块链中找不到它的父区块，那么这个区块被认为是“孤块”。孤块会被保存在孤块池中，直到它们的父区块被节点接收到。一旦收到了父区块并且将其连接到现有的区块链上，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</li></ol><p>pow工作量证明共识机制流程图如下：</p><p><img src="http://image.chaindesk.cn/pow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png/mark" alt="img"></p><p>演示挖坑过程，可链接下面网址：</p><p><a href="https://anders.com/blockchain/blockchain.html" target="_blank" rel="noopener">https://anders.com/blockchain/blockchain.html</a></p><h2 id="pow简单的例子"><a href="#pow简单的例子" class="headerlink" title="pow简单的例子"></a>pow简单的例子</h2><p>下边这个代码很糙，只是简化版的pow挖矿过程，里面的N就是挖矿Bits，我设置了一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"encoding/binary"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//声明了一个挖矿难度Bits</span></span><br><span class="line"><span class="keyword">const</span> N  = <span class="number">0x00FFffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个block结构体</span></span><br><span class="line"><span class="keyword">type</span> block <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">//区块数据</span></span><br><span class="line">    Data  []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//随机数</span></span><br><span class="line">    Nonce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">//当前块的hash</span></span><br><span class="line">    hash []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">//挖矿目标难度值</span></span><br><span class="line">    Bits <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化一个空块</span></span><br><span class="line">    <span class="keyword">var</span> b = block&#123;[]<span class="keyword">byte</span>(<span class="string">"helloworld"</span>), <span class="number">0</span>,<span class="literal">nil</span>,N&#125;</span><br><span class="line"></span><br><span class="line">    nonce := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接block字段内容</span></span><br><span class="line">        dataBytes := b.PreParae(nonce)</span><br><span class="line">        <span class="comment">//矿工计算函数，我只用了一次256hash</span></span><br><span class="line">        hash := sha256.Sum256(dataBytes)</span><br><span class="line">        <span class="comment">//将hash转换成Uint64类型，将与N进行比较大小</span></span><br><span class="line">        hash1 := BytesToUint64(hash[:])</span><br><span class="line">        <span class="comment">//不断显现hash函数后的值</span></span><br><span class="line">        fmt.Printf(<span class="string">"\r%x"</span>, hash)</span><br><span class="line">        <span class="comment">//hash值与目标值进行大小比较</span></span><br><span class="line">        <span class="keyword">if</span> hash1 &lt; <span class="keyword">uint64</span>(N) &#123;</span><br><span class="line">        <span class="comment">//挖矿成功后，给b重新赋值，并跳出循环</span></span><br><span class="line">            fmt.Println()</span><br><span class="line">            b.Nonce=nonce</span><br><span class="line">            b.hash=hash[:]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nonce++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//block字段拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b block)</span> <span class="title">PreParae</span><span class="params">(nonce <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    data := bytes.Join(</span><br><span class="line">        [][]<span class="keyword">byte</span>&#123;</span><br><span class="line">            b.Data,</span><br><span class="line">            IntToHex(<span class="keyword">int64</span>(nonce)),</span><br><span class="line">            b.hash,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="keyword">byte</span>&#123;&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字节转换成64进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToUint64</span><span class="params">(array []<span class="keyword">byte</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">        data = data + <span class="keyword">uint64</span>(<span class="keyword">uint</span>(array[i])&lt;&lt;<span class="keyword">uint</span>(<span class="number">8</span>*i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将64进制数字转换成字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(num <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW目标值</title>
      <link href="/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
      <url>/2020/01/10/POW%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="POW-目标值"><a href="#POW-目标值" class="headerlink" title="POW-目标值"></a>POW-目标值</h3><p>很多文章或解析将区块里的Bits字段解读成难度值，其实是错误的。Bits的作用是直接和区块头2次sha256（）的结果进行比较大小的。比较之前，需要先将两者的类型转换成big.Int型。起初Bits类型是Uint32；hash类型是字节数组。</p><a id="more"></a><h2 id="目标值的产生"><a href="#目标值的产生" class="headerlink" title="目标值的产生"></a>目标值的产生</h2><p>目标值是怎么产生的呢？<br>目标值是一个变量，中本聪设的初始值是0x1d00ffff。这个目标值以后会每隔2016个区块，根据过去2016个区块花费时长算出的难度值进行调整，保证正常出块的时间在10分钟左右。所有节点都会按统一公式自动调整Bits，调整公式：</p><p>新难度值=旧难度值*（过去2016个区块花费时长（分）/20160分钟）</p><p>目标值=最大目标值/难度值。</p><p>最大目标值是恒定的，即为创始区块的Bits值<code>0x1d00FFFF</code>。这个数的由来是<code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>这个64位16进制数通过小端法存储得来。这个64位数字存储需要占32个字节，而Bits在区块头占大小是4个字节，所以通过小端法存储可以把后边的0都抹去，最后得到的数占4个字节。小端法英文表示little-endian，一种是将低序字节存储在起始地址的存储方法。我们经常用到的存储都是大端法，按数据字节顺序从高到低存储。</p><p><code>0x00000000FFFF0000000000000000000000000000000000000000000000000000</code>来自中本聪定义的数字<code>0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>使用浮点编码类型得来的。方法是为满足实现小端法存储，中本聪处理后面F的方法，具体不作分析。真正在代码中出现的最大目标值只是<code>0x1d00FFFF</code>，也就是创始区块的Bits。</p><p>每2016个区块完成后，会自动调整新的目标值Bits。从上边公式可以看出新Bits与难度值成反比。因为Bits是小端法存储，所以存储的数据越大说明实际的数字越小，那么挖矿越难；反之越简单。难度值也是个变量，最开始前2016个块数值是1，之后每隔2016个块后都会改变。在矿工挖矿过程中，都会有一个计时器，记录每个区块挖矿的时间，当累加2016次后，将会通过新难度值公式，计算出下一次挖矿的难度值，然后再通过目标值公式得到以后挖矿的目标值。</p><h2 id="还原真实目标值"><a href="#还原真实目标值" class="headerlink" title="还原真实目标值"></a>还原真实目标值</h2><p>在矿工挖矿过程中，产生的hash值与目标值进行比较大小，需要将目标值还原成真实值。目标值由指数（exponent）和系数（coefficient）两部分组成。高位一个字节为指数，低位三个字节为系数。真实目标值用target表示。</p><p>真实的目标值的大小计算方式是：target = coefficient <em>2^(8</em> (exponent – 3))</p><p>比如：<br>在区块277,316中，nBits字段的值为0x1903a30c，则0x19为指数，而 0x03a30c为系数。<br>计算难度目标的公式为：<br>target = coefficient <em>2^(8</em> (exponent – 3))</p><p>由此公式，以及难度位nBits的值 0x1903a30c，可得：</p><p>target = 0x03a30c <em>2^(0x08</em> (0x19 - 0x03))^</p><p>=&gt; <code>target = 0x03a30c * 2^(0x08 * 0x16)^</code><br>=&gt;<code>target = 0x03a30c * 2^0xB0^</code></p><p>按十进制计算为：</p><p>=&gt;<code>target = 238,348 * 2^176^</code><br>=&gt; <code>target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</code></p><p>转化回十六进制后为：</p><p>=&gt; <code>target = 0x0000000000000003A30C00000000000000000000000000000000000000000000</code></p><p>也就是说高度为277,316的有效区块的区块头哈希值是小于这个真实目标值的。这个数字的二进制表示中必须超过60位的前导位都是0。在这个级别的难度，一个每秒可以处理1万亿次（1 tera-hash per second 或 1 TH/sec）哈希计算的矿工平均每8,496个区块，或者平均每59天，才能找到一个正确结果。</p><p>再看下比特币中创世区块(GenesisBlock)的难度值：<br>nBits字段值为：0x1d00ffff(十进制即为：486604799)，表示为十六进制的Target值为：<code>00000000ffff0000000000000000000000000000000000000000000000000000</code></p><p>综上，这个高度为277,316的有效区块的区块头的部分信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A：Bits = <span class="string">"0x1903a30c"</span></span><br><span class="line"></span><br><span class="line">B：exponent指数，exponent = <span class="number">0x19</span></span><br><span class="line"></span><br><span class="line">C：coefficient系数，coefficient = <span class="number">0x03a30c</span></span><br><span class="line"></span><br><span class="line">D：target = coefficient * Math.Pow(<span class="number">2</span>, <span class="number">8</span> * (exponent - <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">E：Bits真实值（target）：<span class="number">0x0000000000000003A30C00000000000000000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">F：本区块hash：<span class="number">00000000000000000041</span>ff1cfc5f15f929c1a45d262f88e4db83680d90658c0c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POW工作量证明</title>
      <link href="/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/"/>
      <url>/2020/01/10/POW%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h3><p>PoW，全称Proof of Work，即工作量证明，又称挖矿。大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。根据挖矿贡献的有效工作，来决定货币的分配。</p><p>接下来主要以pow在比特币公链上的应用展开讲解。</p><a id="more"></a><h2 id="比特币Pow"><a href="#比特币Pow" class="headerlink" title="比特币Pow"></a>比特币Pow</h2><p>比特币的出块时间是10分钟左右。每个区块内包含最多8笔交易，这些交易需要被验证和确认，才能实现账户代币的转移。每个挖矿节点做的工作就是去验证和确认这个区块，使区块内的交易得以实现。而他们用的算法就是pow。pow计算的是一个数学运算难题，矿工们首先验证要挖坑区块的合法性，如果合法，他们就开始计算本次挖矿的数学难题，谁第一个做出来并且广播出去，告诉其他矿工我做出来了，你们不用做了。其他矿工们验证你的计算结果和对应的区块，如果大部分的矿工认同你的结果，那么他们将停止挖坑并同步你的数据。区块内的所有交易也就得到认可，实现转账。你的成功挖矿会被比特币激励模块记录，并会给你发送比特币奖励金。</p><p>pow算法主要寻找一个随机数（Block里的Nonce值）作为输入，通过改变这个输入，使Block数据不重复变化，Hash函数（一般是sha256）不断计算这个改变后Block的hash值，找出一个特定格式哈希值的过程（即要求有一定数量的前导0），这里找到的值就是当前hash值 &lt; 目标值（Bits），只不过这个比较是在2进制的格式下比较运算的，也就是比较2进制后数字前面0的个数。这个过程就是pow运算过程。而要求的前导0的个数越多，代表难度越大。在将pow算法之前，先学习下区块信息。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如下图所示<br><img src="http://image.chaindesk.cn/po%20w%E5%8C%BA%E5%9D%97%E4%BF%A1%E6%81%AF.png/mark" alt="img"></p><p>从图上可知，比特币区块结构分为区块头和区块体，区块体保存交易的具体信息，由它生成的hash保存在区块头里。其中区块头细分为：<br>父区块头哈希值：前一区块的哈希值，使用SHA256(SHA256(父区块头))计算。</p><p>版本(Version)：区块版本号，表示本区块遵守的验证规则 。</p><p>时间戳(Timestamp)：该区块产生的近似时间，精确到秒的UNIX时间戳，必须严格大于前11个区块时间的中值，同时全节点也会拒绝那些超出自己2个小时时间戳的区块。</p><p>目标值(Bits)：该区块工作量证明算法的难度目标，已经使用特定算法编码。</p><p>随机数（Nonce）：为了找到满足难度目标所设定的随机数，为了解决32位随机数在算力飞升的情况下不够用的问题，规定时间戳和coinbase交易信息均可更改，以此扩展nonce的位数。</p><p>Merkle根(MerkleRoot)：该区块中交易的Merkle树根的哈希值。矿工收到计算过的区块，会跟自己的区块进行比较，其中Merkle root就是比较它们包含的交易是否一样。</p><p>区块头里的所有信息拼接成一个新的字节数组，pow函数运算的参数就是这个字节数组。函数运算是采用SHA256(SHA256())计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">var</span> genesisBlock = wire.MsgBlock&#123;</span><br><span class="line">    Header: wire.BlockHeader&#123;</span><br><span class="line">        Version:    <span class="number">1</span>,</span><br><span class="line">        PrevBlock:  chainhash.Hash&#123;&#125;,         <span class="comment">// 0000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">        MerkleRoot: genesisMerkleRoot,        <span class="comment">// 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b</span></span><br><span class="line">        Timestamp:  time.Unix(<span class="number">0x495fab29</span>, <span class="number">0</span>), <span class="comment">// 2009-01-03 18:15:05 +0000 UTC</span></span><br><span class="line">        Bits:       <span class="number">0x1d00ffff</span>,               <span class="comment">// 486604799 </span></span><br><span class="line">        Nonce:      <span class="number">0x7c2bac1d</span>,               <span class="comment">// 2083236893</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Transactions: []*wire.MsgTx&#123;&amp;genesisCoinbaseTx&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pow三要素"><a href="#Pow三要素" class="headerlink" title="Pow三要素"></a>Pow三要素</h2><p>1.Hash函数：在比特币中使用的是SHA256算法函数，是密码哈希函数家族中输出值为256位的哈希算法。</p><p>2.区块头 Hash函数运算需要的参数，也就是区块头的所有信息字节拼接后的字节数组。</p><p>3.目标值（Bits） 每一个区块会用一种压缩的格式（被称为“Bits”）来表示实际的16进制的目标值。通过这个值和系统中其他常量可计算出该难度值下的难度目标值。Hash函数运算出来的结果与目标值进行比较大小，如果小，则表示挖坑成功，否则继续运算。比较大小时为使运算速度快速，目标值和hash值都会转换成2进制，所以比较大小就是比较前导0的个数。比特币是每隔2016个区块后调整难度值。<br>pow挖矿的难度与目标值成反比，如果Bits的实际值增大，那么挖矿容易点；反之，挖矿难度加大。</p><p>比特币整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力，使整个网络的计算力大致每10分钟产生一个区块。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识机制</title>
      <link href="/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/01/10/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="共识机制概述"><a href="#共识机制概述" class="headerlink" title="共识机制概述"></a>共识机制概述</h3><p>所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。</p><a id="more"></a><p>实现共识机制的算法就是共识算法。接下来的章节我会对Pow，Pos，Pbft，Raft等共识算法进行讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 共识机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go变量和常量</title>
      <link href="/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之变量和常量"><a href="#Go语言基础之变量和常量" class="headerlink" title="Go语言基础之变量和常量"></a>Go语言基础之变量和常量</h1><p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p><a id="more"></a><h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h2><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Q1mi"</span>  <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">"Q1mi"</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">10</span> <span class="comment">//声明并初始化变量,只能在函数内使用，不可使用在函数外</span></span><br><span class="line">m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>执行<code>go fmt main.go</code>使得程序代码格式化</p><h4 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">n <span class="keyword">string</span></span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">isOk <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">name =<span class="string">"lixiang"</span></span><br><span class="line">age =<span class="number">16</span></span><br><span class="line">n=<span class="string">"a"</span></span><br><span class="line">isOk=<span class="literal">true</span></span><br><span class="line"><span class="comment">//GO语言声明变量必须使用，不使用编译不过去</span></span><br><span class="line">fmt.Print(isOk)<span class="comment">//在终端中输出</span></span><br><span class="line">fmt.Printf(<span class="string">"name:%s"</span>,name)<span class="comment">//%s:占位符 使用name这个变量去替换占位符</span></span><br><span class="line">fmt.Println(age)<span class="comment">//打印完后会在后面加上一个换行符，同时类型推导</span></span><br><span class="line">    <span class="comment">//声明变量同时赋值</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> = <span class="string">"hg"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">//类型推导</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"20"</span></span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">//简短变量声明，声明并初始化，只能在函数内部使用</span></span><br><span class="line">s3 := <span class="string">"hahah"</span></span><br><span class="line">fmt.Println(s3)</span><br><span class="line"><span class="comment">//s1 :=10 同一个作用域&#123;&#125; 中不能重复生命同样的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>, <span class="string">"Q1mi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x, _ := foo()</span><br><span class="line">_, y := foo()</span><br><span class="line">fmt.Println(<span class="string">"x="</span>, x)</span><br><span class="line">fmt.Println(<span class="string">"y="</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li><strong>函数外的每个语句都必须以关键字开始（var、const、func等）</strong></li><li><strong><code>:=</code>不能使用在函数外。</strong></li><li><strong><code>_</code>多用于占位，表示忽略值。</strong></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>同一个作用域（{}）不允许重复声明变量</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p><p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(iota+1)(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1 n2=iota   //iota=iota+1=1</span></span><br><span class="line">n3        <span class="comment">//2 n3=iota</span></span><br><span class="line">n4        <span class="comment">//3 n4=iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="几个常见的iota示例-笔试题"><a href="#几个常见的iota示例-笔试题" class="headerlink" title="几个常见的iota示例: 笔试题"></a>几个常见的<code>iota</code>示例: 笔试题</h3><p>使用<code>_</code>跳过某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">_</span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>iota</code>声明中间插队</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2 = <span class="number">100</span>  <span class="comment">//100    const中每新增一行常量声明将使iota计数一次(iota+1)</span></span><br><span class="line">n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//（二进制）10000000000=1024kb</span></span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)  <span class="comment">//1024MB</span></span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//1024GB</span></span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个<code>iota</code>定义在一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2  新增一行才+1</span></span><br><span class="line">c, d                      <span class="comment">//2,3</span></span><br><span class="line">e, f                      <span class="comment">//3,4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/18/hello-world/"/>
      <url>/2019/12/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
